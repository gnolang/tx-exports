{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1w5hst2p69rza9nmf69dp5flxq8hpzhum768yr9","to_address":"g1w5hst2p69rza9nmf69dp5flxq8hpzhum768yr9","amount":"1000000ugnot"}],"fee":{"gas_wanted":"48263","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"dKYsQJfjsVAkrnXB4EGJ9a1WcMFllp4XAiRm+0lc6Q+bZ3u0dEhR2u7mU12DnSH7/DBt4YrTp0idMVB8P+EiAA=="}],"memo":""},"metadata":{"timestamp":"1768352471"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1c9y7qexumxgmrzk3jgj37vkfrhaxvyf6mhk4ke","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","31"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"7BscONhpvbR88OKHNdswEvCfFa8b53Ypj7/090HQbmu+WfbO4qqy72kxSHO8NLu9UYaVSD85CbBW/QeFZ3TgDQ=="}],"memo":""},"metadata":{"timestamp":"1768352531"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"525110ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"nGU4B7rgALHA8Kx7CunPnw29EAF4oCB05rMZvRFUYVOitByri4AAGZR6znu2cyQnI/Qw9nMeSiXuk2nTdpHkBQ=="}],"memo":""},"metadata":{"timestamp":"1768354311"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"525110ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"HH2JTwDJTSkxpK8BUWrMmQoVD4f3KWl3AiGv8x1xmsx4KNmieiFa1UTiOl6g4qJk01GpUshicGxN43U9ytWaDg=="}],"memo":""},"metadata":{"timestamp":"1768354316"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"pKJBUbklERTWUkJaINsDqqOAI9HFbTL/Oy9GnIE0iy/D2MpSvNOT6oX1VD4j7So0+ZpaGEPv0xVxi+hOMxkKCg=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"hnk3hfrEw7HPF3GuNA27g06g4NLo6Gt3iHRlB+fQ0zg95MUMdbxvfzB4jCTHlgncfwOMMBAs6mokfkBcSQabCQ=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"dlYUEcFT92OgQnD5qBv1ap+JlrTEkaRlnZapMri48ZYgurF90tSRNVPkOYuTW1xj64PWIdZ7ejIga+Y8737gCA=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"20jUgQWBe7QxGrwMEFVFWcB+LqvLkrno87lxZEIhHebd0UnrysAHS7wRoc/jfMUhMfxTr//eovoBlx7kTM87DQ=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"TrkkOVfJR3Jcn/YGOitHp2YTZI6pu7KWu7rFBMSPTQHVJ5997MlD34SUwNbcvqwCLlDOblxnQ6JGShlCgk2nCA=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"ggRBQWjozu4xcDtfCwmsPJF5ksbNAAjkTi82t9uX0pEYCTvSEEJRz8osFQDsoVtD39Q7MM6IJ1fJhptHQvEyDQ=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"aK2TItS7wyINfeirLcYKyMQXc4j/8fHSgAG26moFyxIg52Vp8eVDEyJipel/7bxirqZgrRck5LnNGjMNkJ03Aw=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"aV01aAnhxVt8HxcFyY9RXORouS3eGk8SEsh5V97TYR0ZBpNs7R3p9dDVWcARuEpjpKy2CfmMEh8ThQO46nLiCQ=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"pVsLBlgJWA0XNjcCNujFBlSto8w+smUA5fetVwgfxOnU7aSi78BCSgBYN+uIUb3dnWK7JwDTLZFiEwO2NLd2Cg=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"z2GhaZoCmWQQnhPgpEVsziMK/iwCpQOAxz0wAKNBDOOeO+YzmH7G+Jjv23UiSPhAcFKpUigklNiqfBT5bc6tBw=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"2842875ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"ugj9GKV9IJBBzpJTa7EG6lbT//gYU5G0n3uBo/+OnykNXbmhb1oyEQPb8oyRO39NFAE7irG7kQJdLOjG9e1lBQ=="}],"memo":""},"metadata":{"timestamp":"1768354406"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"2842875ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"iQVy77bsAd6NWB802XMRS6ZihYeqkFnuXFjg9JxfmGpr6LfNNI1gckaZH3ySUauQjwFIozjzhelf2YKwHqW4AA=="}],"memo":""},"metadata":{"timestamp":"1768354411"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"P2cN0ALQeEcrMhoHzLNl8DZRKPMDU909H1t74KoP5cZfjs9PT6jEH/aAbXARh9gYZmTgiEE/cmq0xxtMAX5sBw=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"KZenostoPFx9ZXfXH9CABRQ16+IkIas0lin9gV62vhlGbc+3/Bqe3b38AQ9CB6ySNoG6kiYZeJh2zjXGU3BrCQ=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"t2m9ih8tpy8THQAFUrT7TMidaKsJS3i2mikLM5aaGs/qk1p51FcqgPyHq7WBWfskjK/j5N0uJ3oIzbQSdklKAw=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"SDwP1F82W3ZxMc45pv2PpjZ+kVfoHgCWaD3KACBxtdATPwqQHNcLq+7KCJXB/Dz+KNHZRqaYGOZXBROZTr+8BA=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"7bWExP3YItjuqXTFOLDZxIql+iOm/GpK5d4NI++Hb4rMUP/hE6scmD2dDlqjuwPRBfdP/xXP+j9Rl5pO9pUiAg=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"Db09FpUCT5U267ZTHANyQse8sv+pCYhDNQY4utk74VS9eEQ0d3PrJ7RH0L6pdvQt7imCYyApNk8ShJsqYa9fAA=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"FuxBbarwjupViTAfm87f+6DQKi63F/3QlPiAgIgwCdjW0MisVNXBGqAO5TL6tLI7I+2Enr82jrMl7xfaTWelAg=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"tKUg1oxNZZdWnvF4M3RBZ8pcAX2ABD8sv9SabTzeRfaeRRKlj7z/TdQ/x4p637cXSYNiTGEtSRpQkGUZaldTAg=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"YfHiOv9SjMarVyv6WTnPL2x1RMkU7brXZx0d3x+aABBh74VyFrPtq0cDUSFytJTuqko7cOBHalonf6b3sjmZBA=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"Vl0CuAhgz3dgFGrDk0WDUv7HWlww+HHZmxoII898AsFjFSg/O33IhdP2ocmhxQJTysV+vtushovChcKnulLYAw=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"runtime","path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"622239","gas_fee":"623ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"vVVzIE4dj3ZMPutuOH84xMAH5JxAAd8DDtXfJ54vu4ZCUgl3EBLVIkVwpBhp3ut4abCaqVkj2TF+cJgZwb/KDA=="}],"memo":""},"metadata":{"timestamp":"1768354497"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-0"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"H4tLJ6SxMa7BwQksqCw+y8ZV3RM/K6qR2l5sETQryjLCeGVtj6XKL6GgWWgntjm9AImJjskMzTEi39YIdI+GDg=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"8VlANfV/Dplpj21G5XPqTqBy+F1ZYr7dthFUetoHVrTvznPXjA4XkNhEoZHkJ7LKaIKd6GTFLnIeDYuZW9A8Dg=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"jUFVR2bW2GYrgsEpJTQ5tvZz8qtgG2/C6QeQcClBVYbyZs9N+YgRDz3ZMuxPAx/sVqC7XJCicMtqnTkgz/6RBg=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"RW77DOBQk+XXPb/p31fKYuoIZD7KY0a+7EBvsdga3q2YZ652xFa+JASawdAaagVCdQMlw5LURByjS4qd5S21Dw=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"y4X/vUncaYddN8SXt2wfxrKv1mP0S9B71fD5OOElO/lQ5zcr7j3iASQbXb2yDBhYD6D+3iDFufLRrDjCWhUHDA=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"aoAuvDvimukeP2MckLu/54AApzgrOkfklLoJELNMS70YMZuxcn28niIQcoeo1Vtuhr+bohsm7hn8OSYQvxp2BQ=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"oW/pB4Yb1wFG83aCH8sbggh+HZ7ZHIrkkMg/fibARfJxjfzKHae03udoDgEO2g45rKCkYcKBBhTO7Wog1SttAQ=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"ug6hwaqjE0Ic3qYPMWn8p6ZVmdiGDHDS1Mh8ji4Z0uWTyQmYkQCmPZLLliq6adpdZDw77I7WdMnONBRdW2LVCg=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"OrEL36PpLmegcGOhyORWnte5L4pwphYjv9WzOqFMV/aGizvNpW79/KQ5urveSQoEkcJTN37ccOvIR62V5gZoCw=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"KsjkmA/KaP88KqXXSBW6Fkc0WSPJGPE9GW4BFetOvBBx1QeWPwNpuT79z7fpFberb5l1izEUPk9jROdq05WkDA=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"clmm","path":"gno.land/r/gnomo/clmm3","files":[{"name":"clmm.gno","body":"package clmm\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst (\n\tMIN_TICK  = -1000\n\tMAX_TICK  = 1000\n\tPRECISION = 1000000\n\tMAX_INT64 = int64(9223372036854775807)\n)\n\n// =============================================================================\n// SAFE MATH\n// =============================================================================\n\nfunc safeMul(a, b int64) int64 {\n\tif a == 0 || b == 0 {\n\t\treturn 0\n\t}\n\tresult := a * b\n\tif result/a != b {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn result\n}\n\nfunc safeMulDiv(a, b, c int64) int64 {\n\tif c == 0 {\n\t\tpanic(\"division by zero\")\n\t}\n\tif a \u003e MAX_INT64/b \u0026\u0026 b != 0 {\n\t\tquotient := a / c\n\t\tremainder := a % c\n\t\treturn quotient*b + (remainder*b)/c\n\t}\n\treturn (a * b) / c\n}\n\n// =============================================================================\n// DATA STRUCTURES\n// =============================================================================\n\ntype CLMMPool struct {\n\tID          uint64\n\tDenomA      string\n\tDenomB      string\n\tFeeBPS      int64\n\tTickSpacing int64\n\tPriceX6     int64\n\tCurrentTick int64\n\tLiquidity   int64\n\tFeeGrowthA  int64\n\tFeeGrowthB  int64\n}\n\ntype Position struct {\n\tID            uint64\n\tPoolID        uint64\n\tOwner         string\n\tTickLower     int64\n\tTickUpper     int64\n\tLiquidity     int64\n\tFeeGrowthLastA int64\n\tFeeGrowthLastB int64\n\tTokensOwedA   int64\n\tTokensOwedB   int64\n}\n\ntype TickInfo struct {\n\tLiquidityGross int64\n\tLiquidityNet   int64\n\tInitialized    bool\n}\n\nvar (\n\tpools          []*CLMMPool\n\tnextPoolID     uint64\n\tpositions      []*Position\n\tnextPositionID uint64\n\ttickData       map[uint64]map[int64]*TickInfo\n)\n\nfunc init() {\n\ttickData = make(map[uint64]map[int64]*TickInfo)\n}\n\n// =============================================================================\n// TICK MATH\n// =============================================================================\n\nfunc getPriceAtTick(tick int64) int64 {\n\tif tick \u003c MIN_TICK || tick \u003e MAX_TICK {\n\t\tpanic(\"tick out of range\")\n\t}\n\n\tif tick == 0 {\n\t\treturn PRECISION\n\t}\n\n\tabsTick := tick\n\tif absTick \u003c 0 {\n\t\tabsTick = -absTick\n\t}\n\n\t// Use 1.01 per tick (1% price change per tick)\n\t// Calculate 1.01^absTick using simple iteration\n\tresult := int64(PRECISION) // 1.0 in X6\n\n\tfor i := int64(0); i \u003c absTick; i++ {\n\t\t// result = result * 1.01 = result * 101 / 100\n\t\t// Check for overflow before multiplication\n\t\tif result \u003e MAX_INT64/101 {\n\t\t\tpanic(\"price calculation overflow\")\n\t\t}\n\t\tresult = (result * 101) / 100\n\t}\n\n\tif tick \u003c 0 {\n\t\t// Invert: 1 / price = PRECISION^2 / result\n\t\tif result \u003e 0 {\n\t\t\treturn safeMulDiv(PRECISION, PRECISION, result)\n\t\t}\n\t\treturn PRECISION\n\t}\n\n\treturn result\n}\n\nfunc getTickAtPrice(priceX6 int64) int64 {\n\tif priceX6 \u003c= 0 {\n\t\tpanic(\"invalid price\")\n\t}\n\n\tlow := int64(MIN_TICK)\n\thigh := int64(MAX_TICK)\n\n\tfor low \u003c high {\n\t\tmid := (low + high + 1) / 2\n\t\tpriceAtMid := getPriceAtTick(mid)\n\n\t\tif priceAtMid \u003c= priceX6 {\n\t\t\tlow = mid\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\n\treturn low\n}\n\n// =============================================================================\n// LIQUIDITY MATH\n// =============================================================================\n\nfunc getAmountsForLiquidity(pL, pU, pC, liq int64) (int64, int64) {\n\tif pC \u003c= pL {\n\t\t// Price below range: all token0\n\t\tdenominator := safeMulDiv(pL, pU, PRECISION)\n\t\tif denominator == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tamt0 := safeMulDiv(liq, pU-pL, denominator)\n\t\treturn amt0, 0\n\t} else if pC \u003e= pU {\n\t\t// Price above range: all token1\n\t\tamt1 := safeMulDiv(liq, pU-pL, PRECISION)\n\t\treturn 0, amt1\n\t} else {\n\t\t// Price in range: mix of both tokens\n\t\tdenominator := safeMulDiv(pC, pU, PRECISION)\n\t\tif denominator == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tamt0 := safeMulDiv(liq, pU-pC, denominator)\n\t\tamt1 := safeMulDiv(liq, pC-pL, PRECISION)\n\t\treturn amt0, amt1\n\t}\n}\n\nfunc getLiquidityForAmounts(pL, pU, pC, amt0, amt1 int64) int64 {\n\tif pC \u003c= pL {\n\t\tif amt0 \u003c= 0 {\n\t\t\treturn 0\n\t\t}\n\t\tnumerator := safeMulDiv(pL, pU, PRECISION)\n\t\treturn safeMulDiv(amt0, numerator, pU-pL)\n\t} else if pC \u003e= pU {\n\t\tif amt1 \u003c= 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn safeMulDiv(amt1, PRECISION, pU-pL)\n\t} else {\n\t\tnumerator0 := safeMulDiv(pC, pU, PRECISION)\n\t\tliq0 := safeMulDiv(amt0, numerator0, pU-pC)\n\t\tliq1 := safeMulDiv(amt1, PRECISION, pC-pL)\n\t\tif liq0 \u003c liq1 {\n\t\t\treturn liq0\n\t\t}\n\t\treturn liq1\n\t}\n}\n\n// =============================================================================\n// POOL MANAGEMENT\n// =============================================================================\n\nfunc CreateCLMMPool(_ realm, denomA, denomB string, feeBPS int64, initialPriceX6 int64) uint64 {\n\tif denomA == \"\" || denomB == \"\" {\n\t\tpanic(\"invalid denom\")\n\t}\n\tif denomA == denomB {\n\t\tpanic(\"denoms must be different\")\n\t}\n\tif denomA \u003e denomB {\n\t\tdenomA, denomB = denomB, denomA\n\t\tif initialPriceX6 \u003e 0 {\n\t\t\tinitialPriceX6 = (PRECISION * PRECISION) / initialPriceX6\n\t\t}\n\t}\n\n\tfor _, p := range pools {\n\t\tif p.DenomA == denomA \u0026\u0026 p.DenomB == denomB \u0026\u0026 p.FeeBPS == feeBPS {\n\t\t\tpanic(\"pool already exists\")\n\t\t}\n\t}\n\n\tif feeBPS \u003c= 0 || feeBPS \u003e 10000 {\n\t\tpanic(\"fee must be 1-10000 bps\")\n\t}\n\n\tvar tickSpacing int64 = 1\n\tif feeBPS \u003e= 100 {\n\t\ttickSpacing = 10\n\t} else if feeBPS \u003e= 30 {\n\t\ttickSpacing = 5\n\t}\n\n\tif initialPriceX6 \u003c= 0 {\n\t\tinitialPriceX6 = PRECISION\n\t}\n\n\tpool := \u0026CLMMPool{\n\t\tID:          nextPoolID,\n\t\tDenomA:      denomA,\n\t\tDenomB:      denomB,\n\t\tFeeBPS:      feeBPS,\n\t\tTickSpacing: tickSpacing,\n\t\tPriceX6:     initialPriceX6,\n\t\tCurrentTick: getTickAtPrice(initialPriceX6),\n\t\tLiquidity:   0,\n\t}\n\n\tpools = append(pools, pool)\n\ttickData[nextPoolID] = make(map[int64]*TickInfo)\n\tnextPoolID++\n\n\treturn pool.ID\n}\n\n// =============================================================================\n// POSITION MANAGEMENT\n// =============================================================================\n\nfunc MintPosition(_ realm, poolID uint64, tickLower, tickUpper int64) uint64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tpool := pools[poolID]\n\n\tif tickLower \u003e= tickUpper {\n\t\tpanic(\"tickLower must be \u003c tickUpper\")\n\t}\n\tif tickLower \u003c MIN_TICK || tickUpper \u003e MAX_TICK {\n\t\tpanic(\"ticks out of range\")\n\t}\n\tif tickLower%pool.TickSpacing != 0 || tickUpper%pool.TickSpacing != 0 {\n\t\tpanic(\"ticks must align with spacing\")\n\t}\n\n\tcaller := string(runtime.OriginCaller())\n\tsentCoins := banker.OriginSend()\n\n\tamountA := sentCoins.AmountOf(pool.DenomA)\n\tamountB := sentCoins.AmountOf(pool.DenomB)\n\n\tif amountA \u003c= 0 \u0026\u0026 amountB \u003c= 0 {\n\t\tpanic(\"must send tokens\")\n\t}\n\n\tpL := getPriceAtTick(tickLower)\n\tpU := getPriceAtTick(tickUpper)\n\n\tliquidity := getLiquidityForAmounts(pL, pU, pool.PriceX6, amountA, amountB)\n\tif liquidity \u003c= 0 {\n\t\tpanic(\"insufficient liquidity\")\n\t}\n\n\t// Update ticks\n\tupdateTick(poolID, tickLower, liquidity, true)\n\tupdateTick(poolID, tickUpper, liquidity, false)\n\n\t// Update pool liquidity if in range\n\tif pool.PriceX6 \u003e= pL \u0026\u0026 pool.PriceX6 \u003c pU {\n\t\tpool.Liquidity += liquidity\n\t}\n\n\tposition := \u0026Position{\n\t\tID:            nextPositionID,\n\t\tPoolID:        poolID,\n\t\tOwner:         caller,\n\t\tTickLower:     tickLower,\n\t\tTickUpper:     tickUpper,\n\t\tLiquidity:     liquidity,\n\t\tFeeGrowthLastA: pool.FeeGrowthA,\n\t\tFeeGrowthLastB: pool.FeeGrowthB,\n\t}\n\n\tpositions = append(positions, position)\n\tnextPositionID++\n\n\treturn position.ID\n}\n\nfunc BurnPosition(_ realm, positionID uint64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\n\tpos := positions[positionID]\n\tcaller := string(runtime.OriginCaller())\n\n\tif pos.Owner != caller {\n\t\tpanic(\"not owner\")\n\t}\n\tif pos.Liquidity == 0 {\n\t\tpanic(\"already burned\")\n\t}\n\n\tpool := pools[pos.PoolID]\n\tpL := getPriceAtTick(pos.TickLower)\n\tpU := getPriceAtTick(pos.TickUpper)\n\n\tamount0, amount1 := getAmountsForLiquidity(pL, pU, pool.PriceX6, pos.Liquidity)\n\n\t// Update ticks\n\tupdateTick(pos.PoolID, pos.TickLower, -pos.Liquidity, true)\n\tupdateTick(pos.PoolID, pos.TickUpper, -pos.Liquidity, false)\n\n\t// Update pool liquidity\n\tif pool.PriceX6 \u003e= pL \u0026\u0026 pool.PriceX6 \u003c pU {\n\t\tpool.Liquidity -= pos.Liquidity\n\t}\n\n\tpos.Liquidity = 0\n\n\t// Send tokens back\n\tif amount0 \u003e 0 || amount1 \u003e 0 {\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\trealmAddr := runtime.CurrentRealm().Address()\n\t\tcallerAddr := runtime.OriginCaller()\n\n\t\tif amount0 \u003e 0 \u0026\u0026 amount1 \u003e 0 {\n\t\t\tcoins := chain.NewCoins(\n\t\t\t\tchain.NewCoin(pool.DenomA, amount0),\n\t\t\t\tchain.NewCoin(pool.DenomB, amount1),\n\t\t\t)\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, coins)\n\t\t} else if amount0 \u003e 0 {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomA, amount0)))\n\t\t} else {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomB, amount1)))\n\t\t}\n\t}\n}\n\n// =============================================================================\n// SWAP\n// =============================================================================\n\nfunc Swap(_ realm, poolID uint64, tokenIn string, minAmountOut int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tpool := pools[poolID]\n\tif pool.Liquidity == 0 {\n\t\tpanic(\"no liquidity\")\n\t}\n\n\tcaller := runtime.OriginCaller()\n\tsentCoins := banker.OriginSend()\n\n\tvar zeroForOne bool\n\tvar amountIn int64\n\n\tif tokenIn == \"A\" {\n\t\tzeroForOne = true\n\t\tamountIn = sentCoins.AmountOf(pool.DenomA)\n\t} else if tokenIn == \"B\" {\n\t\tzeroForOne = false\n\t\tamountIn = sentCoins.AmountOf(pool.DenomB)\n\t} else {\n\t\tpanic(\"tokenIn must be A or B\")\n\t}\n\n\tif amountIn \u003c= 0 {\n\t\tpanic(\"must send input token\")\n\t}\n\n\t// Calculate fee using safe math\n\tfeeAmount := safeMulDiv(amountIn, pool.FeeBPS, 10000)\n\tamountRemaining := amountIn - feeAmount\n\ttotalAmountOut := int64(0)\n\n\t// Process swap with tick crossing\n\tmaxIterations := 100 // Safety limit to prevent infinite loops\n\tfor i := 0; i \u003c maxIterations \u0026\u0026 amountRemaining \u003e 0; i++ {\n\t\tif pool.Liquidity == 0 {\n\t\t\tbreak // No more liquidity\n\t\t}\n\n\t\t// Find next initialized tick in the direction of swap\n\t\tnextTick := findNextInitializedTick(poolID, pool.CurrentTick, zeroForOne)\n\n\t\t// Calculate how much we can swap before hitting the next tick\n\t\tvar amountInStep, amountOutStep int64\n\t\tvar nextTickPrice int64\n\n\t\tif zeroForOne {\n\t\t\t// Swapping A for B (price decreases)\n\t\t\tnextTickPrice = getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MIN_TICK)\n\t\t\t}\n\n\t\t\t// Calculate max input to reach next tick\n\t\t\tpriceDiff := pool.PriceX6 - nextTickPrice\n\t\t\tif priceDiff \u003c= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Max amount that can be swapped at current liquidity to reach nextTickPrice\n\t\t\tmaxAmountIn := safeMulDiv(pool.Liquidity, priceDiff, pool.PriceX6)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn {\n\t\t\t\t// Swap completes within this tick range\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, pool.PriceX6, PRECISION)\n\t\t\t\t// Update price proportionally\n\t\t\t\tpriceChange := safeMulDiv(amountInStep, pool.PriceX6, pool.Liquidity)\n\t\t\t\tpool.PriceX6 -= priceChange\n\t\t\t\tif pool.PriceX6 \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\t\tpool.PriceX6 = getPriceAtTick(MIN_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Swap crosses this tick\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, pool.PriceX6, PRECISION)\n\t\t\t\tpool.PriceX6 = nextTickPrice\n\n\t\t\t\t// Cross the tick - update liquidity\n\t\t\t\tcrossTick(poolID, nextTick, zeroForOne)\n\t\t\t}\n\t\t} else {\n\t\t\t// Swapping B for A (price increases)\n\t\t\tnextTickPrice = getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MAX_TICK)\n\t\t\t}\n\n\t\t\tpriceDiff := nextTickPrice - pool.PriceX6\n\t\t\tif priceDiff \u003c= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(pool.Liquidity, priceDiff, PRECISION)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, PRECISION, pool.PriceX6)\n\t\t\t\tpriceChange := safeMulDiv(amountInStep, PRECISION, pool.Liquidity)\n\t\t\t\tpool.PriceX6 += priceChange\n\t\t\t\tif pool.PriceX6 \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\t\tpool.PriceX6 = getPriceAtTick(MAX_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, PRECISION, pool.PriceX6)\n\t\t\t\tpool.PriceX6 = nextTickPrice\n\n\t\t\t\tcrossTick(poolID, nextTick, zeroForOne)\n\t\t\t}\n\t\t}\n\n\t\tamountRemaining -= amountInStep\n\t\ttotalAmountOut += amountOutStep\n\n\t\t// Accumulate fees for this step (proportional to amount used)\n\t\tif pool.Liquidity \u003e 0 {\n\t\t\tstepFee := safeMulDiv(feeAmount, amountInStep, amountIn-feeAmount)\n\t\t\tif zeroForOne {\n\t\t\t\tpool.FeeGrowthA += safeMulDiv(stepFee, PRECISION, pool.Liquidity)\n\t\t\t} else {\n\t\t\t\tpool.FeeGrowthB += safeMulDiv(stepFee, PRECISION, pool.Liquidity)\n\t\t\t}\n\t\t}\n\t}\n\n\tpool.CurrentTick = getTickAtPrice(pool.PriceX6)\n\n\tif totalAmountOut \u003c minAmountOut {\n\t\tpanic(\"slippage exceeded\")\n\t}\n\n\t// Send output\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tvar denomOut string\n\tif zeroForOne {\n\t\tdenomOut = pool.DenomB\n\t} else {\n\t\tdenomOut = pool.DenomA\n\t}\n\n\tbnk.SendCoins(realmAddr, caller, chain.NewCoins(chain.NewCoin(denomOut, totalAmountOut)))\n\n\treturn totalAmountOut\n}\n\n// findNextInitializedTick finds the next tick with liquidity in the swap direction\nfunc findNextInitializedTick(poolID uint64, currentTick int64, zeroForOne bool) int64 {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\tif zeroForOne {\n\t\t\treturn MIN_TICK\n\t\t}\n\t\treturn MAX_TICK\n\t}\n\n\tpool := pools[poolID]\n\tspacing := pool.TickSpacing\n\n\tif zeroForOne {\n\t\t// Going down (price decreasing), look for next lower initialized tick\n\t\tfor tick := currentTick - spacing; tick \u003e= MIN_TICK; tick -= spacing {\n\t\t\tif info := ticks[tick]; info != nil \u0026\u0026 info.Initialized {\n\t\t\t\treturn tick\n\t\t\t}\n\t\t}\n\t\treturn MIN_TICK\n\t} else {\n\t\t// Going up (price increasing), look for next higher initialized tick\n\t\tfor tick := currentTick + spacing; tick \u003c= MAX_TICK; tick += spacing {\n\t\t\tif info := ticks[tick]; info != nil \u0026\u0026 info.Initialized {\n\t\t\t\treturn tick\n\t\t\t}\n\t\t}\n\t\treturn MAX_TICK\n\t}\n}\n\n// crossTick updates liquidity when crossing a tick boundary\nfunc crossTick(poolID uint64, tick int64, zeroForOne bool) {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\treturn\n\t}\n\n\tinfo := ticks[tick]\n\tif info == nil || !info.Initialized {\n\t\treturn\n\t}\n\n\tpool := pools[poolID]\n\n\t// When crossing a tick from left to right (price increasing), add liquidityNet\n\t// When crossing from right to left (price decreasing), subtract liquidityNet\n\tif zeroForOne {\n\t\t// Price decreasing, crossing tick from above\n\t\tpool.Liquidity -= info.LiquidityNet\n\t} else {\n\t\t// Price increasing, crossing tick from below\n\t\tpool.Liquidity += info.LiquidityNet\n\t}\n\n\t// Ensure liquidity doesn't go negative\n\tif pool.Liquidity \u003c 0 {\n\t\tpool.Liquidity = 0\n\t}\n}\n\n// =============================================================================\n// COLLECT FEES\n// =============================================================================\n\nfunc CollectFees(_ realm, positionID uint64) (int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\n\tpos := positions[positionID]\n\tcaller := string(runtime.OriginCaller())\n\n\tif pos.Owner != caller {\n\t\tpanic(\"not owner\")\n\t}\n\n\tpool := pools[pos.PoolID]\n\n\t// Calculate fees owed since last collection\n\t// Only collect fees if position is/was in range\n\tvar feesA, feesB int64\n\n\tif pos.Liquidity \u003e 0 {\n\t\t// Calculate accumulated fees based on fee growth difference\n\t\tfeeGrowthDeltaA := pool.FeeGrowthA - pos.FeeGrowthLastA\n\t\tfeeGrowthDeltaB := pool.FeeGrowthB - pos.FeeGrowthLastB\n\n\t\t// Use safe math to prevent overflow\n\t\tfeesA = safeMulDiv(feeGrowthDeltaA, pos.Liquidity, PRECISION)\n\t\tfeesB = safeMulDiv(feeGrowthDeltaB, pos.Liquidity, PRECISION)\n\n\t\t// Update position's last fee growth snapshot\n\t\tpos.FeeGrowthLastA = pool.FeeGrowthA\n\t\tpos.FeeGrowthLastB = pool.FeeGrowthB\n\t}\n\n\t// Add any previously uncollected tokens\n\tfeesA += pos.TokensOwedA\n\tfeesB += pos.TokensOwedB\n\tpos.TokensOwedA = 0\n\tpos.TokensOwedB = 0\n\n\t// Send fees to owner\n\tif feesA \u003e 0 || feesB \u003e 0 {\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\trealmAddr := runtime.CurrentRealm().Address()\n\t\tcallerAddr := runtime.OriginCaller()\n\n\t\tif feesA \u003e 0 \u0026\u0026 feesB \u003e 0 {\n\t\t\tcoins := chain.NewCoins(\n\t\t\t\tchain.NewCoin(pool.DenomA, feesA),\n\t\t\t\tchain.NewCoin(pool.DenomB, feesB),\n\t\t\t)\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, coins)\n\t\t} else if feesA \u003e 0 {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomA, feesA)))\n\t\t} else {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomB, feesB)))\n\t\t}\n\t}\n\n\treturn feesA, feesB\n}\n\n// GetPositionFees returns uncollected fees for a position\nfunc GetPositionFees(positionID uint64) (int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\treturn 0, 0\n\t}\n\n\tpos := positions[positionID]\n\tpool := pools[pos.PoolID]\n\n\tvar feesA, feesB int64\n\n\tif pos.Liquidity \u003e 0 {\n\t\tfeeGrowthDeltaA := pool.FeeGrowthA - pos.FeeGrowthLastA\n\t\tfeeGrowthDeltaB := pool.FeeGrowthB - pos.FeeGrowthLastB\n\n\t\t// Use safe math to prevent overflow\n\t\tfeesA = safeMulDiv(feeGrowthDeltaA, pos.Liquidity, PRECISION)\n\t\tfeesB = safeMulDiv(feeGrowthDeltaB, pos.Liquidity, PRECISION)\n\t}\n\n\tfeesA += pos.TokensOwedA\n\tfeesB += pos.TokensOwedB\n\n\treturn feesA, feesB\n}\n\n// =============================================================================\n// TICK HELPERS\n// =============================================================================\n\nfunc updateTick(poolID uint64, tick int64, liquidityDelta int64, isLower bool) {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\tticks = make(map[int64]*TickInfo)\n\t\ttickData[poolID] = ticks\n\t}\n\n\tinfo := ticks[tick]\n\tif info == nil {\n\t\tinfo = \u0026TickInfo{}\n\t\tticks[tick] = info\n\t}\n\n\tinfo.LiquidityGross += liquidityDelta\n\n\tif isLower {\n\t\tinfo.LiquidityNet += liquidityDelta\n\t} else {\n\t\tinfo.LiquidityNet -= liquidityDelta\n\t}\n\n\tinfo.Initialized = info.LiquidityGross \u003e 0\n}\n\n// =============================================================================\n// QUERIES\n// =============================================================================\n\nfunc GetCLMMPool(poolID uint64) (string, string, int64, int64, int64, int64, int64) {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tp := pools[poolID]\n\treturn p.DenomA, p.DenomB, p.PriceX6, p.CurrentTick, p.Liquidity, p.FeeBPS, p.TickSpacing\n}\n\nfunc GetCLMMPoolCount() uint64 {\n\treturn uint64(len(pools))\n}\n\nfunc GetPosition(positionID uint64) (uint64, string, int64, int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\tp := positions[positionID]\n\treturn p.PoolID, p.Owner, p.TickLower, p.TickUpper, p.Liquidity\n}\n\nfunc GetPositionCount() uint64 {\n\treturn uint64(len(positions))\n}\n\nfunc GetPositionsByOwner(owner string) []uint64 {\n\tvar result []uint64\n\tfor _, p := range positions {\n\t\tif p.Owner == owner \u0026\u0026 p.Liquidity \u003e 0 {\n\t\t\tresult = append(result, p.ID)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc GetQuote(poolID uint64, tokenIn string, amountIn int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\treturn 0\n\t}\n\n\tpool := pools[poolID]\n\tif pool.Liquidity == 0 {\n\t\treturn 0\n\t}\n\n\t// Simulate the swap without modifying state\n\t// Copy pool state for simulation\n\tsimPriceX6 := pool.PriceX6\n\tsimLiquidity := pool.Liquidity\n\tsimCurrentTick := pool.CurrentTick\n\n\tvar zeroForOne bool\n\tif tokenIn == \"A\" {\n\t\tzeroForOne = true\n\t} else if tokenIn == \"B\" {\n\t\tzeroForOne = false\n\t} else {\n\t\treturn 0\n\t}\n\n\t// Calculate fee\n\tfeeAmount := safeMulDiv(amountIn, pool.FeeBPS, 10000)\n\tamountRemaining := amountIn - feeAmount\n\ttotalAmountOut := int64(0)\n\n\t// Simulate swap with tick crossing (same logic as Swap but read-only)\n\tmaxIterations := 100\n\tfor i := 0; i \u003c maxIterations \u0026\u0026 amountRemaining \u003e 0; i++ {\n\t\tif simLiquidity == 0 {\n\t\t\tbreak // No more liquidity\n\t\t}\n\n\t\t// Find next tick (read-only)\n\t\tnextTick := findNextInitializedTick(poolID, simCurrentTick, zeroForOne)\n\n\t\tvar amountInStep, amountOutStep int64\n\n\t\tif zeroForOne {\n\t\t\t// Swapping A for B (price decreases)\n\t\t\tnextTickPrice := getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MIN_TICK)\n\t\t\t}\n\n\t\t\tpriceDiff := simPriceX6 - nextTickPrice\n\t\t\tif priceDiff \u003c= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(simLiquidity, priceDiff, simPriceX6)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, simPriceX6, PRECISION)\n\t\t\t\tpriceChange := safeMulDiv(amountInStep, simPriceX6, simLiquidity)\n\t\t\t\tsimPriceX6 -= priceChange\n\t\t\t\tif simPriceX6 \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\t\tsimPriceX6 = getPriceAtTick(MIN_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, simPriceX6, PRECISION)\n\t\t\t\tsimPriceX6 = nextTickPrice\n\n\t\t\t\t// Simulate tick crossing - get liquidity delta\n\t\t\t\tticks := tickData[poolID]\n\t\t\t\tif ticks != nil {\n\t\t\t\t\tif tickInfo, ok := ticks[nextTick]; ok \u0026\u0026 tickInfo.Initialized {\n\t\t\t\t\t\tsimLiquidity -= tickInfo.LiquidityNet\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsimCurrentTick = nextTick\n\t\t\t}\n\t\t} else {\n\t\t\t// Swapping B for A (price increases)\n\t\t\tnextTickPrice := getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MAX_TICK)\n\t\t\t}\n\n\t\t\tpriceDiff := nextTickPrice - simPriceX6\n\t\t\tif priceDiff \u003c= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(simLiquidity, priceDiff, PRECISION)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, PRECISION, simPriceX6)\n\t\t\t\tpriceChange := safeMulDiv(amountInStep, PRECISION, simLiquidity)\n\t\t\t\tsimPriceX6 += priceChange\n\t\t\t\tif simPriceX6 \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\t\tsimPriceX6 = getPriceAtTick(MAX_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, PRECISION, simPriceX6)\n\t\t\t\tsimPriceX6 = nextTickPrice\n\n\t\t\t\t// Simulate tick crossing\n\t\t\t\tticks := tickData[poolID]\n\t\t\t\tif ticks != nil {\n\t\t\t\t\tif tickInfo, ok := ticks[nextTick]; ok \u0026\u0026 tickInfo.Initialized {\n\t\t\t\t\t\tsimLiquidity += tickInfo.LiquidityNet\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsimCurrentTick = nextTick\n\t\t\t}\n\t\t}\n\n\t\tamountRemaining -= amountInStep\n\t\ttotalAmountOut += amountOutStep\n\t}\n\n\treturn totalAmountOut\n}\n\nfunc GetPriceAtTick(tick int64) int64 {\n\treturn getPriceAtTick(tick)\n}\n\nfunc GetTickAtPrice(priceX6 int64) int64 {\n\treturn getTickAtPrice(priceX6)\n}\n\nfunc GetRealmAddress() string {\n\treturn string(runtime.CurrentRealm().Address())\n}\n\n// =============================================================================\n// RENDER\n// =============================================================================\n\nfunc Render(path string) string {\n\tvar sb strings.Builder\n\n\tsb.WriteString(\"# Gnomo CLMM\\n\\n\")\n\tsb.WriteString(\"**Address:** `\" + string(runtime.CurrentRealm().Address()) + \"`\\n\\n\")\n\n\tif len(pools) == 0 {\n\t\tsb.WriteString(\"No pools yet.\\n\")\n\t} else {\n\t\tsb.WriteString(\"## Pools\\n\\n\")\n\t\tfor _, p := range pools {\n\t\t\tsb.WriteString(\"### Pool \" + strconv.FormatUint(p.ID, 10) + \"\\n\")\n\t\t\tsb.WriteString(\"- Pair: \" + formatDenom(p.DenomA) + \"/\" + formatDenom(p.DenomB) + \"\\n\")\n\t\t\tsb.WriteString(\"- Fee: \" + strconv.FormatInt(p.FeeBPS, 10) + \" bps\\n\")\n\t\t\tsb.WriteString(\"- Tick: \" + strconv.FormatInt(p.CurrentTick, 10) + \"\\n\")\n\t\t\tsb.WriteString(\"- Liquidity: \" + strconv.FormatInt(p.Liquidity, 10) + \"\\n\")\n\t\t\tpriceFloat := float64(p.PriceX6) / float64(PRECISION)\n\t\t\tsb.WriteString(\"- Price: \" + strconv.FormatFloat(priceFloat, 'f', 6, 64) + \"\\n\\n\")\n\t\t}\n\t}\n\n\tsb.WriteString(\"## Stats\\n\")\n\tsb.WriteString(\"- Pools: \" + strconv.Itoa(len(pools)) + \"\\n\")\n\n\tactivePos := 0\n\tfor _, p := range positions {\n\t\tif p.Liquidity \u003e 0 {\n\t\t\tactivePos++\n\t\t}\n\t}\n\tsb.WriteString(\"- Positions: \" + strconv.Itoa(activePos) + \"\\n\")\n\n\treturn sb.String()\n}\n\nfunc formatDenom(denom string) string {\n\tif denom == \"ugnot\" {\n\t\treturn \"GNOT\"\n\t}\n\tif strings.Contains(denom, \":\") {\n\t\tparts := strings.Split(denom, \":\")\n\t\treturn strings.ToUpper(parts[len(parts)-1])\n\t}\n\treturn denom\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/gnomo/clmm3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"50000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"D+ZiovJzdvvX3Ik1i4syhiRrXKTRDUV9IUVqkl36G5f0mJS+A6+LgHAfW7n9JjnXe4MeVQRb1JxRL4FBgS+AAQ=="}],"memo":""},"metadata":{"timestamp":"1768364740"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"gnomo","path":"gno.land/r/gnomo/dex3","files":[{"name":"gnomo.gno","body":"package gnomo\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Pool represents a liquidity pool for two token denoms\ntype Pool struct {\n\tID       uint64\n\tDenomA   string\n\tDenomB   string\n\tReserveA int64\n\tReserveB int64\n\tTotalLP  int64\n\tFeeBPS   int64\n}\n\nvar (\n\tpools      []*Pool\n\tnextPoolID uint64\n\tlpBalances map[uint64]map[string]int64\n)\n\nfunc init() {\n\tlpBalances = make(map[uint64]map[string]int64)\n}\n\n// GetRealmTokenDenom returns the full denom for a realm-issued token\n// e.g., \"usdc\" -\u003e \"/gno.land/r/dev/gnomo:usdc\"\nfunc GetRealmTokenDenom(baseName string) string {\n\treturn runtime.CurrentRealm().CoinDenom(baseName)\n}\n\n// MintTestTokens mints test tokens to the caller (for testing only)\n// This allows testing the DEX without needing external tokens\nfunc MintTestTokens(_ realm, baseName string, amount int64) string {\n\tif amount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\tif baseName == \"\" {\n\t\tpanic(\"baseName required\")\n\t}\n\n\tcaller := runtime.OriginCaller()\n\tbnk := banker.NewBanker(banker.BankerTypeRealmIssue)\n\t\n\tdenom := runtime.CurrentRealm().CoinDenom(baseName)\n\tbnk.IssueCoin(caller, denom, amount)\n\t\n\treturn denom\n}\n\n// CreatePool creates a new liquidity pool\nfunc CreatePool(_ realm, denomA, denomB string, feeBPS int64) uint64 {\n\tif denomA == \"\" || denomB == \"\" {\n\t\tpanic(\"invalid denom\")\n\t}\n\tif denomA == denomB {\n\t\tpanic(\"denoms must be different\")\n\t}\n\tif denomA \u003e denomB {\n\t\tdenomA, denomB = denomB, denomA\n\t}\n\tfor _, p := range pools {\n\t\tif p.DenomA == denomA \u0026\u0026 p.DenomB == denomB \u0026\u0026 p.FeeBPS == feeBPS {\n\t\t\tpanic(\"pool already exists\")\n\t\t}\n\t}\n\tif feeBPS == 0 {\n\t\tfeeBPS = 30\n\t}\n\tif feeBPS \u003e 1000 {\n\t\tpanic(\"fee too high\")\n\t}\n\n\tpool := \u0026Pool{\n\t\tID:     nextPoolID,\n\t\tDenomA: denomA,\n\t\tDenomB: denomB,\n\t\tFeeBPS: feeBPS,\n\t}\n\tpools = append(pools, pool)\n\tlpBalances[nextPoolID] = make(map[string]int64)\n\tnextPoolID++\n\treturn pool.ID\n}\n\n// AddLiquidity adds liquidity to a pool\n// User must send both tokens with the transaction\n// minLPOut provides slippage protection - set to 0 to skip\nfunc AddLiquidity(_ realm, poolID uint64, minLPOut int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tp := pools[poolID]\n\tcaller := string(runtime.OriginCaller())\n\n\tsentCoins := banker.OriginSend()\n\tamountA := sentCoins.AmountOf(p.DenomA)\n\tamountB := sentCoins.AmountOf(p.DenomB)\n\n\tif amountA \u003c= 0 || amountB \u003c= 0 {\n\t\tpanic(\"must send both tokens: \" + p.DenomA + \" and \" + p.DenomB)\n\t}\n\n\tvar lpMinted int64\n\n\tif p.TotalLP == 0 {\n\t\t// Use safe multiplication for initial liquidity\n\t\tlpMinted = sqrt64(safeMul(amountA, amountB))\n\t\tif lpMinted == 0 {\n\t\t\tpanic(\"insufficient initial liquidity\")\n\t\t}\n\t} else {\n\t\t// Use safeMulDiv to prevent overflow\n\t\tlpFromA := safeMulDiv(amountA, p.TotalLP, p.ReserveA)\n\t\tlpFromB := safeMulDiv(amountB, p.TotalLP, p.ReserveB)\n\t\tlpMinted = min64(lpFromA, lpFromB)\n\t\tif lpMinted == 0 {\n\t\t\tpanic(\"insufficient liquidity minted\")\n\t\t}\n\t}\n\n\t// Slippage protection\n\tif minLPOut \u003e 0 \u0026\u0026 lpMinted \u003c minLPOut {\n\t\tpanic(\"slippage: LP minted \" + strconv.FormatInt(lpMinted, 10) + \" \u003c min \" + strconv.FormatInt(minLPOut, 10))\n\t}\n\n\tp.ReserveA += amountA\n\tp.ReserveB += amountB\n\tp.TotalLP += lpMinted\n\tlpBalances[poolID][caller] += lpMinted\n\n\treturn lpMinted\n}\n\n// RemoveLiquidity burns LP tokens and returns proportional reserves\n// minAmountA/minAmountB provide slippage protection - set to 0 to skip\nfunc RemoveLiquidity(_ realm, poolID uint64, lpAmount int64, minAmountA int64, minAmountB int64) {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tif lpAmount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\n\tp := pools[poolID]\n\tcaller := string(runtime.OriginCaller())\n\tcallerLP := lpBalances[poolID][caller]\n\n\tif callerLP \u003c lpAmount {\n\t\tpanic(\"insufficient LP balance\")\n\t}\n\n\t// Use safeMulDiv to prevent overflow\n\tamountA := safeMulDiv(lpAmount, p.ReserveA, p.TotalLP)\n\tamountB := safeMulDiv(lpAmount, p.ReserveB, p.TotalLP)\n\n\tif amountA \u003c= 0 || amountB \u003c= 0 {\n\t\tpanic(\"insufficient output amounts\")\n\t}\n\n\t// Slippage protection\n\tif minAmountA \u003e 0 \u0026\u0026 amountA \u003c minAmountA {\n\t\tpanic(\"slippage: amountA \" + strconv.FormatInt(amountA, 10) + \" \u003c min \" + strconv.FormatInt(minAmountA, 10))\n\t}\n\tif minAmountB \u003e 0 \u0026\u0026 amountB \u003c minAmountB {\n\t\tpanic(\"slippage: amountB \" + strconv.FormatInt(amountB, 10) + \" \u003c min \" + strconv.FormatInt(minAmountB, 10))\n\t}\n\n\tp.ReserveA -= amountA\n\tp.ReserveB -= amountB\n\tp.TotalLP -= lpAmount\n\tlpBalances[poolID][caller] -= lpAmount\n\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\tcallerAddr := runtime.OriginCaller()\n\n\tcoins := chain.NewCoins(\n\t\tchain.NewCoin(p.DenomA, amountA),\n\t\tchain.NewCoin(p.DenomB, amountB),\n\t)\n\tbnk.SendCoins(realmAddr, callerAddr, coins)\n}\n\n// Swap swaps exact input amount for output\nfunc Swap(_ realm, poolID uint64, tokenIn string, minAmountOut int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tif tokenIn != \"A\" \u0026\u0026 tokenIn != \"B\" {\n\t\tpanic(\"tokenIn must be A or B\")\n\t}\n\n\tp := pools[poolID]\n\tif p.ReserveA == 0 || p.ReserveB == 0 {\n\t\tpanic(\"pool has no liquidity\")\n\t}\n\n\tcaller := runtime.OriginCaller()\n\tsentCoins := banker.OriginSend()\n\n\tvar amountIn int64\n\tvar denomOut string\n\n\tif tokenIn == \"A\" {\n\t\tdenomOut = p.DenomB\n\t\tamountIn = sentCoins.AmountOf(p.DenomA)\n\t} else {\n\t\tdenomOut = p.DenomA\n\t\tamountIn = sentCoins.AmountOf(p.DenomB)\n\t}\n\n\tif amountIn \u003c= 0 {\n\t\tpanic(\"must send input token\")\n\t}\n\n\tvar amountOut int64\n\tamountInWithFee := safeMulDiv(amountIn, 10000-p.FeeBPS, 10000)\n\n\tif tokenIn == \"A\" {\n\t\t// amountOut = (amountInWithFee * reserveB) / (reserveA + amountInWithFee)\n\t\tamountOut = safeMulDiv(amountInWithFee, p.ReserveB, p.ReserveA+amountInWithFee)\n\t\tp.ReserveA += amountIn\n\t\tp.ReserveB -= amountOut\n\t} else {\n\t\tamountOut = safeMulDiv(amountInWithFee, p.ReserveA, p.ReserveB+amountInWithFee)\n\t\tp.ReserveB += amountIn\n\t\tp.ReserveA -= amountOut\n\t}\n\n\tif amountOut \u003c= 0 {\n\t\tpanic(\"insufficient output amount\")\n\t}\n\tif amountOut \u003c minAmountOut {\n\t\tpanic(\"slippage: output \" + strconv.FormatInt(amountOut, 10) + \" \u003c min \" + strconv.FormatInt(minAmountOut, 10))\n\t}\n\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\toutCoins := chain.NewCoins(chain.NewCoin(denomOut, amountOut))\n\tbnk.SendCoins(realmAddr, caller, outCoins)\n\n\treturn amountOut\n}\n\n// GetQuote returns expected output without executing swap\nfunc GetQuote(poolID uint64, tokenIn string, amountIn int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tp := pools[poolID]\n\tif p.ReserveA == 0 || p.ReserveB == 0 {\n\t\treturn 0\n\t}\n\n\tamountInWithFee := safeMulDiv(amountIn, 10000-p.FeeBPS, 10000)\n\n\tif tokenIn == \"A\" {\n\t\treturn safeMulDiv(amountInWithFee, p.ReserveB, p.ReserveA+amountInWithFee)\n\t}\n\treturn safeMulDiv(amountInWithFee, p.ReserveA, p.ReserveB+amountInWithFee)\n}\n\n// GetPool returns pool info\nfunc GetPool(poolID uint64) (string, string, int64, int64, int64, int64) {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tp := pools[poolID]\n\treturn p.DenomA, p.DenomB, p.ReserveA, p.ReserveB, p.TotalLP, p.FeeBPS\n}\n\nfunc GetPoolCount() uint64 {\n\treturn uint64(len(pools))\n}\n\nfunc GetLPBalance(poolID uint64, addr string) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\treturn 0\n\t}\n\treturn lpBalances[poolID][addr]\n}\n\nfunc GetRealmAddress() string {\n\treturn string(runtime.CurrentRealm().Address())\n}\n\n// Helper functions\nfunc sqrt64(x int64) int64 {\n\tif x \u003c= 0 {\n\t\treturn 0\n\t}\n\tz := x\n\ty := (z + 1) / 2\n\tfor y \u003c z {\n\t\tz = y\n\t\ty = (z + x/z) / 2\n\t}\n\treturn z\n}\n\nfunc min64(a, b int64) int64 {\n\tif a \u003c b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// Safe math to prevent overflow\nconst MAX_INT64 = int64(9223372036854775807)\n\nfunc safeMul(a, b int64) int64 {\n\tif a == 0 || b == 0 {\n\t\treturn 0\n\t}\n\tresult := a * b\n\t// Check for overflow: if result/a != b, overflow occurred\n\tif result/a != b {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn result\n}\n\nfunc safeMulDiv(a, b, c int64) int64 {\n\tif c == 0 {\n\t\tpanic(\"division by zero\")\n\t}\n\t// For large numbers, divide first to avoid overflow\n\t// Use: (a * b) / c = (a / c) * b + (a % c) * b / c\n\tif a \u003e MAX_INT64/b \u0026\u0026 b != 0 {\n\t\tquotient := a / c\n\t\tremainder := a % c\n\t\treturn quotient*b + (remainder*b)/c\n\t}\n\treturn (a * b) / c\n}\n\n// Render displays pool information\nfunc Render(path string) string {\n\tvar sb strings.Builder\n\tsb.WriteString(\"# Gnomo DEX\\n\\n\")\n\tsb.WriteString(\"**Contract Address:** `\" + string(runtime.CurrentRealm().Address()) + \"`\\n\\n\")\n\n\t// Show test token denom\n\ttestDenom := runtime.CurrentRealm().CoinDenom(\"usdc\")\n\tsb.WriteString(\"**Test Token (usdc):** `\" + testDenom + \"`\\n\\n\")\n\n\tif len(pools) == 0 {\n\t\tsb.WriteString(\"No pools created yet.\\n\\n\")\n\t} else {\n\t\tsb.WriteString(\"## Pools\\n\\n\")\n\t\tfor _, p := range pools {\n\t\t\tsb.WriteString(\"### Pool \" + strconv.FormatUint(p.ID, 10) + \": \" + p.DenomA + \" / \" + p.DenomB + \"\\n\\n\")\n\t\t\tsb.WriteString(\"| Metric | Value |\\n\")\n\t\t\tsb.WriteString(\"|--------|-------|\\n\")\n\t\t\tsb.WriteString(\"| Reserve A | \" + strconv.FormatInt(p.ReserveA, 10) + \" |\\n\")\n\t\t\tsb.WriteString(\"| Reserve B | \" + strconv.FormatInt(p.ReserveB, 10) + \" |\\n\")\n\t\t\tsb.WriteString(\"| Total LP | \" + strconv.FormatInt(p.TotalLP, 10) + \" |\\n\")\n\t\t\tsb.WriteString(\"| Fee | \" + strconv.FormatInt(p.FeeBPS, 10) + \" bps |\\n\")\n\n\t\t\tif p.ReserveA \u003e 0 \u0026\u0026 p.ReserveB \u003e 0 {\n\t\t\t\tpriceAtoB := (p.ReserveB * 1000000) / p.ReserveA\n\t\t\t\tpriceBtoA := (p.ReserveA * 1000000) / p.ReserveB\n\t\t\t\tsb.WriteString(\"| Price A→B | \" + formatPrice(priceAtoB) + \" |\\n\")\n\t\t\t\tsb.WriteString(\"| Price B→A | \" + formatPrice(priceBtoA) + \" |\\n\")\n\t\t\t}\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\tsb.WriteString(\"## Quick Start\\n\\n\")\n\tsb.WriteString(\"### 1. Get Test Tokens\\n\")\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"gnokey maketx call -func MintTestTokens -args \\\"usdc\\\" -args \\\"10000000\\\" ...\\n\")\n\tsb.WriteString(\"```\\n\\n\")\n\tsb.WriteString(\"### 2. Create Pool (ugnot + test usdc)\\n\")\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"gnokey maketx call -func CreatePool -args \\\"ugnot\\\" -args \\\"\" + testDenom + \"\\\" -args \\\"30\\\" ...\\n\")\n\tsb.WriteString(\"```\\n\\n\")\n\tsb.WriteString(\"### 3. Add Liquidity\\n\")\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"gnokey maketx call -send \\\"1000000ugnot,2000000\" + testDenom + \"\\\" -func AddLiquidity -args \\\"0\\\" ...\\n\")\n\tsb.WriteString(\"```\\n\\n\")\n\tsb.WriteString(\"### 4. Swap\\n\")\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"gnokey maketx call -send \\\"100000ugnot\\\" -func Swap -args \\\"0\\\" -args \\\"A\\\" -args \\\"0\\\" ...\\n\")\n\tsb.WriteString(\"```\\n\\n\")\n\n\treturn sb.String()\n}\n\nfunc formatPrice(microPrice int64) string {\n\twhole := microPrice / 1000000\n\tfrac := microPrice % 1000000\n\tif frac == 0 {\n\t\treturn strconv.FormatInt(whole, 10)\n\t}\n\tfracStr := strconv.FormatInt(frac, 10)\n\tfor len(fracStr) \u003c 6 {\n\t\tfracStr = \"0\" + fracStr\n\t}\n\tfracStr = strings.TrimRight(fracStr, \"0\")\n\treturn strconv.FormatInt(whole, 10) + \".\" + fracStr\n}"},{"name":"gnomod.toml","body":"module = \"gno.land/r/gnomo/dex3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"50000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"p08xDLZI7yWhIHU+CmT0LzZq/eWjsiWm3hbzM1G7hDkAcyyfB8eBbf7bqqGz0X2QHvt+wBZfY0TdiIXana8oBA=="}],"memo":""},"metadata":{"timestamp":"1768365765"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"MintTestTokens","args":["usdc","10000000000"]}],"fee":{"gas_wanted":"2746668","gas_fee":"2747ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"t4RWgduRL53u8lrAy2K1useGeA6s5EIEoqFM50xvSkBtnKBZ1oz9YUbQP6JYbNy/09pjzoQSTXPNcec9Q+k4DQ=="}],"memo":""},"metadata":{"timestamp":"1768366062"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"CreatePool","args":["ugnot","/gno.land/r/gnomo/dex3:usdc","5"]}],"fee":{"gas_wanted":"636158","gas_fee":"637ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"hQjYYk+ef6BTzj5CFYob0Ibq5Hfh7iWgqA4Lm90V0gOa04UhfSbZip7F+skDsI0JdgcQce3Hq5GRiP0lFwqnBA=="}],"memo":""},"metadata":{"timestamp":"1768366092"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"250000000/gno.land/r/gnomo/dex3:usdc,250000000ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"AddLiquidity","args":["0","0"]}],"fee":{"gas_wanted":"1440489","gas_fee":"1441ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"jErciW2IroANpzyCX3vV37R06AyuDbq/IZdFLVQ+h/UilwZnHcr//nCg7iD96KrExxM22ImllaKLYpbgOKBtCQ=="}],"memo":""},"metadata":{"timestamp":"1768366112"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"CreateCLMMPool","args":["ugnot","/gno.land/r/gnomo/dex3:usdc","5","1000000"]}],"fee":{"gas_wanted":"2177230","gas_fee":"2178ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"i1QgFpXkQkkCRnLASmJnWbGiM1BVUCpIbZF3MnGlnSuwKoRbQngHZKI5jYx4/Z357OPW4d4NY+d/6wbhrOEFCA=="}],"memo":""},"metadata":{"timestamp":"1768366147"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"1000000000/gno.land/r/gnomo/dex3:usdc,1000055099ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"MintPosition","args":["0","-10","10"]}],"fee":{"gas_wanted":"1774660","gas_fee":"1775ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"2Vd0GF9guZTfDTQUSlO5xPS+dn3UbsdmJhRJYRj32QrtrL3swJRrh+xAi3X0CeH5OVa2cAUouBLiF5VsrB5bDw=="}],"memo":""},"metadata":{"timestamp":"1768366188"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"1000000000ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"Swap","args":["0","B","994502500"]}],"fee":{"gas_wanted":"5634677","gas_fee":"5635ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"cAV9uCYvX+ruM/hp5NsPNpRWJPEUIJZuwDIzdFzJrRC3xOmVKzRTumH+qh+7Eu1Wi2CHBziZrQ6HsItm6BFPAA=="}],"memo":""},"metadata":{"timestamp":"1768366308"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"250000000/gno.land/r/gnomo/dex3:usdc","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"Swap","args":["0","A","272161272"]}],"fee":{"gas_wanted":"5644017","gas_fee":"5645ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"GA7oeyGVdQWr1hgul2WzH9Wri6w7ru07FqX/wxIbg4Cq5UVpCmRrJ9mzMIIVwjXbdJy5zHCWEJb0gewTS0baDA=="}],"memo":""},"metadata":{"timestamp":"1768367032"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"clmm","path":"gno.land/r/gnomo/clmm4","files":[{"name":"clmm.gno","body":"package clmm\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst (\n\tMIN_TICK  = -1000\n\tMAX_TICK  = 1000\n\tPRECISION = 1000000\n\tMAX_INT64 = int64(9223372036854775807)\n)\n\n// =============================================================================\n// SAFE MATH\n// =============================================================================\n\nfunc safeMul(a, b int64) int64 {\n\tif a == 0 || b == 0 {\n\t\treturn 0\n\t}\n\tresult := a * b\n\tif result/a != b {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn result\n}\n\nfunc safeMulDiv(a, b, c int64) int64 {\n\tif c == 0 {\n\t\tpanic(\"division by zero\")\n\t}\n\tif a \u003e MAX_INT64/b \u0026\u0026 b != 0 {\n\t\tquotient := a / c\n\t\tremainder := a % c\n\t\treturn quotient*b + (remainder*b)/c\n\t}\n\treturn (a * b) / c\n}\n\n// Integer square root using Newton's method\nfunc isqrt(n int64) int64 {\n\tif n \u003c 0 {\n\t\tpanic(\"sqrt of negative\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n \u003c 2 {\n\t\treturn n\n\t}\n\n\t// Initial guess\n\tx := n\n\ty := (x + 1) / 2\n\n\tfor y \u003c x {\n\t\tx = y\n\t\ty = (x + n/x) / 2\n\t}\n\n\treturn x\n}\n\n// =============================================================================\n// DATA STRUCTURES\n// =============================================================================\n\ntype CLMMPool struct {\n\tID          uint64\n\tDenomA      string\n\tDenomB      string\n\tFeeBPS      int64\n\tTickSpacing int64\n\tPriceX6     int64\n\tCurrentTick int64\n\tLiquidity   int64\n\tFeeGrowthA  int64\n\tFeeGrowthB  int64\n}\n\ntype Position struct {\n\tID            uint64\n\tPoolID        uint64\n\tOwner         string\n\tTickLower     int64\n\tTickUpper     int64\n\tLiquidity     int64\n\tFeeGrowthLastA int64\n\tFeeGrowthLastB int64\n\tTokensOwedA   int64\n\tTokensOwedB   int64\n}\n\ntype TickInfo struct {\n\tLiquidityGross int64\n\tLiquidityNet   int64\n\tInitialized    bool\n}\n\nvar (\n\tpools          []*CLMMPool\n\tnextPoolID     uint64\n\tpositions      []*Position\n\tnextPositionID uint64\n\ttickData       map[uint64]map[int64]*TickInfo\n)\n\nfunc init() {\n\ttickData = make(map[uint64]map[int64]*TickInfo)\n}\n\n// =============================================================================\n// TICK MATH\n// =============================================================================\n\nfunc getPriceAtTick(tick int64) int64 {\n\tif tick \u003c MIN_TICK || tick \u003e MAX_TICK {\n\t\tpanic(\"tick out of range\")\n\t}\n\n\tif tick == 0 {\n\t\treturn PRECISION\n\t}\n\n\tabsTick := tick\n\tif absTick \u003c 0 {\n\t\tabsTick = -absTick\n\t}\n\n\t// Use 1.01 per tick (1% price change per tick)\n\t// Calculate 1.01^absTick using simple iteration\n\tresult := int64(PRECISION) // 1.0 in X6\n\n\tfor i := int64(0); i \u003c absTick; i++ {\n\t\t// result = result * 1.01 = result * 101 / 100\n\t\t// Check for overflow before multiplication\n\t\tif result \u003e MAX_INT64/101 {\n\t\t\tpanic(\"price calculation overflow\")\n\t\t}\n\t\tresult = (result * 101) / 100\n\t}\n\n\tif tick \u003c 0 {\n\t\t// Invert: 1 / price = PRECISION^2 / result\n\t\tif result \u003e 0 {\n\t\t\treturn safeMulDiv(PRECISION, PRECISION, result)\n\t\t}\n\t\treturn PRECISION\n\t}\n\n\treturn result\n}\n\nfunc getTickAtPrice(priceX6 int64) int64 {\n\tif priceX6 \u003c= 0 {\n\t\tpanic(\"invalid price\")\n\t}\n\n\tlow := int64(MIN_TICK)\n\thigh := int64(MAX_TICK)\n\n\tfor low \u003c high {\n\t\tmid := (low + high + 1) / 2\n\t\tpriceAtMid := getPriceAtTick(mid)\n\n\t\tif priceAtMid \u003c= priceX6 {\n\t\t\tlow = mid\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\n\treturn low\n}\n\n// =============================================================================\n// LIQUIDITY MATH (using sqrt-based Uniswap v3 formulas)\n// =============================================================================\n\n// getAmountsForLiquidity calculates token amounts for a given liquidity\n// Uses proper sqrt-based CLMM math:\n// - amt0 = L * (1/sqrt(pC) - 1/sqrt(pU)) = L * (sqrt(pU) - sqrt(pC)) / (sqrt(pC) * sqrt(pU))\n// - amt1 = L * (sqrt(pC) - sqrt(pL))\nfunc getAmountsForLiquidity(pL, pU, pC, liq int64) (int64, int64) {\n\tif liq \u003c= 0 {\n\t\treturn 0, 0\n\t}\n\n\tsqrtPrecision := int64(1000) // sqrt(PRECISION)\n\tsqrtPL := isqrt(pL * PRECISION)\n\tsqrtPU := isqrt(pU * PRECISION)\n\tsqrtPC := isqrt(pC * PRECISION)\n\n\tif pC \u003c= pL {\n\t\t// Price below range: all token0\n\t\t// amt0 = L * (sqrt(pU) - sqrt(pL)) / (sqrt(pL) * sqrt(pU) / sqrtPrecision)\n\t\tif sqrtPL == 0 || sqrtPU == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tdenom := safeMulDiv(sqrtPL, sqrtPU, sqrtPrecision*PRECISION)\n\t\tif denom == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tamt0 := safeMulDiv(liq, sqrtPU-sqrtPL, denom)\n\t\treturn amt0, 0\n\t} else if pC \u003e= pU {\n\t\t// Price above range: all token1\n\t\t// amt1 = L * (sqrt(pU) - sqrt(pL)) / sqrtPrecision\n\t\tamt1 := safeMulDiv(liq, sqrtPU-sqrtPL, sqrtPrecision*PRECISION)\n\t\treturn 0, amt1\n\t} else {\n\t\t// Price in range: mix of both tokens\n\t\t// amt0 = L * (sqrt(pU) - sqrt(pC)) / (sqrt(pC) * sqrt(pU) / sqrtPrecision)\n\t\t// amt1 = L * (sqrt(pC) - sqrt(pL)) / sqrtPrecision\n\t\tdenom0 := safeMulDiv(sqrtPC, sqrtPU, sqrtPrecision*PRECISION)\n\t\tif denom0 == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tamt0 := safeMulDiv(liq, sqrtPU-sqrtPC, denom0)\n\t\tamt1 := safeMulDiv(liq, sqrtPC-sqrtPL, sqrtPrecision*PRECISION)\n\t\treturn amt0, amt1\n\t}\n}\n\n// getLiquidityForAmounts calculates liquidity from token amounts\n// Uses proper sqrt-based CLMM math (inverse of getAmountsForLiquidity)\nfunc getLiquidityForAmounts(pL, pU, pC, amt0, amt1 int64) int64 {\n\tsqrtPrecision := int64(1000)\n\tsqrtPL := isqrt(pL * PRECISION)\n\tsqrtPU := isqrt(pU * PRECISION)\n\tsqrtPC := isqrt(pC * PRECISION)\n\n\tif pC \u003c= pL {\n\t\t// Price below range: use amt0 only\n\t\t// L = amt0 * sqrt(pL) * sqrt(pU) / (sqrt(pU) - sqrt(pL))\n\t\tif amt0 \u003c= 0 || sqrtPU \u003c= sqrtPL {\n\t\t\treturn 0\n\t\t}\n\t\tnumerator := safeMulDiv(sqrtPL, sqrtPU, sqrtPrecision*PRECISION)\n\t\treturn safeMulDiv(amt0, numerator, sqrtPU-sqrtPL)\n\t} else if pC \u003e= pU {\n\t\t// Price above range: use amt1 only\n\t\t// L = amt1 * sqrtPrecision / (sqrt(pU) - sqrt(pL))\n\t\tif amt1 \u003c= 0 || sqrtPU \u003c= sqrtPL {\n\t\t\treturn 0\n\t\t}\n\t\treturn safeMulDiv(amt1, sqrtPrecision*PRECISION, sqrtPU-sqrtPL)\n\t} else {\n\t\t// Price in range: use min of liquidity from both tokens\n\t\t// L0 = amt0 * sqrt(pC) * sqrt(pU) / (sqrt(pU) - sqrt(pC))\n\t\t// L1 = amt1 * sqrtPrecision / (sqrt(pC) - sqrt(pL))\n\t\tvar liq0, liq1 int64\n\n\t\tif amt0 \u003e 0 \u0026\u0026 sqrtPU \u003e sqrtPC {\n\t\t\tnumerator0 := safeMulDiv(sqrtPC, sqrtPU, sqrtPrecision*PRECISION)\n\t\t\tliq0 = safeMulDiv(amt0, numerator0, sqrtPU-sqrtPC)\n\t\t}\n\n\t\tif amt1 \u003e 0 \u0026\u0026 sqrtPC \u003e sqrtPL {\n\t\t\tliq1 = safeMulDiv(amt1, sqrtPrecision*PRECISION, sqrtPC-sqrtPL)\n\t\t}\n\n\t\t// Return minimum (or whichever is non-zero)\n\t\tif liq0 == 0 {\n\t\t\treturn liq1\n\t\t}\n\t\tif liq1 == 0 {\n\t\t\treturn liq0\n\t\t}\n\t\tif liq0 \u003c liq1 {\n\t\t\treturn liq0\n\t\t}\n\t\treturn liq1\n\t}\n}\n\n// =============================================================================\n// POOL MANAGEMENT\n// =============================================================================\n\nfunc CreateCLMMPool(_ realm, denomA, denomB string, feeBPS int64, initialPriceX6 int64) uint64 {\n\tif denomA == \"\" || denomB == \"\" {\n\t\tpanic(\"invalid denom\")\n\t}\n\tif denomA == denomB {\n\t\tpanic(\"denoms must be different\")\n\t}\n\tif denomA \u003e denomB {\n\t\tdenomA, denomB = denomB, denomA\n\t\tif initialPriceX6 \u003e 0 {\n\t\t\tinitialPriceX6 = (PRECISION * PRECISION) / initialPriceX6\n\t\t}\n\t}\n\n\tfor _, p := range pools {\n\t\tif p.DenomA == denomA \u0026\u0026 p.DenomB == denomB \u0026\u0026 p.FeeBPS == feeBPS {\n\t\t\tpanic(\"pool already exists\")\n\t\t}\n\t}\n\n\tif feeBPS \u003c= 0 || feeBPS \u003e 10000 {\n\t\tpanic(\"fee must be 1-10000 bps\")\n\t}\n\n\tvar tickSpacing int64 = 1\n\tif feeBPS \u003e= 100 {\n\t\ttickSpacing = 10\n\t} else if feeBPS \u003e= 30 {\n\t\ttickSpacing = 5\n\t}\n\n\tif initialPriceX6 \u003c= 0 {\n\t\tinitialPriceX6 = PRECISION\n\t}\n\n\tpool := \u0026CLMMPool{\n\t\tID:          nextPoolID,\n\t\tDenomA:      denomA,\n\t\tDenomB:      denomB,\n\t\tFeeBPS:      feeBPS,\n\t\tTickSpacing: tickSpacing,\n\t\tPriceX6:     initialPriceX6,\n\t\tCurrentTick: getTickAtPrice(initialPriceX6),\n\t\tLiquidity:   0,\n\t}\n\n\tpools = append(pools, pool)\n\ttickData[nextPoolID] = make(map[int64]*TickInfo)\n\tnextPoolID++\n\n\treturn pool.ID\n}\n\n// =============================================================================\n// POSITION MANAGEMENT\n// =============================================================================\n\nfunc MintPosition(_ realm, poolID uint64, tickLower, tickUpper int64) uint64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tpool := pools[poolID]\n\n\tif tickLower \u003e= tickUpper {\n\t\tpanic(\"tickLower must be \u003c tickUpper\")\n\t}\n\tif tickLower \u003c MIN_TICK || tickUpper \u003e MAX_TICK {\n\t\tpanic(\"ticks out of range\")\n\t}\n\tif tickLower%pool.TickSpacing != 0 || tickUpper%pool.TickSpacing != 0 {\n\t\tpanic(\"ticks must align with spacing\")\n\t}\n\n\tcaller := string(runtime.OriginCaller())\n\tsentCoins := banker.OriginSend()\n\n\tamountA := sentCoins.AmountOf(pool.DenomA)\n\tamountB := sentCoins.AmountOf(pool.DenomB)\n\n\tif amountA \u003c= 0 \u0026\u0026 amountB \u003c= 0 {\n\t\tpanic(\"must send tokens\")\n\t}\n\n\tpL := getPriceAtTick(tickLower)\n\tpU := getPriceAtTick(tickUpper)\n\n\tliquidity := getLiquidityForAmounts(pL, pU, pool.PriceX6, amountA, amountB)\n\tif liquidity \u003c= 0 {\n\t\tpanic(\"insufficient liquidity\")\n\t}\n\n\t// Update ticks\n\tupdateTick(poolID, tickLower, liquidity, true)\n\tupdateTick(poolID, tickUpper, liquidity, false)\n\n\t// Update pool liquidity if in range\n\tif pool.PriceX6 \u003e= pL \u0026\u0026 pool.PriceX6 \u003c pU {\n\t\tpool.Liquidity += liquidity\n\t}\n\n\tposition := \u0026Position{\n\t\tID:            nextPositionID,\n\t\tPoolID:        poolID,\n\t\tOwner:         caller,\n\t\tTickLower:     tickLower,\n\t\tTickUpper:     tickUpper,\n\t\tLiquidity:     liquidity,\n\t\tFeeGrowthLastA: pool.FeeGrowthA,\n\t\tFeeGrowthLastB: pool.FeeGrowthB,\n\t}\n\n\tpositions = append(positions, position)\n\tnextPositionID++\n\n\treturn position.ID\n}\n\nfunc BurnPosition(_ realm, positionID uint64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\n\tpos := positions[positionID]\n\tcaller := string(runtime.OriginCaller())\n\n\tif pos.Owner != caller {\n\t\tpanic(\"not owner\")\n\t}\n\tif pos.Liquidity == 0 {\n\t\tpanic(\"already burned\")\n\t}\n\n\tpool := pools[pos.PoolID]\n\tpL := getPriceAtTick(pos.TickLower)\n\tpU := getPriceAtTick(pos.TickUpper)\n\n\tamount0, amount1 := getAmountsForLiquidity(pL, pU, pool.PriceX6, pos.Liquidity)\n\n\t// Update ticks\n\tupdateTick(pos.PoolID, pos.TickLower, -pos.Liquidity, true)\n\tupdateTick(pos.PoolID, pos.TickUpper, -pos.Liquidity, false)\n\n\t// Update pool liquidity\n\tif pool.PriceX6 \u003e= pL \u0026\u0026 pool.PriceX6 \u003c pU {\n\t\tpool.Liquidity -= pos.Liquidity\n\t}\n\n\tpos.Liquidity = 0\n\n\t// Send tokens back\n\tif amount0 \u003e 0 || amount1 \u003e 0 {\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\trealmAddr := runtime.CurrentRealm().Address()\n\t\tcallerAddr := runtime.OriginCaller()\n\n\t\tif amount0 \u003e 0 \u0026\u0026 amount1 \u003e 0 {\n\t\t\tcoins := chain.NewCoins(\n\t\t\t\tchain.NewCoin(pool.DenomA, amount0),\n\t\t\t\tchain.NewCoin(pool.DenomB, amount1),\n\t\t\t)\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, coins)\n\t\t} else if amount0 \u003e 0 {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomA, amount0)))\n\t\t} else {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomB, amount1)))\n\t\t}\n\t}\n}\n\n// =============================================================================\n// SWAP\n// =============================================================================\n\nfunc Swap(_ realm, poolID uint64, tokenIn string, minAmountOut int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tpool := pools[poolID]\n\tif pool.Liquidity == 0 {\n\t\tpanic(\"no liquidity\")\n\t}\n\n\tcaller := runtime.OriginCaller()\n\tsentCoins := banker.OriginSend()\n\n\tvar zeroForOne bool\n\tvar amountIn int64\n\n\tif tokenIn == \"A\" {\n\t\tzeroForOne = true\n\t\tamountIn = sentCoins.AmountOf(pool.DenomA)\n\t} else if tokenIn == \"B\" {\n\t\tzeroForOne = false\n\t\tamountIn = sentCoins.AmountOf(pool.DenomB)\n\t} else {\n\t\tpanic(\"tokenIn must be A or B\")\n\t}\n\n\tif amountIn \u003c= 0 {\n\t\tpanic(\"must send input token\")\n\t}\n\n\t// Calculate fee using safe math\n\tfeeAmount := safeMulDiv(amountIn, pool.FeeBPS, 10000)\n\tamountRemaining := amountIn - feeAmount\n\ttotalAmountOut := int64(0)\n\n\t// Process swap with tick crossing\n\tmaxIterations := 100 // Safety limit to prevent infinite loops\n\tfor i := 0; i \u003c maxIterations \u0026\u0026 amountRemaining \u003e 0; i++ {\n\t\tif pool.Liquidity == 0 {\n\t\t\tbreak // No more liquidity\n\t\t}\n\n\t\t// Find next initialized tick in the direction of swap\n\t\tnextTick := findNextInitializedTick(poolID, pool.CurrentTick, zeroForOne)\n\n\t\t// Calculate how much we can swap before hitting the next tick\n\t\tvar amountInStep, amountOutStep int64\n\t\tvar nextTickPrice int64\n\n\t\tif zeroForOne {\n\t\t\t// Swapping A for B (price decreases)\n\t\t\t// Using sqrt-based CLMM math for accurate output calculation\n\t\t\tnextTickPrice = getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MIN_TICK)\n\t\t\t}\n\n\t\t\t// Calculate using sqrt price (proper CLMM math)\n\t\t\tsqrtPriceCurrent := isqrt(pool.PriceX6 * PRECISION)\n\t\t\tsqrtPriceNext := isqrt(nextTickPrice * PRECISION)\n\n\t\t\tif sqrtPriceCurrent \u003c= sqrtPriceNext {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Max amount in to reach next tick: dx = L * (1/sqrt(P_next) - 1/sqrt(P_current))\n\t\t\t// Simplified: dx = L * (sqrt(P_current) - sqrt(P_next)) / (sqrt(P_current) * sqrt(P_next) / SQRT_PRECISION)\n\t\t\tsqrtPrecision := int64(1000) // sqrt(PRECISION)\n\t\t\tmaxAmountIn := safeMulDiv(pool.Liquidity, sqrtPriceCurrent-sqrtPriceNext, safeMulDiv(sqrtPriceCurrent, sqrtPriceNext, sqrtPrecision*PRECISION))\n\n\t\t\tif amountRemaining \u003c= maxAmountIn || maxAmountIn \u003c= 0 {\n\t\t\t\t// Swap completes within this tick range\n\t\t\t\tamountInStep = amountRemaining\n\n\t\t\t\t// Calculate new sqrt price: 1/sqrt(P_new) = 1/sqrt(P_old) + dx/L\n\t\t\t\t// sqrt(P_new) = sqrt(P_old) * L / (L + dx * sqrt(P_old) / sqrtPrecision)\n\t\t\t\tdenom := pool.Liquidity + safeMulDiv(amountInStep, sqrtPriceCurrent, sqrtPrecision*PRECISION)\n\t\t\t\tif denom \u003c= 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsqrtPriceNew := safeMulDiv(sqrtPriceCurrent, pool.Liquidity, denom)\n\n\t\t\t\t// Output: dy = L * (sqrt(P_old) - sqrt(P_new)) / sqrtPrecision\n\t\t\t\tamountOutStep = safeMulDiv(pool.Liquidity, sqrtPriceCurrent-sqrtPriceNew, sqrtPrecision*PRECISION)\n\n\t\t\t\t// Update price\n\t\t\t\tpool.PriceX6 = safeMulDiv(sqrtPriceNew, sqrtPriceNew, PRECISION)\n\t\t\t\tif pool.PriceX6 \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\t\tpool.PriceX6 = getPriceAtTick(MIN_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Swap crosses this tick\n\t\t\t\tamountInStep = maxAmountIn\n\n\t\t\t\t// Output for crossing to next tick\n\t\t\t\tamountOutStep = safeMulDiv(pool.Liquidity, sqrtPriceCurrent-sqrtPriceNext, sqrtPrecision*PRECISION)\n\t\t\t\tpool.PriceX6 = nextTickPrice\n\n\t\t\t\t// Cross the tick - update liquidity\n\t\t\t\tcrossTick(poolID, nextTick, zeroForOne)\n\t\t\t}\n\t\t} else {\n\t\t\t// Swapping B for A (price increases)\n\t\t\tnextTickPrice = getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MAX_TICK)\n\t\t\t}\n\n\t\t\tsqrtPriceCurrent := isqrt(pool.PriceX6 * PRECISION)\n\t\t\tsqrtPriceNext := isqrt(nextTickPrice * PRECISION)\n\n\t\t\tif sqrtPriceNext \u003c= sqrtPriceCurrent {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tsqrtPrecision := int64(1000)\n\t\t\t// Max amount in to reach next tick: dy = L * (sqrt(P_next) - sqrt(P_current)) / sqrtPrecision\n\t\t\tmaxAmountIn := safeMulDiv(pool.Liquidity, sqrtPriceNext-sqrtPriceCurrent, sqrtPrecision*PRECISION)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn || maxAmountIn \u003c= 0 {\n\t\t\t\tamountInStep = amountRemaining\n\n\t\t\t\t// New sqrt price: sqrt(P_new) = sqrt(P_old) + dy * sqrtPrecision / L\n\t\t\t\tsqrtPriceNew := sqrtPriceCurrent + safeMulDiv(amountInStep, sqrtPrecision*PRECISION, pool.Liquidity)\n\n\t\t\t\t// Output: dx = L * (1/sqrt(P_old) - 1/sqrt(P_new))\n\t\t\t\t// = L * (sqrt(P_new) - sqrt(P_old)) / (sqrt(P_old) * sqrt(P_new) / sqrtPrecision)\n\t\t\t\tamountOutStep = safeMulDiv(pool.Liquidity, sqrtPriceNew-sqrtPriceCurrent, safeMulDiv(sqrtPriceCurrent, sqrtPriceNew, sqrtPrecision*PRECISION))\n\n\t\t\t\tpool.PriceX6 = safeMulDiv(sqrtPriceNew, sqrtPriceNew, PRECISION)\n\t\t\t\tif pool.PriceX6 \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\t\tpool.PriceX6 = getPriceAtTick(MAX_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(pool.Liquidity, sqrtPriceNext-sqrtPriceCurrent, safeMulDiv(sqrtPriceCurrent, sqrtPriceNext, sqrtPrecision*PRECISION))\n\t\t\t\tpool.PriceX6 = nextTickPrice\n\n\t\t\t\tcrossTick(poolID, nextTick, zeroForOne)\n\t\t\t}\n\t\t}\n\n\t\tamountRemaining -= amountInStep\n\t\ttotalAmountOut += amountOutStep\n\n\t\t// Accumulate fees for this step (proportional to amount used)\n\t\tif pool.Liquidity \u003e 0 {\n\t\t\tstepFee := safeMulDiv(feeAmount, amountInStep, amountIn-feeAmount)\n\t\t\tif zeroForOne {\n\t\t\t\tpool.FeeGrowthA += safeMulDiv(stepFee, PRECISION, pool.Liquidity)\n\t\t\t} else {\n\t\t\t\tpool.FeeGrowthB += safeMulDiv(stepFee, PRECISION, pool.Liquidity)\n\t\t\t}\n\t\t}\n\t}\n\n\tpool.CurrentTick = getTickAtPrice(pool.PriceX6)\n\n\tif totalAmountOut \u003c minAmountOut {\n\t\tpanic(\"slippage exceeded\")\n\t}\n\n\t// Send output\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tvar denomOut string\n\tif zeroForOne {\n\t\tdenomOut = pool.DenomB\n\t} else {\n\t\tdenomOut = pool.DenomA\n\t}\n\n\tbnk.SendCoins(realmAddr, caller, chain.NewCoins(chain.NewCoin(denomOut, totalAmountOut)))\n\n\treturn totalAmountOut\n}\n\n// findNextInitializedTick finds the next tick with liquidity in the swap direction\nfunc findNextInitializedTick(poolID uint64, currentTick int64, zeroForOne bool) int64 {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\tif zeroForOne {\n\t\t\treturn MIN_TICK\n\t\t}\n\t\treturn MAX_TICK\n\t}\n\n\tpool := pools[poolID]\n\tspacing := pool.TickSpacing\n\n\tif zeroForOne {\n\t\t// Going down (price decreasing), look for next lower initialized tick\n\t\tfor tick := currentTick - spacing; tick \u003e= MIN_TICK; tick -= spacing {\n\t\t\tif info := ticks[tick]; info != nil \u0026\u0026 info.Initialized {\n\t\t\t\treturn tick\n\t\t\t}\n\t\t}\n\t\treturn MIN_TICK\n\t} else {\n\t\t// Going up (price increasing), look for next higher initialized tick\n\t\tfor tick := currentTick + spacing; tick \u003c= MAX_TICK; tick += spacing {\n\t\t\tif info := ticks[tick]; info != nil \u0026\u0026 info.Initialized {\n\t\t\t\treturn tick\n\t\t\t}\n\t\t}\n\t\treturn MAX_TICK\n\t}\n}\n\n// crossTick updates liquidity when crossing a tick boundary\nfunc crossTick(poolID uint64, tick int64, zeroForOne bool) {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\treturn\n\t}\n\n\tinfo := ticks[tick]\n\tif info == nil || !info.Initialized {\n\t\treturn\n\t}\n\n\tpool := pools[poolID]\n\n\t// When crossing a tick from left to right (price increasing), add liquidityNet\n\t// When crossing from right to left (price decreasing), subtract liquidityNet\n\tif zeroForOne {\n\t\t// Price decreasing, crossing tick from above\n\t\tpool.Liquidity -= info.LiquidityNet\n\t} else {\n\t\t// Price increasing, crossing tick from below\n\t\tpool.Liquidity += info.LiquidityNet\n\t}\n\n\t// Ensure liquidity doesn't go negative\n\tif pool.Liquidity \u003c 0 {\n\t\tpool.Liquidity = 0\n\t}\n}\n\n// =============================================================================\n// COLLECT FEES\n// =============================================================================\n\nfunc CollectFees(_ realm, positionID uint64) (int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\n\tpos := positions[positionID]\n\tcaller := string(runtime.OriginCaller())\n\n\tif pos.Owner != caller {\n\t\tpanic(\"not owner\")\n\t}\n\n\tpool := pools[pos.PoolID]\n\n\t// Calculate fees owed since last collection\n\t// Only collect fees if position is/was in range\n\tvar feesA, feesB int64\n\n\tif pos.Liquidity \u003e 0 {\n\t\t// Calculate accumulated fees based on fee growth difference\n\t\tfeeGrowthDeltaA := pool.FeeGrowthA - pos.FeeGrowthLastA\n\t\tfeeGrowthDeltaB := pool.FeeGrowthB - pos.FeeGrowthLastB\n\n\t\t// Use safe math to prevent overflow\n\t\tfeesA = safeMulDiv(feeGrowthDeltaA, pos.Liquidity, PRECISION)\n\t\tfeesB = safeMulDiv(feeGrowthDeltaB, pos.Liquidity, PRECISION)\n\n\t\t// Update position's last fee growth snapshot\n\t\tpos.FeeGrowthLastA = pool.FeeGrowthA\n\t\tpos.FeeGrowthLastB = pool.FeeGrowthB\n\t}\n\n\t// Add any previously uncollected tokens\n\tfeesA += pos.TokensOwedA\n\tfeesB += pos.TokensOwedB\n\tpos.TokensOwedA = 0\n\tpos.TokensOwedB = 0\n\n\t// Send fees to owner\n\tif feesA \u003e 0 || feesB \u003e 0 {\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\trealmAddr := runtime.CurrentRealm().Address()\n\t\tcallerAddr := runtime.OriginCaller()\n\n\t\tif feesA \u003e 0 \u0026\u0026 feesB \u003e 0 {\n\t\t\tcoins := chain.NewCoins(\n\t\t\t\tchain.NewCoin(pool.DenomA, feesA),\n\t\t\t\tchain.NewCoin(pool.DenomB, feesB),\n\t\t\t)\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, coins)\n\t\t} else if feesA \u003e 0 {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomA, feesA)))\n\t\t} else {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomB, feesB)))\n\t\t}\n\t}\n\n\treturn feesA, feesB\n}\n\n// GetPositionFees returns uncollected fees for a position\nfunc GetPositionFees(positionID uint64) (int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\treturn 0, 0\n\t}\n\n\tpos := positions[positionID]\n\tpool := pools[pos.PoolID]\n\n\tvar feesA, feesB int64\n\n\tif pos.Liquidity \u003e 0 {\n\t\tfeeGrowthDeltaA := pool.FeeGrowthA - pos.FeeGrowthLastA\n\t\tfeeGrowthDeltaB := pool.FeeGrowthB - pos.FeeGrowthLastB\n\n\t\t// Use safe math to prevent overflow\n\t\tfeesA = safeMulDiv(feeGrowthDeltaA, pos.Liquidity, PRECISION)\n\t\tfeesB = safeMulDiv(feeGrowthDeltaB, pos.Liquidity, PRECISION)\n\t}\n\n\tfeesA += pos.TokensOwedA\n\tfeesB += pos.TokensOwedB\n\n\treturn feesA, feesB\n}\n\n// =============================================================================\n// TICK HELPERS\n// =============================================================================\n\nfunc updateTick(poolID uint64, tick int64, liquidityDelta int64, isLower bool) {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\tticks = make(map[int64]*TickInfo)\n\t\ttickData[poolID] = ticks\n\t}\n\n\tinfo := ticks[tick]\n\tif info == nil {\n\t\tinfo = \u0026TickInfo{}\n\t\tticks[tick] = info\n\t}\n\n\tinfo.LiquidityGross += liquidityDelta\n\n\tif isLower {\n\t\tinfo.LiquidityNet += liquidityDelta\n\t} else {\n\t\tinfo.LiquidityNet -= liquidityDelta\n\t}\n\n\tinfo.Initialized = info.LiquidityGross \u003e 0\n}\n\n// =============================================================================\n// QUERIES\n// =============================================================================\n\nfunc GetCLMMPool(poolID uint64) (string, string, int64, int64, int64, int64, int64) {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tp := pools[poolID]\n\treturn p.DenomA, p.DenomB, p.PriceX6, p.CurrentTick, p.Liquidity, p.FeeBPS, p.TickSpacing\n}\n\nfunc GetCLMMPoolCount() uint64 {\n\treturn uint64(len(pools))\n}\n\nfunc GetPosition(positionID uint64) (uint64, string, int64, int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\tp := positions[positionID]\n\treturn p.PoolID, p.Owner, p.TickLower, p.TickUpper, p.Liquidity\n}\n\nfunc GetPositionCount() uint64 {\n\treturn uint64(len(positions))\n}\n\nfunc GetPositionsByOwner(owner string) []uint64 {\n\tvar result []uint64\n\tfor _, p := range positions {\n\t\tif p.Owner == owner \u0026\u0026 p.Liquidity \u003e 0 {\n\t\t\tresult = append(result, p.ID)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc GetQuote(poolID uint64, tokenIn string, amountIn int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\treturn 0\n\t}\n\n\tpool := pools[poolID]\n\tif pool.Liquidity == 0 {\n\t\treturn 0\n\t}\n\n\t// Simulate the swap without modifying state\n\t// Copy pool state for simulation\n\tsimPriceX6 := pool.PriceX6\n\tsimLiquidity := pool.Liquidity\n\tsimCurrentTick := pool.CurrentTick\n\n\tvar zeroForOne bool\n\tif tokenIn == \"A\" {\n\t\tzeroForOne = true\n\t} else if tokenIn == \"B\" {\n\t\tzeroForOne = false\n\t} else {\n\t\treturn 0\n\t}\n\n\t// Calculate fee\n\tfeeAmount := safeMulDiv(amountIn, pool.FeeBPS, 10000)\n\tamountRemaining := amountIn - feeAmount\n\ttotalAmountOut := int64(0)\n\n\t// Simulate swap with tick crossing using sqrt-based CLMM math\n\tsqrtPrecision := int64(1000) // sqrt(PRECISION)\n\tmaxIterations := 100\n\tfor i := 0; i \u003c maxIterations \u0026\u0026 amountRemaining \u003e 0; i++ {\n\t\tif simLiquidity == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tnextTick := findNextInitializedTick(poolID, simCurrentTick, zeroForOne)\n\n\t\tvar amountInStep, amountOutStep int64\n\n\t\tif zeroForOne {\n\t\t\t// Swapping A for B (price decreases)\n\t\t\tnextTickPrice := getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MIN_TICK)\n\t\t\t}\n\n\t\t\tsqrtPriceCurrent := isqrt(simPriceX6 * PRECISION)\n\t\t\tsqrtPriceNext := isqrt(nextTickPrice * PRECISION)\n\n\t\t\tif sqrtPriceCurrent \u003c= sqrtPriceNext {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(simLiquidity, sqrtPriceCurrent-sqrtPriceNext, safeMulDiv(sqrtPriceCurrent, sqrtPriceNext, sqrtPrecision*PRECISION))\n\n\t\t\tif amountRemaining \u003c= maxAmountIn || maxAmountIn \u003c= 0 {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tdenom := simLiquidity + safeMulDiv(amountInStep, sqrtPriceCurrent, sqrtPrecision*PRECISION)\n\t\t\t\tif denom \u003c= 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsqrtPriceNew := safeMulDiv(sqrtPriceCurrent, simLiquidity, denom)\n\t\t\t\tamountOutStep = safeMulDiv(simLiquidity, sqrtPriceCurrent-sqrtPriceNew, sqrtPrecision*PRECISION)\n\t\t\t\tsimPriceX6 = safeMulDiv(sqrtPriceNew, sqrtPriceNew, PRECISION)\n\t\t\t\tif simPriceX6 \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\t\tsimPriceX6 = getPriceAtTick(MIN_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(simLiquidity, sqrtPriceCurrent-sqrtPriceNext, sqrtPrecision*PRECISION)\n\t\t\t\tsimPriceX6 = nextTickPrice\n\n\t\t\t\tticks := tickData[poolID]\n\t\t\t\tif ticks != nil {\n\t\t\t\t\tif tickInfo, ok := ticks[nextTick]; ok \u0026\u0026 tickInfo.Initialized {\n\t\t\t\t\t\tsimLiquidity -= tickInfo.LiquidityNet\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsimCurrentTick = nextTick\n\t\t\t}\n\t\t} else {\n\t\t\t// Swapping B for A (price increases)\n\t\t\tnextTickPrice := getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MAX_TICK)\n\t\t\t}\n\n\t\t\tsqrtPriceCurrent := isqrt(simPriceX6 * PRECISION)\n\t\t\tsqrtPriceNext := isqrt(nextTickPrice * PRECISION)\n\n\t\t\tif sqrtPriceNext \u003c= sqrtPriceCurrent {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(simLiquidity, sqrtPriceNext-sqrtPriceCurrent, sqrtPrecision*PRECISION)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn || maxAmountIn \u003c= 0 {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tsqrtPriceNew := sqrtPriceCurrent + safeMulDiv(amountInStep, sqrtPrecision*PRECISION, simLiquidity)\n\t\t\t\tamountOutStep = safeMulDiv(simLiquidity, sqrtPriceNew-sqrtPriceCurrent, safeMulDiv(sqrtPriceCurrent, sqrtPriceNew, sqrtPrecision*PRECISION))\n\t\t\t\tsimPriceX6 = safeMulDiv(sqrtPriceNew, sqrtPriceNew, PRECISION)\n\t\t\t\tif simPriceX6 \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\t\tsimPriceX6 = getPriceAtTick(MAX_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(simLiquidity, sqrtPriceNext-sqrtPriceCurrent, safeMulDiv(sqrtPriceCurrent, sqrtPriceNext, sqrtPrecision*PRECISION))\n\t\t\t\tsimPriceX6 = nextTickPrice\n\n\t\t\t\tticks := tickData[poolID]\n\t\t\t\tif ticks != nil {\n\t\t\t\t\tif tickInfo, ok := ticks[nextTick]; ok \u0026\u0026 tickInfo.Initialized {\n\t\t\t\t\t\tsimLiquidity += tickInfo.LiquidityNet\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsimCurrentTick = nextTick\n\t\t\t}\n\t\t}\n\n\t\tamountRemaining -= amountInStep\n\t\ttotalAmountOut += amountOutStep\n\t}\n\n\treturn totalAmountOut\n}\n\nfunc GetPriceAtTick(tick int64) int64 {\n\treturn getPriceAtTick(tick)\n}\n\nfunc GetTickAtPrice(priceX6 int64) int64 {\n\treturn getTickAtPrice(priceX6)\n}\n\nfunc GetRealmAddress() string {\n\treturn string(runtime.CurrentRealm().Address())\n}\n\n// =============================================================================\n// RENDER\n// =============================================================================\n\nfunc Render(path string) string {\n\tvar sb strings.Builder\n\n\tsb.WriteString(\"# Gnomo CLMM\\n\\n\")\n\tsb.WriteString(\"**Address:** `\" + string(runtime.CurrentRealm().Address()) + \"`\\n\\n\")\n\n\tif len(pools) == 0 {\n\t\tsb.WriteString(\"No pools yet.\\n\")\n\t} else {\n\t\tsb.WriteString(\"## Pools\\n\\n\")\n\t\tfor _, p := range pools {\n\t\t\tsb.WriteString(\"### Pool \" + strconv.FormatUint(p.ID, 10) + \"\\n\")\n\t\t\tsb.WriteString(\"- Pair: \" + formatDenom(p.DenomA) + \"/\" + formatDenom(p.DenomB) + \"\\n\")\n\t\t\tsb.WriteString(\"- Fee: \" + strconv.FormatInt(p.FeeBPS, 10) + \" bps\\n\")\n\t\t\tsb.WriteString(\"- Tick: \" + strconv.FormatInt(p.CurrentTick, 10) + \"\\n\")\n\t\t\tsb.WriteString(\"- Liquidity: \" + strconv.FormatInt(p.Liquidity, 10) + \"\\n\")\n\t\t\tpriceFloat := float64(p.PriceX6) / float64(PRECISION)\n\t\t\tsb.WriteString(\"- Price: \" + strconv.FormatFloat(priceFloat, 'f', 6, 64) + \"\\n\\n\")\n\t\t}\n\t}\n\n\tsb.WriteString(\"## Stats\\n\")\n\tsb.WriteString(\"- Pools: \" + strconv.Itoa(len(pools)) + \"\\n\")\n\n\tactivePos := 0\n\tfor _, p := range positions {\n\t\tif p.Liquidity \u003e 0 {\n\t\t\tactivePos++\n\t\t}\n\t}\n\tsb.WriteString(\"- Positions: \" + strconv.Itoa(activePos) + \"\\n\")\n\n\treturn sb.String()\n}\n\nfunc formatDenom(denom string) string {\n\tif denom == \"ugnot\" {\n\t\treturn \"GNOT\"\n\t}\n\tif strings.Contains(denom, \":\") {\n\t\tparts := strings.Split(denom, \":\")\n\t\treturn strings.ToUpper(parts[len(parts)-1])\n\t}\n\treturn denom\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/gnomo/clmm4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"50000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"QDJYMEL2YVBnhpNvvD+0semQ8lCk7ZB/PIpMFCbAHqLnfyrzilU9S4iOWf1yE5SWc2NS932iJT6wzMSJvbnOCw=="}],"memo":""},"metadata":{"timestamp":"1768369409"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"MintTestTokens","args":["usdc1","10000000000"]}],"fee":{"gas_wanted":"2760410","gas_fee":"2761ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"3H0OKnHAR7d9L3SKMT8yaEi3147QlJ3rQftvyCN/iWd4mF/8CCqPDtY3CnwJOhEzanx5oE/jT3pbrFxnnTNWBg=="}],"memo":""},"metadata":{"timestamp":"1768369505"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"CreatePool","args":["ugnot","/gno.land/r/gnomo/dex3:usdc1","5"]}],"fee":{"gas_wanted":"693398","gas_fee":"694ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"qvZ5wM4JEvZIFTXyqVLnBQ36JmhYUd9WwP2eLmViC/a88oPr1ACJdchptG6sBCiCYbzs5Moww+c0D93hoN8ODw=="}],"memo":""},"metadata":{"timestamp":"1768369515"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"CreateCLMMPool","args":["ugnot","/gno.land/r/gnomo/dex3:usdc1","5","1000000"]}],"fee":{"gas_wanted":"2240805","gas_fee":"2241ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"Fz9FTogHXdpuu/OCy9QKSCZs7REd1cTlIx+fiHqi/ZNVqMeBNcgnNltDZnXn7zx6T1pUSsgWMD5XNgQ/dbelAg=="}],"memo":""},"metadata":{"timestamp":"1768369550"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"2500000000/gno.land/r/gnomo/dex3:usdc1,2500137747ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"MintPosition","args":["1","-10","10"]}],"fee":{"gas_wanted":"1820764","gas_fee":"1821ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"FIZ0HZ7GZkIkIgkCaeY0hClTloeZI5o4usZLxv0j6woXgKiw3BJ6nJ/Xw4eaXlSBAxNCQoIlhDhfVF9FWwZpCA=="}],"memo":""},"metadata":{"timestamp":"1768369590"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"500000000ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"Swap","args":["1","B","497251250"]}],"fee":{"gas_wanted":"5622408","gas_fee":"5623ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"QvY3/uQvurhxlrW3barUbAlF01ASnJovqssQipzaLAz+QCo4dTaVTcla/frdoN+xphU1TnPQxAfH04jazlhhBg=="}],"memo":""},"metadata":{"timestamp":"1768369641"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1sjzd4060dxdpwgk4g5ssrctmps9yg0hxqe5lu6","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"XkCJNaGgIM+8xXWvQMusQuQqh0mKXNjnplpRdCoSnjujhi719OGgkTj50ejX53Ilb/IJoOYKPzN6/0B3pnpQAQ=="}],"memo":""},"metadata":{"timestamp":"1768382764"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1xh7m96ew0ncje9dyq9z8aadr2ca2xhd7dpd2p9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"XVJk1eMu5USiO4CSlfzLODBNxi++onB6YdYejVAkic8h4Ir8UIMi4uV9nMDZA1/j3ZgmaAl/JmqWdcGWTG+KBQ=="}],"memo":""},"metadata":{"timestamp":"1768382784"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1sjzd4060dxdpwgk4g5ssrctmps9yg0hxqe5lu6","to_address":"g1xh7m96ew0ncje9dyq9z8aadr2ca2xhd7dpd2p9","amount":"1000000ugnot"}],"fee":{"gas_wanted":"45857","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"/5UFCpKSq4mAeYtQ1HY6Ok/EaWMI8ADJgpCMTMOG+H2k2dwf+303JgLl9jY9LoWp4To825acr/w4i+pX+IcqBw=="}],"memo":""},"metadata":{"timestamp":"1768382809"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","package":{"name":"nameregistry","path":"gno.land/r/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/nameregistry","files":[{"name":"checkers.gno","body":"package nameregistry\n\nimport (\n\t\"errors\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/nt/avl/rotree\"\n)\n\n// Checks that a string ends with with 3 numbers.\nvar reEndsWithThreeNumbers = regexp.MustCompile(`[0-9]{3}$`)\n\n// Checker defines an interface for name checkers.\ntype Checker interface {\n\t// Description returns a short description of the name checker.\n\tDescription() string\n\n\t// Check checks that a name is valid.\n\tCheck(name string) error\n}\n\n// NewChecker creates a new name checker.\nfunc NewChecker(description string, fn func(string) error) Checker {\n\tdescription = strings.TrimSpace(description)\n\tif description == \"\" {\n\t\tpanic(\"checker description is required\")\n\t}\n\n\tif fn == nil {\n\t\tpanic(\"checker function is required\")\n\t}\n\n\treturn \u0026checker{description, fn}\n}\n\n// NewMinLengthChecker creates a checker to checks  min length of names.\nfunc NewMinLengthChecker(length int) Checker {\n\tif length == 0 {\n\t\tpanic(\"min length checker requires a length \u003e 0\")\n\t}\n\n\tdesc := \"Minimum name length allowed is \" + strconv.Itoa(length)\n\treturn NewChecker(desc, func(name string) error {\n\t\tif len(name) \u003c length {\n\t\t\treturn errors.New(\"name is too short, min length is \" + strconv.Itoa(length))\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewMaxLengthChecker creates a checker to checks max length of names.\nfunc NewMaxLengthChecker(length int) Checker {\n\tif length \u003c 1 {\n\t\tpanic(\"max length checker requires a length \u003e 1\")\n\t}\n\n\tdesc := \"Maximum name length allowed is \" + strconv.Itoa(length)\n\treturn NewChecker(desc, func(name string) error {\n\t\tif len(name) \u003e length {\n\t\t\treturn errors.New(\"name is too long, max length is \" + strconv.Itoa(length))\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewLowercaseChecker creates a checker to check that all alphanumeric\n// chars are lowercase.\nfunc NewLowercaseChecker() Checker {\n\tdesc := \"Alphanumeric chars must all have lowercase chars\"\n\treturn NewChecker(desc, func(name string) error {\n\t\tif strings.ToLower(name) != name {\n\t\t\treturn errors.New(\"name characters must be in lowercase\")\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewForbiddenPrefixChecker creates a checker to checks that name doesn't\n// start with one or more prefixes.\nfunc NewForbiddenPrefixChecker(prefixes ...string) Checker {\n\tif len(prefixes) == 0 {\n\t\tpanic(\"name prefix checker requires at least one prefix\")\n\t}\n\n\tforbidden := strings.Join(prefixes, \", \")\n\tdesc := \"Name must not start with: \" + forbidden\n\treturn NewChecker(desc, func(name string) error {\n\t\tfor _, s := range prefixes {\n\t\t\tif strings.HasPrefix(name, s) {\n\t\t\t\treturn errors.New(\"name must not start these prefixes: \" + forbidden)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewAlphaNumChecker creates a checker to check that a name starts with\n// a letter and ends with three numbers.\nfunc NewAlphaNumChecker() Checker {\n\tdesc := \"Name must start with a letter and end with 3 numbers\"\n\treturn NewChecker(desc, func(name string) error {\n\t\tname = strings.ToLower(name)\n\t\tif name == \"\" || name[0] \u003e 'z' || name[0] \u003c 'a' {\n\t\t\treturn errors.New(`name must start with a letter between \"a\" and \"z\"`)\n\t\t}\n\n\t\tif len(name) \u003c 4 || !reEndsWithThreeNumbers.MatchString(name) {\n\t\t\treturn errors.New(\"name must end with three numbers\")\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewHomoglyphChecker creates a checker to check that a name is not reserved\n// or blacklisted. Checker considers typosquatting with o=0, i=1 and i=l.\n// Names must be given within one or more AVL trees where key values are names.\nfunc NewHomoglyphChecker(names ...rotree.IReadOnlyTree) Checker {\n\tif len(names) == 0 {\n\t\tpanic(\"homoglyph checker requires at least one names tree\")\n\t}\n\n\treNumbersSuffix := regexp.MustCompile(`[0-9]{1}[a-z0-9]*$`)\n\tdesc := \"Reserved or blacklisted names are not allowed\"\n\treturn NewChecker(desc, func(name string) error {\n\t\tvariants := []string{name}\n\n\t\t// Remove all numbers from name prefix to avoid cases like \"jesus000\"\n\t\tprefix := reNumbersSuffix.ReplaceAllString(name, \"\")\n\t\tif prefix != name {\n\t\t\tvariants = append(variants, prefix)\n\t\t}\n\n\t\tvariants = append(variants, GenHomoglyphVariants(name)...)\n\t\tfor i, n := range variants {\n\t\t\tfor _, storage := range names {\n\t\t\t\tif !storage.Has(n) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// First name in list is the one being checked\n\t\t\t\tif i == 0 {\n\t\t\t\t\treturn errors.New(\"name is reserved\")\n\t\t\t\t} else {\n\t\t\t\t\treturn errors.New(\"similar name already exists: \" + n)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\ntype checker struct {\n\tdescription string\n\tfn          func(string) error\n}\n\nfunc (c checker) Description() string     { return c.description }\nfunc (c checker) Check(name string) error { return c.fn(name) }\n"},{"name":"checkers_test.gno","body":"package nameregistry_test\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/uassert\"\n\n\t\"gno.land/r/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/nameregistry\"\n)\n\nfunc TestNewChecker(t *testing.T) {\n\tuassert.PanicsWithMessage(t, \"checker description is required\", func() {\n\t\t_ = nameregistry.NewChecker(\"\", nil)\n\t}, \"expect required panic\")\n\n\tuassert.PanicsWithMessage(t, \"checker function is required\", func() {\n\t\t_ = nameregistry.NewChecker(\"description\", nil)\n\t}, \"expect required panic\")\n\n\tchecker := nameregistry.NewChecker(\"Foobar\", func(string) error { return nil })\n\tuassert.Equal(t, \"Foobar\", checker.Description(), \"expect description to match\")\n}\n\nfunc TestNewCheckerCheck(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tregisterName string\n\t\terr          error\n\t}{\n\t\t{\n\t\t\tname:         \"ok\",\n\t\t\tregisterName: \"xyz123\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tvar validatedName string\n\t\t\tchecker := nameregistry.NewChecker(\"Foobar\", func(name string) error {\n\t\t\t\tvalidatedName = name\n\t\t\t\treturn tt.err\n\t\t\t})\n\n\t\t\t// Act\n\t\t\terr := checker.Check(tt.registerName)\n\n\t\t\t// Assert\n\t\t\tif tt.err != nil {\n\t\t\t\tuassert.ErrorIs(t, err, tt.err, \"expect an error\")\n\t\t\t} else {\n\t\t\t\tuassert.Nil(t, err, \"expect no error\")\n\t\t\t}\n\n\t\t\tuassert.Equal(t, tt.registerName, validatedName, \"expect validated name to match\")\n\t\t})\n\t}\n}\n\nfunc TestCheckers(t *testing.T) {\n\t// Min length\n\tuassert.PanicsWithMessage(t, \"min length checker requires a length \u003e 0\", func() {\n\t\t_ = nameregistry.NewMinLengthChecker(0)\n\t}, \"expect invalid length panic\")\n\tchecker := nameregistry.NewMinLengthChecker(4)\n\tuassert.Equal(t, \"Minimum name length allowed is 4\", checker.Description(), \"expect description to match\")\n\n\t// Max length\n\tuassert.PanicsWithMessage(t, \"max length checker requires a length \u003e 1\", func() {\n\t\t_ = nameregistry.NewMaxLengthChecker(0)\n\t}, \"expect invalid length panic\")\n\tchecker = nameregistry.NewMaxLengthChecker(4)\n\tuassert.Equal(t, \"Maximum name length allowed is 4\", checker.Description(), \"expect description to match\")\n\n\t// Lowercase\n\tchecker = nameregistry.NewLowercaseChecker()\n\tuassert.Equal(t, \"Alphanumeric chars must all have lowercase chars\", checker.Description(), \"expect description to match\")\n\n\t// Forbidden prefix\n\tuassert.PanicsWithMessage(t, \"name prefix checker requires at least one prefix\", func() {\n\t\t_ = nameregistry.NewForbiddenPrefixChecker()\n\t}, \"expect panic when no prefix\")\n\tchecker = nameregistry.NewForbiddenPrefixChecker(\"a\", \"b\")\n\tuassert.Equal(t, \"Name must not start with: a, b\", checker.Description(), \"expect description to match\")\n\n\t// Alphanum\n\tchecker = nameregistry.NewAlphaNumChecker()\n\tuassert.Equal(t, \"Name must start with a letter and end with 3 numbers\", checker.Description(), \"expect description to match\")\n\n\t// Homoglyph\n\tuassert.PanicsWithMessage(t, \"homoglyph checker requires at least one names tree\", func() {\n\t\t_ = nameregistry.NewHomoglyphChecker()\n\t}, \"expect panic when no name tree\")\n\tchecker = nameregistry.NewHomoglyphChecker(avl.NewTree())\n\tuassert.Equal(t, \"Reserved or blacklisted names are not allowed\", checker.Description(), \"expect description to match\")\n}\n\nfunc TestCheckersCheck(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tregisterName string\n\t\tsetup        func() nameregistry.Checker\n\t\terrMsg       string\n\t}{\n\t\t{\n\t\t\tname: \"min length valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewMinLengthChecker(4)\n\t\t\t},\n\t\t\tregisterName: \"x123\",\n\t\t},\n\t\t{\n\t\t\tname: \"min length invalid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewMinLengthChecker(4)\n\t\t\t},\n\t\t\tregisterName: \"x\",\n\t\t\terrMsg:       \"name is too short, min length is 4\",\n\t\t},\n\t\t{\n\t\t\tname: \"max length valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewMaxLengthChecker(4)\n\t\t\t},\n\t\t\tregisterName: \"x123\",\n\t\t},\n\t\t{\n\t\t\tname: \"max length invalid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewMaxLengthChecker(4)\n\t\t\t},\n\t\t\tregisterName: \"xy123\",\n\t\t\terrMsg:       \"name is too long, max length is 4\",\n\t\t},\n\t\t{\n\t\t\tname: \"lowercase valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewLowercaseChecker()\n\t\t\t},\n\t\t\tregisterName: \"xyz123\",\n\t\t},\n\t\t{\n\t\t\tname: \"lowercase invalid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewLowercaseChecker()\n\t\t\t},\n\t\t\tregisterName: \"XYZ123\",\n\t\t\terrMsg:       \"name characters must be in lowercase\",\n\t\t},\n\t\t{\n\t\t\tname: \"prefix valid with one prefix\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewForbiddenPrefixChecker(\"a\")\n\t\t\t},\n\t\t\tregisterName: \"xyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"prefix valid with many prefixes\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewForbiddenPrefixChecker(\"a\", \"b\", \"c\")\n\t\t\t},\n\t\t\tregisterName: \"xyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"prefix invalid with one prefix\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewForbiddenPrefixChecker(\"a\")\n\t\t\t},\n\t\t\tregisterName: \"aaa\",\n\t\t\terrMsg:       \"name must not start these prefixes: a\",\n\t\t},\n\t\t{\n\t\t\tname: \"prefix invalid with many prefixes\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewForbiddenPrefixChecker(\"a\", \"b\", \"c\")\n\t\t\t},\n\t\t\tregisterName: \"bbb\",\n\t\t\terrMsg:       \"name must not start these prefixes: a, b, c\",\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"x123\",\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum valid with uppercase\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"X123\",\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum invalid without start letter\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"123x\",\n\t\t\terrMsg:       `name must start with a letter between \"a\" and \"z\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum invalid without numbers suffix\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"x\",\n\t\t\terrMsg:       \"name must end with three numbers\",\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum invalid with few numbers suffix\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"x12\",\n\t\t\terrMsg:       \"name must end with three numbers\",\n\t\t},\n\t\t{\n\t\t\tname: \"homoglypgh valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewHomoglyphChecker(avl.NewTree())\n\t\t\t},\n\t\t\tregisterName: \"xyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"homoglypgh of reserved name\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\tt := avl.NewTree()\n\t\t\t\tt.Set(\"foo\", struct{}{})\n\t\t\t\treturn nameregistry.NewHomoglyphChecker(t)\n\t\t\t},\n\t\t\tregisterName: \"foo\",\n\t\t\terrMsg:       \"name is reserved\",\n\t\t},\n\t\t{\n\t\t\tname: \"homoglypgh of similar reserved name\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\tt := avl.NewTree()\n\t\t\t\tt.Set(\"foo\", struct{}{})\n\t\t\t\treturn nameregistry.NewHomoglyphChecker(t)\n\t\t\t},\n\t\t\tregisterName: \"f00\",\n\t\t\terrMsg:       \"similar name already exists: foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"homoglypgh of similar reserved name 2\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\tt := avl.NewTree()\n\t\t\t\tt.Set(\"foo\", struct{}{})\n\t\t\t\treturn nameregistry.NewHomoglyphChecker(t)\n\t\t\t},\n\t\t\tregisterName: \"foo000\",\n\t\t\terrMsg:       \"similar name already exists: foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"homoglypgh of similar reserved name 3\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\tt := avl.NewTree()\n\t\t\t\tt.Set(\"foo\", struct{}{})\n\t\t\t\treturn nameregistry.NewHomoglyphChecker(t)\n\t\t\t},\n\t\t\tregisterName: \"foo000bar000\",\n\t\t\terrMsg:       \"similar name already exists: foo\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tchecker := tt.setup()\n\n\t\t\t// Act\n\t\t\terr := checker.Check(tt.registerName)\n\n\t\t\t// Assert\n\t\t\tif tt.errMsg != \"\" {\n\t\t\t\tuassert.ErrorContains(t, err, tt.errMsg, \"expect an error\")\n\t\t\t} else {\n\t\t\t\tuassert.Nil(t, err, \"expect no error\")\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"genesis.gno","body":"package nameregistry\n\nfunc init() {\n\t// TODO: Assign blacklisted names\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/nameregistry\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl\"\n"},{"name":"homoglyphs.gno","body":"package nameregistry\n\nvar homoglyphs = map[rune]rune{\n\t'0': 'o',\n\t'1': 'i',\n\t'l': 'i',\n}\n\n// GenHomoglyphVariants returns all possible name variants for homoglyphs 0=o, 1=i and l=i.\n// Original name is not included in the returned variants.\nfunc GenHomoglyphVariants(name string) []string {\n\tnames := [][]rune{[]rune(name)}\n\tfor i, letter := range name {\n\t\t// Get letter to replace the homoglyph\n\t\tl, ok := homoglyphs[letter]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Duplicate current variants with the replacement\n\t\tfor _, v := range names {\n\t\t\tv2 := make([]rune, len(name))\n\t\t\tcopy(v2, v)\n\n\t\t\t// Replace the homoglyph by the actual letter\n\t\t\tv2[i] = l\n\t\t\tnames = append(names, v2)\n\t\t}\n\t}\n\n\t// Remove the original name from the variants and check if there are variants\n\tnames = names[1:]\n\tif len(names) == 0 {\n\t\treturn nil\n\t}\n\n\tvariants := make([]string, len(names))\n\tfor i, n := range names {\n\t\tvariants[i] = string(n)\n\t}\n\treturn variants\n}\n"},{"name":"homoglyphs_test.gno","body":"package nameregistry_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"gno.land/p/nt/uassert\"\n\n\t\"gno.land/r/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/nameregistry\"\n)\n\nfunc TestGenHomoglyphVariants(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tbasename string\n\t\tvariants string\n\t}{\n\t\t{\n\t\t\tname:     \"no variants\",\n\t\t\tbasename: \"foobar\",\n\t\t},\n\t\t{\n\t\t\tname:     \"one homoglyph\",\n\t\t\tbasename: \"f0obar\",\n\t\t\tvariants: \"foobar\",\n\t\t},\n\t\t{\n\t\t\tname:     \"two homoglyphs\",\n\t\t\tbasename: \"f00bar\",\n\t\t\tvariants: \"fo0bar,f0obar,foobar\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed homoglyphs\",\n\t\t\tbasename: \"0xlx1\",\n\t\t\tvariants: \"oxlx1,0xix1,oxix1,0xlxi,oxlxi,0xixi,oxixi\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tvariants := nameregistry.GenHomoglyphVariants(tt.basename)\n\n\t\t\t// Assert\n\t\t\tuassert.Equal(t, tt.variants, strings.Join(variants, \",\"), \"expect variants to match\")\n\t\t})\n\t}\n}\n"},{"name":"nameregistry.gno","body":"package nameregistry\n\nimport (\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/avl/rotree\"\n\t\"gno.land/p/nt/ownable\"\n)\n\n// TODO: Use tries to save storage\n\nconst (\n\tTypeReserved    = \"reserved\"\n\tTypeBlacklisted = \"blacklisted\"\n\tTypeCustom      = \"custom\"\n)\n\nvar (\n\treserved    = avl.NewTree()\n\tblacklisted = avl.NewTree()\n\tcustom      = avl.NewTree()\n\n\t// TODO: Remove once realm fully integrates with GovDAO\n\tadmin = ownable.NewWithOrigin()\n\n\t// Name constraints contains checkers that defines the rules for valid names\n\tconstraints = []Checker{\n\t\tNewMinLengthChecker(4),\n\t\tNewMaxLengthChecker(14),\n\t\tNewLowercaseChecker(),\n\t\tNewForbiddenPrefixChecker(\"g1\", \"gi\", \"gl\"),\n\t\tNewAlphaNumChecker(),\n\t\tNewHomoglyphChecker(reserved, custom, blacklisted),\n\t}\n)\n\n// IsNameValid checks is a name is a valid name.\nfunc IsNameValid(name string) error {\n\tfor _, c := range constraints {\n\t\tif err := c.Check(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// GetNames returns reserved, blacklisted or custom registry names.\nfunc GetNames(nameType string) rotree.IReadOnlyTree {\n\tvar storage *avl.Tree\n\tswitch nameType {\n\tcase TypeReserved:\n\t\tstorage = reserved\n\tcase TypeBlacklisted:\n\t\tstorage = blacklisted\n\tcase TypeCustom:\n\t\tstorage = custom\n\tdefault:\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\treturn rotree.Wrap(storage, func(v any) any { return struct{}{} })\n}\n\n// SetNames sets the list of reserved, blacklisted or custom registry names.\n// Existing names are replaced by the new ones.\nfunc SetNames(_ realm, nameType string, names ...string) {\n\tif len(names) == 0 {\n\t\tpanic(\"list of names must not be empty\")\n\t}\n\n\t// TODO: Names be setted though GovDAO proposals\n\tadmin.AssertOwnedByPrevious()\n\n\tstorage := avl.NewTree()\n\tswitch nameType {\n\tcase TypeReserved:\n\t\treserved = storage\n\tcase TypeBlacklisted:\n\t\tblacklisted = storage\n\tcase TypeCustom:\n\t\tcustom = storage\n\tdefault:\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\n\tfor _, n := range names {\n\t\tstorage.Set(n, struct{}{})\n\t}\n}\n\n// AddNames adds new names to the list of reserved, blacklisted or custom registry names.\n// Adding new names keeps the existing names intact.\nfunc AddNames(_ realm, nameType string, names ...string) {\n\tif len(names) == 0 {\n\t\tpanic(\"list of names must not be empty\")\n\t}\n\n\t// TODO: Names be added though GovDAO proposals\n\tadmin.AssertOwnedByPrevious()\n\n\tstorage := avl.NewTree()\n\tswitch nameType {\n\tcase TypeReserved:\n\t\treserved = storage\n\tcase TypeBlacklisted:\n\t\tblacklisted = storage\n\tcase TypeCustom:\n\t\tcustom = storage\n\tdefault:\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\n\tfor _, n := range names {\n\t\tstorage.Set(n, struct{}{})\n\t}\n}\n"},{"name":"nameregistry_test.gno","body":"package nameregistry_test\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/nt/uassert\"\n\n\t\"gno.land/r/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/nameregistry\"\n)\n\nfunc TestIsNameValid(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tregisterName string\n\t\terrMsg       string\n\t}{\n\t\t{\n\t\t\tname:         \"valid\",\n\t\t\tregisterName: \"test123\",\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid prefix g1\",\n\t\t\tregisterName: \"g1test\",\n\t\t\terrMsg:       \"name must not start these prefixes: g1, gi, gl\",\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid prefix gi\",\n\t\t\tregisterName: \"gitest\",\n\t\t\terrMsg:       \"name must not start these prefixes: g1, gi, gl\",\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid prefix gl\",\n\t\t\tregisterName: \"gltest\",\n\t\t\terrMsg:       \"name must not start these prefixes: g1, gi, gl\",\n\t\t},\n\t\t{\n\t\t\tname:         \"upercase not allowed\",\n\t\t\tregisterName: \"TEST123\",\n\t\t\terrMsg:       \"name characters must be in lowercase\",\n\t\t},\n\t\t{\n\t\t\tname:         \"name too long\",\n\t\t\tregisterName: \"alongtestname123\",\n\t\t\terrMsg:       \"name is too long, max length is 14\",\n\t\t},\n\t\t{\n\t\t\tname:         \"name too short\",\n\t\t\tregisterName: \"a12\",\n\t\t\terrMsg:       \"name is too short, min length is 4\",\n\t\t},\n\t\t{\n\t\t\tname:         \"only numbers\",\n\t\t\tregisterName: \"123456\",\n\t\t\terrMsg:       `name must start with a letter between \"a\" and \"z\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"only letters\",\n\t\t\tregisterName: \"test\",\n\t\t\terrMsg:       \"name must end with three numbers\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\terr := nameregistry.IsNameValid(tt.registerName)\n\n\t\t\t// Assert\n\t\t\tif tt.errMsg != \"\" {\n\t\t\t\tuassert.ErrorContains(t, err, tt.errMsg, \"expect an error\")\n\t\t\t} else {\n\t\t\t\tuassert.Nil(t, err, \"expect no error\")\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"proposals.gno","body":"package nameregistry\n\nimport (\n\t\"strings\"\n\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/nt/ufmt\"\n\n\t\"gno.land/r/gov/dao\"\n)\n\n// ProposeConstraintsReset creates a new GovDAO proposal to reset name constraints.\n// Reseting invalidates all existing check contrainst by replacing them with the new ones.\nfunc ProposeConstraintsReset(checkers ...Checker) dao.ProposalRequest {\n\tif len(checkers) == 0 {\n\t\tpanic(\"proposal requires at least one name checker\")\n\t}\n\n\tvar desc strings.Builder\n\tdesc.WriteString(md.Paragraph(\"Proposal replaces current name registry realm constrains by:\"))\n\tfor _, c := range checkers {\n\t\tdesc.WriteString(md.BulletItem(c.Description()))\n\t}\n\n\tcb := func(realm) error {\n\t\tconstraints = checkers\n\t\treturn nil\n\t}\n\n\treturn dao.NewProposalRequest(\n\t\t\"Reset name registry constraints\",\n\t\tdesc.String(),\n\t\tdao.NewSimpleExecutor(cb, \"\"),\n\t)\n}\n\n// ProposeConstraintsAppend creates a new GovDAO proposal to append new name constraints.\nfunc ProposeConstraintsAppend(checkers ...Checker) dao.ProposalRequest {\n\tif len(checkers) == 0 {\n\t\tpanic(\"proposal requires at least one name checker\")\n\t}\n\n\tvar desc strings.Builder\n\tdesc.WriteString(md.Paragraph(\"Proposal appends new name registry realm constrains:\"))\n\tfor _, c := range checkers {\n\t\tdesc.WriteString(md.BulletItem(c.Description()))\n\t}\n\n\tcb := func(realm) error {\n\t\tconstraints = append(constraints, checkers...)\n\t\treturn nil\n\t}\n\n\treturn dao.NewProposalRequest(\n\t\t\"Append new name registry constraints\",\n\t\tdesc.String(),\n\t\tdao.NewSimpleExecutor(cb, \"\"),\n\t)\n}\n\n// ProposeNamesSet creates a new GovDAO proposal to set reserved, blacklisted or custom names.\nfunc ProposeNamesSet(nameType string, names ...string) dao.ProposalRequest {\n\tif len(names) == 0 {\n\t\tpanic(\"list of names must not be empty\")\n\t}\n\n\tif nameType != TypeReserved \u0026\u0026 nameType != TypeBlacklisted \u0026\u0026 nameType != TypeCustom {\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\n\tcb := func(realm) error {\n\t\tSetNames(cross, nameType, names...)\n\t\treturn nil\n\t}\n\n\treturn dao.NewProposalRequest(\n\t\tufmt.Sprintf(\"Initialize %s names\", nameType),\n\t\tufmt.Sprintf(\"Proposal initializes %d %s names\", len(names), nameType),\n\t\tdao.NewSimpleExecutor(cb, \"\"),\n\t)\n}\n\n// ProposeNamesAdd creates a new GovDAO proposal to add reserved, blacklisted or custom names.\nfunc ProposeNamesAdd(nameType string, names ...string) dao.ProposalRequest {\n\tif len(names) == 0 {\n\t\tpanic(\"list of names must not be empty\")\n\t}\n\n\tif nameType != TypeReserved \u0026\u0026 nameType != TypeBlacklisted \u0026\u0026 nameType != TypeCustom {\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\n\tcb := func(realm) error {\n\t\tAddNames(cross, nameType, names...)\n\t\treturn nil\n\t}\n\n\treturn dao.NewProposalRequest(\n\t\tufmt.Sprintf(\"Add new %s names\", nameType),\n\t\tufmt.Sprintf(\"Proposal adds %d %s new names\", len(names), nameType),\n\t\tdao.NewSimpleExecutor(cb, \"\"),\n\t)\n}\n"},{"name":"render.gno","body":"package nameregistry\n\nimport (\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/jefft0/avlhelpers\"\n\t\"gno.land/p/jeronimoalbi/mdform\"\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/moul/mdtable\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/mdalert\"\n\t\"gno.land/p/nt/mux\"\n)\n\nconst (\n\tpathVerify = \"verify\"\n\tpathSearch = \"search\"\n)\n\nconst maxSearchItems = 30\n\nvar realmPath = strings.TrimPrefix(runtime.CurrentRealm().PkgPath(), \"gno.land\")\n\nfunc Render(path string) string {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"\", renderHome)\n\trouter.HandleFunc(pathVerify, renderVerify)\n\trouter.HandleFunc(pathSearch, renderSearch)\n\n\trouter.NotFoundHandler = func(res *mux.ResponseWriter, _ *mux.Request) {\n\t\tres.Write(md.Blockquote(\"Path not found\"))\n\t}\n\n\tvar b strings.Builder\n\tb.WriteString(md.H1(\"Name Registry\"))\n\tb.WriteString(router.Render(path))\n\treturn b.String()\n}\n\nfunc renderHome(res *mux.ResponseWriter, _ *mux.Request) {\n\titems := make([]string, len(constraints))\n\tfor i, c := range constraints {\n\t\titems[i] = c.Description()\n\t}\n\n\ttable := mdtable.Table{\n\t\tHeaders: []string{\"Names\", \"Total\"},\n\t\tRows: [][]string{\n\t\t\t{TypeReserved, strconv.Itoa(reserved.Size())},\n\t\t\t{TypeBlacklisted, strconv.Itoa(blacklisted.Size())},\n\t\t\t{TypeCustom, strconv.Itoa(custom.Size())},\n\t\t},\n\t}\n\n\tres.Write(\" ↳ \")\n\tres.Write(md.Link(\"Verify Name\", makeURI(pathVerify)))\n\tres.Write(\" • \")\n\tres.Write(md.Link(\"Search\", makeURI(pathSearch)))\n\tres.Write(\"\\n\")\n\n\tres.Write(md.H2(\"Naming Constraints\"))\n\tres.Write(md.Paragraph(\"Names must match the following constraints:\"))\n\tres.Write(md.OrderedList(items))\n\n\tres.Write(md.H2(\"Registered Names\"))\n\tres.Write(table.String())\n}\n\nfunc renderVerify(res *mux.ResponseWriter, req *mux.Request) {\n\tname := strings.TrimSpace(req.Query.Get(\"name\"))\n\tform := mdform.New(\"path\", pathVerify)\n\tform.Input(\n\t\t\"name\",\n\t\t\"placeholder\", \"Write a name to verify\",\n\t\t\"value\", name,\n\t)\n\n\tres.Write(md.Link(\"← Back Home\", makeURI(\"\")) + \"\\n\\n\")\n\tres.Write(md.H2(\"Verify Name\"))\n\tres.Write(\n\t\tmd.Paragraph(\n\t\t\t\"Verification checks if a name is valid for current registry contraints\",\n\t\t),\n\t)\n\n\tif name != \"\" {\n\t\tvar errors strings.Builder\n\t\tfor _, c := range constraints {\n\t\t\tif err := c.Check(name); err != nil {\n\t\t\t\terrors.WriteString(md.Paragraph(err.Error()))\n\t\t\t}\n\t\t}\n\n\t\tif errors.Len() == 0 {\n\t\t\tres.Write(mdalert.Info(\"Info\", \"The name is a valid\"))\n\t\t} else {\n\t\t\tres.Write(mdalert.Caution(\"Name is not valid\", errors.String()))\n\t\t}\n\t}\n\n\tres.Write(form.String())\n}\n\nfunc renderSearch(res *mux.ResponseWriter, req *mux.Request) {\n\tnameType := req.Query.Get(\"type\")\n\tprefix := strings.TrimSpace(req.Query.Get(\"prefix\"))\n\n\tform := mdform.New(\"path\", pathSearch)\n\tform.Input(\n\t\t\"prefix\",\n\t\t\"placeholder\", \"Name Prefix\",\n\t\t\"value\", prefix,\n\t)\n\tform.Select(\n\t\t\"type\",\n\t\tTypeReserved,\n\t\t\"selected\", strconv.FormatBool(nameType == \"\" || nameType == TypeReserved),\n\t)\n\tform.Select(\n\t\t\"type\",\n\t\tTypeCustom,\n\t\t\"selected\", strconv.FormatBool(nameType == TypeCustom),\n\t)\n\tform.Select(\n\t\t\"type\",\n\t\tTypeBlacklisted,\n\t\t\"selected\", strconv.FormatBool(nameType == TypeBlacklisted),\n\t)\n\n\tvar names *avl.Tree\n\tswitch nameType {\n\tcase TypeReserved:\n\t\tnames = reserved\n\tcase TypeCustom:\n\t\tnames = custom\n\tcase TypeBlacklisted:\n\t\tnames = blacklisted\n\t}\n\n\tres.Write(md.Link(\"← Back Home\", makeURI(\"\")) + \"\\n\\n\")\n\tres.Write(md.H2(\"Search Names\"))\n\n\tif names == nil || len(prefix) \u003c 3 {\n\t\tif prefix != \"\" {\n\t\t\tres.Write(mdalert.Caution(\"Error\", \"Search requires at least three letters\"))\n\t\t}\n\n\t\tres.Write(form.String())\n\t} else {\n\t\tvar (\n\t\t\tresults strings.Builder\n\t\t\tcurrent int\n\t\t)\n\n\t\tavlhelpers.IterateByteStringKeysByPrefix(names, prefix, func(name string, _ any) bool {\n\t\t\tresults.WriteString(md.BulletItem(name))\n\t\t\tcurrent++\n\t\t\treturn current == maxSearchItems\n\t\t})\n\n\t\tif results.Len() == 0 {\n\t\t\tres.Write(mdalert.Warning(\"Not Found\", \"Search didn't find any matching names\"))\n\t\t\tres.Write(form.String())\n\t\t} else {\n\t\t\tres.Write(form.String())\n\t\t\tres.Write(md.H2(\"Results\"))\n\t\t\tres.Write(results.String())\n\t\t}\n\t}\n}\n\nfunc makeURI(path string) string {\n\tif path == \"\" {\n\t\treturn realmPath\n\t}\n\treturn realmPath + \":\" + path\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"800000000","gas_fee":"800000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"SPIx8KHU7a1JBHHO1ybYbLzkwCLpzHNdyDI6RI4ipwohRRRfYFT8oJFvWaOe3nDfER19nfsi2lh95le+cLmaCg=="}],"memo":""},"metadata":{"timestamp":"1768408839"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"XiJM31HaT6CnUmkx0LUCjWUt0QTpdVBkYiI8bIegbnW6C1SVMNtEafbD5q0HaviqLGqxzo6lAow4WtsFvEwfDw=="}],"memo":""},"metadata":{"timestamp":"1768409070"}}
{"tx":{"msg":[{"@type":"/vm.m_run","caller":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","send":"","max_deposit":"","package":{"name":"main","path":"gno.land/e/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/run","files":[{"name":"gnomod.toml","body":"module = \"gno.land/e/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/run\"\ngno = \"0.9\"\nprivate = true\n"},{"name":"main.gen.gno","body":"package main\n\nimport (\n\t\"strings\"\n\n\t\"gno.land/r/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/nameregistry\"\n)\n\nvar entries = []struct {\n\tName string\n\tType int // 0: full, 1: TLD, 2: custom\n}{\n\t{Name: \"futwiz.com.\", Type: 0},\n\t{Name: \"jquery.com.\", Type: 0},\n\t{Name: \"tunein.com.\", Type: 0},\n\t{Name: \"hatena.ne.jp.\", Type: 0},\n\t{Name: \"square-enix.com.\", Type: 0},\n\t{Name: \"dj.\", Type: 1},\n\t{Name: \"google.\", Type: 1},\n\t{Name: \"amazon.\", Type: 1},\n}\n\nfunc main() {\n\tnames := make([]string, len(entries))\n\tfor _, e := range entries {\n\t\ti := strings.Index(e.Name, \".\")\n\t\tif i == -1 {\n\t\t\tnames = append(names, e.Name)\n\t\t} else {\n\t\t\tnames = append(names, e.Name[:i])\n\t\t}\n\t}\n\n\tnameregistry.SetNames(cross, nameregistry.TypeReserved, names...)\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserProd"}}}],"fee":{"gas_wanted":"3000000000","gas_fee":"9000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"vDtY9drpq+vjK9/hOr0+phjnLCl5ZltE8PzFyWxVxEtqkbcZhsrAjxkWyRWfIDbx+gtcHd7s27ALmVtwlLIeBw=="}],"memo":""},"metadata":{"timestamp":"1768409623"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"XiJM31HaT6CnUmkx0LUCjWUt0QTpdVBkYiI8bIegbnW6C1SVMNtEafbD5q0HaviqLGqxzo6lAow4WtsFvEwfDw=="}],"memo":""},"metadata":{"timestamp":"1768409799"}}
{"tx":{"msg":[{"@type":"/vm.m_run","caller":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","send":"","max_deposit":"","package":{"name":"main","path":"gno.land/e/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/run","files":[{"name":"gnomod.toml","body":"module = \"gno.land/e/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/run\"\ngno = \"0.9\"\nprivate = true\n"},{"name":"main.gen.gno","body":"package main\n\nimport (\n\t\"gno.land/r/g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl/nameregistry\"\n)\n\nfunc main() {\n\tnameregistry.SetNames(cross, nameregistry.TypeBlacklisted, \"jesus\")\n\tnameregistry.SetNames(cross, nameregistry.TypeCustom, \"tendermint\")\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserProd"}}}],"fee":{"gas_wanted":"3000000000","gas_fee":"9000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"GKbYbrmReFTf7gFHiwcRqWI/TKeRc6skwfUdC8A8QHoaR6T5UAwcl2/hf+ZvEwTBGbvB6yE33h4nVnGB1hJCBQ=="}],"memo":""},"metadata":{"timestamp":"1768409819"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"404570ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"jrTQ5h/WA51gaDcfhIjqlN9PgRy/v/yPBIp0HKq0fTkOPwLRVF+ti43jTr9lVfZB6JCIuSotwxaDb7QOErdMDg=="}],"memo":""},"metadata":{"timestamp":"1768440701"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"404570ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"+49Zj1qvVk//2bcgHDPSzi7YB+X/GK+ygPfKgCva8JhuONqD3P4BczWwZn4GVAV8U5smGZtoI5SpYnWH85jFBw=="}],"memo":""},"metadata":{"timestamp":"1768440706"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"BYrVV+X93ocAv4dFKJ653CZc4Aqtib//ZmBhzAKLodIkP81jv+1HH9FPe4hUqAQcMfgu2oJnHR8s2YccKHnBCw=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"yWKmPdk3BgEsTyDFSXqTPgPHVfwVficyGpTmF8+nqh0sUSaa1UhA/C/3QjaxfgZ17eX9pZeg+ReFstGmCA69BA=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"ooGN43D0sh6j/gtp0t9Kq7PJhW9VkaHYzOqtXuXNM/0I5MD3o5Hzdddsn+BoQDJRF1EprQlRvXZSNjDkK58SBg=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"rS+wFoFPIiONX5Z/xASpgyEpc4WpB2NoBB0Zqrryfjy6cc6tIoyRyOdjaktwffEBNjQXuiWSvejQ+iKojeFAAg=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"xJqUj+dDl7tab+yAclS9KJJ+1xSXYNzGYS1Iv4iIcFcpBpAEqG5PZ39MrgPTvqwFsg9rDJWOgtJWk30FJJOTBQ=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"36x/51C6zzLaLg/8WE3kzFK/hAdWqzpiXo/Dn6i3XWk3iARMLbLaRhIZsGKriDHKy4Iy42Ri6GwDQ730rwShDg=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"aY3J9gBQ7by8jW2+4YKh86pyiAJgk+qL3usX8XsikeBUVpVYpymGfl1+l04gmGsJu/g/Ypd9gTPO5+FuelYZAQ=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"z5YYsA2FLeH0CVK3Xdjyjr56iWnpuE+/03DUz2Di3/dD4+EOy0wLUy/5DPkrEwXYxqJGCRS43M9Mc3hrEMNBCw=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440711_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"0bnFAqtRoA8LWrIlg0QaeqHfxdTbVsm/v+cP3u7wNnGWQvka60bfHjADptrre+azE5b/NDIw8ocynjlQbin4BQ=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440711_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"MWLr38VePgRu5SSGTVxJTT7qht7MSJ8ikcumeBnxsol9ESK1JUGLwN3+SbU2a8aUbyfJsEFVTc6kvkJ8FUQPBg=="}],"memo":""},"metadata":{"timestamp":"1768440711"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"2842875ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"ugj9GKV9IJBBzpJTa7EG6lbT//gYU5G0n3uBo/+OnykNXbmhb1oyEQPb8oyRO39NFAE7irG7kQJdLOjG9e1lBQ=="}],"memo":""},"metadata":{"timestamp":"1768440801"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"2842875ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"iQVy77bsAd6NWB802XMRS6ZihYeqkFnuXFjg9JxfmGpr6LfNNI1gckaZH3ySUauQjwFIozjzhelf2YKwHqW4AA=="}],"memo":""},"metadata":{"timestamp":"1768440806"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"TxW4PmDcjS1ctRXcrDCUjjgNddMGlpfMIWYgc7wWR7tjt1pqTKLFw+ZQCyiHaQ35T9emHFaef2U2O5w76V1mAg=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"9aHl+C4f+Bgsg4SFZC+uCJzZofv5lWsgR5HT0GQbsry3y+mV1/ptFXRuY222Nc1Z1FFSGdhnjdVtNLZjW0KcBw=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"pkkt+9hJejjcN5hbKfiiWXD9/+PFHTT+ag/z+mM3Dbol7hV6bqgT+8Ni9cdNwf2uL7KQUnVXPeP5NfZlPV4uBw=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"G+pCmeV+eVlittyNEceDv/kXdQdswQ7wLmAp9i3vjH3fxo+OOFI3N9PQXH9YtIScJNHLleHxUooV6NcirT1fDA=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"OHCe72uv8r18kQlaqu8nBC9PHM55s5PHfAhAHXabZDc6/m+H4UG0D6TkAFItCFrW5VJCkXRMgd8T7FeF4H/7Ag=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"6gFlcwK9qJJ0ub04cWb+M0M5dT2Z0KeygMju1+08AsbNun55+hdGOMoWeDF92mgpVatpEM+u4MV1H0GhEaFrAg=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"UUkBiYxmXo2M42zqNy3SKNISIu68mYNaP3JZHP8diPocRgbfM5AtvNB0L4dHkK96nWP0HXm2vSPyN3g6lewpCQ=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"2tGLjj/SNDzbKmyMGW7FKYiy/MjapyhC870XXuGMq34mBHShWyKWcy6bfEyYAaLZEfbNljseUTnh1BMAKT6PAA=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768440812_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"xITmJMA82JmxgP2j6mZj7l1z0WGhbDDZZvDk/KzZiIYCPv/CJAB4Hs3ZCqsGl2lSCm8PKT/eMPej+z57QXzcDw=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768440812_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"Qm5omoximcMifWo/Pf1jc/8FEDmfnVyYFDN4/rKNBTHimW430i4u22FukotM7d/OoewA9WFtIp9jQ6VtlKCPAA=="}],"memo":""},"metadata":{"timestamp":"1768440811"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g17290cwvmrapvp869xfnhhawa8sm9edpufzat7d","to_address":"g17290cwvmrapvp869xfnhhawa8sm9edpufzat7d","amount":"1000000ugnot"}],"fee":{"gas_wanted":"48422","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"/wk91KobhARJGW/XSmraxvbsoEx1Vj2mDsZXzumoFE+0KnE+dhOSzuJzsYspmDBU4OaXk3EM7RZo5nnNYPQ9AA=="}],"memo":""},"metadata":{"timestamp":"1768440836"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"runtime","path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"633558","gas_fee":"634ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"ex9p/DyXLl7t8Q6G8OABRcRGpsm8Yg+pJ48Ty3zugEZDh0l16YNYVoLYj9mBR0S1GKDenbkw758uwCVDcXE0Aw=="}],"memo":""},"metadata":{"timestamp":"1768440887"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-0"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"TbTWhMy87eUvlYg2eNgPefbgaTu1x28h/mdVb2M4dj8XiXmsJUk02vQfBjoWzbbqaDq+2z4fA9a7XfWStms/Bg=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"0wh27/WUCH9EUoXvh6RpcQzNK/WtbGn/oHFaf2YjHw3i7jdHUTnD/eyLJ14dkHfe7r9Nn81nR9uFQlCK07o9AA=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"dSdAZlCofBhgaBPhfLFetIBpPbiwb9L0XsPgbCCaEyQiBzMBbPLjb+RyAW3O74agr/E5DjV5vnokSUiQFLLMCQ=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"OThEul0JNYDh2B787rgqmvqXOSbQKrz9tlGbsqHC7iiGHAsTumshZoE9CFmnpC2jwbCoaluqcQeyIXgJctT6Ag=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"fzL2mgZNYXFsfPsV9sQ2mryO6I0RLdeSj/ltXBxoiUoE0DGwANmAaVNPfnZLYz/ZbzgL6YsMsYqV8pisEw/xDw=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"3Idb5YE6Sp5YQy7dWDx2r69GPhzuw0g5JzVItyzxN1Y7etxQk8zeCitOh+7yLTmWe8pulcKwvi/xP66QxDezCQ=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"I2PsmoviF6mFJ8hWZ+fiNkTpNqWt293Vrtoc+MR7qGD3WbfI6MFUDTWBNj6xLMk0qlIXBJmTZcUe2akVoqsMCw=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"2Fly3Z+6QBspxtiKhGk1LEyOBrVwx9QKnINQLXFX4oAxK6zd8nybZSv93kV9HDSXvaLm298SS2yHalEUMnEzCA=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"1fGIjQN8Eim8ozYBuwhEsXMgIccZ9l9YZHnjNKLHe/kabJT6nqryeDxXD+9iUVAI1fwlu8Q2Zq0U2TmkhBJsAg=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768440891","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"xD37meRBrB0wKt4CE2Y8W0dNGa2/njSG56mQHTkXcUZBj4XkTfKvGhHmsUveoYjhKPK5aIW9Lahm0VBB2CL1Aw=="}],"memo":""},"metadata":{"timestamp":"1768440892"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1xh7m96ew0ncje9dyq9z8aadr2ca2xhd7dpd2p9","to_address":"g1sjzd4060dxdpwgk4g5ssrctmps9yg0hxqe5lu6","amount":"1111100ugnot"}],"fee":{"gas_wanted":"45927","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"+U1N+02G8D6RRGWyTw3lhz+mc1niWG0eA8pVyRY8vD6NBKtnZC468SrsAFQQjDMdsDjmBwA/1gy01plQaY3jDg=="}],"memo":""},"metadata":{"timestamp":"1768441937"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1sjzd4060dxdpwgk4g5ssrctmps9yg0hxqe5lu6","to_address":"g1xh7m96ew0ncje9dyq9z8aadr2ca2xhd7dpd2p9","amount":"110000ugnot"}],"fee":{"gas_wanted":"48371","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"XMLCAo+b1IXA7i7O0t0QTu5rX+p0Ydy6fF/9YjJd5ba67Cm7o5fopzMmYHTMexxGfK4L6CIdIUR8RvymQQgDDQ=="}],"memo":""},"metadata":{"timestamp":"1768441972"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1s2qw9ktc78sjetsnvsjjd8s73r0qf7a8v35jra","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"hB1PQhNunVwr1L/lPpc1yKn36fJw8BXTafqGrBt1Uo1w/t71o1RQP8fSWDgkBFnaecdQWZ6fu6cxaKiSizMsAw=="}],"memo":""},"metadata":{"timestamp":"1768444506"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1ellux45hlpslywcl458cyxnm9tqheka4ajndgw","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"EaWfOXqTzsClrjIg5VG58mcs+6LcalKUagoPbTSmDhlpym0oZriAUrFGsgJIa64KKESrhWWRoAPqNggOjnxiAw=="}],"memo":""},"metadata":{"timestamp":"1768465576"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1ellux45hlpslywcl458cyxnm9tqheka4ajndgw","to_address":"g1xzmj8yys9aqltvjr8tw0r7ml4ylaql9xkpjncq","amount":"1000000ugnot"}],"fee":{"gas_wanted":"48719","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"Thq+8+bY/VM0d70LqjhiZt6JbCRsZaAwYOxeqtYxBuwRjthIJakO3eOwhWJd6xAuBD8OI6KWD4onXeK1IeqlBg=="}],"memo":""},"metadata":{"timestamp":"1768465591"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1ellux45hlpslywcl458cyxnm9tqheka4ajndgw","to_address":"g12f869vcxkdx3ww3wgrvt55z9504rtkpg3mkk0k","amount":"1000000ugnot"}],"fee":{"gas_wanted":"51573","gas_fee":"52ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"d4I+0MDFNq0bALLBz91PLmapHXIrIrsxTeOYGJy8eioA1dAXSEWHZ/bP+lPBsj1sADEFhz/nMC0BX2Rho6DcDA=="}],"memo":""},"metadata":{"timestamp":"1768465601"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1c9y7qexumxgmrzk3jgj37vkfrhaxvyf6mhk4ke","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"bzgiid/TWcibJIGaGimmtU1eVLmNnWSjZhMdniJ/gx/xN/A8Dl/SF+eHKyJ4vzFrPFDkznXhLZG0N/oT/Dv5Bg=="}],"memo":""},"metadata":{"timestamp":"1768465988"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1xzmj8yys9aqltvjr8tw0r7ml4ylaql9xkpjncq","to_address":"g12f869vcxkdx3ww3wgrvt55z9504rtkpg3mkk0k","amount":"100000ugnot"}],"fee":{"gas_wanted":"45688","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"mQenlxc729WXd0rxafuhu9mXC6XiIEvmh4cXwjX2IiBzEjDar2wAcbHLuG01qUmce8L3knrpiecZdAYYtS7tDA=="}],"memo":""},"metadata":{"timestamp":"1768466169"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g12f869vcxkdx3ww3wgrvt55z9504rtkpg3mkk0k","to_address":"g1ellux45hlpslywcl458cyxnm9tqheka4ajndgw","amount":"100000ugnot"}],"fee":{"gas_wanted":"48219","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"+j8JZGVUIrI3uX8GNWrhCKlmdBOtOYNIVI6XY+JSFy8z7LND2eJ5at8jfit7PNa4hT2m9aiW8TcUfguRGzqyCg=="}],"memo":""},"metadata":{"timestamp":"1768466184"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1yhk5f3r7875tu7x3l9atw7yw736wd9637deew9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"XmGVIX1YuC/p4h3kgCogu6d3rOzopKlzzJtZHjoZYU9/brvU7Trc1IhbHX72QMQfxvN8/xik5Jve35Crt/fsCQ=="}],"memo":""},"metadata":{"timestamp":"1768466280"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/mood17","func":"ChangeMyMood","args":[""]}],"fee":{"gas_wanted":"169686","gas_fee":"170ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"xgWfSVGhRbyIoHBsXX/gJ+LrDkphXjszIKHHPk5LplfDCNFpjO7zUg7KfWO9jc1fWcRA3F6VtXx3cdZ6sEx3BQ=="}],"memo":""},"metadata":{"timestamp":"1768480349"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"mood22","path":"gno.land/r/meeeshell222/mood22","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/mood22\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage mood22"},{"name":"mood.gno","body":"package mood22\n\nvar myMood = \"excited about Beta Mainnet launch!\"\n\nfunc changeMood(newMood string) {\n\tmyMood = newMood\n}\n\nfunc ChangeMyMood(_ realm, myNewMood string) string {\n\tchangeMood(myNewMood)\n\treturn \"Successfully changed the mood\"\n}\n\nfunc Render(_ string) string {\n\treturn \"My mood is \" + myMood\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"542795","gas_fee":"543ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"KwMe9stJr9Z509qB0p3qHNCJIP4YZ65zI8jpAcGMzW7Y7homiz9iyH00dBaoCZjRZqWOvar2J0CkmtC2yHPQDQ=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1768480580"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/mood22","func":"ChangeMyMood","args":[""]}],"fee":{"gas_wanted":"286167","gas_fee":"287ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"OY8vwvn+7O6JBMww+3hekwSYCFa2YmuuFjpaxF4MU9JYwFctxLhpHXNa0/WtvRyZnBJm7zZoQsONoY92XifpBA=="}],"memo":""},"metadata":{"timestamp":"1768480625"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"lqFj9oRTy/7evPLRxaQ8sEPQlkw7fpESqq4neggBAg1UkzLiGQ6tItIvmLDJJ1IGhrRgXaK4cJD3Mf8AFF8cAQ=="}],"memo":""},"metadata":{"timestamp":"1768482852"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"lqFj9oRTy/7evPLRxaQ8sEPQlkw7fpESqq4neggBAg1UkzLiGQ6tItIvmLDJJ1IGhrRgXaK4cJD3Mf8AFF8cAQ=="}],"memo":""},"metadata":{"timestamp":"1768482882"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"name":"nameregistry","path":"gno.land/r/g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun/nameregistry","files":[{"name":"checkers.gno","body":"package nameregistry\n\nimport (\n\t\"errors\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Matches the last three suffix numbers.\nvar reEndsWithThreeNumbers = regexp.MustCompile(`[0-9]{3}$`)\n\n// Checker defines an interface for name checkers.\ntype Checker interface {\n\t// Description returns a short description of the name checker.\n\tDescription() string\n\n\t// Check checks that a name is valid.\n\tCheck(name string) error\n}\n\n// NewChecker creates a new name checker.\nfunc NewChecker(description string, fn func(string) error) Checker {\n\tdescription = strings.TrimSpace(description)\n\tif description == \"\" {\n\t\tpanic(\"checker description is required\")\n\t}\n\n\tif fn == nil {\n\t\tpanic(\"checker function is required\")\n\t}\n\n\treturn \u0026checker{description, fn}\n}\n\n// NewMinLengthChecker creates a checker to checks  min length of names.\nfunc NewMinLengthChecker(length int) Checker {\n\tif length == 0 {\n\t\tpanic(\"min length checker requires a length \u003e 0\")\n\t}\n\n\tdesc := \"Minimum name length allowed is \" + strconv.Itoa(length)\n\treturn NewChecker(desc, func(name string) error {\n\t\tif len(name) \u003c length {\n\t\t\treturn errors.New(\"name is too short, min length is \" + strconv.Itoa(length))\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewMaxLengthChecker creates a checker to checks max length of names.\nfunc NewMaxLengthChecker(length int) Checker {\n\tif length \u003c 1 {\n\t\tpanic(\"max length checker requires a length \u003e 1\")\n\t}\n\n\tdesc := \"Maximum name length allowed is \" + strconv.Itoa(length)\n\treturn NewChecker(desc, func(name string) error {\n\t\tif len(name) \u003e length {\n\t\t\treturn errors.New(\"name is too long, max length is \" + strconv.Itoa(length))\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewLowercaseChecker creates a checker to check that all alphanumeric\n// chars are lowercase.\nfunc NewLowercaseChecker() Checker {\n\tdesc := \"Alphanumeric chars must all have lowercase chars\"\n\treturn NewChecker(desc, func(name string) error {\n\t\tif strings.ToLower(name) != name {\n\t\t\treturn errors.New(\"name characters must be in lowercase\")\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewForbiddenPrefixChecker creates a checker to checks that name doesn't\n// start with one or more prefixes.\nfunc NewForbiddenPrefixChecker(prefixes ...string) Checker {\n\tif len(prefixes) == 0 {\n\t\tpanic(\"name prefix checker requires at least one prefix\")\n\t}\n\n\tforbidden := strings.Join(prefixes, \", \")\n\tdesc := \"Name must not start with: \" + forbidden\n\treturn NewChecker(desc, func(name string) error {\n\t\tfor _, s := range prefixes {\n\t\t\tif strings.HasPrefix(name, s) {\n\t\t\t\treturn errors.New(\"name must not start these prefixes: \" + forbidden)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewAlphaNumChecker creates a checker to check that a name starts with\n// a letter and ends with three numbers.\nfunc NewAlphaNumChecker() Checker {\n\tdesc := \"Name must start with a letter and end with 3 numbers\"\n\treturn NewChecker(desc, func(name string) error {\n\t\tname = strings.ToLower(name)\n\t\tif name == \"\" || name[0] \u003e 'z' || name[0] \u003c 'a' {\n\t\t\treturn errors.New(`name must start with a letter between \"a\" and \"z\"`)\n\t\t}\n\n\t\tif len(name) \u003c 4 || !reEndsWithThreeNumbers.MatchString(name) {\n\t\t\treturn errors.New(\"name must end with three numbers\")\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewSimilarityChecker creates a checker to check that a name is not similar\n// or equal to a reserved or blacklisted name.\nfunc NewSimilarityChecker() Checker {\n\tdesc := \"Reserved or blacklisted names are not allowed\"\n\treturn NewChecker(desc, func(name string) error {\n\t\treturn CheckNameSimilarity(name, reserved, blacklisted, custom)\n\t})\n}\n\ntype checker struct {\n\tdescription string\n\tfn          func(string) error\n}\n\nfunc (c checker) Description() string     { return c.description }\nfunc (c checker) Check(name string) error { return c.fn(name) }\n"},{"name":"checkers_test.gno","body":"package nameregistry_test\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/nt/uassert\"\n\n\t\"gno.land/r/g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun/nameregistry\"\n)\n\nfunc TestNewChecker(t *testing.T) {\n\tuassert.PanicsWithMessage(t, \"checker description is required\", func() {\n\t\t_ = nameregistry.NewChecker(\"\", nil)\n\t}, \"expect required panic\")\n\n\tuassert.PanicsWithMessage(t, \"checker function is required\", func() {\n\t\t_ = nameregistry.NewChecker(\"description\", nil)\n\t}, \"expect required panic\")\n\n\tchecker := nameregistry.NewChecker(\"Foobar\", func(string) error { return nil })\n\tuassert.Equal(t, \"Foobar\", checker.Description(), \"expect description to match\")\n}\n\nfunc TestNewCheckerCheck(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tregisterName string\n\t\terr          error\n\t}{\n\t\t{\n\t\t\tname:         \"ok\",\n\t\t\tregisterName: \"xyz123\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tvar validatedName string\n\t\t\tchecker := nameregistry.NewChecker(\"Foobar\", func(name string) error {\n\t\t\t\tvalidatedName = name\n\t\t\t\treturn tt.err\n\t\t\t})\n\n\t\t\t// Act\n\t\t\terr := checker.Check(tt.registerName)\n\n\t\t\t// Assert\n\t\t\tif tt.err != nil {\n\t\t\t\tuassert.ErrorIs(t, err, tt.err, \"expect an error\")\n\t\t\t} else {\n\t\t\t\tuassert.Nil(t, err, \"expect no error\")\n\t\t\t}\n\n\t\t\tuassert.Equal(t, tt.registerName, validatedName, \"expect validated name to match\")\n\t\t})\n\t}\n}\n\nfunc TestCheckers(t *testing.T) {\n\t// Min length\n\tuassert.PanicsWithMessage(t, \"min length checker requires a length \u003e 0\", func() {\n\t\t_ = nameregistry.NewMinLengthChecker(0)\n\t}, \"expect invalid length panic\")\n\tchecker := nameregistry.NewMinLengthChecker(4)\n\tuassert.Equal(t, \"Minimum name length allowed is 4\", checker.Description(), \"expect description to match\")\n\n\t// Max length\n\tuassert.PanicsWithMessage(t, \"max length checker requires a length \u003e 1\", func() {\n\t\t_ = nameregistry.NewMaxLengthChecker(0)\n\t}, \"expect invalid length panic\")\n\tchecker = nameregistry.NewMaxLengthChecker(4)\n\tuassert.Equal(t, \"Maximum name length allowed is 4\", checker.Description(), \"expect description to match\")\n\n\t// Lowercase\n\tchecker = nameregistry.NewLowercaseChecker()\n\tuassert.Equal(t, \"Alphanumeric chars must all have lowercase chars\", checker.Description(), \"expect description to match\")\n\n\t// Forbidden prefix\n\tuassert.PanicsWithMessage(t, \"name prefix checker requires at least one prefix\", func() {\n\t\t_ = nameregistry.NewForbiddenPrefixChecker()\n\t}, \"expect panic when no prefix\")\n\tchecker = nameregistry.NewForbiddenPrefixChecker(\"a\", \"b\")\n\tuassert.Equal(t, \"Name must not start with: a, b\", checker.Description(), \"expect description to match\")\n\n\t// Alphanum\n\tchecker = nameregistry.NewAlphaNumChecker()\n\tuassert.Equal(t, \"Name must start with a letter and end with 3 numbers\", checker.Description(), \"expect description to match\")\n\n\t// Similarity\n\tchecker = nameregistry.NewSimilarityChecker()\n\tuassert.Equal(t, \"Reserved or blacklisted names are not allowed\", checker.Description(), \"expect description to match\")\n}\n\nfunc TestCheckersCheck(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tregisterName string\n\t\tsetup        func() nameregistry.Checker\n\t\terrMsg       string\n\t}{\n\t\t{\n\t\t\tname: \"min length valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewMinLengthChecker(4)\n\t\t\t},\n\t\t\tregisterName: \"x123\",\n\t\t},\n\t\t{\n\t\t\tname: \"min length invalid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewMinLengthChecker(4)\n\t\t\t},\n\t\t\tregisterName: \"x\",\n\t\t\terrMsg:       \"name is too short, min length is 4\",\n\t\t},\n\t\t{\n\t\t\tname: \"max length valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewMaxLengthChecker(4)\n\t\t\t},\n\t\t\tregisterName: \"x123\",\n\t\t},\n\t\t{\n\t\t\tname: \"max length invalid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewMaxLengthChecker(4)\n\t\t\t},\n\t\t\tregisterName: \"xy123\",\n\t\t\terrMsg:       \"name is too long, max length is 4\",\n\t\t},\n\t\t{\n\t\t\tname: \"lowercase valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewLowercaseChecker()\n\t\t\t},\n\t\t\tregisterName: \"xyz123\",\n\t\t},\n\t\t{\n\t\t\tname: \"lowercase invalid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewLowercaseChecker()\n\t\t\t},\n\t\t\tregisterName: \"XYZ123\",\n\t\t\terrMsg:       \"name characters must be in lowercase\",\n\t\t},\n\t\t{\n\t\t\tname: \"prefix valid with one prefix\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewForbiddenPrefixChecker(\"a\")\n\t\t\t},\n\t\t\tregisterName: \"xyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"prefix valid with many prefixes\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewForbiddenPrefixChecker(\"a\", \"b\", \"c\")\n\t\t\t},\n\t\t\tregisterName: \"xyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"prefix invalid with one prefix\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewForbiddenPrefixChecker(\"a\")\n\t\t\t},\n\t\t\tregisterName: \"aaa\",\n\t\t\terrMsg:       \"name must not start these prefixes: a\",\n\t\t},\n\t\t{\n\t\t\tname: \"prefix invalid with many prefixes\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewForbiddenPrefixChecker(\"a\", \"b\", \"c\")\n\t\t\t},\n\t\t\tregisterName: \"bbb\",\n\t\t\terrMsg:       \"name must not start these prefixes: a, b, c\",\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"x123\",\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum valid with uppercase\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"X123\",\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum invalid without start letter\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"123x\",\n\t\t\terrMsg:       `name must start with a letter between \"a\" and \"z\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum invalid without numbers suffix\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"x\",\n\t\t\terrMsg:       \"name must end with three numbers\",\n\t\t},\n\t\t{\n\t\t\tname: \"alphanum invalid with few numbers suffix\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewAlphaNumChecker()\n\t\t\t},\n\t\t\tregisterName: \"x12\",\n\t\t\terrMsg:       \"name must end with three numbers\",\n\t\t},\n\t\t{\n\t\t\tname: \"similarity valid\",\n\t\t\tsetup: func() nameregistry.Checker {\n\t\t\t\treturn nameregistry.NewSimilarityChecker()\n\t\t\t},\n\t\t\tregisterName: \"xyz\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tchecker := tt.setup()\n\n\t\t\t// Act\n\t\t\terr := checker.Check(tt.registerName)\n\n\t\t\t// Assert\n\t\t\tif tt.errMsg != \"\" {\n\t\t\t\tuassert.ErrorContains(t, err, tt.errMsg, \"expect an error\")\n\t\t\t} else {\n\t\t\t\tuassert.Nil(t, err, \"expect no error\")\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"genesis.gno","body":"package nameregistry\n\nfunc init() {\n\t// TODO: Assign blacklisted names\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun/nameregistry\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\"\n"},{"name":"homoglyphs.gno","body":"package nameregistry\n\nimport (\n\t\"errors\"\n\t\"regexp\"\n\n\t\"gno.land/p/nt/avl/rotree\"\n)\n\n// Matches all numbers used as suffix.\nvar reNumbersSuffix = regexp.MustCompile(`[0-9]{1}[a-z0-9]*$`)\n\nvar homoglyphs = map[rune]rune{\n\t'0': 'o',\n\t'1': 'i',\n\t'l': 'i',\n}\n\n// GenHomoglyphVariants returns all possible name variants for homoglyphs 0=o, 1=i and l=i.\n// Original name is not included in the returned variants.\nfunc GenHomoglyphVariants(name string) []string {\n\tnames := [][]rune{[]rune(name)}\n\tfor i, letter := range name {\n\t\t// Get letter to replace the homoglyph\n\t\tl, ok := homoglyphs[letter]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Duplicate current variants with the replacement\n\t\tfor _, v := range names {\n\t\t\tv2 := make([]rune, len(name))\n\t\t\tcopy(v2, v)\n\n\t\t\t// Replace the homoglyph by the actual letter\n\t\t\tv2[i] = l\n\t\t\tnames = append(names, v2)\n\t\t}\n\t}\n\n\t// Remove the original name from the variants and check if there are variants\n\tnames = names[1:]\n\tif len(names) == 0 {\n\t\treturn nil\n\t}\n\n\tvariants := make([]string, len(names))\n\tfor i, n := range names {\n\t\tvariants[i] = string(n)\n\t}\n\treturn variants\n}\n\n// CheckNameSimilarity checks that a name is not similar to other name from a name tree.\n// It fails when a similar name exists. Similarity is checked though typosquatting with\n// o=0, i=1 and i=l, or by removing the numbers suffix from the name.\nfunc CheckNameSimilarity(name string, names ...rotree.IReadOnlyTree) error {\n\tvariants := []string{name}\n\n\t// Remove all numbers from name prefix to avoid cases like \"jesus000\"\n\tprefix := reNumbersSuffix.ReplaceAllString(name, \"\")\n\tif prefix != name {\n\t\tvariants = append(variants, prefix)\n\t}\n\n\tvariants = append(variants, GenHomoglyphVariants(name)...)\n\tfor i, n := range variants {\n\t\tfor _, storage := range names {\n\t\t\tif !storage.Has(n) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// First name in list is the one being checked\n\t\t\tif i == 0 {\n\t\t\t\treturn errors.New(\"name is reserved\")\n\t\t\t} else {\n\t\t\t\treturn errors.New(\"similar name already exists: \" + n)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n"},{"name":"homoglyphs_test.gno","body":"package nameregistry_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/uassert\"\n\n\t\"gno.land/r/g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun/nameregistry\"\n)\n\nfunc TestGenHomoglyphVariants(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tbasename string\n\t\tvariants string\n\t}{\n\t\t{\n\t\t\tname:     \"no variants\",\n\t\t\tbasename: \"foobar\",\n\t\t},\n\t\t{\n\t\t\tname:     \"one homoglyph\",\n\t\t\tbasename: \"f0obar\",\n\t\t\tvariants: \"foobar\",\n\t\t},\n\t\t{\n\t\t\tname:     \"two homoglyphs\",\n\t\t\tbasename: \"f00bar\",\n\t\t\tvariants: \"fo0bar,f0obar,foobar\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed homoglyphs\",\n\t\t\tbasename: \"0xlx1\",\n\t\t\tvariants: \"oxlx1,0xix1,oxix1,0xlxi,oxlxi,0xixi,oxixi\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tvariants := nameregistry.GenHomoglyphVariants(tt.basename)\n\n\t\t\t// Assert\n\t\t\tuassert.Equal(t, tt.variants, strings.Join(variants, \",\"), \"expect variants to match\")\n\t\t})\n\t}\n}\n\nfunc TestCheckNameSimilarity(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tbasename string\n\t\tnames    []string\n\t\terrMsg   string\n\t}{\n\t\t{\n\t\t\tname:     \"ok\",\n\t\t\tbasename: \"foo\",\n\t\t\tnames:    []string{\"bar\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"reserved name\",\n\t\t\tbasename: \"foo\",\n\t\t\tnames:    []string{\"foo\", \"bar\"},\n\t\t\terrMsg:   \"name is reserved\",\n\t\t},\n\t\t{\n\t\t\tname:     \"reserved name with typosquatting\",\n\t\t\tbasename: \"f00\",\n\t\t\tnames:    []string{\"foo\", \"bar\"},\n\t\t\terrMsg:   \"similar name already exists: foo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"reserved name with numbers suffix\",\n\t\t\tbasename: \"foo000\",\n\t\t\tnames:    []string{\"foo\", \"bar\"},\n\t\t\terrMsg:   \"similar name already exists: foo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"reserved name with numbers and letter suffix\",\n\t\t\tbasename: \"foo000bar000\",\n\t\t\tnames:    []string{\"foo\", \"bar\"},\n\t\t\terrMsg:   \"similar name already exists: foo\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tnames := avl.NewTree()\n\t\t\tfor _, n := range tt.names {\n\t\t\t\tnames.Set(n, struct{}{})\n\t\t\t}\n\n\t\t\t// Act\n\t\t\terr := nameregistry.CheckNameSimilarity(tt.basename, names)\n\n\t\t\t// Assert\n\t\t\tif tt.errMsg != \"\" {\n\t\t\t\tuassert.ErrorContains(t, err, tt.errMsg, \"expect an error\")\n\t\t\t} else {\n\t\t\t\tuassert.Nil(t, err, \"expect no error\")\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"nameregistry.gno","body":"package nameregistry\n\nimport (\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/avl/rotree\"\n\t\"gno.land/p/nt/ownable\"\n)\n\n// TODO: Use tries to save storage\n\nconst (\n\tTypeReserved    = \"reserved\"\n\tTypeBlacklisted = \"blacklisted\"\n\tTypeCustom      = \"custom\"\n)\n\nvar (\n\treserved    = avl.NewTree()\n\tblacklisted = avl.NewTree()\n\tcustom      = avl.NewTree()\n\n\t// TODO: Remove once realm fully integrates with GovDAO\n\tadmin = ownable.NewWithOrigin()\n\n\t// Name constraints contains checkers that defines the rules for valid names\n\tconstraints = []Checker{\n\t\tNewMinLengthChecker(4),\n\t\tNewMaxLengthChecker(14),\n\t\tNewLowercaseChecker(),\n\t\tNewForbiddenPrefixChecker(\"g1\", \"gi\", \"gl\"),\n\t\tNewAlphaNumChecker(),\n\t\tNewSimilarityChecker(),\n\t}\n)\n\n// Size returns the number of names in the registry.\nfunc Size() int {\n\treturn reserved.Size() + blacklisted.Size() + custom.Size()\n}\n\n// IsNameValid checks is a name is a valid name.\nfunc IsNameValid(name string) error {\n\tfor _, c := range constraints {\n\t\tif err := c.Check(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// GetNames returns reserved, blacklisted or custom registry names.\nfunc GetNames(nameType string) rotree.IReadOnlyTree {\n\tvar storage *avl.Tree\n\tswitch nameType {\n\tcase TypeReserved:\n\t\tstorage = reserved\n\tcase TypeBlacklisted:\n\t\tstorage = blacklisted\n\tcase TypeCustom:\n\t\tstorage = custom\n\tdefault:\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\treturn rotree.Wrap(storage, func(v any) any { return struct{}{} })\n}\n\n// SetNames sets the list of reserved, blacklisted or custom registry names.\n// Existing names are replaced by the new ones.\nfunc SetNames(_ realm, nameType string, names ...string) {\n\tif len(names) == 0 {\n\t\tpanic(\"list of names must not be empty\")\n\t}\n\n\t// TODO: Names be setted though GovDAO proposals\n\tadmin.AssertOwnedByPrevious()\n\n\tstorage := avl.NewTree()\n\tswitch nameType {\n\tcase TypeReserved:\n\t\treserved = storage\n\tcase TypeBlacklisted:\n\t\tblacklisted = storage\n\tcase TypeCustom:\n\t\tcustom = storage\n\tdefault:\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\n\tfor _, n := range names {\n\t\tstorage.Set(n, struct{}{})\n\t}\n}\n\n// AddNames adds new names to the list of reserved, blacklisted or custom registry names.\n// Adding new names keeps the existing names intact.\nfunc AddNames(_ realm, nameType string, names ...string) {\n\tif len(names) == 0 {\n\t\tpanic(\"list of names must not be empty\")\n\t}\n\n\t// TODO: Names be added though GovDAO proposals\n\tadmin.AssertOwnedByPrevious()\n\n\tstorage := avl.NewTree()\n\tswitch nameType {\n\tcase TypeReserved:\n\t\treserved = storage\n\tcase TypeBlacklisted:\n\t\tblacklisted = storage\n\tcase TypeCustom:\n\t\tcustom = storage\n\tdefault:\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\n\tfor _, n := range names {\n\t\tstorage.Set(n, struct{}{})\n\t}\n}\n"},{"name":"nameregistry_test.gno","body":"package nameregistry_test\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/nt/uassert\"\n\n\t\"gno.land/r/g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun/nameregistry\"\n)\n\nfunc TestIsNameValid(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tregisterName string\n\t\terrMsg       string\n\t}{\n\t\t{\n\t\t\tname:         \"valid\",\n\t\t\tregisterName: \"test123\",\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid prefix g1\",\n\t\t\tregisterName: \"g1test\",\n\t\t\terrMsg:       \"name must not start these prefixes: g1, gi, gl\",\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid prefix gi\",\n\t\t\tregisterName: \"gitest\",\n\t\t\terrMsg:       \"name must not start these prefixes: g1, gi, gl\",\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid prefix gl\",\n\t\t\tregisterName: \"gltest\",\n\t\t\terrMsg:       \"name must not start these prefixes: g1, gi, gl\",\n\t\t},\n\t\t{\n\t\t\tname:         \"upercase not allowed\",\n\t\t\tregisterName: \"TEST123\",\n\t\t\terrMsg:       \"name characters must be in lowercase\",\n\t\t},\n\t\t{\n\t\t\tname:         \"name too long\",\n\t\t\tregisterName: \"alongtestname123\",\n\t\t\terrMsg:       \"name is too long, max length is 14\",\n\t\t},\n\t\t{\n\t\t\tname:         \"name too short\",\n\t\t\tregisterName: \"a12\",\n\t\t\terrMsg:       \"name is too short, min length is 4\",\n\t\t},\n\t\t{\n\t\t\tname:         \"only numbers\",\n\t\t\tregisterName: \"123456\",\n\t\t\terrMsg:       `name must start with a letter between \"a\" and \"z\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"only letters\",\n\t\t\tregisterName: \"test\",\n\t\t\terrMsg:       \"name must end with three numbers\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\terr := nameregistry.IsNameValid(tt.registerName)\n\n\t\t\t// Assert\n\t\t\tif tt.errMsg != \"\" {\n\t\t\t\tuassert.ErrorContains(t, err, tt.errMsg, \"expect an error\")\n\t\t\t} else {\n\t\t\t\tuassert.Nil(t, err, \"expect no error\")\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"proposals.gno","body":"package nameregistry\n\nimport (\n\t\"strings\"\n\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/nt/ufmt\"\n\n\t\"gno.land/r/gov/dao\"\n)\n\n// ProposeConstraintsReset creates a new GovDAO proposal to reset name constraints.\n// Reseting invalidates all existing check contrainst by replacing them with the new ones.\nfunc ProposeConstraintsReset(checkers ...Checker) dao.ProposalRequest {\n\tif len(checkers) == 0 {\n\t\tpanic(\"proposal requires at least one name checker\")\n\t}\n\n\tvar desc strings.Builder\n\tdesc.WriteString(md.Paragraph(\"Proposal replaces current name registry realm constrains by:\"))\n\tfor _, c := range checkers {\n\t\tdesc.WriteString(md.BulletItem(c.Description()))\n\t}\n\n\tcb := func(realm) error {\n\t\tconstraints = checkers\n\t\treturn nil\n\t}\n\n\treturn dao.NewProposalRequest(\n\t\t\"Reset name registry constraints\",\n\t\tdesc.String(),\n\t\tdao.NewSimpleExecutor(cb, \"\"),\n\t)\n}\n\n// ProposeConstraintsAppend creates a new GovDAO proposal to append new name constraints.\nfunc ProposeConstraintsAppend(checkers ...Checker) dao.ProposalRequest {\n\tif len(checkers) == 0 {\n\t\tpanic(\"proposal requires at least one name checker\")\n\t}\n\n\tvar desc strings.Builder\n\tdesc.WriteString(md.Paragraph(\"Proposal appends new name registry realm constrains:\"))\n\tfor _, c := range checkers {\n\t\tdesc.WriteString(md.BulletItem(c.Description()))\n\t}\n\n\tcb := func(realm) error {\n\t\tconstraints = append(constraints, checkers...)\n\t\treturn nil\n\t}\n\n\treturn dao.NewProposalRequest(\n\t\t\"Append new name registry constraints\",\n\t\tdesc.String(),\n\t\tdao.NewSimpleExecutor(cb, \"\"),\n\t)\n}\n\n// ProposeNamesSet creates a new GovDAO proposal to set reserved, blacklisted or custom names.\nfunc ProposeNamesSet(nameType string, names ...string) dao.ProposalRequest {\n\tif len(names) == 0 {\n\t\tpanic(\"list of names must not be empty\")\n\t}\n\n\tif nameType != TypeReserved \u0026\u0026 nameType != TypeBlacklisted \u0026\u0026 nameType != TypeCustom {\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\n\tcb := func(realm) error {\n\t\tSetNames(cross, nameType, names...)\n\t\treturn nil\n\t}\n\n\treturn dao.NewProposalRequest(\n\t\tufmt.Sprintf(\"Initialize %s names\", nameType),\n\t\tufmt.Sprintf(\"Proposal initializes %d %s names\", len(names), nameType),\n\t\tdao.NewSimpleExecutor(cb, \"\"),\n\t)\n}\n\n// ProposeNamesAdd creates a new GovDAO proposal to add reserved, blacklisted or custom names.\nfunc ProposeNamesAdd(nameType string, names ...string) dao.ProposalRequest {\n\tif len(names) == 0 {\n\t\tpanic(\"list of names must not be empty\")\n\t}\n\n\tif nameType != TypeReserved \u0026\u0026 nameType != TypeBlacklisted \u0026\u0026 nameType != TypeCustom {\n\t\tpanic(\"invalid name type: \" + nameType)\n\t}\n\n\tcb := func(realm) error {\n\t\tAddNames(cross, nameType, names...)\n\t\treturn nil\n\t}\n\n\treturn dao.NewProposalRequest(\n\t\tufmt.Sprintf(\"Add new %s names\", nameType),\n\t\tufmt.Sprintf(\"Proposal adds %d %s new names\", len(names), nameType),\n\t\tdao.NewSimpleExecutor(cb, \"\"),\n\t)\n}\n"},{"name":"render.gno","body":"package nameregistry\n\nimport (\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/jefft0/avlhelpers\"\n\t\"gno.land/p/jeronimoalbi/mdform\"\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/moul/mdtable\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/mdalert\"\n\t\"gno.land/p/nt/mux\"\n)\n\nconst (\n\tpathVerify = \"verify\"\n\tpathSearch = \"search\"\n)\n\nconst maxSearchItems = 30\n\nvar realmPath = strings.TrimPrefix(runtime.CurrentRealm().PkgPath(), \"gno.land\")\n\nfunc Render(path string) string {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"\", renderHome)\n\trouter.HandleFunc(pathVerify, renderVerify)\n\trouter.HandleFunc(pathSearch, renderSearch)\n\n\trouter.NotFoundHandler = func(res *mux.ResponseWriter, _ *mux.Request) {\n\t\tres.Write(md.Blockquote(\"Path not found\"))\n\t}\n\n\tvar b strings.Builder\n\tb.WriteString(md.H1(\"Name Registry\"))\n\tb.WriteString(router.Render(path))\n\treturn b.String()\n}\n\nfunc renderHome(res *mux.ResponseWriter, _ *mux.Request) {\n\titems := make([]string, len(constraints))\n\tfor i, c := range constraints {\n\t\titems[i] = c.Description()\n\t}\n\n\ttable := mdtable.Table{\n\t\tHeaders: []string{\"Names\", \"Total\"},\n\t\tRows: [][]string{\n\t\t\t{TypeReserved, strconv.Itoa(reserved.Size())},\n\t\t\t{TypeBlacklisted, strconv.Itoa(blacklisted.Size())},\n\t\t\t{TypeCustom, strconv.Itoa(custom.Size())},\n\t\t},\n\t}\n\n\tres.Write(\" ↳ \")\n\tres.Write(md.Link(\"Verify Name\", makeURI(pathVerify)))\n\tres.Write(\" • \")\n\tres.Write(md.Link(\"Search\", makeURI(pathSearch)))\n\tres.Write(\"\\n\")\n\n\tres.Write(md.H2(\"Naming Constraints\"))\n\tres.Write(md.Paragraph(\"Names must match the following constraints:\"))\n\tres.Write(md.OrderedList(items))\n\n\tres.Write(md.H2(\"Registered Names\"))\n\tres.Write(table.String())\n}\n\nfunc renderVerify(res *mux.ResponseWriter, req *mux.Request) {\n\tname := strings.TrimSpace(req.Query.Get(\"name\"))\n\tform := mdform.New(\"path\", pathVerify)\n\tform.Input(\n\t\t\"name\",\n\t\t\"placeholder\", \"Write a name to verify\",\n\t\t\"value\", name,\n\t)\n\n\tres.Write(md.Link(\"← Back Home\", makeURI(\"\")) + \"\\n\\n\")\n\tres.Write(md.H2(\"Verify Name\"))\n\tres.Write(\n\t\tmd.Paragraph(\n\t\t\t\"Verification checks if a name is valid for current registry contraints\",\n\t\t),\n\t)\n\n\tif name != \"\" {\n\t\tvar errors strings.Builder\n\t\tfor _, c := range constraints {\n\t\t\tif err := c.Check(name); err != nil {\n\t\t\t\terrors.WriteString(md.Paragraph(err.Error()))\n\t\t\t}\n\t\t}\n\n\t\tif errors.Len() == 0 {\n\t\t\tres.Write(mdalert.Info(\"Info\", \"The name is a valid\"))\n\t\t} else {\n\t\t\tres.Write(mdalert.Caution(\"Name is not valid\", errors.String()))\n\t\t}\n\t}\n\n\tres.Write(form.String())\n}\n\nfunc renderSearch(res *mux.ResponseWriter, req *mux.Request) {\n\tnameType := req.Query.Get(\"type\")\n\tprefix := strings.TrimSpace(req.Query.Get(\"prefix\"))\n\n\tform := mdform.New(\"path\", pathSearch)\n\tform.Input(\n\t\t\"prefix\",\n\t\t\"placeholder\", \"Name Prefix\",\n\t\t\"value\", prefix,\n\t)\n\tform.Select(\n\t\t\"type\",\n\t\tTypeReserved,\n\t\t\"selected\", strconv.FormatBool(nameType == \"\" || nameType == TypeReserved),\n\t)\n\tform.Select(\n\t\t\"type\",\n\t\tTypeCustom,\n\t\t\"selected\", strconv.FormatBool(nameType == TypeCustom),\n\t)\n\tform.Select(\n\t\t\"type\",\n\t\tTypeBlacklisted,\n\t\t\"selected\", strconv.FormatBool(nameType == TypeBlacklisted),\n\t)\n\n\tvar names *avl.Tree\n\tswitch nameType {\n\tcase TypeReserved:\n\t\tnames = reserved\n\tcase TypeCustom:\n\t\tnames = custom\n\tcase TypeBlacklisted:\n\t\tnames = blacklisted\n\t}\n\n\tres.Write(md.Link(\"← Back Home\", makeURI(\"\")) + \"\\n\\n\")\n\tres.Write(md.H2(\"Search Names\"))\n\n\tif names == nil || len(prefix) \u003c 3 {\n\t\tif prefix != \"\" {\n\t\t\tres.Write(mdalert.Caution(\"Error\", \"Search requires at least three letters\"))\n\t\t}\n\n\t\tres.Write(form.String())\n\t} else {\n\t\tvar (\n\t\t\tresults strings.Builder\n\t\t\tcurrent int\n\t\t)\n\n\t\tavlhelpers.IterateByteStringKeysByPrefix(names, prefix, func(name string, _ any) bool {\n\t\t\tresults.WriteString(md.BulletItem(name))\n\t\t\tcurrent++\n\t\t\treturn current == maxSearchItems\n\t\t})\n\n\t\tif results.Len() == 0 {\n\t\t\tres.Write(mdalert.Warning(\"Not Found\", \"Search didn't find any matching names\"))\n\t\t\tres.Write(form.String())\n\t\t} else {\n\t\t\tres.Write(form.String())\n\t\t\tres.Write(md.H2(\"Results\"))\n\t\t\tres.Write(results.String())\n\t\t}\n\t}\n}\n\nfunc makeURI(path string) string {\n\tif path == \"\" {\n\t\treturn realmPath\n\t}\n\treturn realmPath + \":\" + path\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"800000000","gas_fee":"800000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"7oQB/7uzsY4cHbdwIflt8Lx02KtJBUuSj/dRh8q//yasrsgYFwu0DqvdULzDnOEoh9QdFI5JOA7DJutCCVfqDw=="}],"memo":""},"metadata":{"timestamp":"1768482903"}}
{"tx":{"msg":[{"@type":"/vm.m_run","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","max_deposit":"","package":{"name":"main","path":"gno.land/e/g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun/run","files":[{"name":"gnomod.toml","body":"module = \"gno.land/e/g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun/run\"\ngno = \"0.9\"\nprivate = true\n"},{"name":"main.gno","body":"package main\n\nimport \"gno.land/r/g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun/nameregistry\"\n\nfunc main() {\n\tnameregistry.SetNames(cross, nameregistry.TypeBlacklisted, \"jesus\")\n\tnameregistry.SetNames(cross, nameregistry.TypeCustom, \"tendermint\", \"newtendermint\", \"nt\")\n\tnameregistry.SetNames(cross, nameregistry.TypeReserved, \"google\", \"amazon\")\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserProd"}}}],"fee":{"gas_wanted":"3000000000","gas_fee":"9000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"a3jjMt9VSkq684/evo4pMVeEFoMsc0xoMsBBMO4y0I+vFzVDeH13MFeOo3iaEVJAenFaAOekBylYVHsxcgdPCA=="}],"memo":""},"metadata":{"timestamp":"1768483018"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"mood23","path":"gno.land/r/meeeshell222/mood23","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/mood23\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage mood23"},{"name":"mood.gno","body":"package mood23\n\nvar myMood = \"excited about Beta Mainnet launch!\"\n\nfunc changeMood(newMood string) {\n\tmyMood = newMood\n}\n\nfunc ChangeMyMood(_ realm, myNewMood string) string {\n\tchangeMood(myNewMood)\n\treturn \"My mood is \" + myNewMood\n}\n\nfunc Render(_ string) string {\n\treturn \"My mood is \" + myMood\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"542683","gas_fee":"543ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"0YTnPKh28Z/d29gDRKNsue4A50bZu7zb6pgNzdUk0wdCHVxfqkWk+9snrY79rdqT1vRZ6jAmUhxU2eHSgVhbDQ=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1768483395"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/mood23","func":"ChangeMyMood","args":[""]}],"fee":{"gas_wanted":"286289","gas_fee":"287ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"SlgWWCGCfnrSTmtqj4cBd4E3FZpuTSlI1uJWLxrBWdFbLINNMtcaamLZ/hfKVJ1br+43yH78EbydO8opAN6JCQ=="}],"memo":""},"metadata":{"timestamp":"1768483410"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"mood24","path":"gno.land/r/meeeshell222/mood24","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/mood24\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage mood24"},{"name":"mood.gno","body":"package mood24\n\nvar myMood = \"excited about Beta Mainnet launch!\"\n\nfunc changeMood(newMood string) {\n\tmyMood = newMood\n}\n\nfunc Render(_ string) string {\n\treturn \"My mood is\" + myMood\n}\n\nfunc ChangeMyMood(_ realm, myNewMood string) string {\n\tchangeMood(myNewMood)\n\treturn \"My mood is \" + myNewMood\n}\n\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"542650","gas_fee":"543ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"bTqrTfdKKT90I+8/Mqefil2PBoihDiuAksx1vhFD7dFmxoILIfgjcOVwigTEH07wgPg3l6iGziFJTW9YmweYDw=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1768483521"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/mood24","func":"ChangeMyMood","args":[""]}],"fee":{"gas_wanted":"286130","gas_fee":"287ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"IrXPmgN2RFe0o/3SchZVcJsr6S9tVPJB+8yVn+0Alzp1dw4CyMbFkxKOqdo81arAE/HSRDsTwkpVl6oUt0JrAg=="}],"memo":""},"metadata":{"timestamp":"1768483536"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"mood25","path":"gno.land/r/meeeshell222/mood25","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/mood25\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage mood25"},{"name":"mood.gno","body":"package mood25\n\n// ChangeMyMood does NOT mutate state.\n// It simply returns the new mood.\nfunc ChangeMyMood(_ string, myNewMood string) string {\n\treturn myNewMood\n}\n\n// Render renders whatever mood it is given.\nfunc Render(mood string) string {\n\treturn \"My mood is \" + mood\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"523153","gas_fee":"524ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"H/n467nM+W2kk5QaPg88BVmpCHrkrQpwEbtkDwRazSZA0Iywnxk21hivwQZOzi5SiPiI8/B1B5kd7PTV4XXfBw=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1768483913"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"mood26","path":"gno.land/r/meeeshell222/mood26","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/mood26\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage mood26"},{"name":"mood.gno","body":"package mood26\n\n// Persistent realm state\nvar myMood = \"excited about Beta Mainnet launch!\"\n\n// ChangeMyMood is a crossing function (transaction)\nfunc ChangeMyMood(cross string, newMood string) {\n\tmyMood = newMood\n}\n\n// Render displays the current mood\nfunc Render(_ string) string {\n\treturn \"# Mood\\n\\nMy mood is \" + myMood\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"530014","gas_fee":"531ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"3W/r2AKh+JNpVKgPWOiG3+1EO8jl0oSX1t1iI1mEDYoxHaf47xgDaYEWKLyCfrmUsqMB15xAu6xxvcGvjKbbAA=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1768484345"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"mood30","path":"gno.land/r/meeeshell222/mood30","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/mood30\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage mood30"},{"name":"mood.gno","body":"package mood30\n\nvar myMood = \"building my first tutorial\"\n\nfunc changeMood(newMood string) {\n\tmyMood = newMood\n}\n\nfunc ChangeMyMood(_realm, newMood string) string {\n\tchangeMood(newMood)\n\treturn \"Successfully changed the mood\"\n}\n\nfunc Render(_ string) string {\n\treturn \"My mood is\" + myMood\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"541825","gas_fee":"542ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"RRmpw7+hHjzONkndB2b5fNbPiXaJK1YKTWRlCalQc2XUBweHmzbG2BxBieQXXHHkYwa8zN7KY70lKC00Z/OgDA=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1768484948"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"mood32","path":"gno.land/r/meeeshell222/mood32","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/mood32\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage mood32"},{"name":"mood.gno","body":"package mood32\n\nvar myMood = \"building my first tutorial\"\n\nfunc changeMood(newMood string) {\n\tmyMood = newMood\n}\n\nfunc ChangeMyMood(_ realm, newMood string) string {\n\tchangeMood(newMood)\n\treturn \"Successfully changed the mood\"\n}\n\nfunc Render(_ string) string {\n\treturn \"My mood is\" + myMood\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"542164","gas_fee":"543ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"4vL7WNjFwflMPlBDTpxHjXaateh50AO8wRStBeVICwIt3GYQ8JNRn/an+BR98tcGDp/UTvB0/q+INI7cTPuHDA=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1768485290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/mood32","func":"ChangeMyMood","args":[""]}],"fee":{"gas_wanted":"285797","gas_fee":"286ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"I24aeg6Iq1QXe+Lh+fRsgbbfoBKVhG0Pgv1Kzut1U3iDap4r24SYtPnfohDDGCqtLxe2fJGPterOuGXejw7mBg=="}],"memo":""},"metadata":{"timestamp":"1768485305"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"mood33","path":"gno.land/r/meeeshell222/mood33","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/mood33\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage mood33"},{"name":"mood.gno","body":"package mood33\n\nvar myMood = \"building my first tutorial\"\n\nfunc changeMood(newMood string) {\n\tmyMood = newMood\n}\n\nfunc ChangeMood(_realm, newMood string) string {\n\tchangeMood(newMood)\n\treturn \"Successfully changed the mood\"\n}\n\nfunc Render(_ string) string {\n\treturn \"My mood is\" + myMood\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"541751","gas_fee":"542ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"PDBT2vCaX0Mk4MXXZfJ4P/mZSgs7TA5UfugSkBu9xJg="},"signature":"dtMFl5hmlK7iS7vOs0twv42nGnMAN1drWcYIZ7jgLFi86ELp2kvNXOfvcMbx+wWRMHY9wcldZTyLwFjiZVyxDQ=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1768485526"}}
