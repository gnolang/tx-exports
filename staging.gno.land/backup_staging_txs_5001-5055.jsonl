{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1w5hst2p69rza9nmf69dp5flxq8hpzhum768yr9","to_address":"g1w5hst2p69rza9nmf69dp5flxq8hpzhum768yr9","amount":"1000000ugnot"}],"fee":{"gas_wanted":"48263","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"P4/2bY8HMYx+n4t9vU+MsMIk9WDk1WK2k3nZhCuvs/yPqID47f96yK49tP3NAfxl7GfSrh7Z5ZbCEw8sOrB1Bw=="}],"memo":""},"metadata":{"timestamp":"1768352471"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1c9y7qexumxgmrzk3jgj37vkfrhaxvyf6mhk4ke","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","31"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"f8jThq2bgtf+E/ojDz2XvdMRozTp0Hk25r0XW2w4KUzQ4AjZpLRm2/xY7R09MTn7Ik3f74H7KoHDZyIhbw5gDA=="}],"memo":""},"metadata":{"timestamp":"1768352531"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"525110ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"n4E9xitEfdPzb1ZdWVd/9ax7g5KqrYF5gv0nmfrekWJ0j/dyw8gJ/aC8kH3h5IC1/GYOFcmhsqEXcQWeuDHaCg=="}],"memo":""},"metadata":{"timestamp":"1768354311"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"525110ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"34PH2BvlMVD+AiZPZuToIOur2BcJg/3nfHW7aCC/4PN2t3R+5FXgKEBa+1FKJqzd4X8riAcflGbRFktRO/VTDA=="}],"memo":""},"metadata":{"timestamp":"1768354316"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"w1KjB7yJC7MC2kPyuZGudvUo+Fb4XEiY+/zhC91EV6bZpIAdIpTJkHFKT3IiUf8iijuGpYjVIwncIVd7U7OhCg=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"ZRW9dc4nZXNYrjuwO6g6mA5QtlFyDeyiY9eNrbCJfnDL0/8TS6P1JwNx88Euszdk8H3yaOnn3euvM+VuHNZzCQ=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"mvPYI0EHGuqc6Y6p8IV88f4W558GtLcnnw3ZqZS//wCq6FoeoU938GJW4LHB1WumJvJEfzBTaK7SBZuEkKNGAw=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"I4+eElwn/KtcH0b/VlnZcfIJz1W5X/nR1AI+6gng6CQb1xb/qVAe54nPxPNiMLbA7ZnjTqJv77aGsRYLfOjxAg=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"hQq20zXoTaqmQVZ5HyE0pgHW8XF8LARKz3zfSkRfzTehTeQhogY2vk+Wcp+hG3MYPxzgwZ+22K6Ulto/df/VAQ=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"anTL3PWIu/hTBWYmwZE9WIFmBmlkoCcywUb02vl8EHFH9DicNpIjxC77lEwG6WMY0nU8/DdjS90TkZPFYoV0CQ=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"AzKDWsUeJKhoVEYtBpy8FRikMeIJwtfpXt3aykimQNHhnx1hyx8igsKmCm9/1Lu6D32xQyr4sfKoGNRDmgzsBw=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"Os72AoDcvYQ7f+qmJAc3W/vxK6hflKys34LzRmHSLRWETmbB1vrewTBj2qnfSm7I/CmbF/831OE4ql8JZ86fAQ=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354321_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"+BTYFNkAwuVOKup/iYoNHUzC8QKmJlIrZQXydect7iBU6ExDEwf4K2ncwpaq5QcGgcY3tz53WjVY602/w1GxCg=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354321_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"नमस्ते\"\n\tcase Bulgarian:\n\t\treturn \"Здравейте\"\n\tcase Serbian:\n\t\treturn \"Здраво\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478384","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"st7uobrPfAdLx9YOPEkNmjEeAeGAIbuHjJptm5dplxI4BZprPcWaWEu/LrzUakdkDkLEXE0kxZEX2IZEI7rWBg=="}],"memo":""},"metadata":{"timestamp":"1768354321"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"2842875ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"TiJ+y4RoXFMxWYowZUeQtOwmUMmy4QFKmF51hA2jE+Gl/yrRD7r4TAKRjjLmi3ycFhLz+J/LoqotaDXex475Cw=="}],"memo":""},"metadata":{"timestamp":"1768354406"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"2842875ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"NpJ3DlsrcCaBSUW2hdK+A8rZ4Wh/2uIYwFAabj29KXrHK/vv0Uo5G8vwIxNaj7L3rYhtfAgtG84eWVcvcTv/Aw=="}],"memo":""},"metadata":{"timestamp":"1768354411"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"4LvaNXrJx+jxHpsJNcAmfbpHtQnSedfhfLF6+OhKs53+OwgFua+DCFdbNJk6W1+BV3J+uyd0jqflnQySif/YAw=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"eWP+IM13dT5oktB481WWjlZu/L1Kdul0hsGw4UHWY/Fnx2yq+eOfCmYRK6bmBB2Vw/XqWbBVIQoQUsB8IOw+DQ=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"a04xjwrxT+X4KAQyMCbbYrfI9LoYz3kCwxvpNXfO6aXC7Goao8wz5hZ6gn1i/4Tiqe5JDi9Getnu6zE5JxyuCA=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"pAitnuIHeWlcTjMD/Qr2XY4E94ENmcWqXavGfzlYZ0KRJz2bTLRdg+qcUF4R1Zm+zWxrOfx6MiERFGgG1qLRAQ=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"3L+SukoeNpViclyLRDr6jnlcgJTfSRUI2AJp+S0FfaGB/ByC+lI6WptkHH3xAgrxOSgZlGe47H88kzdUbx5CDw=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"nF50rd9YERVNmY2GpuQRD3qhTMr48s7g50s5wOxmZ7Pq3hv1RxwdfXFQVPpNoGXD/EBARGOzM2k2nAsJAb3vAQ=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"opKQbrxXTwMSAvUlC/DtDSpItTs9SgfkWuk6UeYdMjfT+OQObpUyNgRSYpCzuOUi4Q9FTG0vTG2jCtX0MiglAw=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"1w4/iFZsnZecL0mGim6U8Np/7/mdTuxspUjjqzo6QW1e8DCynettvRj2dPaTWUEWU1JRI+JPVTf7XVfn8gQVCQ=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1768354417_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"ZP2giqX6i52bTV09W2U15Tn+uWZ/dym7x4cchNbb6asEOfPjLM3bUtu/yPuZcHfsqS7CRddTBsdE93UbCyhBCw=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1768354417_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603532","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"AWRWi56njJRLShuEbm0he7w+8X0dJIh9/PMXgyGscsrDP35iNjIK7tFxMK3YgfyYopDAMr/8/PRE40dktX1SBw=="}],"memo":""},"metadata":{"timestamp":"1768354416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"runtime","path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"622239","gas_fee":"623ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"LQc5LjFEMSwhc9LLy32NLYcwm/76NxbP2jxpZ3vQB+h/lJ73XccoePCMOzK9/TSVs8jdH/ujmbtUhO6RuXOdAA=="}],"memo":""},"metadata":{"timestamp":"1768354497"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-0"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"AuJGI1LHFvzo1Xd3Cn3LQaaug0ahJRV++jtNT0dBFMX6RSvef7XnjsMbyhUEuLrxlIwmYZ+fvf+FREbiJlgtDw=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"FAbWRhaaWztUfWBh/xCespxbM7deA0z2HIL5oHq+A6sr5l4jCwYQBTS/JR/VNExbCk5eR2Wfz61sxiokRX4KBA=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"+vJodg7BuZhZE8w3Q2z9mrv0h3I29pAyyWemsB62VNhWDZ9Q0rksWU+ydZsl8ZabZGgL0pM9inS6/W7rRZm9Dw=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"f/GSecZ/tyn1Gm2HjaSd5rZHpAcPm+3y79jQ00yFYtURHOyTKrj1Pvm2Vx7NsiQtOk2+wthBUtnRm/91rUd+CA=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"W0uIxp+wpKCJpLov4Fo//8PYQxHoLz5W8NuYhcxFnV3qDxzl9fQK7ubQHcYmfvuCElvNXxcHC/5kuz4fq1dmBw=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"bvB2PbVIZUgp/6H/69W7fL837oQgrl5NVjKl0eRgu0PEqlooELzu66G3H66S/ON51Y6P1NlW7G/D2mw6p1JLAQ=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"Yrk4Ra7F9lz3RyIlN3xyDMnWHX3jj8s0VnO5aSjgF4fmaxhRYfIUJzmuJwlkEOZmw+IwNIws0xEOj+4PwVkeCA=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"PrPiV1Peou9XiOOKowso3l7NCtfCZTMpQ9cr1LPBljBlU+wuXUSy4TCwIa7InuivlbvXffHvdltRWVrpm4IgCQ=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"bY21YBjgC2WcDyTEgqg4Q5IdLDNwLLyEqTIMn0qh98xSOwYyqEQLG4jUz+QbPXHLfthqLNcTrqjhkyy+d1Y2Aw=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1768354501","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167628","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"Q+gfOzmk/+VYpaeiOEmhvD/ZyVpSUNQpt4CxirvaX70y+LP88TbIuffGBBcIH41oNr3aM5hOmjFMh12oxptJAg=="}],"memo":""},"metadata":{"timestamp":"1768354502"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"clmm","path":"gno.land/r/gnomo/clmm3","files":[{"name":"clmm.gno","body":"package clmm\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst (\n\tMIN_TICK  = -1000\n\tMAX_TICK  = 1000\n\tPRECISION = 1000000\n\tMAX_INT64 = int64(9223372036854775807)\n)\n\n// =============================================================================\n// SAFE MATH\n// =============================================================================\n\nfunc safeMul(a, b int64) int64 {\n\tif a == 0 || b == 0 {\n\t\treturn 0\n\t}\n\tresult := a * b\n\tif result/a != b {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn result\n}\n\nfunc safeMulDiv(a, b, c int64) int64 {\n\tif c == 0 {\n\t\tpanic(\"division by zero\")\n\t}\n\tif a \u003e MAX_INT64/b \u0026\u0026 b != 0 {\n\t\tquotient := a / c\n\t\tremainder := a % c\n\t\treturn quotient*b + (remainder*b)/c\n\t}\n\treturn (a * b) / c\n}\n\n// =============================================================================\n// DATA STRUCTURES\n// =============================================================================\n\ntype CLMMPool struct {\n\tID          uint64\n\tDenomA      string\n\tDenomB      string\n\tFeeBPS      int64\n\tTickSpacing int64\n\tPriceX6     int64\n\tCurrentTick int64\n\tLiquidity   int64\n\tFeeGrowthA  int64\n\tFeeGrowthB  int64\n}\n\ntype Position struct {\n\tID            uint64\n\tPoolID        uint64\n\tOwner         string\n\tTickLower     int64\n\tTickUpper     int64\n\tLiquidity     int64\n\tFeeGrowthLastA int64\n\tFeeGrowthLastB int64\n\tTokensOwedA   int64\n\tTokensOwedB   int64\n}\n\ntype TickInfo struct {\n\tLiquidityGross int64\n\tLiquidityNet   int64\n\tInitialized    bool\n}\n\nvar (\n\tpools          []*CLMMPool\n\tnextPoolID     uint64\n\tpositions      []*Position\n\tnextPositionID uint64\n\ttickData       map[uint64]map[int64]*TickInfo\n)\n\nfunc init() {\n\ttickData = make(map[uint64]map[int64]*TickInfo)\n}\n\n// =============================================================================\n// TICK MATH\n// =============================================================================\n\nfunc getPriceAtTick(tick int64) int64 {\n\tif tick \u003c MIN_TICK || tick \u003e MAX_TICK {\n\t\tpanic(\"tick out of range\")\n\t}\n\n\tif tick == 0 {\n\t\treturn PRECISION\n\t}\n\n\tabsTick := tick\n\tif absTick \u003c 0 {\n\t\tabsTick = -absTick\n\t}\n\n\t// Use 1.01 per tick (1% price change per tick)\n\t// Calculate 1.01^absTick using simple iteration\n\tresult := int64(PRECISION) // 1.0 in X6\n\n\tfor i := int64(0); i \u003c absTick; i++ {\n\t\t// result = result * 1.01 = result * 101 / 100\n\t\t// Check for overflow before multiplication\n\t\tif result \u003e MAX_INT64/101 {\n\t\t\tpanic(\"price calculation overflow\")\n\t\t}\n\t\tresult = (result * 101) / 100\n\t}\n\n\tif tick \u003c 0 {\n\t\t// Invert: 1 / price = PRECISION^2 / result\n\t\tif result \u003e 0 {\n\t\t\treturn safeMulDiv(PRECISION, PRECISION, result)\n\t\t}\n\t\treturn PRECISION\n\t}\n\n\treturn result\n}\n\nfunc getTickAtPrice(priceX6 int64) int64 {\n\tif priceX6 \u003c= 0 {\n\t\tpanic(\"invalid price\")\n\t}\n\n\tlow := int64(MIN_TICK)\n\thigh := int64(MAX_TICK)\n\n\tfor low \u003c high {\n\t\tmid := (low + high + 1) / 2\n\t\tpriceAtMid := getPriceAtTick(mid)\n\n\t\tif priceAtMid \u003c= priceX6 {\n\t\t\tlow = mid\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\n\treturn low\n}\n\n// =============================================================================\n// LIQUIDITY MATH\n// =============================================================================\n\nfunc getAmountsForLiquidity(pL, pU, pC, liq int64) (int64, int64) {\n\tif pC \u003c= pL {\n\t\t// Price below range: all token0\n\t\tdenominator := safeMulDiv(pL, pU, PRECISION)\n\t\tif denominator == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tamt0 := safeMulDiv(liq, pU-pL, denominator)\n\t\treturn amt0, 0\n\t} else if pC \u003e= pU {\n\t\t// Price above range: all token1\n\t\tamt1 := safeMulDiv(liq, pU-pL, PRECISION)\n\t\treturn 0, amt1\n\t} else {\n\t\t// Price in range: mix of both tokens\n\t\tdenominator := safeMulDiv(pC, pU, PRECISION)\n\t\tif denominator == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tamt0 := safeMulDiv(liq, pU-pC, denominator)\n\t\tamt1 := safeMulDiv(liq, pC-pL, PRECISION)\n\t\treturn amt0, amt1\n\t}\n}\n\nfunc getLiquidityForAmounts(pL, pU, pC, amt0, amt1 int64) int64 {\n\tif pC \u003c= pL {\n\t\tif amt0 \u003c= 0 {\n\t\t\treturn 0\n\t\t}\n\t\tnumerator := safeMulDiv(pL, pU, PRECISION)\n\t\treturn safeMulDiv(amt0, numerator, pU-pL)\n\t} else if pC \u003e= pU {\n\t\tif amt1 \u003c= 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn safeMulDiv(amt1, PRECISION, pU-pL)\n\t} else {\n\t\tnumerator0 := safeMulDiv(pC, pU, PRECISION)\n\t\tliq0 := safeMulDiv(amt0, numerator0, pU-pC)\n\t\tliq1 := safeMulDiv(amt1, PRECISION, pC-pL)\n\t\tif liq0 \u003c liq1 {\n\t\t\treturn liq0\n\t\t}\n\t\treturn liq1\n\t}\n}\n\n// =============================================================================\n// POOL MANAGEMENT\n// =============================================================================\n\nfunc CreateCLMMPool(_ realm, denomA, denomB string, feeBPS int64, initialPriceX6 int64) uint64 {\n\tif denomA == \"\" || denomB == \"\" {\n\t\tpanic(\"invalid denom\")\n\t}\n\tif denomA == denomB {\n\t\tpanic(\"denoms must be different\")\n\t}\n\tif denomA \u003e denomB {\n\t\tdenomA, denomB = denomB, denomA\n\t\tif initialPriceX6 \u003e 0 {\n\t\t\tinitialPriceX6 = (PRECISION * PRECISION) / initialPriceX6\n\t\t}\n\t}\n\n\tfor _, p := range pools {\n\t\tif p.DenomA == denomA \u0026\u0026 p.DenomB == denomB \u0026\u0026 p.FeeBPS == feeBPS {\n\t\t\tpanic(\"pool already exists\")\n\t\t}\n\t}\n\n\tif feeBPS \u003c= 0 || feeBPS \u003e 10000 {\n\t\tpanic(\"fee must be 1-10000 bps\")\n\t}\n\n\tvar tickSpacing int64 = 1\n\tif feeBPS \u003e= 100 {\n\t\ttickSpacing = 10\n\t} else if feeBPS \u003e= 30 {\n\t\ttickSpacing = 5\n\t}\n\n\tif initialPriceX6 \u003c= 0 {\n\t\tinitialPriceX6 = PRECISION\n\t}\n\n\tpool := \u0026CLMMPool{\n\t\tID:          nextPoolID,\n\t\tDenomA:      denomA,\n\t\tDenomB:      denomB,\n\t\tFeeBPS:      feeBPS,\n\t\tTickSpacing: tickSpacing,\n\t\tPriceX6:     initialPriceX6,\n\t\tCurrentTick: getTickAtPrice(initialPriceX6),\n\t\tLiquidity:   0,\n\t}\n\n\tpools = append(pools, pool)\n\ttickData[nextPoolID] = make(map[int64]*TickInfo)\n\tnextPoolID++\n\n\treturn pool.ID\n}\n\n// =============================================================================\n// POSITION MANAGEMENT\n// =============================================================================\n\nfunc MintPosition(_ realm, poolID uint64, tickLower, tickUpper int64) uint64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tpool := pools[poolID]\n\n\tif tickLower \u003e= tickUpper {\n\t\tpanic(\"tickLower must be \u003c tickUpper\")\n\t}\n\tif tickLower \u003c MIN_TICK || tickUpper \u003e MAX_TICK {\n\t\tpanic(\"ticks out of range\")\n\t}\n\tif tickLower%pool.TickSpacing != 0 || tickUpper%pool.TickSpacing != 0 {\n\t\tpanic(\"ticks must align with spacing\")\n\t}\n\n\tcaller := string(runtime.OriginCaller())\n\tsentCoins := banker.OriginSend()\n\n\tamountA := sentCoins.AmountOf(pool.DenomA)\n\tamountB := sentCoins.AmountOf(pool.DenomB)\n\n\tif amountA \u003c= 0 \u0026\u0026 amountB \u003c= 0 {\n\t\tpanic(\"must send tokens\")\n\t}\n\n\tpL := getPriceAtTick(tickLower)\n\tpU := getPriceAtTick(tickUpper)\n\n\tliquidity := getLiquidityForAmounts(pL, pU, pool.PriceX6, amountA, amountB)\n\tif liquidity \u003c= 0 {\n\t\tpanic(\"insufficient liquidity\")\n\t}\n\n\t// Update ticks\n\tupdateTick(poolID, tickLower, liquidity, true)\n\tupdateTick(poolID, tickUpper, liquidity, false)\n\n\t// Update pool liquidity if in range\n\tif pool.PriceX6 \u003e= pL \u0026\u0026 pool.PriceX6 \u003c pU {\n\t\tpool.Liquidity += liquidity\n\t}\n\n\tposition := \u0026Position{\n\t\tID:            nextPositionID,\n\t\tPoolID:        poolID,\n\t\tOwner:         caller,\n\t\tTickLower:     tickLower,\n\t\tTickUpper:     tickUpper,\n\t\tLiquidity:     liquidity,\n\t\tFeeGrowthLastA: pool.FeeGrowthA,\n\t\tFeeGrowthLastB: pool.FeeGrowthB,\n\t}\n\n\tpositions = append(positions, position)\n\tnextPositionID++\n\n\treturn position.ID\n}\n\nfunc BurnPosition(_ realm, positionID uint64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\n\tpos := positions[positionID]\n\tcaller := string(runtime.OriginCaller())\n\n\tif pos.Owner != caller {\n\t\tpanic(\"not owner\")\n\t}\n\tif pos.Liquidity == 0 {\n\t\tpanic(\"already burned\")\n\t}\n\n\tpool := pools[pos.PoolID]\n\tpL := getPriceAtTick(pos.TickLower)\n\tpU := getPriceAtTick(pos.TickUpper)\n\n\tamount0, amount1 := getAmountsForLiquidity(pL, pU, pool.PriceX6, pos.Liquidity)\n\n\t// Update ticks\n\tupdateTick(pos.PoolID, pos.TickLower, -pos.Liquidity, true)\n\tupdateTick(pos.PoolID, pos.TickUpper, -pos.Liquidity, false)\n\n\t// Update pool liquidity\n\tif pool.PriceX6 \u003e= pL \u0026\u0026 pool.PriceX6 \u003c pU {\n\t\tpool.Liquidity -= pos.Liquidity\n\t}\n\n\tpos.Liquidity = 0\n\n\t// Send tokens back\n\tif amount0 \u003e 0 || amount1 \u003e 0 {\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\trealmAddr := runtime.CurrentRealm().Address()\n\t\tcallerAddr := runtime.OriginCaller()\n\n\t\tif amount0 \u003e 0 \u0026\u0026 amount1 \u003e 0 {\n\t\t\tcoins := chain.NewCoins(\n\t\t\t\tchain.NewCoin(pool.DenomA, amount0),\n\t\t\t\tchain.NewCoin(pool.DenomB, amount1),\n\t\t\t)\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, coins)\n\t\t} else if amount0 \u003e 0 {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomA, amount0)))\n\t\t} else {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomB, amount1)))\n\t\t}\n\t}\n}\n\n// =============================================================================\n// SWAP\n// =============================================================================\n\nfunc Swap(_ realm, poolID uint64, tokenIn string, minAmountOut int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tpool := pools[poolID]\n\tif pool.Liquidity == 0 {\n\t\tpanic(\"no liquidity\")\n\t}\n\n\tcaller := runtime.OriginCaller()\n\tsentCoins := banker.OriginSend()\n\n\tvar zeroForOne bool\n\tvar amountIn int64\n\n\tif tokenIn == \"A\" {\n\t\tzeroForOne = true\n\t\tamountIn = sentCoins.AmountOf(pool.DenomA)\n\t} else if tokenIn == \"B\" {\n\t\tzeroForOne = false\n\t\tamountIn = sentCoins.AmountOf(pool.DenomB)\n\t} else {\n\t\tpanic(\"tokenIn must be A or B\")\n\t}\n\n\tif amountIn \u003c= 0 {\n\t\tpanic(\"must send input token\")\n\t}\n\n\t// Calculate fee using safe math\n\tfeeAmount := safeMulDiv(amountIn, pool.FeeBPS, 10000)\n\tamountRemaining := amountIn - feeAmount\n\ttotalAmountOut := int64(0)\n\n\t// Process swap with tick crossing\n\tmaxIterations := 100 // Safety limit to prevent infinite loops\n\tfor i := 0; i \u003c maxIterations \u0026\u0026 amountRemaining \u003e 0; i++ {\n\t\tif pool.Liquidity == 0 {\n\t\t\tbreak // No more liquidity\n\t\t}\n\n\t\t// Find next initialized tick in the direction of swap\n\t\tnextTick := findNextInitializedTick(poolID, pool.CurrentTick, zeroForOne)\n\n\t\t// Calculate how much we can swap before hitting the next tick\n\t\tvar amountInStep, amountOutStep int64\n\t\tvar nextTickPrice int64\n\n\t\tif zeroForOne {\n\t\t\t// Swapping A for B (price decreases)\n\t\t\tnextTickPrice = getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MIN_TICK)\n\t\t\t}\n\n\t\t\t// Calculate max input to reach next tick\n\t\t\tpriceDiff := pool.PriceX6 - nextTickPrice\n\t\t\tif priceDiff \u003c= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Max amount that can be swapped at current liquidity to reach nextTickPrice\n\t\t\tmaxAmountIn := safeMulDiv(pool.Liquidity, priceDiff, pool.PriceX6)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn {\n\t\t\t\t// Swap completes within this tick range\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, pool.PriceX6, PRECISION)\n\t\t\t\t// Update price proportionally\n\t\t\t\tpriceChange := safeMulDiv(amountInStep, pool.PriceX6, pool.Liquidity)\n\t\t\t\tpool.PriceX6 -= priceChange\n\t\t\t\tif pool.PriceX6 \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\t\tpool.PriceX6 = getPriceAtTick(MIN_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Swap crosses this tick\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, pool.PriceX6, PRECISION)\n\t\t\t\tpool.PriceX6 = nextTickPrice\n\n\t\t\t\t// Cross the tick - update liquidity\n\t\t\t\tcrossTick(poolID, nextTick, zeroForOne)\n\t\t\t}\n\t\t} else {\n\t\t\t// Swapping B for A (price increases)\n\t\t\tnextTickPrice = getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MAX_TICK)\n\t\t\t}\n\n\t\t\tpriceDiff := nextTickPrice - pool.PriceX6\n\t\t\tif priceDiff \u003c= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(pool.Liquidity, priceDiff, PRECISION)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, PRECISION, pool.PriceX6)\n\t\t\t\tpriceChange := safeMulDiv(amountInStep, PRECISION, pool.Liquidity)\n\t\t\t\tpool.PriceX6 += priceChange\n\t\t\t\tif pool.PriceX6 \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\t\tpool.PriceX6 = getPriceAtTick(MAX_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, PRECISION, pool.PriceX6)\n\t\t\t\tpool.PriceX6 = nextTickPrice\n\n\t\t\t\tcrossTick(poolID, nextTick, zeroForOne)\n\t\t\t}\n\t\t}\n\n\t\tamountRemaining -= amountInStep\n\t\ttotalAmountOut += amountOutStep\n\n\t\t// Accumulate fees for this step (proportional to amount used)\n\t\tif pool.Liquidity \u003e 0 {\n\t\t\tstepFee := safeMulDiv(feeAmount, amountInStep, amountIn-feeAmount)\n\t\t\tif zeroForOne {\n\t\t\t\tpool.FeeGrowthA += safeMulDiv(stepFee, PRECISION, pool.Liquidity)\n\t\t\t} else {\n\t\t\t\tpool.FeeGrowthB += safeMulDiv(stepFee, PRECISION, pool.Liquidity)\n\t\t\t}\n\t\t}\n\t}\n\n\tpool.CurrentTick = getTickAtPrice(pool.PriceX6)\n\n\tif totalAmountOut \u003c minAmountOut {\n\t\tpanic(\"slippage exceeded\")\n\t}\n\n\t// Send output\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tvar denomOut string\n\tif zeroForOne {\n\t\tdenomOut = pool.DenomB\n\t} else {\n\t\tdenomOut = pool.DenomA\n\t}\n\n\tbnk.SendCoins(realmAddr, caller, chain.NewCoins(chain.NewCoin(denomOut, totalAmountOut)))\n\n\treturn totalAmountOut\n}\n\n// findNextInitializedTick finds the next tick with liquidity in the swap direction\nfunc findNextInitializedTick(poolID uint64, currentTick int64, zeroForOne bool) int64 {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\tif zeroForOne {\n\t\t\treturn MIN_TICK\n\t\t}\n\t\treturn MAX_TICK\n\t}\n\n\tpool := pools[poolID]\n\tspacing := pool.TickSpacing\n\n\tif zeroForOne {\n\t\t// Going down (price decreasing), look for next lower initialized tick\n\t\tfor tick := currentTick - spacing; tick \u003e= MIN_TICK; tick -= spacing {\n\t\t\tif info := ticks[tick]; info != nil \u0026\u0026 info.Initialized {\n\t\t\t\treturn tick\n\t\t\t}\n\t\t}\n\t\treturn MIN_TICK\n\t} else {\n\t\t// Going up (price increasing), look for next higher initialized tick\n\t\tfor tick := currentTick + spacing; tick \u003c= MAX_TICK; tick += spacing {\n\t\t\tif info := ticks[tick]; info != nil \u0026\u0026 info.Initialized {\n\t\t\t\treturn tick\n\t\t\t}\n\t\t}\n\t\treturn MAX_TICK\n\t}\n}\n\n// crossTick updates liquidity when crossing a tick boundary\nfunc crossTick(poolID uint64, tick int64, zeroForOne bool) {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\treturn\n\t}\n\n\tinfo := ticks[tick]\n\tif info == nil || !info.Initialized {\n\t\treturn\n\t}\n\n\tpool := pools[poolID]\n\n\t// When crossing a tick from left to right (price increasing), add liquidityNet\n\t// When crossing from right to left (price decreasing), subtract liquidityNet\n\tif zeroForOne {\n\t\t// Price decreasing, crossing tick from above\n\t\tpool.Liquidity -= info.LiquidityNet\n\t} else {\n\t\t// Price increasing, crossing tick from below\n\t\tpool.Liquidity += info.LiquidityNet\n\t}\n\n\t// Ensure liquidity doesn't go negative\n\tif pool.Liquidity \u003c 0 {\n\t\tpool.Liquidity = 0\n\t}\n}\n\n// =============================================================================\n// COLLECT FEES\n// =============================================================================\n\nfunc CollectFees(_ realm, positionID uint64) (int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\n\tpos := positions[positionID]\n\tcaller := string(runtime.OriginCaller())\n\n\tif pos.Owner != caller {\n\t\tpanic(\"not owner\")\n\t}\n\n\tpool := pools[pos.PoolID]\n\n\t// Calculate fees owed since last collection\n\t// Only collect fees if position is/was in range\n\tvar feesA, feesB int64\n\n\tif pos.Liquidity \u003e 0 {\n\t\t// Calculate accumulated fees based on fee growth difference\n\t\tfeeGrowthDeltaA := pool.FeeGrowthA - pos.FeeGrowthLastA\n\t\tfeeGrowthDeltaB := pool.FeeGrowthB - pos.FeeGrowthLastB\n\n\t\t// Use safe math to prevent overflow\n\t\tfeesA = safeMulDiv(feeGrowthDeltaA, pos.Liquidity, PRECISION)\n\t\tfeesB = safeMulDiv(feeGrowthDeltaB, pos.Liquidity, PRECISION)\n\n\t\t// Update position's last fee growth snapshot\n\t\tpos.FeeGrowthLastA = pool.FeeGrowthA\n\t\tpos.FeeGrowthLastB = pool.FeeGrowthB\n\t}\n\n\t// Add any previously uncollected tokens\n\tfeesA += pos.TokensOwedA\n\tfeesB += pos.TokensOwedB\n\tpos.TokensOwedA = 0\n\tpos.TokensOwedB = 0\n\n\t// Send fees to owner\n\tif feesA \u003e 0 || feesB \u003e 0 {\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\trealmAddr := runtime.CurrentRealm().Address()\n\t\tcallerAddr := runtime.OriginCaller()\n\n\t\tif feesA \u003e 0 \u0026\u0026 feesB \u003e 0 {\n\t\t\tcoins := chain.NewCoins(\n\t\t\t\tchain.NewCoin(pool.DenomA, feesA),\n\t\t\t\tchain.NewCoin(pool.DenomB, feesB),\n\t\t\t)\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, coins)\n\t\t} else if feesA \u003e 0 {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomA, feesA)))\n\t\t} else {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomB, feesB)))\n\t\t}\n\t}\n\n\treturn feesA, feesB\n}\n\n// GetPositionFees returns uncollected fees for a position\nfunc GetPositionFees(positionID uint64) (int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\treturn 0, 0\n\t}\n\n\tpos := positions[positionID]\n\tpool := pools[pos.PoolID]\n\n\tvar feesA, feesB int64\n\n\tif pos.Liquidity \u003e 0 {\n\t\tfeeGrowthDeltaA := pool.FeeGrowthA - pos.FeeGrowthLastA\n\t\tfeeGrowthDeltaB := pool.FeeGrowthB - pos.FeeGrowthLastB\n\n\t\t// Use safe math to prevent overflow\n\t\tfeesA = safeMulDiv(feeGrowthDeltaA, pos.Liquidity, PRECISION)\n\t\tfeesB = safeMulDiv(feeGrowthDeltaB, pos.Liquidity, PRECISION)\n\t}\n\n\tfeesA += pos.TokensOwedA\n\tfeesB += pos.TokensOwedB\n\n\treturn feesA, feesB\n}\n\n// =============================================================================\n// TICK HELPERS\n// =============================================================================\n\nfunc updateTick(poolID uint64, tick int64, liquidityDelta int64, isLower bool) {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\tticks = make(map[int64]*TickInfo)\n\t\ttickData[poolID] = ticks\n\t}\n\n\tinfo := ticks[tick]\n\tif info == nil {\n\t\tinfo = \u0026TickInfo{}\n\t\tticks[tick] = info\n\t}\n\n\tinfo.LiquidityGross += liquidityDelta\n\n\tif isLower {\n\t\tinfo.LiquidityNet += liquidityDelta\n\t} else {\n\t\tinfo.LiquidityNet -= liquidityDelta\n\t}\n\n\tinfo.Initialized = info.LiquidityGross \u003e 0\n}\n\n// =============================================================================\n// QUERIES\n// =============================================================================\n\nfunc GetCLMMPool(poolID uint64) (string, string, int64, int64, int64, int64, int64) {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tp := pools[poolID]\n\treturn p.DenomA, p.DenomB, p.PriceX6, p.CurrentTick, p.Liquidity, p.FeeBPS, p.TickSpacing\n}\n\nfunc GetCLMMPoolCount() uint64 {\n\treturn uint64(len(pools))\n}\n\nfunc GetPosition(positionID uint64) (uint64, string, int64, int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\tp := positions[positionID]\n\treturn p.PoolID, p.Owner, p.TickLower, p.TickUpper, p.Liquidity\n}\n\nfunc GetPositionCount() uint64 {\n\treturn uint64(len(positions))\n}\n\nfunc GetPositionsByOwner(owner string) []uint64 {\n\tvar result []uint64\n\tfor _, p := range positions {\n\t\tif p.Owner == owner \u0026\u0026 p.Liquidity \u003e 0 {\n\t\t\tresult = append(result, p.ID)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc GetQuote(poolID uint64, tokenIn string, amountIn int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\treturn 0\n\t}\n\n\tpool := pools[poolID]\n\tif pool.Liquidity == 0 {\n\t\treturn 0\n\t}\n\n\t// Simulate the swap without modifying state\n\t// Copy pool state for simulation\n\tsimPriceX6 := pool.PriceX6\n\tsimLiquidity := pool.Liquidity\n\tsimCurrentTick := pool.CurrentTick\n\n\tvar zeroForOne bool\n\tif tokenIn == \"A\" {\n\t\tzeroForOne = true\n\t} else if tokenIn == \"B\" {\n\t\tzeroForOne = false\n\t} else {\n\t\treturn 0\n\t}\n\n\t// Calculate fee\n\tfeeAmount := safeMulDiv(amountIn, pool.FeeBPS, 10000)\n\tamountRemaining := amountIn - feeAmount\n\ttotalAmountOut := int64(0)\n\n\t// Simulate swap with tick crossing (same logic as Swap but read-only)\n\tmaxIterations := 100\n\tfor i := 0; i \u003c maxIterations \u0026\u0026 amountRemaining \u003e 0; i++ {\n\t\tif simLiquidity == 0 {\n\t\t\tbreak // No more liquidity\n\t\t}\n\n\t\t// Find next tick (read-only)\n\t\tnextTick := findNextInitializedTick(poolID, simCurrentTick, zeroForOne)\n\n\t\tvar amountInStep, amountOutStep int64\n\n\t\tif zeroForOne {\n\t\t\t// Swapping A for B (price decreases)\n\t\t\tnextTickPrice := getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MIN_TICK)\n\t\t\t}\n\n\t\t\tpriceDiff := simPriceX6 - nextTickPrice\n\t\t\tif priceDiff \u003c= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(simLiquidity, priceDiff, simPriceX6)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, simPriceX6, PRECISION)\n\t\t\t\tpriceChange := safeMulDiv(amountInStep, simPriceX6, simLiquidity)\n\t\t\t\tsimPriceX6 -= priceChange\n\t\t\t\tif simPriceX6 \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\t\tsimPriceX6 = getPriceAtTick(MIN_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, simPriceX6, PRECISION)\n\t\t\t\tsimPriceX6 = nextTickPrice\n\n\t\t\t\t// Simulate tick crossing - get liquidity delta\n\t\t\t\tticks := tickData[poolID]\n\t\t\t\tif ticks != nil {\n\t\t\t\t\tif tickInfo, ok := ticks[nextTick]; ok \u0026\u0026 tickInfo.Initialized {\n\t\t\t\t\t\tsimLiquidity -= tickInfo.LiquidityNet\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsimCurrentTick = nextTick\n\t\t\t}\n\t\t} else {\n\t\t\t// Swapping B for A (price increases)\n\t\t\tnextTickPrice := getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MAX_TICK)\n\t\t\t}\n\n\t\t\tpriceDiff := nextTickPrice - simPriceX6\n\t\t\tif priceDiff \u003c= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(simLiquidity, priceDiff, PRECISION)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, PRECISION, simPriceX6)\n\t\t\t\tpriceChange := safeMulDiv(amountInStep, PRECISION, simLiquidity)\n\t\t\t\tsimPriceX6 += priceChange\n\t\t\t\tif simPriceX6 \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\t\tsimPriceX6 = getPriceAtTick(MAX_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(amountInStep, PRECISION, simPriceX6)\n\t\t\t\tsimPriceX6 = nextTickPrice\n\n\t\t\t\t// Simulate tick crossing\n\t\t\t\tticks := tickData[poolID]\n\t\t\t\tif ticks != nil {\n\t\t\t\t\tif tickInfo, ok := ticks[nextTick]; ok \u0026\u0026 tickInfo.Initialized {\n\t\t\t\t\t\tsimLiquidity += tickInfo.LiquidityNet\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsimCurrentTick = nextTick\n\t\t\t}\n\t\t}\n\n\t\tamountRemaining -= amountInStep\n\t\ttotalAmountOut += amountOutStep\n\t}\n\n\treturn totalAmountOut\n}\n\nfunc GetPriceAtTick(tick int64) int64 {\n\treturn getPriceAtTick(tick)\n}\n\nfunc GetTickAtPrice(priceX6 int64) int64 {\n\treturn getTickAtPrice(priceX6)\n}\n\nfunc GetRealmAddress() string {\n\treturn string(runtime.CurrentRealm().Address())\n}\n\n// =============================================================================\n// RENDER\n// =============================================================================\n\nfunc Render(path string) string {\n\tvar sb strings.Builder\n\n\tsb.WriteString(\"# Gnomo CLMM\\n\\n\")\n\tsb.WriteString(\"**Address:** `\" + string(runtime.CurrentRealm().Address()) + \"`\\n\\n\")\n\n\tif len(pools) == 0 {\n\t\tsb.WriteString(\"No pools yet.\\n\")\n\t} else {\n\t\tsb.WriteString(\"## Pools\\n\\n\")\n\t\tfor _, p := range pools {\n\t\t\tsb.WriteString(\"### Pool \" + strconv.FormatUint(p.ID, 10) + \"\\n\")\n\t\t\tsb.WriteString(\"- Pair: \" + formatDenom(p.DenomA) + \"/\" + formatDenom(p.DenomB) + \"\\n\")\n\t\t\tsb.WriteString(\"- Fee: \" + strconv.FormatInt(p.FeeBPS, 10) + \" bps\\n\")\n\t\t\tsb.WriteString(\"- Tick: \" + strconv.FormatInt(p.CurrentTick, 10) + \"\\n\")\n\t\t\tsb.WriteString(\"- Liquidity: \" + strconv.FormatInt(p.Liquidity, 10) + \"\\n\")\n\t\t\tpriceFloat := float64(p.PriceX6) / float64(PRECISION)\n\t\t\tsb.WriteString(\"- Price: \" + strconv.FormatFloat(priceFloat, 'f', 6, 64) + \"\\n\\n\")\n\t\t}\n\t}\n\n\tsb.WriteString(\"## Stats\\n\")\n\tsb.WriteString(\"- Pools: \" + strconv.Itoa(len(pools)) + \"\\n\")\n\n\tactivePos := 0\n\tfor _, p := range positions {\n\t\tif p.Liquidity \u003e 0 {\n\t\t\tactivePos++\n\t\t}\n\t}\n\tsb.WriteString(\"- Positions: \" + strconv.Itoa(activePos) + \"\\n\")\n\n\treturn sb.String()\n}\n\nfunc formatDenom(denom string) string {\n\tif denom == \"ugnot\" {\n\t\treturn \"GNOT\"\n\t}\n\tif strings.Contains(denom, \":\") {\n\t\tparts := strings.Split(denom, \":\")\n\t\treturn strings.ToUpper(parts[len(parts)-1])\n\t}\n\treturn denom\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/gnomo/clmm3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"50000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"j6nNIIGLKnYtmpqJKLHSvCve8SoT3UVxPsj7teI/yxkv5SOcktpPvSkxxEBJOaGlDxXMGjoanjXA6aPB7Rt8Aw=="}],"memo":""},"metadata":{"timestamp":"1768364740"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"gnomo","path":"gno.land/r/gnomo/dex3","files":[{"name":"gnomo.gno","body":"package gnomo\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Pool represents a liquidity pool for two token denoms\ntype Pool struct {\n\tID       uint64\n\tDenomA   string\n\tDenomB   string\n\tReserveA int64\n\tReserveB int64\n\tTotalLP  int64\n\tFeeBPS   int64\n}\n\nvar (\n\tpools      []*Pool\n\tnextPoolID uint64\n\tlpBalances map[uint64]map[string]int64\n)\n\nfunc init() {\n\tlpBalances = make(map[uint64]map[string]int64)\n}\n\n// GetRealmTokenDenom returns the full denom for a realm-issued token\n// e.g., \"usdc\" -\u003e \"/gno.land/r/dev/gnomo:usdc\"\nfunc GetRealmTokenDenom(baseName string) string {\n\treturn runtime.CurrentRealm().CoinDenom(baseName)\n}\n\n// MintTestTokens mints test tokens to the caller (for testing only)\n// This allows testing the DEX without needing external tokens\nfunc MintTestTokens(_ realm, baseName string, amount int64) string {\n\tif amount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\tif baseName == \"\" {\n\t\tpanic(\"baseName required\")\n\t}\n\n\tcaller := runtime.OriginCaller()\n\tbnk := banker.NewBanker(banker.BankerTypeRealmIssue)\n\t\n\tdenom := runtime.CurrentRealm().CoinDenom(baseName)\n\tbnk.IssueCoin(caller, denom, amount)\n\t\n\treturn denom\n}\n\n// CreatePool creates a new liquidity pool\nfunc CreatePool(_ realm, denomA, denomB string, feeBPS int64) uint64 {\n\tif denomA == \"\" || denomB == \"\" {\n\t\tpanic(\"invalid denom\")\n\t}\n\tif denomA == denomB {\n\t\tpanic(\"denoms must be different\")\n\t}\n\tif denomA \u003e denomB {\n\t\tdenomA, denomB = denomB, denomA\n\t}\n\tfor _, p := range pools {\n\t\tif p.DenomA == denomA \u0026\u0026 p.DenomB == denomB \u0026\u0026 p.FeeBPS == feeBPS {\n\t\t\tpanic(\"pool already exists\")\n\t\t}\n\t}\n\tif feeBPS == 0 {\n\t\tfeeBPS = 30\n\t}\n\tif feeBPS \u003e 1000 {\n\t\tpanic(\"fee too high\")\n\t}\n\n\tpool := \u0026Pool{\n\t\tID:     nextPoolID,\n\t\tDenomA: denomA,\n\t\tDenomB: denomB,\n\t\tFeeBPS: feeBPS,\n\t}\n\tpools = append(pools, pool)\n\tlpBalances[nextPoolID] = make(map[string]int64)\n\tnextPoolID++\n\treturn pool.ID\n}\n\n// AddLiquidity adds liquidity to a pool\n// User must send both tokens with the transaction\n// minLPOut provides slippage protection - set to 0 to skip\nfunc AddLiquidity(_ realm, poolID uint64, minLPOut int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tp := pools[poolID]\n\tcaller := string(runtime.OriginCaller())\n\n\tsentCoins := banker.OriginSend()\n\tamountA := sentCoins.AmountOf(p.DenomA)\n\tamountB := sentCoins.AmountOf(p.DenomB)\n\n\tif amountA \u003c= 0 || amountB \u003c= 0 {\n\t\tpanic(\"must send both tokens: \" + p.DenomA + \" and \" + p.DenomB)\n\t}\n\n\tvar lpMinted int64\n\n\tif p.TotalLP == 0 {\n\t\t// Use safe multiplication for initial liquidity\n\t\tlpMinted = sqrt64(safeMul(amountA, amountB))\n\t\tif lpMinted == 0 {\n\t\t\tpanic(\"insufficient initial liquidity\")\n\t\t}\n\t} else {\n\t\t// Use safeMulDiv to prevent overflow\n\t\tlpFromA := safeMulDiv(amountA, p.TotalLP, p.ReserveA)\n\t\tlpFromB := safeMulDiv(amountB, p.TotalLP, p.ReserveB)\n\t\tlpMinted = min64(lpFromA, lpFromB)\n\t\tif lpMinted == 0 {\n\t\t\tpanic(\"insufficient liquidity minted\")\n\t\t}\n\t}\n\n\t// Slippage protection\n\tif minLPOut \u003e 0 \u0026\u0026 lpMinted \u003c minLPOut {\n\t\tpanic(\"slippage: LP minted \" + strconv.FormatInt(lpMinted, 10) + \" \u003c min \" + strconv.FormatInt(minLPOut, 10))\n\t}\n\n\tp.ReserveA += amountA\n\tp.ReserveB += amountB\n\tp.TotalLP += lpMinted\n\tlpBalances[poolID][caller] += lpMinted\n\n\treturn lpMinted\n}\n\n// RemoveLiquidity burns LP tokens and returns proportional reserves\n// minAmountA/minAmountB provide slippage protection - set to 0 to skip\nfunc RemoveLiquidity(_ realm, poolID uint64, lpAmount int64, minAmountA int64, minAmountB int64) {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tif lpAmount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\n\tp := pools[poolID]\n\tcaller := string(runtime.OriginCaller())\n\tcallerLP := lpBalances[poolID][caller]\n\n\tif callerLP \u003c lpAmount {\n\t\tpanic(\"insufficient LP balance\")\n\t}\n\n\t// Use safeMulDiv to prevent overflow\n\tamountA := safeMulDiv(lpAmount, p.ReserveA, p.TotalLP)\n\tamountB := safeMulDiv(lpAmount, p.ReserveB, p.TotalLP)\n\n\tif amountA \u003c= 0 || amountB \u003c= 0 {\n\t\tpanic(\"insufficient output amounts\")\n\t}\n\n\t// Slippage protection\n\tif minAmountA \u003e 0 \u0026\u0026 amountA \u003c minAmountA {\n\t\tpanic(\"slippage: amountA \" + strconv.FormatInt(amountA, 10) + \" \u003c min \" + strconv.FormatInt(minAmountA, 10))\n\t}\n\tif minAmountB \u003e 0 \u0026\u0026 amountB \u003c minAmountB {\n\t\tpanic(\"slippage: amountB \" + strconv.FormatInt(amountB, 10) + \" \u003c min \" + strconv.FormatInt(minAmountB, 10))\n\t}\n\n\tp.ReserveA -= amountA\n\tp.ReserveB -= amountB\n\tp.TotalLP -= lpAmount\n\tlpBalances[poolID][caller] -= lpAmount\n\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\tcallerAddr := runtime.OriginCaller()\n\n\tcoins := chain.NewCoins(\n\t\tchain.NewCoin(p.DenomA, amountA),\n\t\tchain.NewCoin(p.DenomB, amountB),\n\t)\n\tbnk.SendCoins(realmAddr, callerAddr, coins)\n}\n\n// Swap swaps exact input amount for output\nfunc Swap(_ realm, poolID uint64, tokenIn string, minAmountOut int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tif tokenIn != \"A\" \u0026\u0026 tokenIn != \"B\" {\n\t\tpanic(\"tokenIn must be A or B\")\n\t}\n\n\tp := pools[poolID]\n\tif p.ReserveA == 0 || p.ReserveB == 0 {\n\t\tpanic(\"pool has no liquidity\")\n\t}\n\n\tcaller := runtime.OriginCaller()\n\tsentCoins := banker.OriginSend()\n\n\tvar amountIn int64\n\tvar denomOut string\n\n\tif tokenIn == \"A\" {\n\t\tdenomOut = p.DenomB\n\t\tamountIn = sentCoins.AmountOf(p.DenomA)\n\t} else {\n\t\tdenomOut = p.DenomA\n\t\tamountIn = sentCoins.AmountOf(p.DenomB)\n\t}\n\n\tif amountIn \u003c= 0 {\n\t\tpanic(\"must send input token\")\n\t}\n\n\tvar amountOut int64\n\tamountInWithFee := safeMulDiv(amountIn, 10000-p.FeeBPS, 10000)\n\n\tif tokenIn == \"A\" {\n\t\t// amountOut = (amountInWithFee * reserveB) / (reserveA + amountInWithFee)\n\t\tamountOut = safeMulDiv(amountInWithFee, p.ReserveB, p.ReserveA+amountInWithFee)\n\t\tp.ReserveA += amountIn\n\t\tp.ReserveB -= amountOut\n\t} else {\n\t\tamountOut = safeMulDiv(amountInWithFee, p.ReserveA, p.ReserveB+amountInWithFee)\n\t\tp.ReserveB += amountIn\n\t\tp.ReserveA -= amountOut\n\t}\n\n\tif amountOut \u003c= 0 {\n\t\tpanic(\"insufficient output amount\")\n\t}\n\tif amountOut \u003c minAmountOut {\n\t\tpanic(\"slippage: output \" + strconv.FormatInt(amountOut, 10) + \" \u003c min \" + strconv.FormatInt(minAmountOut, 10))\n\t}\n\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\toutCoins := chain.NewCoins(chain.NewCoin(denomOut, amountOut))\n\tbnk.SendCoins(realmAddr, caller, outCoins)\n\n\treturn amountOut\n}\n\n// GetQuote returns expected output without executing swap\nfunc GetQuote(poolID uint64, tokenIn string, amountIn int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tp := pools[poolID]\n\tif p.ReserveA == 0 || p.ReserveB == 0 {\n\t\treturn 0\n\t}\n\n\tamountInWithFee := safeMulDiv(amountIn, 10000-p.FeeBPS, 10000)\n\n\tif tokenIn == \"A\" {\n\t\treturn safeMulDiv(amountInWithFee, p.ReserveB, p.ReserveA+amountInWithFee)\n\t}\n\treturn safeMulDiv(amountInWithFee, p.ReserveA, p.ReserveB+amountInWithFee)\n}\n\n// GetPool returns pool info\nfunc GetPool(poolID uint64) (string, string, int64, int64, int64, int64) {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tp := pools[poolID]\n\treturn p.DenomA, p.DenomB, p.ReserveA, p.ReserveB, p.TotalLP, p.FeeBPS\n}\n\nfunc GetPoolCount() uint64 {\n\treturn uint64(len(pools))\n}\n\nfunc GetLPBalance(poolID uint64, addr string) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\treturn 0\n\t}\n\treturn lpBalances[poolID][addr]\n}\n\nfunc GetRealmAddress() string {\n\treturn string(runtime.CurrentRealm().Address())\n}\n\n// Helper functions\nfunc sqrt64(x int64) int64 {\n\tif x \u003c= 0 {\n\t\treturn 0\n\t}\n\tz := x\n\ty := (z + 1) / 2\n\tfor y \u003c z {\n\t\tz = y\n\t\ty = (z + x/z) / 2\n\t}\n\treturn z\n}\n\nfunc min64(a, b int64) int64 {\n\tif a \u003c b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// Safe math to prevent overflow\nconst MAX_INT64 = int64(9223372036854775807)\n\nfunc safeMul(a, b int64) int64 {\n\tif a == 0 || b == 0 {\n\t\treturn 0\n\t}\n\tresult := a * b\n\t// Check for overflow: if result/a != b, overflow occurred\n\tif result/a != b {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn result\n}\n\nfunc safeMulDiv(a, b, c int64) int64 {\n\tif c == 0 {\n\t\tpanic(\"division by zero\")\n\t}\n\t// For large numbers, divide first to avoid overflow\n\t// Use: (a * b) / c = (a / c) * b + (a % c) * b / c\n\tif a \u003e MAX_INT64/b \u0026\u0026 b != 0 {\n\t\tquotient := a / c\n\t\tremainder := a % c\n\t\treturn quotient*b + (remainder*b)/c\n\t}\n\treturn (a * b) / c\n}\n\n// Render displays pool information\nfunc Render(path string) string {\n\tvar sb strings.Builder\n\tsb.WriteString(\"# Gnomo DEX\\n\\n\")\n\tsb.WriteString(\"**Contract Address:** `\" + string(runtime.CurrentRealm().Address()) + \"`\\n\\n\")\n\n\t// Show test token denom\n\ttestDenom := runtime.CurrentRealm().CoinDenom(\"usdc\")\n\tsb.WriteString(\"**Test Token (usdc):** `\" + testDenom + \"`\\n\\n\")\n\n\tif len(pools) == 0 {\n\t\tsb.WriteString(\"No pools created yet.\\n\\n\")\n\t} else {\n\t\tsb.WriteString(\"## Pools\\n\\n\")\n\t\tfor _, p := range pools {\n\t\t\tsb.WriteString(\"### Pool \" + strconv.FormatUint(p.ID, 10) + \": \" + p.DenomA + \" / \" + p.DenomB + \"\\n\\n\")\n\t\t\tsb.WriteString(\"| Metric | Value |\\n\")\n\t\t\tsb.WriteString(\"|--------|-------|\\n\")\n\t\t\tsb.WriteString(\"| Reserve A | \" + strconv.FormatInt(p.ReserveA, 10) + \" |\\n\")\n\t\t\tsb.WriteString(\"| Reserve B | \" + strconv.FormatInt(p.ReserveB, 10) + \" |\\n\")\n\t\t\tsb.WriteString(\"| Total LP | \" + strconv.FormatInt(p.TotalLP, 10) + \" |\\n\")\n\t\t\tsb.WriteString(\"| Fee | \" + strconv.FormatInt(p.FeeBPS, 10) + \" bps |\\n\")\n\n\t\t\tif p.ReserveA \u003e 0 \u0026\u0026 p.ReserveB \u003e 0 {\n\t\t\t\tpriceAtoB := (p.ReserveB * 1000000) / p.ReserveA\n\t\t\t\tpriceBtoA := (p.ReserveA * 1000000) / p.ReserveB\n\t\t\t\tsb.WriteString(\"| Price A→B | \" + formatPrice(priceAtoB) + \" |\\n\")\n\t\t\t\tsb.WriteString(\"| Price B→A | \" + formatPrice(priceBtoA) + \" |\\n\")\n\t\t\t}\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\tsb.WriteString(\"## Quick Start\\n\\n\")\n\tsb.WriteString(\"### 1. Get Test Tokens\\n\")\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"gnokey maketx call -func MintTestTokens -args \\\"usdc\\\" -args \\\"10000000\\\" ...\\n\")\n\tsb.WriteString(\"```\\n\\n\")\n\tsb.WriteString(\"### 2. Create Pool (ugnot + test usdc)\\n\")\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"gnokey maketx call -func CreatePool -args \\\"ugnot\\\" -args \\\"\" + testDenom + \"\\\" -args \\\"30\\\" ...\\n\")\n\tsb.WriteString(\"```\\n\\n\")\n\tsb.WriteString(\"### 3. Add Liquidity\\n\")\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"gnokey maketx call -send \\\"1000000ugnot,2000000\" + testDenom + \"\\\" -func AddLiquidity -args \\\"0\\\" ...\\n\")\n\tsb.WriteString(\"```\\n\\n\")\n\tsb.WriteString(\"### 4. Swap\\n\")\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"gnokey maketx call -send \\\"100000ugnot\\\" -func Swap -args \\\"0\\\" -args \\\"A\\\" -args \\\"0\\\" ...\\n\")\n\tsb.WriteString(\"```\\n\\n\")\n\n\treturn sb.String()\n}\n\nfunc formatPrice(microPrice int64) string {\n\twhole := microPrice / 1000000\n\tfrac := microPrice % 1000000\n\tif frac == 0 {\n\t\treturn strconv.FormatInt(whole, 10)\n\t}\n\tfracStr := strconv.FormatInt(frac, 10)\n\tfor len(fracStr) \u003c 6 {\n\t\tfracStr = \"0\" + fracStr\n\t}\n\tfracStr = strings.TrimRight(fracStr, \"0\")\n\treturn strconv.FormatInt(whole, 10) + \".\" + fracStr\n}"},{"name":"gnomod.toml","body":"module = \"gno.land/r/gnomo/dex3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"50000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"EdcM/0n+RstXNhP/o1+Fi20HxpU+gaTxFUpQba2z8dKJ6zb8U+SoGXV+pxhJNe94GjkuI+a+0hQGQt6pmHA6Dg=="}],"memo":""},"metadata":{"timestamp":"1768365765"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"MintTestTokens","args":["usdc","10000000000"]}],"fee":{"gas_wanted":"2746668","gas_fee":"2747ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"vDBuK8kwTTANTPCP0ZZszUy55QvN4ZEJdWRPKhL4OeSj+NaBZytyxvha9FCrM9gjyChf0wBUsST7L/OS0GMRAQ=="}],"memo":""},"metadata":{"timestamp":"1768366062"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"CreatePool","args":["ugnot","/gno.land/r/gnomo/dex3:usdc","5"]}],"fee":{"gas_wanted":"636158","gas_fee":"637ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"yBkMXMcj7yfoKK+82cMcJw06fH7oJcVncsBNAbAqmK1RjcOmIe98IqVsFV1Gqe5HAkEsESxigk05KrBmWu+tCQ=="}],"memo":""},"metadata":{"timestamp":"1768366092"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"250000000/gno.land/r/gnomo/dex3:usdc,250000000ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"AddLiquidity","args":["0","0"]}],"fee":{"gas_wanted":"1440489","gas_fee":"1441ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"J8zQJ4Q3Gj9xZgz67P0S6C6/gFxtx5hQLPKu6OJQkjdA95fu2ImGYj2Rh7ih3cNi6ygZZvpbvspMdqmxB/RPBg=="}],"memo":""},"metadata":{"timestamp":"1768366112"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"CreateCLMMPool","args":["ugnot","/gno.land/r/gnomo/dex3:usdc","5","1000000"]}],"fee":{"gas_wanted":"2177230","gas_fee":"2178ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"zKc74eDUoxzMdD8s5BL4VGezxo4XtQP4xHR9OqkpdUyf7FI1CLtJjzlRQ27Cd1jtdR8hcKCv5ZkAc1hf0uhvCw=="}],"memo":""},"metadata":{"timestamp":"1768366147"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"1000000000/gno.land/r/gnomo/dex3:usdc,1000055099ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"MintPosition","args":["0","-10","10"]}],"fee":{"gas_wanted":"1774660","gas_fee":"1775ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"xxmPwn3P1/HZJ4mKMOale02ZCA2xM3ouxDU8KGn4702DlAQSzeSUV5+tvoHjc9iV6CZw+qQzb57Spjaf4EHJAg=="}],"memo":""},"metadata":{"timestamp":"1768366188"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"1000000000ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"Swap","args":["0","B","994502500"]}],"fee":{"gas_wanted":"5634677","gas_fee":"5635ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"2rvhj/RkmtAR2u+DvsS/vwLVYWbODgEk3CzcSTkU6zKns8B9n45ByCypP2e9uWfC9AuP48tHn+iS1yc/dRsbAQ=="}],"memo":""},"metadata":{"timestamp":"1768366308"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"250000000/gno.land/r/gnomo/dex3:usdc","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"Swap","args":["0","A","272161272"]}],"fee":{"gas_wanted":"5644017","gas_fee":"5645ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"x9DnZhIst5zfxHCO9L4DYMMEgoQhr1yVQgDVV556LlVM5rcujZuRy0bmhFOtH5f9U8A7fDnESY9481msB34dBw=="}],"memo":""},"metadata":{"timestamp":"1768367032"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"clmm","path":"gno.land/r/gnomo/clmm4","files":[{"name":"clmm.gno","body":"package clmm\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst (\n\tMIN_TICK  = -1000\n\tMAX_TICK  = 1000\n\tPRECISION = 1000000\n\tMAX_INT64 = int64(9223372036854775807)\n)\n\n// =============================================================================\n// SAFE MATH\n// =============================================================================\n\nfunc safeMul(a, b int64) int64 {\n\tif a == 0 || b == 0 {\n\t\treturn 0\n\t}\n\tresult := a * b\n\tif result/a != b {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn result\n}\n\nfunc safeMulDiv(a, b, c int64) int64 {\n\tif c == 0 {\n\t\tpanic(\"division by zero\")\n\t}\n\tif a \u003e MAX_INT64/b \u0026\u0026 b != 0 {\n\t\tquotient := a / c\n\t\tremainder := a % c\n\t\treturn quotient*b + (remainder*b)/c\n\t}\n\treturn (a * b) / c\n}\n\n// Integer square root using Newton's method\nfunc isqrt(n int64) int64 {\n\tif n \u003c 0 {\n\t\tpanic(\"sqrt of negative\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n \u003c 2 {\n\t\treturn n\n\t}\n\n\t// Initial guess\n\tx := n\n\ty := (x + 1) / 2\n\n\tfor y \u003c x {\n\t\tx = y\n\t\ty = (x + n/x) / 2\n\t}\n\n\treturn x\n}\n\n// =============================================================================\n// DATA STRUCTURES\n// =============================================================================\n\ntype CLMMPool struct {\n\tID          uint64\n\tDenomA      string\n\tDenomB      string\n\tFeeBPS      int64\n\tTickSpacing int64\n\tPriceX6     int64\n\tCurrentTick int64\n\tLiquidity   int64\n\tFeeGrowthA  int64\n\tFeeGrowthB  int64\n}\n\ntype Position struct {\n\tID            uint64\n\tPoolID        uint64\n\tOwner         string\n\tTickLower     int64\n\tTickUpper     int64\n\tLiquidity     int64\n\tFeeGrowthLastA int64\n\tFeeGrowthLastB int64\n\tTokensOwedA   int64\n\tTokensOwedB   int64\n}\n\ntype TickInfo struct {\n\tLiquidityGross int64\n\tLiquidityNet   int64\n\tInitialized    bool\n}\n\nvar (\n\tpools          []*CLMMPool\n\tnextPoolID     uint64\n\tpositions      []*Position\n\tnextPositionID uint64\n\ttickData       map[uint64]map[int64]*TickInfo\n)\n\nfunc init() {\n\ttickData = make(map[uint64]map[int64]*TickInfo)\n}\n\n// =============================================================================\n// TICK MATH\n// =============================================================================\n\nfunc getPriceAtTick(tick int64) int64 {\n\tif tick \u003c MIN_TICK || tick \u003e MAX_TICK {\n\t\tpanic(\"tick out of range\")\n\t}\n\n\tif tick == 0 {\n\t\treturn PRECISION\n\t}\n\n\tabsTick := tick\n\tif absTick \u003c 0 {\n\t\tabsTick = -absTick\n\t}\n\n\t// Use 1.01 per tick (1% price change per tick)\n\t// Calculate 1.01^absTick using simple iteration\n\tresult := int64(PRECISION) // 1.0 in X6\n\n\tfor i := int64(0); i \u003c absTick; i++ {\n\t\t// result = result * 1.01 = result * 101 / 100\n\t\t// Check for overflow before multiplication\n\t\tif result \u003e MAX_INT64/101 {\n\t\t\tpanic(\"price calculation overflow\")\n\t\t}\n\t\tresult = (result * 101) / 100\n\t}\n\n\tif tick \u003c 0 {\n\t\t// Invert: 1 / price = PRECISION^2 / result\n\t\tif result \u003e 0 {\n\t\t\treturn safeMulDiv(PRECISION, PRECISION, result)\n\t\t}\n\t\treturn PRECISION\n\t}\n\n\treturn result\n}\n\nfunc getTickAtPrice(priceX6 int64) int64 {\n\tif priceX6 \u003c= 0 {\n\t\tpanic(\"invalid price\")\n\t}\n\n\tlow := int64(MIN_TICK)\n\thigh := int64(MAX_TICK)\n\n\tfor low \u003c high {\n\t\tmid := (low + high + 1) / 2\n\t\tpriceAtMid := getPriceAtTick(mid)\n\n\t\tif priceAtMid \u003c= priceX6 {\n\t\t\tlow = mid\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\n\treturn low\n}\n\n// =============================================================================\n// LIQUIDITY MATH (using sqrt-based Uniswap v3 formulas)\n// =============================================================================\n\n// getAmountsForLiquidity calculates token amounts for a given liquidity\n// Uses proper sqrt-based CLMM math:\n// - amt0 = L * (1/sqrt(pC) - 1/sqrt(pU)) = L * (sqrt(pU) - sqrt(pC)) / (sqrt(pC) * sqrt(pU))\n// - amt1 = L * (sqrt(pC) - sqrt(pL))\nfunc getAmountsForLiquidity(pL, pU, pC, liq int64) (int64, int64) {\n\tif liq \u003c= 0 {\n\t\treturn 0, 0\n\t}\n\n\tsqrtPrecision := int64(1000) // sqrt(PRECISION)\n\tsqrtPL := isqrt(pL * PRECISION)\n\tsqrtPU := isqrt(pU * PRECISION)\n\tsqrtPC := isqrt(pC * PRECISION)\n\n\tif pC \u003c= pL {\n\t\t// Price below range: all token0\n\t\t// amt0 = L * (sqrt(pU) - sqrt(pL)) / (sqrt(pL) * sqrt(pU) / sqrtPrecision)\n\t\tif sqrtPL == 0 || sqrtPU == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tdenom := safeMulDiv(sqrtPL, sqrtPU, sqrtPrecision*PRECISION)\n\t\tif denom == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tamt0 := safeMulDiv(liq, sqrtPU-sqrtPL, denom)\n\t\treturn amt0, 0\n\t} else if pC \u003e= pU {\n\t\t// Price above range: all token1\n\t\t// amt1 = L * (sqrt(pU) - sqrt(pL)) / sqrtPrecision\n\t\tamt1 := safeMulDiv(liq, sqrtPU-sqrtPL, sqrtPrecision*PRECISION)\n\t\treturn 0, amt1\n\t} else {\n\t\t// Price in range: mix of both tokens\n\t\t// amt0 = L * (sqrt(pU) - sqrt(pC)) / (sqrt(pC) * sqrt(pU) / sqrtPrecision)\n\t\t// amt1 = L * (sqrt(pC) - sqrt(pL)) / sqrtPrecision\n\t\tdenom0 := safeMulDiv(sqrtPC, sqrtPU, sqrtPrecision*PRECISION)\n\t\tif denom0 == 0 {\n\t\t\treturn 0, 0\n\t\t}\n\t\tamt0 := safeMulDiv(liq, sqrtPU-sqrtPC, denom0)\n\t\tamt1 := safeMulDiv(liq, sqrtPC-sqrtPL, sqrtPrecision*PRECISION)\n\t\treturn amt0, amt1\n\t}\n}\n\n// getLiquidityForAmounts calculates liquidity from token amounts\n// Uses proper sqrt-based CLMM math (inverse of getAmountsForLiquidity)\nfunc getLiquidityForAmounts(pL, pU, pC, amt0, amt1 int64) int64 {\n\tsqrtPrecision := int64(1000)\n\tsqrtPL := isqrt(pL * PRECISION)\n\tsqrtPU := isqrt(pU * PRECISION)\n\tsqrtPC := isqrt(pC * PRECISION)\n\n\tif pC \u003c= pL {\n\t\t// Price below range: use amt0 only\n\t\t// L = amt0 * sqrt(pL) * sqrt(pU) / (sqrt(pU) - sqrt(pL))\n\t\tif amt0 \u003c= 0 || sqrtPU \u003c= sqrtPL {\n\t\t\treturn 0\n\t\t}\n\t\tnumerator := safeMulDiv(sqrtPL, sqrtPU, sqrtPrecision*PRECISION)\n\t\treturn safeMulDiv(amt0, numerator, sqrtPU-sqrtPL)\n\t} else if pC \u003e= pU {\n\t\t// Price above range: use amt1 only\n\t\t// L = amt1 * sqrtPrecision / (sqrt(pU) - sqrt(pL))\n\t\tif amt1 \u003c= 0 || sqrtPU \u003c= sqrtPL {\n\t\t\treturn 0\n\t\t}\n\t\treturn safeMulDiv(amt1, sqrtPrecision*PRECISION, sqrtPU-sqrtPL)\n\t} else {\n\t\t// Price in range: use min of liquidity from both tokens\n\t\t// L0 = amt0 * sqrt(pC) * sqrt(pU) / (sqrt(pU) - sqrt(pC))\n\t\t// L1 = amt1 * sqrtPrecision / (sqrt(pC) - sqrt(pL))\n\t\tvar liq0, liq1 int64\n\n\t\tif amt0 \u003e 0 \u0026\u0026 sqrtPU \u003e sqrtPC {\n\t\t\tnumerator0 := safeMulDiv(sqrtPC, sqrtPU, sqrtPrecision*PRECISION)\n\t\t\tliq0 = safeMulDiv(amt0, numerator0, sqrtPU-sqrtPC)\n\t\t}\n\n\t\tif amt1 \u003e 0 \u0026\u0026 sqrtPC \u003e sqrtPL {\n\t\t\tliq1 = safeMulDiv(amt1, sqrtPrecision*PRECISION, sqrtPC-sqrtPL)\n\t\t}\n\n\t\t// Return minimum (or whichever is non-zero)\n\t\tif liq0 == 0 {\n\t\t\treturn liq1\n\t\t}\n\t\tif liq1 == 0 {\n\t\t\treturn liq0\n\t\t}\n\t\tif liq0 \u003c liq1 {\n\t\t\treturn liq0\n\t\t}\n\t\treturn liq1\n\t}\n}\n\n// =============================================================================\n// POOL MANAGEMENT\n// =============================================================================\n\nfunc CreateCLMMPool(_ realm, denomA, denomB string, feeBPS int64, initialPriceX6 int64) uint64 {\n\tif denomA == \"\" || denomB == \"\" {\n\t\tpanic(\"invalid denom\")\n\t}\n\tif denomA == denomB {\n\t\tpanic(\"denoms must be different\")\n\t}\n\tif denomA \u003e denomB {\n\t\tdenomA, denomB = denomB, denomA\n\t\tif initialPriceX6 \u003e 0 {\n\t\t\tinitialPriceX6 = (PRECISION * PRECISION) / initialPriceX6\n\t\t}\n\t}\n\n\tfor _, p := range pools {\n\t\tif p.DenomA == denomA \u0026\u0026 p.DenomB == denomB \u0026\u0026 p.FeeBPS == feeBPS {\n\t\t\tpanic(\"pool already exists\")\n\t\t}\n\t}\n\n\tif feeBPS \u003c= 0 || feeBPS \u003e 10000 {\n\t\tpanic(\"fee must be 1-10000 bps\")\n\t}\n\n\tvar tickSpacing int64 = 1\n\tif feeBPS \u003e= 100 {\n\t\ttickSpacing = 10\n\t} else if feeBPS \u003e= 30 {\n\t\ttickSpacing = 5\n\t}\n\n\tif initialPriceX6 \u003c= 0 {\n\t\tinitialPriceX6 = PRECISION\n\t}\n\n\tpool := \u0026CLMMPool{\n\t\tID:          nextPoolID,\n\t\tDenomA:      denomA,\n\t\tDenomB:      denomB,\n\t\tFeeBPS:      feeBPS,\n\t\tTickSpacing: tickSpacing,\n\t\tPriceX6:     initialPriceX6,\n\t\tCurrentTick: getTickAtPrice(initialPriceX6),\n\t\tLiquidity:   0,\n\t}\n\n\tpools = append(pools, pool)\n\ttickData[nextPoolID] = make(map[int64]*TickInfo)\n\tnextPoolID++\n\n\treturn pool.ID\n}\n\n// =============================================================================\n// POSITION MANAGEMENT\n// =============================================================================\n\nfunc MintPosition(_ realm, poolID uint64, tickLower, tickUpper int64) uint64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tpool := pools[poolID]\n\n\tif tickLower \u003e= tickUpper {\n\t\tpanic(\"tickLower must be \u003c tickUpper\")\n\t}\n\tif tickLower \u003c MIN_TICK || tickUpper \u003e MAX_TICK {\n\t\tpanic(\"ticks out of range\")\n\t}\n\tif tickLower%pool.TickSpacing != 0 || tickUpper%pool.TickSpacing != 0 {\n\t\tpanic(\"ticks must align with spacing\")\n\t}\n\n\tcaller := string(runtime.OriginCaller())\n\tsentCoins := banker.OriginSend()\n\n\tamountA := sentCoins.AmountOf(pool.DenomA)\n\tamountB := sentCoins.AmountOf(pool.DenomB)\n\n\tif amountA \u003c= 0 \u0026\u0026 amountB \u003c= 0 {\n\t\tpanic(\"must send tokens\")\n\t}\n\n\tpL := getPriceAtTick(tickLower)\n\tpU := getPriceAtTick(tickUpper)\n\n\tliquidity := getLiquidityForAmounts(pL, pU, pool.PriceX6, amountA, amountB)\n\tif liquidity \u003c= 0 {\n\t\tpanic(\"insufficient liquidity\")\n\t}\n\n\t// Update ticks\n\tupdateTick(poolID, tickLower, liquidity, true)\n\tupdateTick(poolID, tickUpper, liquidity, false)\n\n\t// Update pool liquidity if in range\n\tif pool.PriceX6 \u003e= pL \u0026\u0026 pool.PriceX6 \u003c pU {\n\t\tpool.Liquidity += liquidity\n\t}\n\n\tposition := \u0026Position{\n\t\tID:            nextPositionID,\n\t\tPoolID:        poolID,\n\t\tOwner:         caller,\n\t\tTickLower:     tickLower,\n\t\tTickUpper:     tickUpper,\n\t\tLiquidity:     liquidity,\n\t\tFeeGrowthLastA: pool.FeeGrowthA,\n\t\tFeeGrowthLastB: pool.FeeGrowthB,\n\t}\n\n\tpositions = append(positions, position)\n\tnextPositionID++\n\n\treturn position.ID\n}\n\nfunc BurnPosition(_ realm, positionID uint64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\n\tpos := positions[positionID]\n\tcaller := string(runtime.OriginCaller())\n\n\tif pos.Owner != caller {\n\t\tpanic(\"not owner\")\n\t}\n\tif pos.Liquidity == 0 {\n\t\tpanic(\"already burned\")\n\t}\n\n\tpool := pools[pos.PoolID]\n\tpL := getPriceAtTick(pos.TickLower)\n\tpU := getPriceAtTick(pos.TickUpper)\n\n\tamount0, amount1 := getAmountsForLiquidity(pL, pU, pool.PriceX6, pos.Liquidity)\n\n\t// Update ticks\n\tupdateTick(pos.PoolID, pos.TickLower, -pos.Liquidity, true)\n\tupdateTick(pos.PoolID, pos.TickUpper, -pos.Liquidity, false)\n\n\t// Update pool liquidity\n\tif pool.PriceX6 \u003e= pL \u0026\u0026 pool.PriceX6 \u003c pU {\n\t\tpool.Liquidity -= pos.Liquidity\n\t}\n\n\tpos.Liquidity = 0\n\n\t// Send tokens back\n\tif amount0 \u003e 0 || amount1 \u003e 0 {\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\trealmAddr := runtime.CurrentRealm().Address()\n\t\tcallerAddr := runtime.OriginCaller()\n\n\t\tif amount0 \u003e 0 \u0026\u0026 amount1 \u003e 0 {\n\t\t\tcoins := chain.NewCoins(\n\t\t\t\tchain.NewCoin(pool.DenomA, amount0),\n\t\t\t\tchain.NewCoin(pool.DenomB, amount1),\n\t\t\t)\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, coins)\n\t\t} else if amount0 \u003e 0 {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomA, amount0)))\n\t\t} else {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomB, amount1)))\n\t\t}\n\t}\n}\n\n// =============================================================================\n// SWAP\n// =============================================================================\n\nfunc Swap(_ realm, poolID uint64, tokenIn string, minAmountOut int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\n\tpool := pools[poolID]\n\tif pool.Liquidity == 0 {\n\t\tpanic(\"no liquidity\")\n\t}\n\n\tcaller := runtime.OriginCaller()\n\tsentCoins := banker.OriginSend()\n\n\tvar zeroForOne bool\n\tvar amountIn int64\n\n\tif tokenIn == \"A\" {\n\t\tzeroForOne = true\n\t\tamountIn = sentCoins.AmountOf(pool.DenomA)\n\t} else if tokenIn == \"B\" {\n\t\tzeroForOne = false\n\t\tamountIn = sentCoins.AmountOf(pool.DenomB)\n\t} else {\n\t\tpanic(\"tokenIn must be A or B\")\n\t}\n\n\tif amountIn \u003c= 0 {\n\t\tpanic(\"must send input token\")\n\t}\n\n\t// Calculate fee using safe math\n\tfeeAmount := safeMulDiv(amountIn, pool.FeeBPS, 10000)\n\tamountRemaining := amountIn - feeAmount\n\ttotalAmountOut := int64(0)\n\n\t// Process swap with tick crossing\n\tmaxIterations := 100 // Safety limit to prevent infinite loops\n\tfor i := 0; i \u003c maxIterations \u0026\u0026 amountRemaining \u003e 0; i++ {\n\t\tif pool.Liquidity == 0 {\n\t\t\tbreak // No more liquidity\n\t\t}\n\n\t\t// Find next initialized tick in the direction of swap\n\t\tnextTick := findNextInitializedTick(poolID, pool.CurrentTick, zeroForOne)\n\n\t\t// Calculate how much we can swap before hitting the next tick\n\t\tvar amountInStep, amountOutStep int64\n\t\tvar nextTickPrice int64\n\n\t\tif zeroForOne {\n\t\t\t// Swapping A for B (price decreases)\n\t\t\t// Using sqrt-based CLMM math for accurate output calculation\n\t\t\tnextTickPrice = getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MIN_TICK)\n\t\t\t}\n\n\t\t\t// Calculate using sqrt price (proper CLMM math)\n\t\t\tsqrtPriceCurrent := isqrt(pool.PriceX6 * PRECISION)\n\t\t\tsqrtPriceNext := isqrt(nextTickPrice * PRECISION)\n\n\t\t\tif sqrtPriceCurrent \u003c= sqrtPriceNext {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Max amount in to reach next tick: dx = L * (1/sqrt(P_next) - 1/sqrt(P_current))\n\t\t\t// Simplified: dx = L * (sqrt(P_current) - sqrt(P_next)) / (sqrt(P_current) * sqrt(P_next) / SQRT_PRECISION)\n\t\t\tsqrtPrecision := int64(1000) // sqrt(PRECISION)\n\t\t\tmaxAmountIn := safeMulDiv(pool.Liquidity, sqrtPriceCurrent-sqrtPriceNext, safeMulDiv(sqrtPriceCurrent, sqrtPriceNext, sqrtPrecision*PRECISION))\n\n\t\t\tif amountRemaining \u003c= maxAmountIn || maxAmountIn \u003c= 0 {\n\t\t\t\t// Swap completes within this tick range\n\t\t\t\tamountInStep = amountRemaining\n\n\t\t\t\t// Calculate new sqrt price: 1/sqrt(P_new) = 1/sqrt(P_old) + dx/L\n\t\t\t\t// sqrt(P_new) = sqrt(P_old) * L / (L + dx * sqrt(P_old) / sqrtPrecision)\n\t\t\t\tdenom := pool.Liquidity + safeMulDiv(amountInStep, sqrtPriceCurrent, sqrtPrecision*PRECISION)\n\t\t\t\tif denom \u003c= 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsqrtPriceNew := safeMulDiv(sqrtPriceCurrent, pool.Liquidity, denom)\n\n\t\t\t\t// Output: dy = L * (sqrt(P_old) - sqrt(P_new)) / sqrtPrecision\n\t\t\t\tamountOutStep = safeMulDiv(pool.Liquidity, sqrtPriceCurrent-sqrtPriceNew, sqrtPrecision*PRECISION)\n\n\t\t\t\t// Update price\n\t\t\t\tpool.PriceX6 = safeMulDiv(sqrtPriceNew, sqrtPriceNew, PRECISION)\n\t\t\t\tif pool.PriceX6 \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\t\tpool.PriceX6 = getPriceAtTick(MIN_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Swap crosses this tick\n\t\t\t\tamountInStep = maxAmountIn\n\n\t\t\t\t// Output for crossing to next tick\n\t\t\t\tamountOutStep = safeMulDiv(pool.Liquidity, sqrtPriceCurrent-sqrtPriceNext, sqrtPrecision*PRECISION)\n\t\t\t\tpool.PriceX6 = nextTickPrice\n\n\t\t\t\t// Cross the tick - update liquidity\n\t\t\t\tcrossTick(poolID, nextTick, zeroForOne)\n\t\t\t}\n\t\t} else {\n\t\t\t// Swapping B for A (price increases)\n\t\t\tnextTickPrice = getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MAX_TICK)\n\t\t\t}\n\n\t\t\tsqrtPriceCurrent := isqrt(pool.PriceX6 * PRECISION)\n\t\t\tsqrtPriceNext := isqrt(nextTickPrice * PRECISION)\n\n\t\t\tif sqrtPriceNext \u003c= sqrtPriceCurrent {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tsqrtPrecision := int64(1000)\n\t\t\t// Max amount in to reach next tick: dy = L * (sqrt(P_next) - sqrt(P_current)) / sqrtPrecision\n\t\t\tmaxAmountIn := safeMulDiv(pool.Liquidity, sqrtPriceNext-sqrtPriceCurrent, sqrtPrecision*PRECISION)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn || maxAmountIn \u003c= 0 {\n\t\t\t\tamountInStep = amountRemaining\n\n\t\t\t\t// New sqrt price: sqrt(P_new) = sqrt(P_old) + dy * sqrtPrecision / L\n\t\t\t\tsqrtPriceNew := sqrtPriceCurrent + safeMulDiv(amountInStep, sqrtPrecision*PRECISION, pool.Liquidity)\n\n\t\t\t\t// Output: dx = L * (1/sqrt(P_old) - 1/sqrt(P_new))\n\t\t\t\t// = L * (sqrt(P_new) - sqrt(P_old)) / (sqrt(P_old) * sqrt(P_new) / sqrtPrecision)\n\t\t\t\tamountOutStep = safeMulDiv(pool.Liquidity, sqrtPriceNew-sqrtPriceCurrent, safeMulDiv(sqrtPriceCurrent, sqrtPriceNew, sqrtPrecision*PRECISION))\n\n\t\t\t\tpool.PriceX6 = safeMulDiv(sqrtPriceNew, sqrtPriceNew, PRECISION)\n\t\t\t\tif pool.PriceX6 \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\t\tpool.PriceX6 = getPriceAtTick(MAX_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(pool.Liquidity, sqrtPriceNext-sqrtPriceCurrent, safeMulDiv(sqrtPriceCurrent, sqrtPriceNext, sqrtPrecision*PRECISION))\n\t\t\t\tpool.PriceX6 = nextTickPrice\n\n\t\t\t\tcrossTick(poolID, nextTick, zeroForOne)\n\t\t\t}\n\t\t}\n\n\t\tamountRemaining -= amountInStep\n\t\ttotalAmountOut += amountOutStep\n\n\t\t// Accumulate fees for this step (proportional to amount used)\n\t\tif pool.Liquidity \u003e 0 {\n\t\t\tstepFee := safeMulDiv(feeAmount, amountInStep, amountIn-feeAmount)\n\t\t\tif zeroForOne {\n\t\t\t\tpool.FeeGrowthA += safeMulDiv(stepFee, PRECISION, pool.Liquidity)\n\t\t\t} else {\n\t\t\t\tpool.FeeGrowthB += safeMulDiv(stepFee, PRECISION, pool.Liquidity)\n\t\t\t}\n\t\t}\n\t}\n\n\tpool.CurrentTick = getTickAtPrice(pool.PriceX6)\n\n\tif totalAmountOut \u003c minAmountOut {\n\t\tpanic(\"slippage exceeded\")\n\t}\n\n\t// Send output\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tvar denomOut string\n\tif zeroForOne {\n\t\tdenomOut = pool.DenomB\n\t} else {\n\t\tdenomOut = pool.DenomA\n\t}\n\n\tbnk.SendCoins(realmAddr, caller, chain.NewCoins(chain.NewCoin(denomOut, totalAmountOut)))\n\n\treturn totalAmountOut\n}\n\n// findNextInitializedTick finds the next tick with liquidity in the swap direction\nfunc findNextInitializedTick(poolID uint64, currentTick int64, zeroForOne bool) int64 {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\tif zeroForOne {\n\t\t\treturn MIN_TICK\n\t\t}\n\t\treturn MAX_TICK\n\t}\n\n\tpool := pools[poolID]\n\tspacing := pool.TickSpacing\n\n\tif zeroForOne {\n\t\t// Going down (price decreasing), look for next lower initialized tick\n\t\tfor tick := currentTick - spacing; tick \u003e= MIN_TICK; tick -= spacing {\n\t\t\tif info := ticks[tick]; info != nil \u0026\u0026 info.Initialized {\n\t\t\t\treturn tick\n\t\t\t}\n\t\t}\n\t\treturn MIN_TICK\n\t} else {\n\t\t// Going up (price increasing), look for next higher initialized tick\n\t\tfor tick := currentTick + spacing; tick \u003c= MAX_TICK; tick += spacing {\n\t\t\tif info := ticks[tick]; info != nil \u0026\u0026 info.Initialized {\n\t\t\t\treturn tick\n\t\t\t}\n\t\t}\n\t\treturn MAX_TICK\n\t}\n}\n\n// crossTick updates liquidity when crossing a tick boundary\nfunc crossTick(poolID uint64, tick int64, zeroForOne bool) {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\treturn\n\t}\n\n\tinfo := ticks[tick]\n\tif info == nil || !info.Initialized {\n\t\treturn\n\t}\n\n\tpool := pools[poolID]\n\n\t// When crossing a tick from left to right (price increasing), add liquidityNet\n\t// When crossing from right to left (price decreasing), subtract liquidityNet\n\tif zeroForOne {\n\t\t// Price decreasing, crossing tick from above\n\t\tpool.Liquidity -= info.LiquidityNet\n\t} else {\n\t\t// Price increasing, crossing tick from below\n\t\tpool.Liquidity += info.LiquidityNet\n\t}\n\n\t// Ensure liquidity doesn't go negative\n\tif pool.Liquidity \u003c 0 {\n\t\tpool.Liquidity = 0\n\t}\n}\n\n// =============================================================================\n// COLLECT FEES\n// =============================================================================\n\nfunc CollectFees(_ realm, positionID uint64) (int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\n\tpos := positions[positionID]\n\tcaller := string(runtime.OriginCaller())\n\n\tif pos.Owner != caller {\n\t\tpanic(\"not owner\")\n\t}\n\n\tpool := pools[pos.PoolID]\n\n\t// Calculate fees owed since last collection\n\t// Only collect fees if position is/was in range\n\tvar feesA, feesB int64\n\n\tif pos.Liquidity \u003e 0 {\n\t\t// Calculate accumulated fees based on fee growth difference\n\t\tfeeGrowthDeltaA := pool.FeeGrowthA - pos.FeeGrowthLastA\n\t\tfeeGrowthDeltaB := pool.FeeGrowthB - pos.FeeGrowthLastB\n\n\t\t// Use safe math to prevent overflow\n\t\tfeesA = safeMulDiv(feeGrowthDeltaA, pos.Liquidity, PRECISION)\n\t\tfeesB = safeMulDiv(feeGrowthDeltaB, pos.Liquidity, PRECISION)\n\n\t\t// Update position's last fee growth snapshot\n\t\tpos.FeeGrowthLastA = pool.FeeGrowthA\n\t\tpos.FeeGrowthLastB = pool.FeeGrowthB\n\t}\n\n\t// Add any previously uncollected tokens\n\tfeesA += pos.TokensOwedA\n\tfeesB += pos.TokensOwedB\n\tpos.TokensOwedA = 0\n\tpos.TokensOwedB = 0\n\n\t// Send fees to owner\n\tif feesA \u003e 0 || feesB \u003e 0 {\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\trealmAddr := runtime.CurrentRealm().Address()\n\t\tcallerAddr := runtime.OriginCaller()\n\n\t\tif feesA \u003e 0 \u0026\u0026 feesB \u003e 0 {\n\t\t\tcoins := chain.NewCoins(\n\t\t\t\tchain.NewCoin(pool.DenomA, feesA),\n\t\t\t\tchain.NewCoin(pool.DenomB, feesB),\n\t\t\t)\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, coins)\n\t\t} else if feesA \u003e 0 {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomA, feesA)))\n\t\t} else {\n\t\t\tbnk.SendCoins(realmAddr, callerAddr, chain.NewCoins(chain.NewCoin(pool.DenomB, feesB)))\n\t\t}\n\t}\n\n\treturn feesA, feesB\n}\n\n// GetPositionFees returns uncollected fees for a position\nfunc GetPositionFees(positionID uint64) (int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\treturn 0, 0\n\t}\n\n\tpos := positions[positionID]\n\tpool := pools[pos.PoolID]\n\n\tvar feesA, feesB int64\n\n\tif pos.Liquidity \u003e 0 {\n\t\tfeeGrowthDeltaA := pool.FeeGrowthA - pos.FeeGrowthLastA\n\t\tfeeGrowthDeltaB := pool.FeeGrowthB - pos.FeeGrowthLastB\n\n\t\t// Use safe math to prevent overflow\n\t\tfeesA = safeMulDiv(feeGrowthDeltaA, pos.Liquidity, PRECISION)\n\t\tfeesB = safeMulDiv(feeGrowthDeltaB, pos.Liquidity, PRECISION)\n\t}\n\n\tfeesA += pos.TokensOwedA\n\tfeesB += pos.TokensOwedB\n\n\treturn feesA, feesB\n}\n\n// =============================================================================\n// TICK HELPERS\n// =============================================================================\n\nfunc updateTick(poolID uint64, tick int64, liquidityDelta int64, isLower bool) {\n\tticks := tickData[poolID]\n\tif ticks == nil {\n\t\tticks = make(map[int64]*TickInfo)\n\t\ttickData[poolID] = ticks\n\t}\n\n\tinfo := ticks[tick]\n\tif info == nil {\n\t\tinfo = \u0026TickInfo{}\n\t\tticks[tick] = info\n\t}\n\n\tinfo.LiquidityGross += liquidityDelta\n\n\tif isLower {\n\t\tinfo.LiquidityNet += liquidityDelta\n\t} else {\n\t\tinfo.LiquidityNet -= liquidityDelta\n\t}\n\n\tinfo.Initialized = info.LiquidityGross \u003e 0\n}\n\n// =============================================================================\n// QUERIES\n// =============================================================================\n\nfunc GetCLMMPool(poolID uint64) (string, string, int64, int64, int64, int64, int64) {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\tpanic(\"pool not found\")\n\t}\n\tp := pools[poolID]\n\treturn p.DenomA, p.DenomB, p.PriceX6, p.CurrentTick, p.Liquidity, p.FeeBPS, p.TickSpacing\n}\n\nfunc GetCLMMPoolCount() uint64 {\n\treturn uint64(len(pools))\n}\n\nfunc GetPosition(positionID uint64) (uint64, string, int64, int64, int64) {\n\tif positionID \u003e= uint64(len(positions)) {\n\t\tpanic(\"position not found\")\n\t}\n\tp := positions[positionID]\n\treturn p.PoolID, p.Owner, p.TickLower, p.TickUpper, p.Liquidity\n}\n\nfunc GetPositionCount() uint64 {\n\treturn uint64(len(positions))\n}\n\nfunc GetPositionsByOwner(owner string) []uint64 {\n\tvar result []uint64\n\tfor _, p := range positions {\n\t\tif p.Owner == owner \u0026\u0026 p.Liquidity \u003e 0 {\n\t\t\tresult = append(result, p.ID)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc GetQuote(poolID uint64, tokenIn string, amountIn int64) int64 {\n\tif poolID \u003e= uint64(len(pools)) {\n\t\treturn 0\n\t}\n\n\tpool := pools[poolID]\n\tif pool.Liquidity == 0 {\n\t\treturn 0\n\t}\n\n\t// Simulate the swap without modifying state\n\t// Copy pool state for simulation\n\tsimPriceX6 := pool.PriceX6\n\tsimLiquidity := pool.Liquidity\n\tsimCurrentTick := pool.CurrentTick\n\n\tvar zeroForOne bool\n\tif tokenIn == \"A\" {\n\t\tzeroForOne = true\n\t} else if tokenIn == \"B\" {\n\t\tzeroForOne = false\n\t} else {\n\t\treturn 0\n\t}\n\n\t// Calculate fee\n\tfeeAmount := safeMulDiv(amountIn, pool.FeeBPS, 10000)\n\tamountRemaining := amountIn - feeAmount\n\ttotalAmountOut := int64(0)\n\n\t// Simulate swap with tick crossing using sqrt-based CLMM math\n\tsqrtPrecision := int64(1000) // sqrt(PRECISION)\n\tmaxIterations := 100\n\tfor i := 0; i \u003c maxIterations \u0026\u0026 amountRemaining \u003e 0; i++ {\n\t\tif simLiquidity == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tnextTick := findNextInitializedTick(poolID, simCurrentTick, zeroForOne)\n\n\t\tvar amountInStep, amountOutStep int64\n\n\t\tif zeroForOne {\n\t\t\t// Swapping A for B (price decreases)\n\t\t\tnextTickPrice := getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MIN_TICK)\n\t\t\t}\n\n\t\t\tsqrtPriceCurrent := isqrt(simPriceX6 * PRECISION)\n\t\t\tsqrtPriceNext := isqrt(nextTickPrice * PRECISION)\n\n\t\t\tif sqrtPriceCurrent \u003c= sqrtPriceNext {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(simLiquidity, sqrtPriceCurrent-sqrtPriceNext, safeMulDiv(sqrtPriceCurrent, sqrtPriceNext, sqrtPrecision*PRECISION))\n\n\t\t\tif amountRemaining \u003c= maxAmountIn || maxAmountIn \u003c= 0 {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tdenom := simLiquidity + safeMulDiv(amountInStep, sqrtPriceCurrent, sqrtPrecision*PRECISION)\n\t\t\t\tif denom \u003c= 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsqrtPriceNew := safeMulDiv(sqrtPriceCurrent, simLiquidity, denom)\n\t\t\t\tamountOutStep = safeMulDiv(simLiquidity, sqrtPriceCurrent-sqrtPriceNew, sqrtPrecision*PRECISION)\n\t\t\t\tsimPriceX6 = safeMulDiv(sqrtPriceNew, sqrtPriceNew, PRECISION)\n\t\t\t\tif simPriceX6 \u003c getPriceAtTick(MIN_TICK) {\n\t\t\t\t\tsimPriceX6 = getPriceAtTick(MIN_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(simLiquidity, sqrtPriceCurrent-sqrtPriceNext, sqrtPrecision*PRECISION)\n\t\t\t\tsimPriceX6 = nextTickPrice\n\n\t\t\t\tticks := tickData[poolID]\n\t\t\t\tif ticks != nil {\n\t\t\t\t\tif tickInfo, ok := ticks[nextTick]; ok \u0026\u0026 tickInfo.Initialized {\n\t\t\t\t\t\tsimLiquidity -= tickInfo.LiquidityNet\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsimCurrentTick = nextTick\n\t\t\t}\n\t\t} else {\n\t\t\t// Swapping B for A (price increases)\n\t\t\tnextTickPrice := getPriceAtTick(nextTick)\n\t\t\tif nextTickPrice \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\tnextTickPrice = getPriceAtTick(MAX_TICK)\n\t\t\t}\n\n\t\t\tsqrtPriceCurrent := isqrt(simPriceX6 * PRECISION)\n\t\t\tsqrtPriceNext := isqrt(nextTickPrice * PRECISION)\n\n\t\t\tif sqrtPriceNext \u003c= sqrtPriceCurrent {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tmaxAmountIn := safeMulDiv(simLiquidity, sqrtPriceNext-sqrtPriceCurrent, sqrtPrecision*PRECISION)\n\n\t\t\tif amountRemaining \u003c= maxAmountIn || maxAmountIn \u003c= 0 {\n\t\t\t\tamountInStep = amountRemaining\n\t\t\t\tsqrtPriceNew := sqrtPriceCurrent + safeMulDiv(amountInStep, sqrtPrecision*PRECISION, simLiquidity)\n\t\t\t\tamountOutStep = safeMulDiv(simLiquidity, sqrtPriceNew-sqrtPriceCurrent, safeMulDiv(sqrtPriceCurrent, sqrtPriceNew, sqrtPrecision*PRECISION))\n\t\t\t\tsimPriceX6 = safeMulDiv(sqrtPriceNew, sqrtPriceNew, PRECISION)\n\t\t\t\tif simPriceX6 \u003e getPriceAtTick(MAX_TICK) {\n\t\t\t\t\tsimPriceX6 = getPriceAtTick(MAX_TICK)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tamountInStep = maxAmountIn\n\t\t\t\tamountOutStep = safeMulDiv(simLiquidity, sqrtPriceNext-sqrtPriceCurrent, safeMulDiv(sqrtPriceCurrent, sqrtPriceNext, sqrtPrecision*PRECISION))\n\t\t\t\tsimPriceX6 = nextTickPrice\n\n\t\t\t\tticks := tickData[poolID]\n\t\t\t\tif ticks != nil {\n\t\t\t\t\tif tickInfo, ok := ticks[nextTick]; ok \u0026\u0026 tickInfo.Initialized {\n\t\t\t\t\t\tsimLiquidity += tickInfo.LiquidityNet\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsimCurrentTick = nextTick\n\t\t\t}\n\t\t}\n\n\t\tamountRemaining -= amountInStep\n\t\ttotalAmountOut += amountOutStep\n\t}\n\n\treturn totalAmountOut\n}\n\nfunc GetPriceAtTick(tick int64) int64 {\n\treturn getPriceAtTick(tick)\n}\n\nfunc GetTickAtPrice(priceX6 int64) int64 {\n\treturn getTickAtPrice(priceX6)\n}\n\nfunc GetRealmAddress() string {\n\treturn string(runtime.CurrentRealm().Address())\n}\n\n// =============================================================================\n// RENDER\n// =============================================================================\n\nfunc Render(path string) string {\n\tvar sb strings.Builder\n\n\tsb.WriteString(\"# Gnomo CLMM\\n\\n\")\n\tsb.WriteString(\"**Address:** `\" + string(runtime.CurrentRealm().Address()) + \"`\\n\\n\")\n\n\tif len(pools) == 0 {\n\t\tsb.WriteString(\"No pools yet.\\n\")\n\t} else {\n\t\tsb.WriteString(\"## Pools\\n\\n\")\n\t\tfor _, p := range pools {\n\t\t\tsb.WriteString(\"### Pool \" + strconv.FormatUint(p.ID, 10) + \"\\n\")\n\t\t\tsb.WriteString(\"- Pair: \" + formatDenom(p.DenomA) + \"/\" + formatDenom(p.DenomB) + \"\\n\")\n\t\t\tsb.WriteString(\"- Fee: \" + strconv.FormatInt(p.FeeBPS, 10) + \" bps\\n\")\n\t\t\tsb.WriteString(\"- Tick: \" + strconv.FormatInt(p.CurrentTick, 10) + \"\\n\")\n\t\t\tsb.WriteString(\"- Liquidity: \" + strconv.FormatInt(p.Liquidity, 10) + \"\\n\")\n\t\t\tpriceFloat := float64(p.PriceX6) / float64(PRECISION)\n\t\t\tsb.WriteString(\"- Price: \" + strconv.FormatFloat(priceFloat, 'f', 6, 64) + \"\\n\\n\")\n\t\t}\n\t}\n\n\tsb.WriteString(\"## Stats\\n\")\n\tsb.WriteString(\"- Pools: \" + strconv.Itoa(len(pools)) + \"\\n\")\n\n\tactivePos := 0\n\tfor _, p := range positions {\n\t\tif p.Liquidity \u003e 0 {\n\t\t\tactivePos++\n\t\t}\n\t}\n\tsb.WriteString(\"- Positions: \" + strconv.Itoa(activePos) + \"\\n\")\n\n\treturn sb.String()\n}\n\nfunc formatDenom(denom string) string {\n\tif denom == \"ugnot\" {\n\t\treturn \"GNOT\"\n\t}\n\tif strings.Contains(denom, \":\") {\n\t\tparts := strings.Split(denom, \":\")\n\t\treturn strings.ToUpper(parts[len(parts)-1])\n\t}\n\treturn denom\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/gnomo/clmm4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"50000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"b70wHCPr5gvHR51sX7pcS0kXbLQ1X3vRx9kj/6gUO8bCkWKK01ySCIU8U4jaEildaEpQbo1bIjmpbx4jRCU7BQ=="}],"memo":""},"metadata":{"timestamp":"1768369409"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"MintTestTokens","args":["usdc1","10000000000"]}],"fee":{"gas_wanted":"2760410","gas_fee":"2761ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"5isHIh/dvT8mRT6zV0kJXiLLarmulmAT2YuJY+OecJfWSPdeJHrgXybZaa/rTBwB4l9uHpdExue0H4EpoteaAg=="}],"memo":""},"metadata":{"timestamp":"1768369505"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/dex3","func":"CreatePool","args":["ugnot","/gno.land/r/gnomo/dex3:usdc1","5"]}],"fee":{"gas_wanted":"693398","gas_fee":"694ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"D2lIOC/0sD6zWfntseW3tbESowaRHW7nd6jFKJRAlqPiI6tcoFuj5BPaj+vOtJqu8VuhFw1VGkNw9SZzbyaMCw=="}],"memo":""},"metadata":{"timestamp":"1768369515"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"CreateCLMMPool","args":["ugnot","/gno.land/r/gnomo/dex3:usdc1","5","1000000"]}],"fee":{"gas_wanted":"2240805","gas_fee":"2241ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"s81A7YJ1Rjdn8jCCoe1AFTmH313CCKW4x2IuuIjFqauaOKVViyMm+AXYTBmy2GtQq84tbbjUsJ8iPzGVkX/qAw=="}],"memo":""},"metadata":{"timestamp":"1768369550"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"2500000000/gno.land/r/gnomo/dex3:usdc1,2500137747ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"MintPosition","args":["1","-10","10"]}],"fee":{"gas_wanted":"1820764","gas_fee":"1821ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"26Lapv2fCg9UzYcddArZmDm9cpDoxTDUjjZcOSY/5hEJHgKV5A7qmgSwg0PzODJ3CZQ/3czM1uMzqwlXcKa+Bg=="}],"memo":""},"metadata":{"timestamp":"1768369590"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"500000000ugnot","max_deposit":"","pkg_path":"gno.land/r/gnomo/clmm3","func":"Swap","args":["1","B","497251250"]}],"fee":{"gas_wanted":"5622408","gas_fee":"5623ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"/kcJdikfUxJ1h4sBN3zG/Va0HLm5nE3HLOhoP+CGkRxsIg7SWqgqhpLlvfv6HZbHDamxr0Ni00w1MGJBKUTFBQ=="}],"memo":""},"metadata":{"timestamp":"1768369641"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1sjzd4060dxdpwgk4g5ssrctmps9yg0hxqe5lu6","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"lV5BXN/ulHafI/1Kv8a8PyVroYi5hisAdcARkBaL9+EldrOQo/nEY+tCJ6P/VZ1iZvcsraNFvJNeOav0IHK3BA=="}],"memo":""},"metadata":{"timestamp":"1768382764"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1xh7m96ew0ncje9dyq9z8aadr2ca2xhd7dpd2p9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"zKEx0LhWEHbTqu7f48cWi4mNDu3muAKpBm1ep8pVWgG8L8nUxReKLKn9Ana2JX/dTc0GC+r6lKrv6IOih9LtBA=="}],"memo":""},"metadata":{"timestamp":"1768382784"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1sjzd4060dxdpwgk4g5ssrctmps9yg0hxqe5lu6","to_address":"g1xh7m96ew0ncje9dyq9z8aadr2ca2xhd7dpd2p9","amount":"1000000ugnot"}],"fee":{"gas_wanted":"45857","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"bhezHfblG1xPW2bTUjVPNb0YgfgCNmcqmE/Ru2QHQuk="},"signature":"iDgcOxaO+WLDMBxAsSyMva2SxAE25lOjm9m9l1rETzL2obiIPZVoOYsj1KH75XbtrBt4zVNU/lUJOxW7xS1dAA=="}],"memo":""},"metadata":{"timestamp":"1768382809"}}
