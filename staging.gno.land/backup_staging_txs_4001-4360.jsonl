{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"rgoA0WZiByTQzOuAjFomHIluG30OYR3wCQElAdRkXdL3AVcju5bZFxjU2v2dG7tggimdOhq3/oWftm7EaNx3Cg=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"2MCIjylSP2UijZQE8ahTTm4Lc/O4zw3w5kDenoif7Ph416aI8tEA4lMq88Ora/Q9n4X9x2hGLI6DhDD+znUNAg=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"rI0UyCNUcrpaN6AEkT4X+Aef8N83Z3LcJB9TwelOlGdEinKYwF5sOqqSc3XBXTNhxOUbztsmEriino/oE0jTCA=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"FRpJPiSZRi00p2YZGi7E6jN9UiwyoEA9ynHdQA4Bx/CQhzJvjnmsqclOH23Vw6en3ff1AlmZCzRIFUNTje0RBg=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"rQEwHRe8c2vzGo+4MvpfcXvxfOzyMmcMX1DoR5vYaTIxX64NEcYZUgHRcoBy0rHU2xanxIF4tuKgbv/rPSrqDg=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"bmHrZROyonDwtCJpuB9Gd1Z2W32rGXKHF3JY0kC/i2mSdhHbguyBnnNdFhTzd5RAU4ojzyGIsqSVlCm5Ap9XDg=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"0JfujkGL36dqO9Ft3OcAzFOKw78yXeWpqtaBWG/3tOo6TQTDH5ElosxG0WMK52SLOwiwWs+tGDKpyNw8I8gHDA=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"MzCrMxa2J/WxfkjyJJArhkNevX0xFBTmOrFbC5xUUumysn5/gUf84f4QhVDqUDCIhkfDSd/lS41LDIsPDKgTDA=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765330485","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PLycz61pIwS832DfMOQvNDbKkhhdbO3TS06Aqrxg+661ywPu+c2kfGbM97oIlg/zzvIhm7anWHaP8cOt4AKkCg=="}],"memo":""},"metadata":{"timestamp":"1765330487"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1gxhtcp4md9tswtvnxq50n4pgagj3tefw4wtfrp","amount":"5000000ugnot"}],"fee":{"gas_wanted":"52246","gas_fee":"53ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Ykcc0gRibuE6eh9cAsOIfhftkff+FpCx1JDHVbIrCMB0ybNV95eIj70VDULpcKN9kqFhd5WsRWO+ptYdasMLCw=="}],"memo":""},"metadata":{"timestamp":"1765330688"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1sg2xpgstxlmpf686hczshr3kg0hrqkdxq8gj8l","amount":"5000000ugnot"}],"fee":{"gas_wanted":"52246","gas_fee":"53ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"nCh3uxNy41Ms6Md/L64ItUmaPFg6CCWkvbEeCOb1nGGoH/szCTyGEC+UIGp6kxX7o9DASnJYUhV7Rqo8FghLAA=="}],"memo":""},"metadata":{"timestamp":"1765331734"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","amount":"5000000ugnot"}],"fee":{"gas_wanted":"52246","gas_fee":"53ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"U7xgPIDUFMs9LPPc/WcDz3Qr1RFPkj3NjuN2uJLBlRVbNeguoaCAc2x8YHtVddsG2DD9MfVShQQ+Y70DgObLDA=="}],"memo":""},"metadata":{"timestamp":"1765335578"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"P+BASGjapoDCAA5pmfhf7KT0Znl/zoRQUlr9FKcDOn2CEig76+B2M7B2Zf0n3R+e9PF1YkAVj20vTnB+UnsjAw=="}],"memo":""},"metadata":{"timestamp":"1765337498"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"C+28L5/jB04UM8iQa/14MEOnAujbH1XZAt6IjvZ14QM4YZ6s4suwAuGbb5AV3ohG+M0Yc+fO8gV+WO0WreQzCQ=="}],"memo":""},"metadata":{"timestamp":"1765337971"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"3000000","gas_fee":"3000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"WIVEWcd315TejNc4TLW7T3yMSptChrpNyChl9/HXlkMVNgp07WTZVZ0xrGWFMeuI2OaVn75ezNGE2rT1ImU8CQ=="}],"memo":""},"metadata":{"timestamp":"1765338056"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","amount":"10000000ugnot"}],"fee":{"gas_wanted":"57778","gas_fee":"58ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ilDtR+m/fXU4gbYo+kJdjiEy7gO1rpO2TcFktVf++9f/xENtZBCTliOTDeYtp1ui4e1/ASiPPXAfMkmy22ejAA=="}],"memo":""},"metadata":{"timestamp":"1765338232"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"3500000","gas_fee":"3500000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"7GK6Zs0SkGqPZw7Kd00C9wMXTIh/dl3bY+AuYOVXPHCT/XYkGkhNHuJJe5cuti8F6+UaG8vCyg3te4dqiIPqAg=="}],"memo":""},"metadata":{"timestamp":"1765338247"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"2500000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ooL27f841gbmoJ5FdocB1CpOeTjkgIKjSx1r460kS7NgmpH2T8ltib3fd7GlooujmoiVer0FiJWuI0IFUEzGDA=="}],"memo":""},"metadata":{"timestamp":"1765338564"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","amount":"5000000ugnot"}],"fee":{"gas_wanted":"57774","gas_fee":"58ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"hUWBLOtqAbanPOWpdMjctEvAXsWduyf2gHl0N9FIHBHAc1qP3FxFgYFfViNjhJo9Uyqcee6qKLbeWkmyeWVxDQ=="}],"memo":""},"metadata":{"timestamp":"1765338724"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"EkhhBOCYfrhxdunMOvTN7BROE0h+K93ELSxzRdnvDsoD1GLVaF2isXqF9Xd9XKfYRfqVILrFl4DIksgPZXR2CQ=="}],"memo":""},"metadata":{"timestamp":"1765339001"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","150"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"09QLaPbMclUpIL/BVTRDRkXrUQhGeB74hkfFBSo08+cf3yqfwvHC9oTUWIUhBH1ZdiidNb4R2fHkuxXoXe/2Dw=="}],"memo":""},"metadata":{"timestamp":"1765341207"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1naxylpythknhqj66un25eq6kg9zrku68cjr8cj","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"EkhhBOCYfrhxdunMOvTN7BROE0h+K93ELSxzRdnvDsoD1GLVaF2isXqF9Xd9XKfYRfqVILrFl4DIksgPZXR2CQ=="}],"memo":""},"metadata":{"timestamp":"1765348097"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg","send":"","max_deposit":"","pkg_path":"gno.land/r/demo/counter","func":"Increment"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1scdn3PZgDtUyWiTDpu2RnceBDvg7qorbozdqZ788DTeTTO8xC0s6QFhD5R6hfQ/Jhw5q15sjA5hy+dj44lFCg=="}],"memo":""},"metadata":{"timestamp":"1765355706"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg","send":"","max_deposit":"","pkg_path":"gno.land/r/demo/counter","func":"Increment"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1scdn3PZgDtUyWiTDpu2RnceBDvg7qorbozdqZ788DTeTTO8xC0s6QFhD5R6hfQ/Jhw5q15sjA5hy+dj44lFCg=="}],"memo":""},"metadata":{"timestamp":"1765355791"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg","send":"","max_deposit":"","pkg_path":"gno.land/r/demo/counter","func":"Increment"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1scdn3PZgDtUyWiTDpu2RnceBDvg7qorbozdqZ788DTeTTO8xC0s6QFhD5R6hfQ/Jhw5q15sjA5hy+dj44lFCg=="}],"memo":""},"metadata":{"timestamp":"1765355806"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","package":{"name":"gnobounty","path":"gno.land/r/greg007/gnobounty","files":[{"name":"README.md","body":"# GnoBounty\n\nA decentralized bounty system for managing rewards on GitHub issues (or any issue tracker) using the Gno blockchain, with DAO-based validation through validator voting.\n\n## Features\n\n- **Create Bounties**: Post a bounty on any issue by providing the issue URL and sending GNOT tokens\n- **Apply for Bounties**: Submit your merged PR link to apply for a bounty\n- **DAO Validation**: 3 validators are randomly selected to vote on each application\n- **Automatic Claims**: Bounties are automatically claimed when 2/3 validators approve\n- **Validator System**: Decentralized validation through registered validators\n- **Cancel Bounties**: Creators can cancel unclaimed bounties and receive a refund\n- **List Bounties**: Browse all active bounties with reward amounts\n- **Transparent**: All bounties and applications are stored on-chain and publicly viewable\n\n## How to Use\n\n### Creating a Bounty\n\nTo create a bounty, call the `CreateBounty` function with the issue URL and description, and send GNOT tokens:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"CreateBounty\" \\\n  -args \"https://github.com/gnolang/gno/issues/1234\" \\\n  -args \"Fix the rendering bug in GRC20 token display\" \\\n  -send \"5000000ugnot\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- `issueURL`: The URL of the issue (GitHub, GitLab, etc.)\n- `description`: A brief description of what needs to be done\n- `send`: The bounty amount in ugnot (1 GNOT = 1,000,000 ugnot)\n\n**Minimum bounty**: 1 GNOT (1,000,000 ugnot)\n\n### Viewing Bounties\n\nVisit the realm in your browser to see all active bounties:\n\n```\nhttps://gno.land/r/greg007/gnobounty\n```\n\nOr view a specific bounty by ID:\n\n```\nhttps://gno.land/r/greg007/gnobounty/1\n```\n\n### Applying for a Bounty\n\nWhen you complete work on a bounty, submit your merged PR link to apply:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"ApplyForBounty\" \\\n  -args \"1\" \\\n  -args \"https://github.com/gnolang/gno/pull/5678\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- First arg: Bounty ID\n- Second arg: URL of your merged pull request\n\n**What happens next:**\n1. Your application is created\n2. 3 random validators are selected from the validator pool\n3. Validators review your PR and vote to approve or reject\n4. If 2 out of 3 validators approve, the bounty is automatically transferred to you!\n\n### Validator Voting\n\nIf you're a registered validator, you can vote on applications assigned to you:\n\n```bash\n# Approve an application\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"true\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n\n# Reject an application\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"false\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- First arg: Application ID\n- Second arg: \"true\" to approve, \"false\" to reject\n\n### Legacy: Manual Claiming (deprecated)\n\nThe old manual claim system is still available but deprecated in favor of DAO validation:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"ClaimBounty\" \\\n  -args \"1\" \\\n  -args \"g1abc123...xyz\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n### Cancelling a Bounty\n\nIf you need to cancel a bounty and get your funds back:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"CancelBounty\" \\\n  -args \"1\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Note:** You can only cancel bounties that haven't been claimed yet.\n\n## API Reference\n\n### Bounty Functions\n\n#### `CreateBounty(cur realm, issueURL, description string) uint64`\nCreates a new bounty and returns the bounty ID. Must send GNOT with the transaction.\n\n#### `GetBounty(id uint64) *Bounty`\nReturns bounty details by ID.\n\n#### `CancelBounty(cur realm, id uint64)`\nCancels a bounty and refunds the creator. Only callable by the bounty creator on unclaimed bounties.\n\n#### `ListBounties() string`\nReturns a formatted list of all active bounties.\n\n#### `GetBountyDetails(id uint64) string`\nReturns detailed information about a specific bounty with apply button.\n\n#### `GetBountyCount() uint64`\nReturns the total number of bounties created.\n\n### Application \u0026 Voting Functions\n\n#### `ApplyForBounty(cur realm, bountyID uint64, prLink string) uint64`\nSubmit an application for a bounty with your merged PR link. Returns the application ID.\n- Automatically selects 3 random validators\n- Creates a pending application\n- Returns application ID\n\n#### `Vote(cur realm, applicationID uint64, approve bool)`\nVote on an application (validator only). Must be one of the selected validators.\n- `approve`: true to approve, false to reject\n- Automatically claims bounty if 2/3 validators approve\n\n#### `GetApplication(id uint64) *Application`\nReturns application details by ID.\n\n#### `GetApplicationsForBounty(bountyID uint64) []*Application`\nReturns all applications for a specific bounty.\n\n#### `GetApplicationsForValidator(validatorAddr address) []*Application`\nReturns all applications assigned to a validator for voting.\n\n#### `GetApplicationCount() uint64`\nReturns the total number of applications created.\n\n### Validator Management Functions\n\n#### `AddValidator(cur realm, validatorAddr address)`\nAdds a new validator to the system (admin function).\n\n#### `RemoveValidator(cur realm, validatorAddr address)`\nDeactivates a validator (admin function).\n\n#### `IsValidator(addr address) bool`\nChecks if an address is an active validator.\n\n#### `GetActiveValidatorCount() int`\nReturns the number of active validators.\n\n#### `ListValidators() string`\nReturns a formatted list of all validators and their status.\n\n### Rendering Functions\n\n#### `RenderMyVotes(validatorAddr address) string`\nShows pending applications that need votes from the specified validator, with approve/reject buttons.\n\n#### `Render(path string) string`\nMain render function for the realm.\n\n### Bounty Structure\n\n```go\ntype Bounty struct {\n    ID          uint64    // Unique bounty identifier\n    IssueURL    string    // Link to the issue\n    Description string    // Description of the work\n    Amount      int64     // Reward amount in ugnot\n    Creator     address   // Address of the bounty creator\n    CreatedAt   time.Time // When the bounty was created\n    IsClaimed   bool      // Whether the bounty has been claimed\n    Claimer     address   // Address of the claimer (if claimed)\n    ClaimedAt   time.Time // When the bounty was claimed\n}\n```\n\n## Example Workflow\n\n1. **Alice creates a bounty** for fixing a bug, sending 5 GNOT:\n   ```\n   CreateBounty(\"https://github.com/project/repo/issues/42\", \"Fix memory leak in parser\")\n   ```\n\n2. **Bob sees the bounty** and decides to work on it. He visits the issue URL and starts coding.\n\n3. **Bob completes the work** and submits a pull request fixing the issue.\n\n4. **Alice verifies the fix** and approves Bob's claim:\n   ```\n   ClaimBounty(cross, 1, \"g1bob123...xyz\")\n   ```\n\n5. **Bob receives 5 GNOT** automatically to his address!\n\n## Security Considerations\n\n- Only the bounty creator can approve claims\n- Bounties are locked in the realm contract until claimed or cancelled\n- Once claimed, bounties cannot be cancelled\n- The realm must have sufficient funds to pay out bounties\n\n## Notes\n\n- This implementation uses the new Gno standard library split (post-#3874)\n- Amounts are stored in ugnot (micro-GNOT): 1 GNOT = 1,000,000 ugnot\n- The `address` type is used as a builtin instead of `std.Address`\n- Uses new imports:\n  - `gno.land/r/sys/chain` for `Coin` and `Coins` types\n  - `gno.land/r/sys/chain/banker` for banker operations (`NewBanker`, `BankerType*`, `OriginSend`)\n  - `gno.land/r/sys/chain/runtime` for realm functions (`PreviousRealm`, `CurrentRealm`)\n\n## License\n\nMIT\n"},{"name":"application.gno","body":"package gnobounty\n\nimport (\n\t\"chain/runtime\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ApplyForBounty allows a user to apply for a bounty with their merged PR link\n// This creates an application with a private DAO for 3 random validators to vote\nfunc ApplyForBounty(_ realm, bountyID uint64, prLink string) uint64 {\n\tcaller := runtime.OriginCaller()\n\n\t// Validate inputs\n\tif prLink == \"\" {\n\t\tpanic(\"PR link cannot be empty\")\n\t}\n\n\t// Check bounty exists and is not claimed\n\tbounty := GetBounty(bountyID)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"bounty already claimed\")\n\t}\n\n\t// Check if there are enough validators\n\tactiveValidatorCount := GetActiveValidatorCount()\n\tif activeValidatorCount \u003c validatorsPerDAO {\n\t\tpanic(ufmt.Sprintf(\"not enough validators: need %d, have %d\", validatorsPerDAO, activeValidatorCount))\n\t}\n\n\t// Check if user already has a pending application for this bounty\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\tif app.BountyID == bountyID \u0026\u0026 app.Applicant == caller \u0026\u0026 app.Status == StatusPending {\n\t\t\tpanic(\"you already have a pending application for this bounty\")\n\t\t}\n\t\treturn false\n\t})\n\n\t// Select 3 random validators for this application\n\tselectedValidators := selectRandomValidators(applicationCount+1, validatorsPerDAO)\n\n\t// Create the DAO for this application\n\tapplicationCount++\n\tdaoName := ufmt.Sprintf(\"Bounty #%d Application #%d Review DAO\", bountyID, applicationCount)\n\tdaoDesc := ufmt.Sprintf(\"Private DAO to review application for bounty #%d\", bountyID)\n\n\t// Create DAO with selected validators as members\n\t// DisableVotingDeadlineCheck allows immediate execution after votes\n\tdao := commondao.New(\n\t\tcommondao.WithID(applicationCount),\n\t\tcommondao.WithName(daoName),\n\t\tcommondao.WithDescription(daoDesc),\n\t\tcommondao.DisableVotingDeadlineCheck(),\n\t)\n\n\t// Add selected validators as members\n\tfor _, validatorAddr := range selectedValidators {\n\t\tdao.Members().Add(validatorAddr)\n\t}\n\n\t// Create the application\n\tapplication := \u0026Application{\n\t\tID:         applicationCount,\n\t\tBountyID:   bountyID,\n\t\tApplicant:  caller,\n\t\tPRLink:     prLink,\n\t\tAppliedAt:  time.Now(),\n\t\tStatus:     StatusPending,\n\t\tDAO:        dao,\n\t\tProposalID: 0, // Will be set when proposal is created\n\t}\n\n\t// Create a proposal in the DAO to approve this application\n\tproposalDef := NewClaimBountyProposal(bountyID, applicationCount, caller, prLink)\n\n\tproposal := dao.MustPropose(caller, proposalDef)\n\tapplication.ProposalID = proposal.ID()\n\n\t// Store application\n\tapplications.Set(ufmt.Sprintf(\"%d\", applicationCount), application)\n\n\treturn applicationCount\n}\n\n// Vote allows a selected validator to vote on an application via the DAO\nfunc Vote(_ realm, applicationID uint64, vote string) {\n\tcaller := runtime.OriginCaller()\n\n\t// Check if caller is a validator\n\tif !IsValidator(caller) {\n\t\tpanic(\"only validators can vote\")\n\t}\n\n\t// Get application\n\tapp := GetApplication(applicationID)\n\tif app == nil {\n\t\tpanic(\"application not found\")\n\t}\n\n\tif app.Status != StatusPending {\n\t\tpanic(\"application is no longer pending\")\n\t}\n\n\t// Check if caller is a member of this application's DAO\n\tif !app.DAO.Members().Has(caller) {\n\t\tpanic(\"you are not a validator for this application\")\n\t}\n\n\t// Get the proposal\n\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal == nil {\n\t\tpanic(\"proposal not found\")\n\t}\n\n\t// Convert string vote to VoteChoice\n\tvar voteChoice commondao.VoteChoice\n\tswitch vote {\n\tcase \"yes\", \"true\", \"approve\":\n\t\tvoteChoice = commondao.ChoiceYes\n\tcase \"no\", \"false\", \"reject\":\n\t\tvoteChoice = commondao.ChoiceNo\n\tcase \"abstain\":\n\t\tvoteChoice = commondao.ChoiceAbstain\n\tdefault:\n\t\tpanic(\"invalid vote: must be 'yes', 'no', or 'abstain'\")\n\t}\n\n\t// Vote on the proposal using CommonDAO's Vote method\n\t// This method validates membership, deadline, and vote choice\n\terr := app.DAO.Vote(caller, app.ProposalID, voteChoice, \"\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Record vote locally\n\tapp.Votes = append(app.Votes, VoteRecord{\n\t\tVoter:  caller,\n\t\tChoice: voteChoice,\n\t})\n\n\t// Try to execute the proposal\n\t// Tally() will return true when all validators have voted\n\t// Execute() will handle both approval and rejection\n\tproposal = app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal != nil {\n\t\ttotalMembers := app.DAO.Members().Size()\n\t\ttotalVotes := proposal.VotingRecord().Size()\n\n\t\t// If all validators have voted, execute to finalize\n\t\tif totalVotes == totalMembers {\n\t\t\terr = app.DAO.Execute(app.ProposalID)\n\t\t\t// Ignore errors - proposal might already be executed or failed\n\t\t\t// The status will be updated in Execute() regardless\n\t\t}\n\t}\n}\n\n// GetApplicationsForBounty returns all applications for a specific bounty\nfunc GetApplicationsForBounty(bountyID uint64) []*Application {\n\tapps := make([]*Application, 0)\n\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\tif app.BountyID == bountyID {\n\t\t\tapps = append(apps, app)\n\t\t}\n\t\treturn false\n\t})\n\n\treturn apps\n}\n\n// GetApplicationsForValidator returns all applications assigned to a validator\nfunc GetApplicationsForValidator(validatorAddr address) []*Application {\n\tapps := make([]*Application, 0)\n\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\t// Check if validator is a member of the application's DAO\n\t\tif app.DAO != nil \u0026\u0026 app.Status == StatusPending {\n\t\t\tif app.DAO.Members().Has(validatorAddr) {\n\t\t\t\tapps = append(apps, app)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n\n\treturn apps\n}\n"},{"name":"application_test.gno","body":"package gnobounty\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/testutils\"\n)\n\nfunc TestAddValidator(t *testing.T) {\n\t// Setup owner\n\tadminAddr := testutils.TestAddress(\"admin\")\n\ttesting.SetOriginCaller(adminAddr)\n\townership = ownable.New()\n\n\t// Add a validator\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tAddValidator(cross, validator1)\n\n\tif !IsValidator(validator1) {\n\t\tt.Error(\"Validator should be active\")\n\t}\n\n\tcount := GetActiveValidatorCount()\n\tif count \u003c 1 {\n\t\tt.Error(\"Expected at least 1 active validator\")\n\t}\n}\n\nfunc TestValidatorList(t *testing.T) {\n\t// Setup owner\n\tadminAddr := testutils.TestAddress(\"admin\")\n\ttesting.SetOriginCaller(adminAddr)\n\townership = ownable.New()\n\n\t// Add more validators\n\tvalidator2 := testutils.TestAddress(\"validator2\")\n\n\t// Check if already exists before adding\n\tif !IsValidator(validator2) {\n\t\tAddValidator(cross, validator2)\n\t}\n\n\tif !IsValidator(validator2) {\n\t\tt.Error(\"Validator2 should be active\")\n\t}\n\n\tcount := GetActiveValidatorCount()\n\tif count \u003c 2 {\n\t\tt.Errorf(\"Expected at least 2 active validators, got %d\", count)\n\t}\n}\n\nfunc TestListValidators(t *testing.T) {\n\tlist := ListValidators()\n\tif list == \"\" {\n\t\tt.Error(\"Expected non-empty validators list\")\n\t}\n}\n\nfunc TestIsValidatorCheck(t *testing.T) {\n\t// Test a non-validator address\n\tnonValidator := testutils.TestAddress(\"nonvalidator\")\n\tif IsValidator(nonValidator) {\n\t\tt.Error(\"Non-validator should not be recognized as validator\")\n\t}\n\n\t// Test existing validator\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tif !IsValidator(validator1) {\n\t\tt.Error(\"validator1 should be recognized as validator\")\n\t}\n}\n\nfunc TestGetValidator(t *testing.T) {\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tv := GetValidator(validator1)\n\n\tif v == nil {\n\t\tt.Fatal(\"Expected to find validator1\")\n\t}\n\n\tif v.Address != validator1 {\n\t\tt.Error(\"Validator address mismatch\")\n\t}\n\n\tif !v.Active {\n\t\tt.Error(\"Validator should be active\")\n\t}\n}\n"},{"name":"gnobounty_test.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"testing\"\n\n\t\"gno.land/p/nt/testutils\"\n)\n\nfunc TestCreateBounty(t *testing.T) {\n\t// Setup test environment\n\ttesting.SetOriginCaller(testutils.TestAddress(\"alice\"))\n\ttesting.SetOriginSend(chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: 5000000}})\n\n\t// Create a bounty\n\tbountyID := CreateBounty(\n\t\tcross,\n\t\t\"Fix Rendering Bug\",\n\t\t\"https://github.com/gnolang/gno/issues/1234\",\n\t\t\"Fix the rendering issue in the GRC20 token display\",\n\t)\n\n\tif bountyID != 1 {\n\t\tt.Errorf(\"Expected bounty ID 1, got %d\", bountyID)\n\t}\n\n\t// Check bounty was created\n\tbounty := GetBounty(bountyID)\n\tif bounty == nil {\n\t\tt.Fatal(\"Bounty not found\")\n\t}\n\n\tif bounty.Amount != 5000000 {\n\t\tt.Errorf(\"Expected amount 5000000, got %d\", bounty.Amount)\n\t}\n\n\tif bounty.IsClaimed {\n\t\tt.Error(\"Bounty should not be claimed yet\")\n\t}\n\n\tif bounty.Title != \"Fix Rendering Bug\" {\n\t\tt.Errorf(\"Expected title 'Fix Rendering Bug', got %s\", bounty.Title)\n\t}\n}\n\nfunc TestGetBountyCount(t *testing.T) {\n\tcount := GetBountyCount()\n\tif count \u003c 1 {\n\t\tt.Error(\"Expected at least 1 bounty from previous test\")\n\t}\n}\n\nfunc TestListBounties(t *testing.T) {\n\tlist := ListBounties()\n\tif list == \"\" {\n\t\tt.Error(\"Expected non-empty bounties list\")\n\t}\n\tif list == \"No bounties available\" {\n\t\tt.Error(\"Expected bounties to be listed\")\n\t}\n}\n\nfunc TestGetBountyDetails(t *testing.T) {\n\t// Test getting details for existing bounty\n\tdetails := GetBountyDetails(1)\n\tif details == \"\" {\n\t\tt.Error(\"Expected non-empty bounty details\")\n\t}\n\tif details == \"Bounty not found\" {\n\t\tt.Error(\"Bounty #1 should exist\")\n\t}\n}\n\nfunc TestGetBountyDetailsNotFound(t *testing.T) {\n\t// Test getting details for non-existent bounty\n\tdetails := GetBountyDetails(99999)\n\tif details != \"Bounty not found\" {\n\t\tt.Error(\"Expected 'Bounty not found' for non-existent bounty\")\n\t}\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/greg007/gnobounty\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0\"\n"},{"name":"leaderboard.gno","body":"package gnobounty\n\nimport (\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// LeaderboardEntry holds the stats for a user\ntype LeaderboardEntry struct {\n\tAddress              address\n\tBountiesCreated      int\n\tBountiesApplied      int\n\tValidationsPerformed int\n\tScore                int\n}\n\n// GetLeaderboard aggregates stats for all users\nfunc GetLeaderboard() []LeaderboardEntry {\n\tvar stats avl.Tree // address -\u003e *LeaderboardEntry\n\n\t// Count bounties created (10 points)\n\tbounties.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tif value == nil {\n\t\t\treturn false\n\t\t}\n\t\tbounty, ok := value.(*Bounty)\n\t\tif !ok || bounty == nil {\n\t\t\treturn false\n\t\t}\n\t\tentry := getEntry(\u0026stats, bounty.Creator)\n\t\tentry.BountiesCreated++\n\t\tentry.Score += 10\n\t\treturn false\n\t})\n\n\t// Count applications and validations\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tif value == nil {\n\t\t\treturn false\n\t\t}\n\t\tapp, ok := value.(*Application)\n\t\tif !ok || app == nil {\n\t\t\treturn false\n\t\t}\n\n\t\t// Only count approved applications (20 points)\n\t\tif app.Status == StatusApproved {\n\t\t\tentry := getEntry(\u0026stats, app.Applicant)\n\t\t\tentry.BountiesApplied++\n\t\t\tentry.Score += 20\n\t\t}\n\n\t\t// Count validations from local record (5 points)\n\t\tfor _, vote := range app.Votes {\n\t\t\tentry := getEntry(\u0026stats, vote.Voter)\n\t\t\tentry.ValidationsPerformed++\n\t\t\tentry.Score += 5\n\t\t}\n\n\t\treturn false\n\t})\n\n\t// Convert tree to slice\n\tvar result []LeaderboardEntry\n\tstats.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tentry := value.(*LeaderboardEntry)\n\t\tresult = append(result, *entry)\n\t\treturn false\n\t})\n\n\t// Sort by Score descending\n\t// Manual bubble sort since sort.Slice is not available\n\tfor i := 0; i \u003c len(result)-1; i++ {\n\t\tfor j := 0; j \u003c len(result)-i-1; j++ {\n\t\t\tif result[j].Score \u003c result[j+1].Score {\n\t\t\t\t// Swap\n\t\t\t\tresult[j], result[j+1] = result[j+1], result[j]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n// RenderLeaderboard renders the leaderboard page\nfunc RenderLeaderboard() string {\n\tentries := GetLeaderboard()\n\n\toutput := \"# üèÜ Community Leaderboard\\n\\n\"\n\toutput += \"Top contributors to the GnoBounty ecosystem.\\n\\n\"\n\toutput += \"**Scoring:** Bounty Creation (10pts) | Approved Application (20pts) | Validation (5pts)\\n\\n\"\n\n\toutput += \"| Rank | User | Score | üí∞ Bounties | üìù Applications | ‚öñÔ∏è Validations |\\n\"\n\toutput += \"|---|---|---|---|---|---|\\n\"\n\n\tfor i, entry := range entries {\n\t\trank := \"\"\n\t\tswitch i {\n\t\tcase 0:\n\t\t\trank = \"ü•á\"\n\t\tcase 1:\n\t\t\trank = \"ü•à\"\n\t\tcase 2:\n\t\t\trank = \"ü•â\"\n\t\tdefault:\n\t\t\trank = ufmt.Sprintf(\"%d\", i+1)\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"| %s | %s | **%d** | %d | %d | %d |\\n\",\n\t\t\trank,\n\t\t\tentry.Address,\n\t\t\tentry.Score,\n\t\t\tentry.BountiesCreated,\n\t\t\tentry.BountiesApplied,\n\t\t\tentry.ValidationsPerformed,\n\t\t)\n\t}\n\n\tif len(entries) == 0 {\n\t\toutput += \"\\nNo activity recorded yet.\"\n\t}\n\n\treturn output\n}\n\nfunc getEntry(stats *avl.Tree, addr address) *LeaderboardEntry {\n\tkey := string(addr)\n\tval, ok := stats.Get(key)\n\tif !ok {\n\t\tentry := \u0026LeaderboardEntry{Address: addr}\n\t\tstats.Set(key, entry)\n\t\treturn entry\n\t}\n\treturn val.(*LeaderboardEntry)\n}\n"},{"name":"logic.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"time\"\n\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// CreateBounty creates a new bounty post\n// title: short title for the bounty\n// issueURL: link to the GitHub issue or other issue tracker\n// description: description of what needs to be done\n// Caller must send GNOT tokens with this transaction\nfunc CreateBounty(_ realm, title, issueURL, description string) uint64 {\n\t// Validate inputs\n\tif title == \"\" {\n\t\tpanic(\"title is required\")\n\t}\n\tif issueURL == \"\" {\n\t\tpanic(\"issue URL is required\")\n\t}\n\tif description == \"\" {\n\t\tpanic(\"description is required\")\n\t}\n\n\t// Get the sent coins\n\tsent := banker.OriginSend()\n\tif len(sent) == 0 {\n\t\tpanic(\"no coins sent with bounty\")\n\t}\n\n\t// Find GNOT amount\n\tvar gnotAmount int64\n\tfor _, coin := range sent {\n\t\tif coin.Denom == \"ugnot\" {\n\t\t\tgnotAmount = coin.Amount\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif gnotAmount \u003c minimumBounty {\n\t\tpanic(ufmt.Sprintf(\"bounty amount must be at least %d ugnot\", minimumBounty))\n\t}\n\n\t// Create bounty\n\tbountyCount++\n\tbounty := \u0026Bounty{\n\t\tID:          bountyCount,\n\t\tTitle:       title,\n\t\tIssueURL:    issueURL,\n\t\tDescription: description,\n\t\tAmount:      gnotAmount,\n\t\tCreator:     runtime.OriginCaller(),\n\t\tCreatedAt:   time.Now(),\n\t\tIsClaimed:   false,\n\t}\n\n\t// Store bounty\n\tbounties.Set(ufmt.Sprintf(\"%d\", bountyCount), bounty)\n\n\treturn bountyCount\n}\n\n// ClaimBounty allows someone to claim a bounty\n// Only the creator can approve and transfer funds\nfunc ClaimBounty(_ realm, id uint64, claimer address) {\n\tcaller := runtime.OriginCaller()\n\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"bounty already claimed\")\n\t}\n\n\tif caller != bounty.Creator {\n\t\tpanic(\"only bounty creator can approve claims\")\n\t}\n\n\tif claimer == \"\" {\n\t\tpanic(\"claimer address cannot be empty\")\n\t}\n\n\t// Mark as claimed\n\tbounty.IsClaimed = true\n\tbounty.Claimer = claimer\n\tbounty.ClaimedAt = time.Now()\n\n\t// Transfer bounty amount to claimer\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\tsend := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: bounty.Amount}}\n\tpkgAddr := chain.PackageAddress(\"gno.land/r/greg007/gnobounty\")\n\tbnk.SendCoins(pkgAddr, claimer, send)\n}\n\n// CancelBounty allows creator to cancel and get refund\nfunc CancelBounty(_ realm, id uint64) {\n\tcaller := runtime.OriginCaller()\n\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"cannot cancel claimed bounty\")\n\t}\n\n\tif caller != bounty.Creator {\n\t\tpanic(\"only bounty creator can cancel\")\n\t}\n\n\t// Remove bounty first (Checks-Effects-Interactions)\n\tbounties.Remove(ufmt.Sprintf(\"%d\", id))\n\n\t// Refund the creator\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\tsend := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: bounty.Amount}}\n\tpkgAddr := chain.PackageAddress(\"gno.land/r/greg007/gnobounty\")\n\tbnk.SendCoins(pkgAddr, bounty.Creator, send)\n}\n"},{"name":"proposal.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ClaimBountyProposal implements commondao.ProposalDefinition for bounty claim proposals\ntype ClaimBountyProposal struct {\n\tBountyID      uint64\n\tApplicationID uint64\n\tApplicant     address\n\tPRLink        string\n\ttitle         string\n\tdescription   string\n}\n\n// NewClaimBountyProposal creates a new bounty claim proposal definition\nfunc NewClaimBountyProposal(bountyID, applicationID uint64, applicant address, prLink string) *ClaimBountyProposal {\n\treturn \u0026ClaimBountyProposal{\n\t\tBountyID:      bountyID,\n\t\tApplicationID: applicationID,\n\t\tApplicant:     applicant,\n\t\tPRLink:        prLink,\n\t\ttitle:         ufmt.Sprintf(\"Approve Application #%d for Bounty #%d\", applicationID, bountyID),\n\t\tdescription:   ufmt.Sprintf(\"Review PR: %s\\nApplicant: %s\", prLink, applicant),\n\t}\n}\n\n// Title returns proposal title\nfunc (p *ClaimBountyProposal) Title() string {\n\treturn p.title\n}\n\n// Body returns proposal's body\nfunc (p *ClaimBountyProposal) Body() string {\n\treturn p.description\n}\n\n// VotingPeriod returns the period where votes are allowed after proposal creation\nfunc (p *ClaimBountyProposal) VotingPeriod() time.Duration {\n\t// 7 days voting period\n\treturn 7 * 24 * time.Hour\n}\n\n// Tally counts votes and determines if proposal is ready to execute\n// Returns true when all validators have voted (regardless of outcome)\nfunc (p *ClaimBountyProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\ttotalMembers := ctx.Members.Size()\n\tif totalMembers == 0 {\n\t\treturn false, ufmt.Errorf(\"no members in DAO\")\n\t}\n\n\ttotalVotes := ctx.VotingRecord.Size()\n\n\t// Return true when all validators have voted\n\t// This allows Execute to be called and handle approval/rejection\n\tif totalVotes == totalMembers {\n\t\treturn true, nil\n\t}\n\n\t// Not ready yet - waiting for more votes\n\treturn false, nil\n}\n\n// Execute executes the proposal after all votes are in\n// Determines approval or rejection based on vote counts\nfunc (p *ClaimBountyProposal) Execute(_ realm) error {\n\tapp := GetApplication(p.ApplicationID)\n\tif app == nil {\n\t\treturn ufmt.Errorf(\"application not found\")\n\t}\n\n\tbounty := GetBounty(p.BountyID)\n\tif bounty == nil {\n\t\treturn ufmt.Errorf(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\treturn ufmt.Errorf(\"bounty already claimed\")\n\t}\n\n\t// Get vote counts from the DAO proposal\n\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal == nil {\n\t\treturn ufmt.Errorf(\"proposal not found\")\n\t}\n\n\tyesCount := proposal.VotingRecord().VoteCount(commondao.ChoiceYes)\n\tnoCount := proposal.VotingRecord().VoteCount(commondao.ChoiceNo)\n\ttotalMembers := app.DAO.Members().Size()\n\n\t// Check if unanimous approval (all YES, no NO)\n\tif yesCount == totalMembers \u0026\u0026 noCount == 0 {\n\t\t// Approve and transfer funds\n\t\tapp.Status = StatusApproved\n\n\t\tbounty.IsClaimed = true\n\t\tbounty.Claimer = p.Applicant\n\t\tbounty.ClaimedAt = time.Now()\n\n\t\t// Calculate reward split: 5% to validators, 95% to applicant\n\t\tvalidatorReward := (bounty.Amount * validatorRewardPercent) / 100\n\t\tapplicantReward := bounty.Amount - validatorReward\n\n\t\t// Split validator reward equally among all validators who voted\n\t\trewardPerValidator := validatorReward / int64(totalMembers)\n\n\t\t// Transfer rewards\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\t\tpkgAddr := chain.PackageAddress(\"gno.land/r/greg007/gnobounty\")\n\n\t\t// Pay each validator their share\n\t\tapp.DAO.Members().IterateByOffset(0, totalMembers, func(member address) bool {\n\t\t\tvalidatorPayout := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: rewardPerValidator}}\n\t\t\tbnk.SendCoins(pkgAddr, member, validatorPayout)\n\t\t\treturn false\n\t\t})\n\n\t\t// Pay the applicant the remaining 95%\n\t\tapplicantPayout := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: applicantReward}}\n\t\tbnk.SendCoins(pkgAddr, p.Applicant, applicantPayout)\n\t} else {\n\t\t// Reject - not unanimous\n\t\tapp.Status = StatusRejected\n\t}\n\n\treturn nil\n}\n"},{"name":"render.gno","body":"package gnobounty\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ListBounties returns all active bounties\nfunc ListBounties() string {\n\tminSend := ufmt.Sprintf(\"%dugnot\", minimumBounty)\n\tcreateBountyLink := txlink.NewLink(\"CreateBounty\").\n\t\tAddArgs(\n\t\t\t\"title\", \"\",\n\t\t\t\"issueURL\", \"\",\n\t\t\t\"description\", \"\",\n\t\t).\n\t\tSetSend(minSend).\n\t\tURL()\n\n\toutput := \"# GnoBounty - Decentralized Bounty System\\n\\n\"\n\n\toutput += \"## üéØ Quick Actions\\n\\n\"\n\toutput += md.Link(\"üí∞ Create a new bounty\", createBountyLink)\n\toutput += ufmt.Sprintf(\" _(minimum reward: %s)_\", minSend)\n\toutput += \" | \"\n\toutput += md.Link(\"üìã View All Validators\", \"/r/greg007/gnobounty:validators\")\n\toutput += \" | \"\n\toutput += md.Link(\"üèÜ Leaderboard\", \"/r/greg007/gnobounty:leaderboard\")\n\toutput += \"\\n\\n\"\n\n\t// Add validator stats\n\tactiveValidatorCount := GetActiveValidatorCount()\n\toutput += ufmt.Sprintf(\"**Active Validators:** %d | **Total Bounties:** %d\\n\\n\", activeValidatorCount, bountyCount)\n\n\toutput += \"---\\n\\n\"\n\toutput += \"## üíé Active Bounties\\n\\n\"\n\toutput += \"**How to apply:** To apply to a bounty, you need to give your **MERGED PR** (important) URL in the transaction. You also need to write your Gno address in the description of your PR to verify your identity. If no address is written, the bounty can be refused.\\n\\n\"\n\n\tif bountyCount == 0 {\n\t\toutput += \"No bounties available\"\n\t\treturn output\n\t}\n\n\tbounties.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tbounty := value.(*Bounty)\n\t\tif !bounty.IsClaimed {\n\t\t\toutput += ufmt.Sprintf(\"## Bounty #%d: %s\\n\", bounty.ID, bounty.Title)\n\t\t\toutput += ufmt.Sprintf(\"**Issue:** %s\\n\", bounty.IssueURL)\n\t\t\toutput += ufmt.Sprintf(\"**Description:** %s\\n\", bounty.Description)\n\t\t\toutput += ufmt.Sprintf(\"**Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\t\t\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\", bounty.Creator)\n\t\t\toutput += ufmt.Sprintf(\"**Created:** %s\\n\\n\", bounty.CreatedAt.Format(\"2006-01-02 15:04:05\"))\n\n\t\t\t// Add apply button for this bounty\n\t\t\tapplyLink := txlink.NewLink(\"ApplyForBounty\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"bountyID\", ufmt.Sprintf(\"%d\", bounty.ID),\n\t\t\t\t\t\"prLink\", \"\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\toutput += md.Link(\"üìù Apply for this bounty\", applyLink)\n\t\t\toutput += \" | \"\n\n\t\t\t// Add view details link\n\t\t\tdetailsPath := ufmt.Sprintf(\"/r/greg007/gnobounty:%d\", bounty.ID)\n\t\t\toutput += md.Link(\"üîç View details\", detailsPath)\n\t\t\toutput += \"\\n\\n\"\n\t\t}\n\t\treturn false\n\t})\n\n\treturn output\n}\n\n// GetBountyDetails returns detailed information about a specific bounty\nfunc GetBountyDetails(id uint64) string {\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\treturn \"Bounty not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Bounty #%d: %s\\n\\n\", bounty.ID, bounty.Title)\n\toutput += ufmt.Sprintf(\"**Issue URL:** %s\\n\", bounty.IssueURL)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\", bounty.Description)\n\toutput += ufmt.Sprintf(\"**Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\", bounty.Creator)\n\toutput += ufmt.Sprintf(\"**Created:** %s\\n\", bounty.CreatedAt.Format(\"2006-01-02 15:04:05\"))\n\n\tif bounty.IsClaimed {\n\t\toutput += ufmt.Sprintf(\"**Status:** CLAIMED\\n\")\n\t\toutput += ufmt.Sprintf(\"**Claimed by:** %s\\n\", bounty.Claimer)\n\t\toutput += ufmt.Sprintf(\"**Claimed at:** %s\\n\", bounty.ClaimedAt.Format(\"2006-01-02 15:04:05\"))\n\t} else {\n\t\toutput += ufmt.Sprintf(\"**Status:** OPEN\\n\\n\")\n\t\toutput += \"**How to apply:** To apply to a bounty, you need to give your **MERGED PR** (important) URL in the transaction. You also need to write your Gno address in the description of your PR to verify your identity. If no address is written, the bounty can be refused.\\n\\n\"\n\n\t\t// Add apply button\n\t\tapplyLink := txlink.NewLink(\"ApplyForBounty\").\n\t\t\tAddArgs(\n\t\t\t\t\"bountyID\", ufmt.Sprintf(\"%d\", id),\n\t\t\t\t\"prLink\", \"\",\n\t\t\t).\n\t\t\tURL()\n\t\toutput += md.Link(\"Apply for this bounty\", applyLink) + \"\\n\\n\"\n\n\t\t// Show existing applications\n\t\tapps := GetApplicationsForBounty(id)\n\t\tif len(apps) \u003e 0 {\n\t\t\toutput += \"### Applications\\n\\n\"\n\t\t\tfor _, app := range apps {\n\t\t\t\toutput += renderApplication(app)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output\n}\n\n// renderApplication renders a single application\nfunc renderApplication(app *Application) string {\n\toutput := ufmt.Sprintf(\"**Application #%d**\\n\", app.ID)\n\toutput += ufmt.Sprintf(\"- Applicant: %s\\n\", app.Applicant)\n\toutput += ufmt.Sprintf(\"- PR Link: %s\\n\", app.PRLink)\n\toutput += ufmt.Sprintf(\"- Applied: %s\\n\", app.AppliedAt.Format(\"2006-01-02 15:04:05\"))\n\n\tstatusStr := \"PENDING\"\n\tif app.Status == StatusApproved {\n\t\tstatusStr = \"APPROVED\"\n\t} else if app.Status == StatusRejected {\n\t\tstatusStr = \"REJECTED\"\n\t}\n\toutput += ufmt.Sprintf(\"- Status: %s\\n\", statusStr)\n\n\t// Show DAO voting information if DAO exists\n\tif app.DAO != nil {\n\t\toutput += ufmt.Sprintf(\"- Proposal ID: %d\\n\", app.ProposalID)\n\n\t\t// Get proposal and show detailed validator voting status\n\t\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\t\tif proposal != nil {\n\t\t\t// Get vote counts\n\t\t\tyesCount := proposal.VotingRecord().VoteCount(commondao.ChoiceYes)\n\t\t\tnoCount := proposal.VotingRecord().VoteCount(commondao.ChoiceNo)\n\t\t\tabstainCount := proposal.VotingRecord().VoteCount(commondao.ChoiceAbstain)\n\t\t\ttotalVotes := proposal.VotingRecord().Size()\n\t\t\ttotalMembers := app.DAO.Members().Size()\n\n\t\t\toutput += ufmt.Sprintf(\"\\n**Voting Progress:** %d/%d validators have voted\\n\", totalVotes, totalMembers)\n\t\t\toutput += ufmt.Sprintf(\"- ‚úÖ YES: %d\\n\", yesCount)\n\t\t\toutput += ufmt.Sprintf(\"- ‚ùå NO: %d\\n\", noCount)\n\t\t\toutput += ufmt.Sprintf(\"- ü§∑ ABSTAIN: %d\\n\", abstainCount)\n\t\t\toutput += ufmt.Sprintf(\"- ‚è≥ PENDING: %d\\n\", totalMembers-totalVotes)\n\t\t}\n\t}\n\n\t// Add vote buttons for validators if application is still pending\n\tif app.Status == StatusPending \u0026\u0026 app.DAO != nil {\n\t\toutput += \"\\n**Vote on this application:**\\n\"\n\n\t\t// Add vote buttons (yes/no/abstain)\n\t\tyesLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"yes\",\n\t\t\t).\n\t\t\tURL()\n\t\tnoLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"no\",\n\t\t\t).\n\t\t\tURL()\n\t\tabstainLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"abstain\",\n\t\t\t).\n\t\t\tURL()\n\n\t\toutput += md.Link(\"‚úÖ Approve\", yesLink) + \" | \" + md.Link(\"‚ùå Reject\", noLink) + \" | \" + md.Link(\"ü§∑ Abstain\", abstainLink) + \"\\n\"\n\t\toutput += \"\\n_Note: Only assigned validators can vote on this application._\\n\"\n\t}\n\toutput += \"\\n\"\n\n\treturn output\n}\n\n// RenderMyVotes shows pending votes for a validator\nfunc RenderMyVotes(validatorAddr address) string {\n\tif !IsValidator(validatorAddr) {\n\t\treturn \"You are not a registered validator\"\n\t}\n\n\toutput := \"# My Pending Votes\\n\\n\"\n\n\tapps := GetApplicationsForValidator(validatorAddr)\n\tpendingCount := 0\n\n\tfor _, app := range apps {\n\t\tif app.Status == StatusPending {\n\t\t\tbounty := GetBounty(app.BountyID)\n\t\t\tif bounty == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpendingCount++\n\t\t\toutput += ufmt.Sprintf(\"## Application #%d for Bounty #%d\\n\", app.ID, app.BountyID)\n\t\t\toutput += ufmt.Sprintf(\"**Bounty:** %s\\n\", bounty.Description)\n\t\t\toutput += ufmt.Sprintf(\"**Bounty Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\t\t\toutput += ufmt.Sprintf(\"**Applicant:** %s\\n\", app.Applicant)\n\t\t\toutput += ufmt.Sprintf(\"**PR Link:** %s\\n\", app.PRLink)\n\n\t\t\t// Show DAO proposal details\n\t\t\tif app.DAO != nil {\n\t\t\t\toutput += ufmt.Sprintf(\"**Proposal ID:** %d\\n\", app.ProposalID)\n\n\t\t\t\t// Get proposal and show vote count\n\t\t\t\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\t\t\t\tif proposal != nil {\n\t\t\t\t\tvoteCount := 0\n\t\t\t\t\tproposal.VotingRecord().Iterate(0, 0, false, func(v commondao.Vote) bool {\n\t\t\t\t\t\tvoteCount++\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\toutput += ufmt.Sprintf(\"**Votes Submitted:** %d/%d\\n\", voteCount, app.DAO.Members().Size())\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput += \"\\n\"\n\n\t\t\t// Add vote buttons (yes/no/abstain)\n\t\t\tyesLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"yes\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\tnoLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"no\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\tabstainLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"abstain\",\n\t\t\t\t).\n\t\t\t\tURL()\n\n\t\t\toutput += md.Link(\"Approve (Yes)\", yesLink) + \" | \" + md.Link(\"Reject (No)\", noLink) + \" | \" + md.Link(\"Abstain\", abstainLink) + \"\\n\\n\"\n\t\t\toutput += \"---\\n\\n\"\n\t\t}\n\t}\n\n\tif pendingCount == 0 {\n\t\toutput += \"No pending votes\"\n\t}\n\n\treturn output\n}\n\n// RenderValidators shows all validators\nfunc RenderValidators() string {\n\treturn ListValidators()\n}\n\n// Render implements the Render() method for the realm\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn ListBounties()\n\t}\n\n\t// Check for special paths\n\tif path == \"validators\" {\n\t\treturn RenderValidators()\n\t}\n\n\tif path == \"leaderboard\" {\n\t\treturn RenderLeaderboard()\n\t}\n\n\t// Parse bounty ID from path\n\tid, err := strconv.Atoi(path)\n\tif err != nil {\n\t\treturn \"Invalid path. Use /r/greg007/gnobounty for bounties or /r/greg007/gnobounty:validators for validators list\"\n\t}\n\n\treturn GetBountyDetails(uint64(id))\n}\n"},{"name":"storage.gno","body":"package gnobounty\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nvar (\n\tbounties      avl.Tree // uint64 -\u003e *Bounty\n\tbountyCount   uint64\n\tminimumBounty int64 = 1000000 // 1 GNOT minimum\n\n\tapplications     avl.Tree // uint64 -\u003e *Application\n\tapplicationCount uint64\n\n\tvalidators       avl.Tree      // address -\u003e *Validator\n\tvalidatorList    []address     // List of validator addresses for random selection\n\tvalidatorsPerDAO int       = 3 // Number of validators per DAO vote\n\trequiredVotes    int       = 3 // Number of approvals needed (3/3)\n\n\t// Validator reward percentage (5% of bounty split among validators)\n\tvalidatorRewardPercent int64 = 5 // 5% of bounty goes to validators\n\n\townership *ownable.Ownable\n)\n\nfunc init() {\n\townership = ownable.New()\n}\n\n// GetBounty returns a bounty by ID\nfunc GetBounty(id uint64) *Bounty {\n\tbountyInterface, exists := bounties.Get(ufmt.Sprintf(\"%d\", id))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn bountyInterface.(*Bounty)\n}\n\n// GetBountyCount returns the total number of bounties created\nfunc GetBountyCount() uint64 {\n\treturn bountyCount\n}\n\n// SetMinimumBounty allows setting minimum bounty amount (admin function)\nfunc SetMinimumBounty(amount int64) {\n\tif ownership.Owner() != runtime.OriginCaller() {\n\t\tpanic(\"unauthorized: only owner can set minimum bounty\")\n\t}\n\tminimumBounty = amount\n}\n\n// GetApplication returns an application by ID\nfunc GetApplication(id uint64) *Application {\n\tappInterface, exists := applications.Get(ufmt.Sprintf(\"%d\", id))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn appInterface.(*Application)\n}\n\n// GetApplicationCount returns the total number of applications\nfunc GetApplicationCount() uint64 {\n\treturn applicationCount\n}\n\n// IsValidator checks if an address is a validator\nfunc IsValidator(addr address) bool {\n\tvalidatorInterface, exists := validators.Get(string(addr))\n\tif !exists {\n\t\treturn false\n\t}\n\tvalidator := validatorInterface.(*Validator)\n\treturn validator.Active\n}\n\n// GetValidator returns a validator by address\nfunc GetValidator(addr address) *Validator {\n\tvalidatorInterface, exists := validators.Get(string(addr))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn validatorInterface.(*Validator)\n}\n\n// GetActiveValidatorCount returns the number of active validators\nfunc GetActiveValidatorCount() int {\n\tcount := 0\n\tvalidators.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tvalidator := value.(*Validator)\n\t\tif validator.Active {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n"},{"name":"types.gno","body":"package gnobounty\n\nimport (\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\n// Bounty represents a bounty post for an issue\ntype Bounty struct {\n\tID          uint64\n\tTitle       string // Short title for the bounty\n\tIssueURL    string\n\tDescription string\n\tAmount      int64 // Amount in ugnot\n\tCreator     address\n\tCreatedAt   time.Time\n\tIsClaimed   bool\n\tClaimer     address\n\tClaimedAt   time.Time\n}\n\n// Application represents a claim application for a bounty with a private DAO\ntype Application struct {\n\tID         uint64\n\tBountyID   uint64\n\tApplicant  address\n\tPRLink     string\n\tAppliedAt  time.Time\n\tStatus     ApplicationStatus\n\tDAO        *commondao.CommonDAO // Private DAO for this application\n\tProposalID uint64               // Proposal ID in the DAO\n\tVotes      []VoteRecord         // Local record of votes\n}\n\n// VoteRecord represents a vote cast by a validator\ntype VoteRecord struct {\n\tVoter  address\n\tChoice commondao.VoteChoice\n}\n\n// ApplicationStatus represents the status of an application\ntype ApplicationStatus int\n\nconst (\n\tStatusPending ApplicationStatus = iota\n\tStatusApproved\n\tStatusRejected\n)\n\n// Validator represents a validator who can vote on applications\ntype Validator struct {\n\tAddress address\n\tAddedAt time.Time\n\tActive  bool\n}\n"},{"name":"validators.gno","body":"package gnobounty\n\nimport (\n\t\"chain/runtime\"\n\t\"time\"\n\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// AddValidator adds a new validator to the system (Admin only)\nfunc AddValidator(_ realm, validatorAddr address) {\n\t// Check if caller is admin\n\tif ownership.Owner() != runtime.OriginCaller() {\n\t\tpanic(\"unauthorized: only owner can add validators\")\n\t}\n\n\t// Check if validator already exists\n\tif _, exists := validators.Get(string(validatorAddr)); exists {\n\t\tpanic(\"validator already exists\")\n\t}\n\n\tvalidator := \u0026Validator{\n\t\tAddress: validatorAddr,\n\t\tAddedAt: time.Now(),\n\t\tActive:  true,\n\t}\n\n\tvalidators.Set(string(validatorAddr), validator)\n\tvalidatorList = append(validatorList, validatorAddr)\n}\n\n// RemoveValidator removes a validator from the system (Admin only)\nfunc RemoveValidator(_ realm, validatorAddr address) {\n\t// Check if caller is admin\n\tif ownership.Owner() != runtime.OriginCaller() {\n\t\tpanic(\"unauthorized: only owner can remove validators\")\n\t}\n\n\tvalidatorInterface, exists := validators.Get(string(validatorAddr))\n\tif !exists {\n\t\tpanic(\"validator not found\")\n\t}\n\n\tvalidator := validatorInterface.(*Validator)\n\tvalidator.Active = false\n\n\t// Remove from validator list\n\tnewList := make([]address, 0)\n\tfor _, addr := range validatorList {\n\t\tif addr != validatorAddr {\n\t\t\tnewList = append(newList, addr)\n\t\t}\n\t}\n\tvalidatorList = newList\n}\n\n// selectRandomValidators selects N random validators for voting\n// Uses a simple pseudo-random selection based on application ID\nfunc selectRandomValidators(appID uint64, count int) []address {\n\tactiveValidators := getActiveValidators()\n\n\tif len(activeValidators) \u003c count {\n\t\tpanic(ufmt.Sprintf(\"not enough active validators: need %d, have %d\", count, len(activeValidators)))\n\t}\n\n\t// Simple pseudo-random selection using appID as seed\n\tselected := make([]address, 0, count)\n\tseed := appID\n\n\tfor i := 0; i \u003c count; i++ {\n\t\tindex := int((seed + uint64(i)*7) % uint64(len(activeValidators)))\n\t\tselected = append(selected, activeValidators[index])\n\n\t\t// Remove selected validator to avoid duplicates\n\t\tactiveValidators = append(activeValidators[:index], activeValidators[index+1:]...)\n\t}\n\n\treturn selected\n}\n\n// getActiveValidators returns all active validator addresses\nfunc getActiveValidators() []address {\n\tactive := make([]address, 0)\n\tfor _, addr := range validatorList {\n\t\tif IsValidator(addr) {\n\t\t\tactive = append(active, addr)\n\t\t}\n\t}\n\treturn active\n}\n\n// ListValidators returns information about all validators\nfunc ListValidators() string {\n\toutput := \"# Validators\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"**Total Active Validators:** %d\\n\\n\", GetActiveValidatorCount())\n\n\tif len(validatorList) == 0 {\n\t\toutput += \"No validators registered yet.\\n\\n\"\n\t} else {\n\t\tvalidators.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tvalidator := value.(*Validator)\n\t\t\tstatus := \"‚úÖ ACTIVE\"\n\t\t\tif !validator.Active {\n\t\t\t\tstatus = \"‚ùå INACTIVE\"\n\t\t\t}\n\t\t\toutput += ufmt.Sprintf(\"- %s %s - Added: %s\\n\",\n\t\t\t\tstatus,\n\t\t\t\tvalidator.Address,\n\t\t\t\tvalidator.AddedAt.Format(\"2006-01-02\"))\n\t\t\treturn false\n\t\t})\n\t\toutput += \"\\n\"\n\t}\n\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"tvh/nB0OnmRq6TeUxiyOnlTnp0eBiyheEJpK72xqK+XdaLS02A7tXOYFa5czNUT3fGvz+ESkTIHsKceQPmSNDw=="}],"memo":""},"metadata":{"timestamp":"1765360631"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"1000000ugnot","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty","func":"CreateBounty","args":["test","test","test"]}],"fee":{"gas_wanted":"6478926","gas_fee":"6479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1OhdYrJnS+UuSOBm0MLM5WqhQrh4zn1yZRdaZaFfuAO41RTb+JCLJWdIw0Ov+29Mx3rS+zHnQaYb2kuvraCsBQ=="}],"memo":""},"metadata":{"timestamp":"1765360752"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"1000000ugnot","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty","func":"CreateBounty","args":["test2","https://github.com/gnoverse/community/pulls","do it"]}],"fee":{"gas_wanted":"6529046","gas_fee":"6530ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"fP74lDqyC8SiiGlhkhOSAKraiyFZmsoi6/wZi0oVO9rPu736v4O8YbTAYPTjCRoBawpx1obnc7GPaOVOPjOFAw=="}],"memo":""},"metadata":{"timestamp":"1765361742"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"290880ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"k1KHJeIL8OHdog1Kn6XinkKg5w+vz8rDkjvI+EnFctE5JfhUX84SA0Md/lWoGnYBLjLrxDUMRSggrU3Pc0IkDA=="}],"memo":""},"metadata":{"timestamp":"1765416689"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"290880ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"01gIlpBGolKQiXBQphjnLM6o9za2ZDBFT0HRkXZNGaLZa3yBsm3gdm8plqgWH4TlaNBsgMVuDYgArYeKQxF8BA=="}],"memo":""},"metadata":{"timestamp":"1765416694"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"wv949Dqagw0JUsy9KjKRCPslp4j/68/7XoA8edyk5Afs932p+zTd/aAXS5dUH6Qi8c6tgv8QO5a7W+xdZ/Z4Bg=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"wXDecmQajmGaDli34zHUcP7gH9vgexxen4yxGb/peaCyy1eNKzwNAQEUpnXulx7FkF93w4I5G+W/m8EjkvliBQ=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Vk8TwCOJm+wFj21LaV8A1WBvjHCG7enPFOhzF/37daR/xUanfmJhe1YLcF8klkLI3POPvAdFhpDpubI5g+PqCw=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"5BVcxbPPZ0zVgqln8PGPnY5LWRh1WxA9kNNAjHEeSQITaSN4h/7ybaFIYdnN/LVyhQcfm4EanC1aru7++hyMAw=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"o281cRQpGwI+hhTVTVL0B70P2LzDkvAcCHrc8QXZeIqRTINvLdRbNi1l2RFXRQr7tIVri57mKJHvz1LWAc0BDw=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"E3whF3nLWizJSzGRICrqoTu7Evua74cHK7IkIp5LzRkktFw0Bk7VOMv3HQzmFTsEwxCh8P5lqlbSp8GN/rFuDg=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"zeEkXftIaW84fyBrzlg+topmHZLWHiIh9QxFqSexsjCYbYRdWqbI+IQdgoQPxpDZ6+6+xX6nFoUyw2xaotCPBw=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"0qmOvIT6JWROQrCA8W3MxK49e4kE/Q1D+3gckN5B6o6wM+pp0TdhbCE/hhkKL/kFO1AgH9/qKY5E9IQG8RBhBw=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416699_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Tzo7PnzlPPsNdk92sdSVE7TGaQgdXTuWQa4ro+JQugHjAjzzMQ/KA6Iy+YCAS+zSbEUOP+TEoyogxpXa/ZFeBg=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416699_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"NlnnhKCQZ/JdcIHwSzsFiNvCDNMPGPNKRb7LVPjm7woz4HhfsmxwkiWAt3OrpZaKG2ITyRYlaw+GTl+5eh1QAg=="}],"memo":""},"metadata":{"timestamp":"1765416699"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"2843295ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iIZcR49jCAgFOQQGYTsRRrU9BhBvh43mU9qlR+bLvJ657DNqwkmlVcanmm+dYflMq+/s4dHE+P72QMpv1bX0Cw=="}],"memo":""},"metadata":{"timestamp":"1765416794"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"2843295ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"y2OXRK4dJeyYzN1ClIpnvQWYQFH6y3xonhZgnDoA4fy/Jpv4YMA29xi/umVFH2JYOwuYa9M1LoaEfKu1PSn7Bg=="}],"memo":""},"metadata":{"timestamp":"1765416799"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iRbqMnQsdRLr4MfMxaX4Uv6j7edMAz/9sDTUz5EOm7rTRGQf5/scE0AhrQD4uWR+nZUQbPnPsJVnfMXD6ddZCw=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"C8jHPeIiZipPTd10oN4Fkh81D9F8uZ2uEU5Ar8ysWDRjPEyMeYhFhuFEIvPYEFGSGD73CppkGUW2gB4rmb+CAw=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"EXs08paJsYgS5vMXbVLHspo7enhX7W8aus1fPYnvYoD5mYTGF44FHcL4xwzCPTeRnYPJb3NExBjUB+VN7OTsDQ=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1wOj2sRkBR4b0DScRPmJUz9IBCS0mB5a0qMI+WbnOpv83soeNZQRLWthc64Vto+jynqR/If3Hx+8dKvc0DAgAw=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"sWH41Z2ARHYYgk9yLo188OZ8idLI/NkhQ6BBTfDx03U7VwQV3HFlMzC4ZXpa0vlDJMNQ8RPwiXkLFwlaLSiTBQ=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"TTqQGFyEuakYP30piVmK3NKo5DkpEOntzT6hx/b+yEY7bq93kvmKGywhUR+gXYyeS296BsGqbpXOEky9QqJNDw=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"IQQniom25SR+pHcwy5kWWsD3KAteFGZ8o4v0k+GmCZ3ejp4N2btQtD/YhhR08Zn9HuKSB6GYDiAo33H/URYWAQ=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ts/78XZqWWDTVKNUW+W/7mJiRx2KThA/lRmQ/xexHpaRc6Ppsl4+I99NIRfEch+d1j31sAr46ONKr5d86mgLBA=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765416804_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"uLh3pH59EokaNrQvVn9ibPHUYBS7slzxm+musSeW1O8YU/O5XeSTVuRfkUDLrJ9Z2kir+d/lRx/I3qlWeuDdCg=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765416804_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"sKGHjLVcT2oygJYdt07geATLBKHXctmMqvT1cG7cZpVEmhiqpSdqZwGStMc66mLJMLCyVhTvLyoq9C1G6+YcCQ=="}],"memo":""},"metadata":{"timestamp":"1765416804"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"runtime","path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"598830","gas_fee":"599ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"3ekqSissqtpRMJqYmj63/JLuQru2kC+CcjsFSFBz54FaqzVxufnY5gkkhlhjyPG24ZR1bohfgrHh6Ws9euryDA=="}],"memo":""},"metadata":{"timestamp":"1765416895"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-0"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"0MJVRu/Ou83nDAM+xLPhsiLTU9ASLsaKASNcZw4upH9syGVew2c7Klin1YqovSbqeBq2YJ9+N/D03spA3+3xBg=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1IIxdtxp25cbIGapWAIAewIFL1sDtgHze2Cy6O/Ao4SrCizcHwPiDL7njdbJNIRT5Lsd/HH17t44xEjZt9dOCw=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"pzvx7c4ModV/uXTYM5GNN+KC7EaGqLyA7HMjv3I41tyOR8SOTJ/QHYZKOAHNoRNKdxbCzfBy+29EE6s08XfWBg=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"/LxlpeRpk2f09V7vRZNjE/4cArkHV5KocLusCFojHUIzct5Ric8B1DSo4PeRcm+0IwXgTKt4ec35pCGxafCUAw=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"TJRQs0V2P1SYe3xxlxzJ3JaxurhN+U3LuLn5XHnA0TpvYn+NBbiJsmY1vws7cDUWrDU01+4F8RXR3iWxl5LKCA=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"fRy6nk3DqKXFmq0ePDtlf9/I3x6A3YOQ2LcQZyaO35NtL0rbAU+zzXBFeeq0vhextOnNZKwCcWfEsPazeJDIDQ=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"KYoHYoaf3eFDlIJZpOdjaHEgKs9P+crerL1Ru4GAO0+SFIdnHP2eKdIdRNvifT6rATs3VmOLYMJ9MXBKMhBXCQ=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"+EgA5Nr3UvGwNVMjRWJyehkvpLZHWmMLW/QOtTl00D1hyC+XHcCQvYHIpDUwG86Fi1Ne/x0RDH1CcxirQE7uCg=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"f7hDV3+9aKsIGF8Dh+CEAouFAUACVL3x6szFJVEu9bDvKYvFeKaND3UjcNs6+xlr8d3iK0+3Ql3BBySJna4yDQ=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765416897","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ma3aWAaiz0mU98QyAFgBA3Q2PvNdsmeWhyvggboZRGAxTSHaQOA2UZCk9PExQ8E7dZvK3Bksr24TxspJNHKcCg=="}],"memo":""},"metadata":{"timestamp":"1765416900"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1g4cttr7z65uvnsh08w4cw3gncy54tvupz24qh8","amount":"1000000ugnot"}],"fee":{"gas_wanted":"52246","gas_fee":"53ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"D4dg3s+yFX7QXfDgIZZ5yM5tU1XToTcrN7uiJDY5iIv0QwD7GrLEJmd+TtXJBb5DO4PfQ9lsTQ4rLXesXmyxBw=="}],"memo":""},"metadata":{"timestamp":"1765439959"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1eg0lxpnulp2acxlhzfq2x9h3jp404nlmcf3qc9","amount":"1000000ugnot"}],"fee":{"gas_wanted":"52246","gas_fee":"53ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6hzX6e01uaZMBR3reROa65zT6cejB2yMyIgIYmeo6Rkllr4VpP3rom2WS1BhEdpiKPiifPdPeJJNs++yOzcBCg=="}],"memo":""},"metadata":{"timestamp":"1765439979"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1pmjf4fgcd0k6pxrdzj2veggsj95zxqwk9rehwg","amount":"1000000ugnot"}],"fee":{"gas_wanted":"52246","gas_fee":"53ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"f21+3pVM81l5UH63AdCQdTz5V5OJ2HmFM9GnqalUG8fjNEwb4qYwNAUWas8Fg4X/umZXNtOSZMhar7S6xCFWBg=="}],"memo":""},"metadata":{"timestamp":"1765439989"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1g4cttr7z65uvnsh08w4cw3gncy54tvupz24qh8","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"100000ugnot"}],"fee":{"gas_wanted":"48341","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"I5l0eaXMwgtfxLrTvDtrY5SNrYsX2gBPCDZCtMKAC2Xg4nSqfnmR9uDBiHQcRbU/uuI56NFU3ZpaHuCAUeHMAA=="}],"memo":""},"metadata":{"timestamp":"1765440089"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1eg0lxpnulp2acxlhzfq2x9h3jp404nlmcf3qc9","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"100000ugnot"}],"fee":{"gas_wanted":"48341","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ubNqtQkr9BdlK2FrNrWZYpZFK0gMMOKSlWMZPLBpBewVLWHMKMfW9lgL09RSJGi23pz3z2YZtytJDPryvimNBg=="}],"memo":""},"metadata":{"timestamp":"1765440100"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1pmjf4fgcd0k6pxrdzj2veggsj95zxqwk9rehwg","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"100000ugnot"}],"fee":{"gas_wanted":"48341","gas_fee":"49ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"CcEzsQWz/zgCkOYOydMsZ9OVQ8SEsSKXkrQk0Bqs89r0LYCXpOZ1gKXVEta82qKg7PeAFDe7qazOlX2b33kvBw=="}],"memo":""},"metadata":{"timestamp":"1765440110"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1g4cttr7z65uvnsh08w4cw3gncy54tvupz24qh8","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"10000ugnot"}],"fee":{"gas_wanted":"45826","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"j38ENnv8kjKyYnEBEPU+Z32lLpKj8TN2RJu6QiguIygIGGl4LLhMFpE8ZywjlQsdXdupxd198bzfmVhpThz2DQ=="}],"memo":""},"metadata":{"timestamp":"1765454494"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1eg0lxpnulp2acxlhzfq2x9h3jp404nlmcf3qc9","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"10000ugnot"}],"fee":{"gas_wanted":"45826","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"jF6zdRX1toOLMbiDywCafQa8sFbtJXHw7SSgUmDcEwUXtAM99xb+CHZPoLx6gUWNNfMSKJ6Xp0D/9ipvZlThCA=="}],"memo":""},"metadata":{"timestamp":"1765454509"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1pmjf4fgcd0k6pxrdzj2veggsj95zxqwk9rehwg","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"10000ugnot"}],"fee":{"gas_wanted":"45826","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"LtvmIxZd8m1ODQ+l92oMTSLQbnp3ocwCKbRO04zz6GgPdQ6wBJ7nNxDlNbDzgaReqoLxn5qDQvrMBnNnHwvnDw=="}],"memo":""},"metadata":{"timestamp":"1765454524"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1gdfr9rlny9xqgrlj8ll7np7x29fnfle64jjqxe","amount":"5000000ugnot"}],"fee":{"gas_wanted":"49336","gas_fee":"50ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"FF/MuiLfxBMLNwrX4g17Ba9QZ2IPZH1xWoE3GgozsPw6YSjH15FLp6v3FFGWPn/PMH48odQAjHs45JLTgEe6CA=="}],"memo":""},"metadata":{"timestamp":"1765454685"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1y6hgjuw2qcd65dhyn5kym5rkvuw7vupntx5twd","amount":"1000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"a8a+A214J282uFiKzmtzxpbSExn2DqiCM+k+Ct8vggJD/YaD3k2hDgg+kl28fGtUSvotaXqQH+ciazA+F9R8AA=="}],"memo":""},"metadata":{"timestamp":"1765460450"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1vjrx0lks65yefnsz4xk92vugda2z25esh8g8q9","amount":"1000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"jLuKR0+W5NTXq6vCO1VrUOezFuTe36L8IJlJnaiAtkyr1/0h7FCtyfm+TnoTCSwAGfcAqNyouk4Z66djeQUtAg=="}],"memo":""},"metadata":{"timestamp":"1765479601"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1g4cttr7z65uvnsh08w4cw3gncy54tvupz24qh8","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"1000ugnot"}],"fee":{"gas_wanted":"45815","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"9oT1n21UUT7n+3MpiSbnO9G37asaF+nb90J3W+/4IyxPzRCkVZRLQrIeRgc10ZfJ8P+17oAjnToeWeHZNHG9Ag=="}],"memo":""},"metadata":{"timestamp":"1765500827"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1eg0lxpnulp2acxlhzfq2x9h3jp404nlmcf3qc9","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"1000ugnot"}],"fee":{"gas_wanted":"45815","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"QctY5fU+v8KFL8JdxnaiQMWGvvXUHCnbF7IjOMJA1CCKkLU89Lr8LTHMovqZS9o9HZ5Z1evgwF97BPfIX7ViAA=="}],"memo":""},"metadata":{"timestamp":"1765500852"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1pmjf4fgcd0k6pxrdzj2veggsj95zxqwk9rehwg","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"1000ugnot"}],"fee":{"gas_wanted":"45815","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iUiK2SFaGucy330ZBHmaj3TYGnK/Da8ap3wB+OApDz4xpgH6VWkuye4SIRn8HE0bAHQGnevWxS9RQ0JAfN66Ag=="}],"memo":""},"metadata":{"timestamp":"1765500877"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"290960ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"p6Z/h15lLa1vVILXySpyzlW22KH8GVt2iI85ZcljQqQG/wZ5vdPUUB+c/psCY/NuGWkO41eJip94KYhQBQ6QDQ=="}],"memo":""},"metadata":{"timestamp":"1765503089"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"290960ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ceSsLhbFTF7j9KliHWlxJQ/J1hj3P20LBYzY1yriIPb0h9Z+Dh5iqyyP5zjC/s34YZ5R3Czeb1MDvjkbsO9PDQ=="}],"memo":""},"metadata":{"timestamp":"1765503094"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Qqy8yPbR4Bv4IpPShFBxK2sY4Ed9o0F2b91m8LtjAt1ProF6koKoSVbGY8vtlh6kRKlGhetyKIp832N7hpYYAQ=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"QMCoIkd+uiNAe+KuGIo/3TXJaZAowuXn2vi4tuH0giI3FTh569fO7WufZOi0/umnb1w6lFJzqYinQNKxjiFhCA=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"uDy+FL4w1lFRZPz6ygh++tFh4AMbuodsU9zpk+3OSYdzbAcO3gnFGS9sk14iQKCPoRA3cAcq15H5pO1a0F/nAg=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ZcAdbHxvFTIVUwLp5x+lqt017B+oHddC/iunXHWA1yvAOkI5XtKsgNOQFd75Nf/j5L+uKe+FlHALP1teojBDBQ=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ThPGWkamkAnAeVKYnO8q3WJ40VhZw7+BScqbelu6c+u66Yp+zwc/sCQEoh8RCJY13dzcTIikgfMsn7lz6UBtBQ=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"+hhJA9ZGILK3QFkoYk0t35g82+REJ8LsBs0OF37E/POAD4Tv3rLAtAxzdkRmMMdeEJvgKI+dDYE4RsafFVN7CA=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"kqY8raePxJvzBkvTNZPqT00gy9gwcvIpvzT0mu2rIg3HDmy1Kj0FXvROgm4EexS+koqJtPDW13rdsuxi/ArIDg=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"IdXyuTHQB3zn1MDICS95LjmynCd6gPozolvzF+8Evg2KGwL+uA2/u/0i73UchGx331GuiKKpO9Oz/KANsqYjBQ=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503099_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"zFfYgBH1YdvkBsrvMNd52K8gWPFgpKazWEfKlqWsPZAg/5NrXg+YLcxrfAo52IeAQuQCHGpYWvOEvfFYslKfAQ=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503099_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"478348","gas_fee":"479ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"bW+vP8M5Y09mo/APiEJ2MBomuqNv4LCgXs5y05/20tpWHOC3XGdWNEAMPey47dS4s1k11Awst9iiLDDiXeIMAg=="}],"memo":""},"metadata":{"timestamp":"1765503099"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"2843295ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iIZcR49jCAgFOQQGYTsRRrU9BhBvh43mU9qlR+bLvJ657DNqwkmlVcanmm+dYflMq+/s4dHE+P72QMpv1bX0Cw=="}],"memo":""},"metadata":{"timestamp":"1765503189"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"2843295ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"y2OXRK4dJeyYzN1ClIpnvQWYQFH6y3xonhZgnDoA4fy/Jpv4YMA29xi/umVFH2JYOwuYa9M1LoaEfKu1PSn7Bg=="}],"memo":""},"metadata":{"timestamp":"1765503194"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"P/xyll8lWrDF3jcMmyi3YS0ryaYiFHtBhqTqIBOwlHqcrRNWcvo87hXiq0tmssNxYoNyyv/2GkZjcgbbL6UHDg=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PNrepxgV+BowQEUSjW2pRKYuEij5AFHtmnQfImYK0QVp5AoM+G8aSDTf7cIL+f7J1CISbLtP8luGG8JeKGV4Dw=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"QcX9nrGu9BHGZ4LA87lqmU4y72zEhaMcuJINLU+k5ro0gPh4JxMdh21Ky/MCKi2u/5fJlpbcBeA3ty1zc9vnDA=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1EMfazvBsdA31zqtT2tW83xvCa7/MQyYLdfoIpzRj8wOAFq0YJML/wAJoamDDY9JpaOAYkGuqGbA6sBRdeS8Ag=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"8YMyRnjAbHbsrOb7LUhaLBrEvXUmoHRMaX5fmTiC6moaUSk4TVRwbLccfUb94kLuOoeeWu3kttinRwybVRGeCg=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"I/nejqyGFMqrQ+omvp7p8nT2Z87qFNOlgyaGvFgbiZR2yWFYynkJ7Af2dS4DPHjqSWEFyy/Lp7RK8ngG3qZ4CA=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"4EsYj/Kwr8VKlNiaNrc9wbpN9SFbVSjdXWqrTZLTr4PnznF6ZwJ2UMiuXcoVHsXDnUk0l7IWo1mvLZJUt/1OCg=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"0E9ManLUF+RgOB3QqgFQTj5CjWBjaTdn1KTENogKHfVqa41dgQyyK7OSZ3wSms4b/VZJTve2gqYhSII563zqAw=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765503200_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"lJlnTNokjr9em+Kxs1hD9bZB/ZxeO6hIHmqIEVL6hPJyRa9NdstndHtqAGXR8Y0g+QufpCbitsv8bYA4rFZ8Cw=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765503200_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603496","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Q9mZn0pRl74O3c/4ky6vw7wPP/ASm7p61aIsX1BSvsAcEh9LkY96CGFMXN95UkGAGpbViqdXrUTyrgyTYnS3Aw=="}],"memo":""},"metadata":{"timestamp":"1765503199"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"runtime","path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"598830","gas_fee":"599ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"mT+qD3GHUKb0GO/2C7VjIlQ1w3OViAbRXHoSYYtYKuLXI+g/sD0+fxKjjkyAPBtbC6vh9igoaFAzq+T8eNJ4Dg=="}],"memo":""},"metadata":{"timestamp":"1765503285"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-0"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"8fouOMLs1etOlNwdAJSTH2c9oYxQMNjrNGWK5FchjASSwIPSX4yMJvHAGKwD9NaOeDiHXCPoDDYoYwuWlA09Cg=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"FBMOYp4Fz+Nv10Eaa8YNsvXVyIX36YYmAZoZTm/QzJVrM/5hSeNOXr+WgoFciGd8yzfHcfBSz7Qem/bCBHFmDw=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"d+go6QVt9IBWcJg692BGWfalVYNYzchZoGMtThmWXsH5WFjcfbPrDEJfXDOOqLgMVQ0FkFnT1kHNKBchWth2Bg=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"bQu0On58UZH62QLqZoXnpAHfETgByJy/bfkt7nfzWC2OHwRhTl1YqR53th5K8YJ/+BhZu1OLAJB5IaoDQWRGBw=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"cOzSuMyZFqV2ZvjFGBj2ycGHEax6MLFCZNnGa6IGlW0oMV6LcvhZoUvK6OVSTal+wC+YBQTvbQfxp17BvIO6BA=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"eHR1gUlxCGXgh1AsBzeCCMe7o5x/1RpY65Z5or7BFwvseM+eZdZ376ExmAE9U951f6BwsCA3fwvuAEz5RLV9Cg=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"lJYCE89A9MKTydGFZE9IlECrMH2ZePdyf2cIUSvh60ueHp819NdH+PJJItS6sbU1rW8d3Tffah7hvoIJD/rICQ=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"79U4MgEhz/9IZIr1tQes34nkBOauHgKRK5onz8Fbwm9OputJfcvCaDGbYVViPx6qyKxr9CrBwNJFGkAktOIoDw=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6k5iU8PyOVqyYB5mTRTKkMDYWr/WdH3T38AJPWK+KL3oqqzzd7hf4gy5aMG/JE9LgXUyqzq/9WM8bbuhRjBDDw=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765503288","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"OK/mE3RUB2O/9KIDH/FDuQ4JYWW+Yck5GI4rXmHtQlLS+P5ekwaLppNthx7+tQ6kVpC9HztiwnOitOTJChNQBQ=="}],"memo":""},"metadata":{"timestamp":"1765503290"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g17290cwvmrapvp869xfnhhawa8sm9edpufzat7d","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"4189047","gas_fee":"4190ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"cjlzDM6Gn6UkqdBZuV9a7ZRt911Jc3+PMOrlBUCc//fb8Ws+r+mNhNbbfZoW8sstaJy14T4d+5wiy6zIolszBg=="}],"memo":""},"metadata":{"timestamp":"1765505818"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g17290cwvmrapvp869xfnhhawa8sm9edpufzat7d","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"4104669","gas_fee":"4105ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"TdTkntcpYPPEWcGB+asIrcEp+aZHKxDaH/0Z/XR8CN3zuD9YSi6jsu+pezm/EVAQrd6pCZRvfkQHQiC9RUfOBQ=="}],"memo":""},"metadata":{"timestamp":"1765505858"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1h4de3tdpy00vz7m0xqatnc50q2l98xgc4wmzxr","amount":"5000000ugnot"}],"fee":{"gas_wanted":"52246","gas_fee":"53ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"R60dw9V0QaolwDHahnuJZD6+EIvQjbeLUZvOl6LibYKtVNYdx6DQSemeaO6foVGA8cIqv60FJ3XSW7KbJP7KAg=="}],"memo":""},"metadata":{"timestamp":"1765524792"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1caam202v07etgtvk79wcv6m0k2uzjqqqkwrkln","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"s8QkCVJwcBk2ZLqZ9Yynuy2Bc6frdHT/F8kw8v8g+1H7Y2c2W1CwTbFqWezvR/zPp2iRs7RH8kfraV4cIYF5Aw=="}],"memo":""},"metadata":{"timestamp":"1765532065"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1jwzv6s4s9hktyepz0gzhl0hlfh5yruspejvmyz","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PDxTBsELKjYTCthcKCWN7OHutQRhlVm4otviwcfzH/R5itU+etZbgcfVIn7wbQyyMR5ONQp9zxFTlbC7BlM5AQ=="}],"memo":""},"metadata":{"timestamp":"1765532075"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1fj2lzq0q00k9uxupqxz2zmk0jmmwhhftpy6f50","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"4nbyDEQqGJ9JMVSyfxa8AHSkqaje8taxQjdNLu4MfY7qOfY0fMga4iiZgoa1JT234fq6FAUVxguHh5EM5jOiCw=="}],"memo":""},"metadata":{"timestamp":"1765532080"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1drt5pa3qezked3j0gy5dtwu7wc5zv9vrv5p8nz","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"rMtpeN5aczfXJPQBjLE2G7gaoIcst492ZymYdeJ/GHmN97ryoNa5jYK0iC6nVtpmO+unnE1vNfIR5EuXiRBcDw=="}],"memo":""},"metadata":{"timestamp":"1765532086"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1avg5276m5rwk5a56akfg550qdel7d3jkdckr70","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"euQtgyZCfw0oVIwEAZALu3JS6WNsJm9MqcRjmI8eQe3tsysz07ZYwSWwrFY2qzmtXv9Sj+++jjfKubnjzb4mCQ=="}],"memo":""},"metadata":{"timestamp":"1765532096"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1uwg3z7sl3y35pfmtkwgs3gmnd2s077jz9zkcvp","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"YiNh92EZfctr/rtcpPp50PCy+d7zQGjjSPqfIHjoK2qOktOq4nkYyujqR7Z21b3ORNAs0XwNmuzQMD2HMRtiCA=="}],"memo":""},"metadata":{"timestamp":"1765532101"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1caam202v07etgtvk79wcv6m0k2uzjqqqkwrkln","to_address":"g1wvjhs6lzhscyhd3a5qr2q2lyrzmtvjvxf0cxpl","amount":"9999952ugnot"}],"fee":{"gas_wanted":"45692","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"46/aTKiYKtJtvRitU0lvZ9/LPj5J7AR6OsO/xYYqJbiB8xKVti7f0JZq5sc+uamr5smuAQdd+Kpkha8JZkQ5BA=="}],"memo":""},"metadata":{"timestamp":"1765532121"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jwzv6s4s9hktyepz0gzhl0hlfh5yruspejvmyz","to_address":"g1wvjhs6lzhscyhd3a5qr2q2lyrzmtvjvxf0cxpl","amount":"9999951ugnot"}],"fee":{"gas_wanted":"45692","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6jkYEbwmtfbhEByhPIl8xS9xejKnXdBbBxybNhqrLCj0HbdjPKasmcRUhEMkWdRFjmMLW1SfP5a0MM98oUIZBg=="}],"memo":""},"metadata":{"timestamp":"1765532131"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1fj2lzq0q00k9uxupqxz2zmk0jmmwhhftpy6f50","to_address":"g1wvjhs6lzhscyhd3a5qr2q2lyrzmtvjvxf0cxpl","amount":"10520224ugnot"}],"fee":{"gas_wanted":"45779","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"QJj9rGiRCqJPUZ7lY0/+itqAT7xcm0oHZezGy1dyBrGJsA3dP9sY0dYyQuk0UX4ysl7DdZU70s/Fyt0dM+1FBg=="}],"memo":""},"metadata":{"timestamp":"1765532146"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1drt5pa3qezked3j0gy5dtwu7wc5zv9vrv5p8nz","to_address":"g1wvjhs6lzhscyhd3a5qr2q2lyrzmtvjvxf0cxpl","amount":"10513771ugnot"}],"fee":{"gas_wanted":"45779","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"f+rbsbNn6w6idOsPlXrpTouVUSVobsRKvXyfjlfR7IyCgWpSapKvFq1UDS/0W7WVciM112o6lb6xC5jZSZc6Cg=="}],"memo":""},"metadata":{"timestamp":"1765532161"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1avg5276m5rwk5a56akfg550qdel7d3jkdckr70","to_address":"g1wvjhs6lzhscyhd3a5qr2q2lyrzmtvjvxf0cxpl","amount":"9999953ugnot"}],"fee":{"gas_wanted":"45692","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"a+o9f0r42bM4esuTm3otHvUpfH4cHtgs7X05fkW0bQ4cnHwOfLyw45CGWRMGZmrk6b742tCqnawJtW8tYEfIBQ=="}],"memo":""},"metadata":{"timestamp":"1765532186"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1uwg3z7sl3y35pfmtkwgs3gmnd2s077jz9zkcvp","to_address":"g1wvjhs6lzhscyhd3a5qr2q2lyrzmtvjvxf0cxpl","amount":"9999953ugnot"}],"fee":{"gas_wanted":"45692","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Wwuo/QZqIy9rsKBCx2KMeYkvfugr3Phxi5QmIXNmDVc5SV/BbwrAeI5scR+m00zirirEIYCIAJsCKZojh1GICg=="}],"memo":""},"metadata":{"timestamp":"1765532206"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765534242"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"1000000ugnot","max_deposit":"","pkg_path":"gno.land/r/gnoland/users/v1","func":"Register","args":["pierre155"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"kJIMfSDYmqmMAf8I+KWVpX4Fs8TH7vfu1cFPrYdTPImCb4amtMqns36KyESm8l0F0LvWxWQLg3EyJjUS3Vd+Ag=="}],"memo":""},"metadata":{"timestamp":"1765534312"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"daoregistry","path":"gno.land/r/pierre115/daoregistry","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/daoregistry\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"joinregistry.gno","body":"package daoregistry\n\nimport (\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tregistryDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 10_000_000 // 10 GNOT minimum to join registry DAO\n)\n\nfunc initRegistryDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tregistryDAO = commondao.New(\n\t\tcommondao.WithID(2), // Different ID from marketplace DAO\n\t\tcommondao.WithName(\"NFT Registry DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for NFT Registry\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinRegistryDAO - Join the NFT Registry DAO by staking GNOT\nfunc JoinRegistryDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\tsent := banker.OriginSend()\n\n\tamount := sent.AmountOf(\"ugnot\")\n\tif amount \u003c MIN_STAKE_UGNOT {\n\t\tpanic(\"minimum 10 GNOT required to join Registry DAO\")\n\t}\n\n\tif registryDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tregistryDAO.Members().Add(caller)\n\n\treturn \"Successfully joined NFT Registry DAO\"\n}\n\n// IsRegistryDAOMember - Check if an address is a registry DAO member\nfunc IsRegistryDAOMember(addr address) bool {\n\treturn registryDAO.Members().Has(addr)\n}\n\n// GetTotalRegistryMembers - Returns total number of registry DAO members\nfunc GetTotalRegistryMembers() int {\n\treturn registryDAO.Members().Size()\n}\n"},{"name":"proposals.gno","body":"package daoregistry\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_VERIFY_COLLECTION   = \"verify_collection\"\n\tPROPOSAL_TYPE_UNVERIFY_COLLECTION = \"unverify_collection\"\n\n\tREGISTRY_VOTING_PERIOD = 5 * time.Minute\n\tREGISTRY_QUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// VerifyCollectionProposal - Proposal to verify a collection\ntype VerifyCollectionProposal struct {\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc NewVerifyCollectionProposal(addr address, name string, reason string) *VerifyCollectionProposal {\n\treturn \u0026VerifyCollectionProposal{\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *VerifyCollectionProposal) Title() string {\n\treturn \"Verify Collection: \" + p.collectionName\n}\n\nfunc (p *VerifyCollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Collection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to verify, NO to reject\",\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *VerifyCollectionProposal) VotingPeriod() time.Duration {\n\treturn REGISTRY_VOTING_PERIOD\n}\n\nfunc (p *VerifyCollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\t\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(REGISTRY_QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *VerifyCollectionProposal) Execute(realm) error {\n\tinfo := GetCollection(p.collectionAddr)\n\tif info == nil {\n\t\treturn errors.New(\"collection not found\")\n\t}\n\n\tif info.Verified {\n\t\treturn errors.New(\"collection already verified\")\n\t}\n\n\tinfo.Verified = true\n\tcollections.Set(p.collectionAddr.String(), info)\n\n\tp.executed = true\n\treturn nil\n}\n\n// UnverifyCollectionProposal - Proposal to unverify a collection\ntype UnverifyCollectionProposal struct {\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc NewUnverifyCollectionProposal(addr address, name string, reason string) *UnverifyCollectionProposal {\n\treturn \u0026UnverifyCollectionProposal{\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *UnverifyCollectionProposal) Title() string {\n\treturn \"Unverify Collection: \" + p.collectionName\n}\n\nfunc (p *UnverifyCollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Collection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to unverify, NO to reject\",\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *UnverifyCollectionProposal) VotingPeriod() time.Duration {\n\treturn REGISTRY_VOTING_PERIOD\n}\n\nfunc (p *UnverifyCollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\t\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(REGISTRY_QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *UnverifyCollectionProposal) Execute(realm) error {\n\tinfo := GetCollection(p.collectionAddr)\n\tif info == nil {\n\t\treturn errors.New(\"collection not found\")\n\t}\n\n\tif !info.Verified {\n\t\treturn errors.New(\"collection not verified\")\n\t}\n\n\tinfo.Verified = false\n\tcollections.Set(p.collectionAddr.String(), info)\n\n\tp.executed = true\n\treturn nil\n}"},{"name":"registry.gno","body":"package daoregistry\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n)\n\n// CollectionInfo - Extended metadata stored in the registry\ntype CollectionInfo struct {\n\tAddress          address\n\tName             string\n\tSymbol           string\n\tCreator          address\n\tRegisteredAt     int64\n\tVerified         bool\n\tCategory         string\n\tDescription      string\n\tExternalURL      string\n\tNFTGetter        grc721.NFTGetter\n\tSupportsMetadata bool\n}\n\nvar (\n\tcollections     avl.Tree\n\tcategoriesIndex avl.Tree\n\tregistrationFee int64 = 1000000\n)\n\nfunc init() {\n\tinitRegistryDAO()\n}\n\n// RegisterCollection - Register a new NFT collection\nfunc RegisterCollection(\n\trealmAddr address,\n\tname string,\n\tsymbol string,\n\tcategory string,\n\tdescription string,\n\texternalURL string,\n\tsupportsMetadata bool,\n\tgetter grc721.NFTGetter,\n) {\n\tcreator := runtime.OriginCaller()\n\n\t// Check if collection already registered\n\tif collections.Has(realmAddr.String()) {\n\t\tpanic(\"Collection already registered\")\n\t}\n\n\tif getter == nil {\n\t\tpanic(\"NFT getter function is required\")\n\t}\n\n\tif name == \"\" || symbol == \"\" {\n\t\tpanic(\"Name and symbol cannot be empty\")\n\t}\n\n\tinfo := \u0026CollectionInfo{\n\t\tAddress:          realmAddr,\n\t\tCreator:          creator,\n\t\tName:             name,\n\t\tSymbol:           symbol,\n\t\tRegisteredAt:     runtime.ChainHeight(),\n\t\tVerified:         false,\n\t\tCategory:         category,\n\t\tDescription:      description,\n\t\tExternalURL:      externalURL,\n\t\tNFTGetter:        getter,\n\t\tSupportsMetadata: supportsMetadata,\n\t}\n\n\tcollections.Set(realmAddr.String(), info)\n}\n\n// IsRegistered - Check if a collection is registered\nfunc IsRegistered(collectionAddr address) bool {\n\treturn collections.Has(collectionAddr.String())\n}\n\n// GetTotalCollections - Total number of registered collections\nfunc GetTotalCollections() int {\n\tcount := 0\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcount++\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetVerifiedCount - Count of verified collections\nfunc GetVerifiedCount() int {\n\tcount := 0\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tinfo := value.(*CollectionInfo)\n\t\tif info.Verified {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetCollection - Retrieve collection info by address\nfunc GetCollection(collectionAddr address) *CollectionInfo {\n\tval, exists := collections.Get(collectionAddr.String())\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn val.(*CollectionInfo)\n}\n\n// GetNFTGetter - Retrieve the NFTGetter function for a collection\nfunc GetNFTGetter(collectionAddr address) (grc721.NFTGetter, bool) {\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\treturn nil, false\n\t}\n\treturn info.NFTGetter, true\n}\n\n// GetTokenMetadata - Retrieve onchain metadata for a token\nfunc GetTokenMetadata(collectionAddr address, tokenId grc721.TokenID) (grc721.Metadata, error) {\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"Collection not registered\")\n\t}\n\n\tif !info.SupportsMetadata {\n\t\tpanic(\"Collection does not support onchain metadata\")\n\t}\n\n\tnftInstance := info.NFTGetter()\n\tmetadataCollection := nftInstance.(grc721.IGRC721MetadataOnchain)\n\n\treturn metadataCollection.TokenMetadata(tokenId)\n}\n\n// UpdateCollectionInfo - Update collection metadata\nfunc UpdateCollectionInfo(category, description, externalURL string) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tinfo := GetCollection(caller)\n\tif info == nil {\n\t\tpanic(\"Collection not registered\")\n\t}\n\n\tinfo.Category = category\n\tinfo.Description = description\n\tinfo.ExternalURL = externalURL\n\tcollections.Set(caller.String(), info)\n}\n"},{"name":"render.gno","body":"package daoregistry\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"collection/\") {\n\t\taddrStr := strings.TrimPrefix(path, \"collection/\")\n\t\taddr := address(addrStr)\n\t\treturn renderCollection(addr)\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# NFT Registry\\n\\n\"\n\toutput += \"Decentralized NFT Collection Registry with DAO Governance\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\toutput += \"## Statistics\\n\\n\"\n\toutput += ufmt.Sprintf(\"- Total registered collections: %d\\n\", GetTotalCollections())\n\toutput += ufmt.Sprintf(\"- Verified collections: %d\\n\\n\", GetVerifiedCount())\n\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalRegistryMembers())\n\n\tactiveProposals := registryDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/daoregistry:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"[View proposals](/r/pierre115/daoregistry:proposals) | \"\n\t}\n\n\tfinishedProposals := registryDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/daoregistry:archive)\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinRegistryDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join DAO\", linkjoin) + \"\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// Collections list\n\toutput += \"## Registered Collections\\n\\n\"\n\n\thasCollections := false\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\thasCollections = true\n\t\tinfo := value.(*CollectionInfo)\n\t\toutput += renderCollectionPreview(info)\n\t\treturn false\n\t})\n\n\tif !hasCollections {\n\t\toutput += \"No collections registered yet.\\n\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderCollectionPreview(info *CollectionInfo) string {\n\toutput := ufmt.Sprintf(\"### %s (%s)\\n\\n\", info.Name, info.Symbol)\n\n\tif info.Verified {\n\t\toutput += \"Status: VERIFIED\\n\\n\"\n\t} else {\n\t\toutput += \"Status: Not verified\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"Category: %s\\n\\n\", info.Category)\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/daoregistry:collection/%s)\\n\\n\", info.Address.String())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderCollection(addr address) string {\n\tinfo := GetCollection(addr)\n\tif info == nil {\n\t\treturn \"# Collection not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", info.Name)\n\n\tif info.Verified {\n\t\toutput += \"**Status:** VERIFIED\\n\\n\"\n\t} else {\n\t\toutput += \"**Status:** Not verified\\n\\n\"\n\t}\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Symbol:** %s\\n\\n\", info.Symbol)\n\toutput += ufmt.Sprintf(\"**Address:** %s\\n\\n\", info.Address.String())\n\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\\n\", info.Creator.String())\n\toutput += ufmt.Sprintf(\"**Category:** %s\\n\\n\", info.Category)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\\n\", info.Description)\n\n\tif info.ExternalURL != \"\" {\n\t\toutput += ufmt.Sprintf(\"**External URL:** %s\\n\\n\", info.ExternalURL)\n\t}\n\n\toutput += ufmt.Sprintf(\"**Registered at block:** %d\\n\\n\", info.RegisteredAt)\n\toutput += ufmt.Sprintf(\"**Supports onchain metadata:** %t\\n\\n\", info.SupportsMetadata)\n\n\toutput += \"[Back to registry](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderProposals() string {\n\toutput := \"# Active Registry Proposals\\n\\n\"\n\n\tproposals := registryDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"No active proposals at the moment.\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Verify collections\\n\"\n\t\toutput += \"- Unverify collections\\n\\n\"\n\t\toutput += \"[Back](/r/pierre115/daoregistry)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[View archive](/r/pierre115/daoregistry:archive) | [Back](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"Status: Voting ended\\n\\n\"\n\t} else {\n\t\toutput += \"Status: Voting open\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View and Vote](/r/pierre115/daoregistry:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := registryDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalRegistryMembers()\n\tquorumRequired := int(float64(totalMembers) * REGISTRY_QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"**Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"**Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"VoteRegistry\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"VoteRegistry\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[Back to proposals](/r/pierre115/daoregistry:proposals) | [Home](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := registryDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"No finished proposals yet.\\n\\n\"\n\t\toutput += \"[Back](/r/pierre115/daoregistry)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[Back](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusLabel := \"PASSED\"\n\tif p.Status() == \"failed\" {\n\t\tstatusLabel = \"FAILED\"\n\t}\n\toutput += ufmt.Sprintf(\"**Status:** %s\\n\\n\", statusLabel)\n\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/daoregistry:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := registryDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalRegistryMembers()\n\tquorumRequired := int(float64(totalMembers) * REGISTRY_QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusLabel := \"PASSED\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusLabel = \"FAILED\"\n\t}\n\toutput += ufmt.Sprintf(\"**Final Status:** %s\\n\\n\", statusLabel)\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[Back to archive](/r/pierre115/daoregistry:archive) | [Home](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n"},{"name":"voting.gno","body":"package daoregistry\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeVerifyCollection - Create proposal to verify a collection\nfunc ProposeVerifyCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsRegistryDAOMember(caller) {\n\t\tpanic(\"only Registry DAO members can create proposals\")\n\t}\n\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"collection not registered\")\n\t}\n\n\tif info.Verified {\n\t\tpanic(\"collection already verified\")\n\t}\n\n\tpropDef := NewVerifyCollectionProposal(collectionAddr, collectionName, reason)\n\n\tproposal, err := registryDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUnverifyCollection - Create proposal to unverify a collection\nfunc ProposeUnverifyCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsRegistryDAOMember(caller) {\n\t\tpanic(\"only Registry DAO members can create proposals\")\n\t}\n\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"collection not registered\")\n\t}\n\n\tif !info.Verified {\n\t\tpanic(\"collection not verified\")\n\t}\n\n\tpropDef := NewUnverifyCollectionProposal(collectionAddr, collectionName, reason)\n\n\tproposal, err := registryDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// VoteRegistry - Vote on a registry proposal\nfunc VoteRegistry(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif choice != \"yes\" \u0026\u0026 choice != \"no\" {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - handles all validations automatically\n\terr := registryDAO.Vote(caller, proposalID, commondao.VoteChoice(choice), \"\")\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyRegistryProposal - Execute a registry proposal\nfunc TallyRegistryProposal(_ realm, proposalID uint64) string {\n\terr := registryDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"osKtDlJ6f0CLWXyOcFwyUPl/oZEMWngm6gRJM8S6c+L4EmxDgTRSAwFNFFWgCJZZwF4KrsE4C12W5BQ30YEOCA=="}],"memo":""},"metadata":{"timestamp":"1765535654"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765543068"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"mynft","path":"gno.land/r/pierre115/mynft","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/mynft\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"nft.gno","body":"package mynft\n\nimport (\n\t\"strconv\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry\"\n)\n\ntype NFTCollection interface {\n\tgrc721.IGRC721\n\tMint(to address, tid grc721.TokenID) error\n\tGetter() grc721.NFTGetter\n}\n\nvar (\n\tnft         NFTCollection\n\tnextTokenId = 1\n\tmyRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n\tnft = grc721.NewBasicNFT(\"Test NFT Collection\", \"TEST\")\n}\n\n// Register registers this collection on the NFT registry\nfunc Register(_ realm) {\n\tdaoregistry.RegisterCollection(\n\t\tmyRealmAddr,\n\t\t\"Test NFT Collection\",\n\t\t\"TEST\",\n\t\t\"art\",\n\t\t\"First wars\",\n\t\t\"https://example.com\",\n\t\tfalse,\n\t\tnft.Getter(),\n\t)\n}\n\nfunc MintNFT(_ realm) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\nfunc SetApprovalForAll(_ realm, operator address, approved bool) {\n\terr := nft.SetApprovalForAll(operator, approved)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc Getter() grc721.NFTGetter {\n\treturn nft.Getter()\n}\n\nfunc Render(path string) string {\n\toutput := \"# My test collection\\n\\n\"\n\toutput += \"## test\\n\\n\"\n\toutput += ufmt.Sprintf(\"**NftRealmAddr:** %d\\n\\n\", myRealmAddr.String())\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"kq4hfIEFaDi/FcLi8yPo+D3LJoeRJfgewY2B2e86Lbyd5kzSRTTQ2GxXOZvYCxDI0lW5e4AH4MdXWhn/36WLCA=="}],"memo":""},"metadata":{"timestamp":"1765543153"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","amount":"1000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"eYbK43/tWH0ZBirQ6/7sIS4iXWcJUXrZwxUgkcLXjxl5tS88scfOd/4R34x+HbI6YQROl1lhgfZANsD8YEiIDA=="}],"memo":""},"metadata":{"timestamp":"1765546731"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","package":{"name":"gnobounty","path":"gno.land/r/greg007/gnobounty_v2","files":[{"name":"README.md","body":"# GnoBounty\n\nA decentralized bounty system for managing rewards on GitHub issues (or any issue tracker) using the Gno blockchain, with DAO-based validation through validator voting.\n\n## Features\n\n- **Create Bounties**: Post a bounty on any issue by providing the issue URL and sending GNOT tokens\n- **Apply for Bounties**: Submit your merged PR link to apply for a bounty\n- **DAO Validation**: 3 validators are randomly selected to vote on each application\n- **Automatic Claims**: Bounties are automatically claimed when 2/3 validators approve\n- **Validator System**: Decentralized validation through registered validators\n- **Cancel Bounties**: Creators can cancel unclaimed bounties and receive a refund\n- **List Bounties**: Browse all active bounties with reward amounts\n- **Transparent**: All bounties and applications are stored on-chain and publicly viewable\n\n## How to Use\n\n### Creating a Bounty\n\nTo create a bounty, call the `CreateBounty` function with the issue URL and description, and send GNOT tokens:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"CreateBounty\" \\\n  -args \"https://github.com/gnolang/gno/issues/1234\" \\\n  -args \"Fix the rendering bug in GRC20 token display\" \\\n  -send \"5000000ugnot\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- `issueURL`: The URL of the issue (GitHub, GitLab, etc.)\n- `description`: A brief description of what needs to be done\n- `send`: The bounty amount in ugnot (1 GNOT = 1,000,000 ugnot)\n\n**Minimum bounty**: 1 GNOT (1,000,000 ugnot)\n\n### Viewing Bounties\n\nVisit the realm in your browser to see all active bounties:\n\n```\nhttps://gno.land/r/greg007/gnobounty\n```\n\nOr view a specific bounty by ID:\n\n```\nhttps://gno.land/r/greg007/gnobounty/1\n```\n\n### Applying for a Bounty\n\nWhen you complete work on a bounty, submit your merged PR link to apply:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"ApplyForBounty\" \\\n  -args \"1\" \\\n  -args \"https://github.com/gnolang/gno/pull/5678\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- First arg: Bounty ID\n- Second arg: URL of your merged pull request\n\n**What happens next:**\n1. Your application is created\n2. 3 random validators are selected from the validator pool\n3. Validators review your PR and vote to approve or reject\n4. If 2 out of 3 validators approve, the bounty is automatically transferred to you!\n\n### Validator Voting\n\nIf you're a registered validator, you can vote on applications assigned to you:\n\n```bash\n# Approve an application\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"true\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n\n# Reject an application\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"false\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- First arg: Application ID\n- Second arg: \"true\" to approve, \"false\" to reject\n\n### Legacy: Manual Claiming (deprecated)\n\nThe old manual claim system is still available but deprecated in favor of DAO validation:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"ClaimBounty\" \\\n  -args \"1\" \\\n  -args \"g1abc123...xyz\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n### Cancelling a Bounty\n\nIf you need to cancel a bounty and get your funds back:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty\" \\\n  -func \"CancelBounty\" \\\n  -args \"1\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Note:** You can only cancel bounties that haven't been claimed yet.\n\n## API Reference\n\n### Bounty Functions\n\n#### `CreateBounty(cur realm, issueURL, description string) uint64`\nCreates a new bounty and returns the bounty ID. Must send GNOT with the transaction.\n\n#### `GetBounty(id uint64) *Bounty`\nReturns bounty details by ID.\n\n#### `CancelBounty(cur realm, id uint64)`\nCancels a bounty and refunds the creator. Only callable by the bounty creator on unclaimed bounties.\n\n#### `ListBounties() string`\nReturns a formatted list of all active bounties.\n\n#### `GetBountyDetails(id uint64) string`\nReturns detailed information about a specific bounty with apply button.\n\n#### `GetBountyCount() uint64`\nReturns the total number of bounties created.\n\n### Application \u0026 Voting Functions\n\n#### `ApplyForBounty(cur realm, bountyID uint64, prLink string) uint64`\nSubmit an application for a bounty with your merged PR link. Returns the application ID.\n- Automatically selects 3 random validators\n- Creates a pending application\n- Returns application ID\n\n#### `Vote(cur realm, applicationID uint64, approve bool)`\nVote on an application (validator only). Must be one of the selected validators.\n- `approve`: true to approve, false to reject\n- Automatically claims bounty if 2/3 validators approve\n\n#### `GetApplication(id uint64) *Application`\nReturns application details by ID.\n\n#### `GetApplicationsForBounty(bountyID uint64) []*Application`\nReturns all applications for a specific bounty.\n\n#### `GetApplicationsForValidator(validatorAddr address) []*Application`\nReturns all applications assigned to a validator for voting.\n\n#### `GetApplicationCount() uint64`\nReturns the total number of applications created.\n\n### Validator Management Functions\n\n#### `AddValidator(cur realm, validatorAddr address)`\nAdds a new validator to the system (admin function).\n\n#### `RemoveValidator(cur realm, validatorAddr address)`\nDeactivates a validator (admin function).\n\n#### `IsValidator(addr address) bool`\nChecks if an address is an active validator.\n\n#### `GetActiveValidatorCount() int`\nReturns the number of active validators.\n\n#### `ListValidators() string`\nReturns a formatted list of all validators and their status.\n\n### Rendering Functions\n\n#### `RenderMyVotes(validatorAddr address) string`\nShows pending applications that need votes from the specified validator, with approve/reject buttons.\n\n#### `Render(path string) string`\nMain render function for the realm.\n\n### Bounty Structure\n\n```go\ntype Bounty struct {\n    ID          uint64    // Unique bounty identifier\n    IssueURL    string    // Link to the issue\n    Description string    // Description of the work\n    Amount      int64     // Reward amount in ugnot\n    Creator     address   // Address of the bounty creator\n    CreatedAt   time.Time // When the bounty was created\n    IsClaimed   bool      // Whether the bounty has been claimed\n    Claimer     address   // Address of the claimer (if claimed)\n    ClaimedAt   time.Time // When the bounty was claimed\n}\n```\n\n## Example Workflow\n\n1. **Alice creates a bounty** for fixing a bug, sending 5 GNOT:\n   ```\n   CreateBounty(\"https://github.com/project/repo/issues/42\", \"Fix memory leak in parser\")\n   ```\n\n2. **Bob sees the bounty** and decides to work on it. He visits the issue URL and starts coding.\n\n3. **Bob completes the work** and submits a pull request fixing the issue.\n\n4. **Alice verifies the fix** and approves Bob's claim:\n   ```\n   ClaimBounty(cross, 1, \"g1bob123...xyz\")\n   ```\n\n5. **Bob receives 5 GNOT** automatically to his address!\n\n## Security Considerations\n\n- Only the bounty creator can approve claims\n- Bounties are locked in the realm contract until claimed or cancelled\n- Once claimed, bounties cannot be cancelled\n- The realm must have sufficient funds to pay out bounties\n\n## Notes\n\n- This implementation uses the new Gno standard library split (post-#3874)\n- Amounts are stored in ugnot (micro-GNOT): 1 GNOT = 1,000,000 ugnot\n- The `address` type is used as a builtin instead of `std.Address`\n- Uses new imports:\n  - `gno.land/r/sys/chain` for `Coin` and `Coins` types\n  - `gno.land/r/sys/chain/banker` for banker operations (`NewBanker`, `BankerType*`, `OriginSend`)\n  - `gno.land/r/sys/chain/runtime` for realm functions (`PreviousRealm`, `CurrentRealm`)\n\n## License\n\nMIT\n"},{"name":"application.gno","body":"package gnobounty\n\nimport (\n\t\"chain/runtime\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ApplyForBounty allows a user to apply for a bounty with their merged PR link\n// This creates an application with a private DAO for 3 random validators to vote\nfunc ApplyForBounty(_ realm, bountyID uint64, prLink string) uint64 {\n\tcaller := runtime.OriginCaller()\n\n\t// Validate inputs\n\tif prLink == \"\" {\n\t\tpanic(\"PR link cannot be empty\")\n\t}\n\n\t// Check bounty exists and is not claimed\n\tbounty := GetBounty(bountyID)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"bounty already claimed\")\n\t}\n\n\t// Check if there are enough validators\n\tactiveValidatorCount := GetActiveValidatorCount()\n\tif activeValidatorCount \u003c validatorsPerDAO {\n\t\tpanic(ufmt.Sprintf(\"not enough validators: need %d, have %d\", validatorsPerDAO, activeValidatorCount))\n\t}\n\n\t// Check if user already has a pending application for this bounty\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\tif app.BountyID == bountyID \u0026\u0026 app.Applicant == caller \u0026\u0026 app.Status == StatusPending {\n\t\t\tpanic(\"you already have a pending application for this bounty\")\n\t\t}\n\t\treturn false\n\t})\n\n\t// Select 3 random validators for this application\n\tselectedValidators := selectRandomValidators(applicationCount+1, validatorsPerDAO)\n\n\t// Create the DAO for this application\n\tapplicationCount++\n\tdaoName := ufmt.Sprintf(\"Bounty #%d Application #%d Review DAO\", bountyID, applicationCount)\n\tdaoDesc := ufmt.Sprintf(\"Private DAO to review application for bounty #%d\", bountyID)\n\n\t// Create DAO with selected validators as members\n\t// DisableVotingDeadlineCheck allows immediate execution after votes\n\tdao := commondao.New(\n\t\tcommondao.WithID(applicationCount),\n\t\tcommondao.WithName(daoName),\n\t\tcommondao.WithDescription(daoDesc),\n\t\tcommondao.DisableVotingDeadlineCheck(),\n\t)\n\n\t// Add selected validators as members\n\tfor _, validatorAddr := range selectedValidators {\n\t\tdao.Members().Add(validatorAddr)\n\t}\n\n\t// Create a proposal in the DAO to approve this application BEFORE creating the Application struct\n\tproposalDef := NewClaimBountyProposal(bountyID, applicationCount, caller, prLink)\n\tproposal := dao.MustPropose(caller, proposalDef)\n\n\t// Create the application with the correct proposalID from the start\n\tapplication := \u0026Application{\n\t\tID:         applicationCount,\n\t\tBountyID:   bountyID,\n\t\tApplicant:  caller,\n\t\tPRLink:     prLink,\n\t\tAppliedAt:  time.Now(),\n\t\tStatus:     StatusPending,\n\t\tDAO:        dao,\n\t\tProposalID: proposal.ID(),\n\t}\n\n\t// Store application\n\tapplications.Set(ufmt.Sprintf(\"%d\", applicationCount), application)\n\n\treturn applicationCount\n}\n\n// Vote allows a selected validator to vote on an application via the DAO\nfunc Vote(_ realm, applicationID uint64, vote string) {\n\tcaller := runtime.OriginCaller()\n\n\t// Check if caller is a validator\n\tif !IsValidator(caller) {\n\t\tpanic(\"only validators can vote\")\n\t}\n\n\t// Get application\n\tapp := GetApplication(applicationID)\n\tif app == nil {\n\t\tpanic(\"application not found\")\n\t}\n\n\tif app.Status != StatusPending {\n\t\tpanic(\"application is no longer pending\")\n\t}\n\n\t// Check if caller is a member of this application's DAO\n\tif !app.DAO.Members().Has(caller) {\n\t\tpanic(\"you are not a validator for this application\")\n\t}\n\n\t// Get the proposal\n\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal == nil {\n\t\tpanic(\"proposal not found\")\n\t}\n\n\t// Convert string vote to VoteChoice\n\tvar voteChoice commondao.VoteChoice\n\tswitch vote {\n\tcase \"yes\", \"true\", \"approve\":\n\t\tvoteChoice = commondao.ChoiceYes\n\tcase \"no\", \"false\", \"reject\":\n\t\tvoteChoice = commondao.ChoiceNo\n\tcase \"abstain\":\n\t\tvoteChoice = commondao.ChoiceAbstain\n\tdefault:\n\t\tpanic(\"invalid vote: must be 'yes', 'no', or 'abstain'\")\n\t}\n\n\t// Vote on the proposal using CommonDAO's Vote method\n\t// This method validates membership, deadline, and vote choice\n\terr := app.DAO.Vote(caller, app.ProposalID, voteChoice, \"\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Record vote locally\n\tapp.Votes = append(app.Votes, VoteRecord{\n\t\tVoter:  caller,\n\t\tChoice: voteChoice,\n\t})\n\n\t// Try to execute the proposal\n\t// Tally() will return true when all validators have voted\n\t// Execute() will handle both approval and rejection\n\tproposal = app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal != nil {\n\t\ttotalMembers := app.DAO.Members().Size()\n\t\ttotalVotes := proposal.VotingRecord().Size()\n\n\t\t// If all validators have voted, execute to finalize\n\t\tif totalVotes == totalMembers {\n\t\t\terr = app.DAO.Execute(app.ProposalID)\n\t\t\t// Ignore errors - proposal might already be executed or failed\n\t\t\t// The status will be updated in Execute() regardless\n\t\t}\n\t}\n}\n\n// GetApplicationsForBounty returns all applications for a specific bounty\nfunc GetApplicationsForBounty(bountyID uint64) []*Application {\n\tapps := make([]*Application, 0)\n\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\tif app.BountyID == bountyID {\n\t\t\tapps = append(apps, app)\n\t\t}\n\t\treturn false\n\t})\n\n\treturn apps\n}\n\n// GetApplicationsForValidator returns all applications assigned to a validator\nfunc GetApplicationsForValidator(validatorAddr address) []*Application {\n\tapps := make([]*Application, 0)\n\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\t// Check if validator is a member of the application's DAO\n\t\tif app.DAO != nil \u0026\u0026 app.Status == StatusPending \u0026\u0026 app.DAO.Members().Has(validatorAddr) {\n\t\t\tapps = append(apps, app)\n\t\t}\n\t\treturn false\n\t})\n\n\treturn apps\n}\n"},{"name":"application_test.gno","body":"package gnobounty\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/testutils\"\n)\n\nfunc TestAddValidator(t *testing.T) {\n\t// Setup owner - use testing.SetOriginCaller to set who is calling\n\tadminAddr := testutils.TestAddress(\"admin\")\n\ttesting.SetOriginCaller(adminAddr)\n\n\t// Initialize ownership with current caller as owner\n\townership = ownable.New()\n\n\t// Add a validator\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tAddValidator(cross, validator1)\n\n\tif !IsValidator(validator1) {\n\t\tt.Error(\"Validator should be active\")\n\t}\n\n\tcount := GetActiveValidatorCount()\n\tif count \u003c 1 {\n\t\tt.Error(\"Expected at least 1 active validator\")\n\t}\n}\n\nfunc TestValidatorList(t *testing.T) {\n\t// Setup owner - reuse same admin from previous test\n\tadminAddr := testutils.TestAddress(\"admin\")\n\ttesting.SetOriginCaller(adminAddr)\n\n\t// Add more validators\n\tvalidator2 := testutils.TestAddress(\"validator2\")\n\n\t// Check if already exists before adding\n\tif !IsValidator(validator2) {\n\t\tAddValidator(cross, validator2)\n\t}\n\n\tif !IsValidator(validator2) {\n\t\tt.Error(\"Validator2 should be active\")\n\t}\n\n\tcount := GetActiveValidatorCount()\n\tif count \u003c 2 {\n\t\tt.Errorf(\"Expected at least 2 active validators, got %d\", count)\n\t}\n}\n\nfunc TestListValidators(t *testing.T) {\n\tlist := ListValidators()\n\tif list == \"\" {\n\t\tt.Error(\"Expected non-empty validators list\")\n\t}\n}\n\nfunc TestIsValidatorCheck(t *testing.T) {\n\t// Test a non-validator address\n\tnonValidator := testutils.TestAddress(\"nonvalidator\")\n\tif IsValidator(nonValidator) {\n\t\tt.Error(\"Non-validator should not be recognized as validator\")\n\t}\n\n\t// Test existing validator\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tif !IsValidator(validator1) {\n\t\tt.Error(\"validator1 should be recognized as validator\")\n\t}\n}\n\nfunc TestGetValidator(t *testing.T) {\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tv := GetValidator(validator1)\n\n\tif v == nil {\n\t\tt.Fatal(\"Expected to find validator1\")\n\t}\n\n\tif v.Address != validator1 {\n\t\tt.Error(\"Validator address mismatch\")\n\t}\n\n\tif !v.Active {\n\t\tt.Error(\"Validator should be active\")\n\t}\n}\n"},{"name":"gnobounty_test.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"testing\"\n\n\t\"gno.land/p/nt/testutils\"\n)\n\nfunc TestCreateBounty(t *testing.T) {\n\t// Setup test environment\n\ttesting.SetOriginCaller(testutils.TestAddress(\"alice\"))\n\ttesting.SetOriginSend(chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: 5000000}})\n\n\t// Create a bounty\n\tbountyID := CreateBounty(\n\t\tcross,\n\t\t\"Fix Rendering Bug\",\n\t\t\"https://github.com/gnolang/gno/issues/1234\",\n\t\t\"Fix the rendering issue in the GRC20 token display\",\n\t)\n\n\tif bountyID != 1 {\n\t\tt.Errorf(\"Expected bounty ID 1, got %d\", bountyID)\n\t}\n\n\t// Check bounty was created\n\tbounty := GetBounty(bountyID)\n\tif bounty == nil {\n\t\tt.Fatal(\"Bounty not found\")\n\t}\n\n\tif bounty.Amount != 5000000 {\n\t\tt.Errorf(\"Expected amount 5000000, got %d\", bounty.Amount)\n\t}\n\n\tif bounty.IsClaimed {\n\t\tt.Error(\"Bounty should not be claimed yet\")\n\t}\n\n\tif bounty.Title != \"Fix Rendering Bug\" {\n\t\tt.Errorf(\"Expected title 'Fix Rendering Bug', got %s\", bounty.Title)\n\t}\n}\n\nfunc TestGetBountyCount(t *testing.T) {\n\tcount := GetBountyCount()\n\tif count \u003c 1 {\n\t\tt.Error(\"Expected at least 1 bounty from previous test\")\n\t}\n}\n\nfunc TestListBounties(t *testing.T) {\n\tlist := ListBounties()\n\tif list == \"\" {\n\t\tt.Error(\"Expected non-empty bounties list\")\n\t}\n\tif list == \"No bounties available\" {\n\t\tt.Error(\"Expected bounties to be listed\")\n\t}\n}\n\nfunc TestGetBountyDetails(t *testing.T) {\n\t// Test getting details for existing bounty\n\tdetails := GetBountyDetails(1)\n\tif details == \"\" {\n\t\tt.Error(\"Expected non-empty bounty details\")\n\t}\n\tif details == \"Bounty not found\" {\n\t\tt.Error(\"Bounty #1 should exist\")\n\t}\n}\n\nfunc TestGetBountyDetailsNotFound(t *testing.T) {\n\t// Test getting details for non-existent bounty\n\tdetails := GetBountyDetails(99999)\n\tif details != \"Bounty not found\" {\n\t\tt.Error(\"Expected 'Bounty not found' for non-existent bounty\")\n\t}\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/greg007/gnobounty_v2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0\"\n"},{"name":"leaderboard.gno","body":"package gnobounty\n\nimport (\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// LeaderboardEntry holds the stats for a user\ntype LeaderboardEntry struct {\n\tAddress              address\n\tBountiesCreated      int\n\tBountiesApplied      int\n\tValidationsPerformed int\n\tScore                int\n}\n\n// GetLeaderboard aggregates stats for all users\nfunc GetLeaderboard() []LeaderboardEntry {\n\tvar stats avl.Tree // address -\u003e *LeaderboardEntry\n\n\t// Count bounties created (10 points)\n\tbounties.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tif value == nil {\n\t\t\treturn false\n\t\t}\n\t\tbounty, ok := value.(*Bounty)\n\t\tif !ok || bounty == nil {\n\t\t\treturn false\n\t\t}\n\t\tentry := getEntry(\u0026stats, bounty.Creator)\n\t\tentry.BountiesCreated++\n\t\tentry.Score += 10\n\t\treturn false\n\t})\n\n\t// Count applications and validations\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tif value == nil {\n\t\t\treturn false\n\t\t}\n\t\tapp, ok := value.(*Application)\n\t\tif !ok || app == nil {\n\t\t\treturn false\n\t\t}\n\n\t\t// Only count approved applications (20 points)\n\t\tif app.Status == StatusApproved {\n\t\t\tentry := getEntry(\u0026stats, app.Applicant)\n\t\t\tentry.BountiesApplied++\n\t\t\tentry.Score += 20\n\t\t}\n\n\t\t// Count validations from local record (5 points)\n\t\tfor _, vote := range app.Votes {\n\t\t\tentry := getEntry(\u0026stats, vote.Voter)\n\t\t\tentry.ValidationsPerformed++\n\t\t\tentry.Score += 5\n\t\t}\n\n\t\treturn false\n\t})\n\n\t// Convert tree to slice\n\tvar result []LeaderboardEntry\n\tstats.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tentry := value.(*LeaderboardEntry)\n\t\tresult = append(result, *entry)\n\t\treturn false\n\t})\n\n\t// Sort by Score descending\n\t// Manual bubble sort since sort.Slice is not available\n\tfor i := 0; i \u003c len(result)-1; i++ {\n\t\tfor j := 0; j \u003c len(result)-i-1; j++ {\n\t\t\tif result[j].Score \u003c result[j+1].Score {\n\t\t\t\t// Swap\n\t\t\t\tresult[j], result[j+1] = result[j+1], result[j]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n// RenderLeaderboard renders the leaderboard page\nfunc RenderLeaderboard() string {\n\tentries := GetLeaderboard()\n\n\toutput := md.H1(\"üèÜ Community Leaderboard\")\n\toutput += \"Top contributors to the GnoBounty ecosystem.\\n\\n\"\n\toutput += md.Bold(\"Scoring:\") + \" Bounty Creation (10pts) | Approved Application (20pts) | Validation (5pts)\\n\\n\"\n\n\tif len(entries) == 0 {\n\t\toutput += \"No activity recorded yet.\"\n\t\treturn output\n\t}\n\n\t// Table header\n\toutput += \"| Rank | User | Score | üí∞ Bounties | üìù Applications | ‚öñÔ∏è Validations |\\n\"\n\toutput += \"|---|---|---|---|---|---|\\n\"\n\n\t// Table rows\n\tfor i, entry := range entries {\n\t\trank := getRankDisplay(i)\n\t\toutput += tableRow(\n\t\t\trank,\n\t\t\tstring(entry.Address),\n\t\t\tmd.Bold(ufmt.Sprintf(\"%d\", entry.Score)),\n\t\t\tufmt.Sprintf(\"%d\", entry.BountiesCreated),\n\t\t\tufmt.Sprintf(\"%d\", entry.BountiesApplied),\n\t\t\tufmt.Sprintf(\"%d\", entry.ValidationsPerformed),\n\t\t)\n\t}\n\n\treturn output\n}\n\n// getRankDisplay returns the rank display (medal for top 3, number otherwise)\nfunc getRankDisplay(position int) string {\n\tswitch position {\n\tcase 0:\n\t\treturn \"ü•á\"\n\tcase 1:\n\t\treturn \"ü•à\"\n\tcase 2:\n\t\treturn \"ü•â\"\n\tdefault:\n\t\treturn ufmt.Sprintf(\"%d\", position+1)\n\t}\n}\n\n// tableRow creates a markdown table row\nfunc tableRow(cells ...string) string {\n\toutput := \"|\"\n\tfor _, cell := range cells {\n\t\toutput += \" \" + cell + \" |\"\n\t}\n\treturn output + \"\\n\"\n}\n\nfunc getEntry(stats *avl.Tree, addr address) *LeaderboardEntry {\n\tkey := string(addr)\n\tval, ok := stats.Get(key)\n\tif !ok {\n\t\tentry := \u0026LeaderboardEntry{Address: addr}\n\t\tstats.Set(key, entry)\n\t\treturn entry\n\t}\n\treturn val.(*LeaderboardEntry)\n}\n"},{"name":"logic.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"time\"\n\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// CreateBounty creates a new bounty post\n// title: short title for the bounty\n// issueURL: link to the GitHub issue or other issue tracker\n// description: description of what needs to be done\n// Caller must send GNOT tokens with this transaction\nfunc CreateBounty(_ realm, title, issueURL, description string) uint64 {\n\t// Validate inputs\n\tif title == \"\" {\n\t\tpanic(\"title is required\")\n\t}\n\tif issueURL == \"\" {\n\t\tpanic(\"issue URL is required\")\n\t}\n\tif description == \"\" {\n\t\tpanic(\"description is required\")\n\t}\n\n\t// Get the sent coins\n\tsent := banker.OriginSend()\n\tif len(sent) == 0 {\n\t\tpanic(\"no coins sent with bounty\")\n\t}\n\n\t// Find GNOT amount\n\tvar gnotAmount int64\n\tfor _, coin := range sent {\n\t\tif coin.Denom == \"ugnot\" {\n\t\t\tgnotAmount = coin.Amount\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif gnotAmount \u003c minimumBounty {\n\t\tpanic(ufmt.Sprintf(\"bounty amount must be at least %d ugnot\", minimumBounty))\n\t}\n\n\t// Create bounty\n\tbountyCount++\n\tbounty := \u0026Bounty{\n\t\tID:          bountyCount,\n\t\tTitle:       title,\n\t\tIssueURL:    issueURL,\n\t\tDescription: description,\n\t\tAmount:      gnotAmount,\n\t\tCreator:     runtime.OriginCaller(),\n\t\tCreatedAt:   time.Now(),\n\t\tIsClaimed:   false,\n\t}\n\n\t// Store bounty\n\tbounties.Set(ufmt.Sprintf(\"%d\", bountyCount), bounty)\n\n\treturn bountyCount\n}\n\n// ClaimBounty allows someone to claim a bounty\n// Only the creator can approve and transfer funds\nfunc ClaimBounty(_ realm, id uint64, claimer address) {\n\tcaller := runtime.OriginCaller()\n\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"bounty already claimed\")\n\t}\n\n\tif caller != bounty.Creator {\n\t\tpanic(\"only bounty creator can approve claims\")\n\t}\n\n\tif claimer == \"\" {\n\t\tpanic(\"claimer address cannot be empty\")\n\t}\n\n\t// Mark as claimed\n\tbounty.IsClaimed = true\n\tbounty.Claimer = claimer\n\tbounty.ClaimedAt = time.Now()\n\n\t// Transfer bounty amount to claimer\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\tsend := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: bounty.Amount}}\n\tbnk.SendCoins(pkgAddr, claimer, send)\n}\n\n// CancelBounty allows creator to cancel and get refund\nfunc CancelBounty(_ realm, id uint64) {\n\tcaller := runtime.OriginCaller()\n\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"cannot cancel claimed bounty\")\n\t}\n\n\tif caller != bounty.Creator {\n\t\tpanic(\"only bounty creator can cancel\")\n\t}\n\n\t// Remove bounty first (Checks-Effects-Interactions)\n\tbounties.Remove(ufmt.Sprintf(\"%d\", id))\n\n\t// Refund the creator\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\tsend := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: bounty.Amount}}\n\tbnk.SendCoins(pkgAddr, bounty.Creator, send)\n}\n"},{"name":"proposal.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ClaimBountyProposal implements commondao.ProposalDefinition for bounty claim proposals\ntype ClaimBountyProposal struct {\n\tBountyID      uint64\n\tApplicationID uint64\n\tApplicant     address\n\tPRLink        string\n\ttitle         string\n\tdescription   string\n}\n\n// NewClaimBountyProposal creates a new bounty claim proposal definition\nfunc NewClaimBountyProposal(bountyID, applicationID uint64, applicant address, prLink string) *ClaimBountyProposal {\n\treturn \u0026ClaimBountyProposal{\n\t\tBountyID:      bountyID,\n\t\tApplicationID: applicationID,\n\t\tApplicant:     applicant,\n\t\tPRLink:        prLink,\n\t\ttitle:         ufmt.Sprintf(\"Approve Application #%d for Bounty #%d\", applicationID, bountyID),\n\t\tdescription:   ufmt.Sprintf(\"Review PR: %s\\nApplicant: %s\", prLink, applicant),\n\t}\n}\n\n// Title returns proposal title\nfunc (p *ClaimBountyProposal) Title() string {\n\treturn p.title\n}\n\n// Body returns proposal's body\nfunc (p *ClaimBountyProposal) Body() string {\n\treturn p.description\n}\n\n// VotingPeriod returns the period where votes are allowed after proposal creation\nfunc (p *ClaimBountyProposal) VotingPeriod() time.Duration {\n\t// 7 days voting period\n\treturn 7 * 24 * time.Hour\n}\n\n// Tally counts votes and determines if proposal is ready to execute\n// Returns true when all validators have voted (regardless of outcome)\nfunc (p *ClaimBountyProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\ttotalMembers := ctx.Members.Size()\n\tif totalMembers == 0 {\n\t\treturn false, ufmt.Errorf(\"no members in DAO\")\n\t}\n\n\ttotalVotes := ctx.VotingRecord.Size()\n\n\t// Return true when all validators have voted\n\t// This allows Execute to be called and handle approval/rejection\n\tif totalVotes == totalMembers {\n\t\treturn true, nil\n\t}\n\n\t// Not ready yet - waiting for more votes\n\treturn false, nil\n}\n\n// Execute executes the proposal after all votes are in\n// Determines approval or rejection based on vote counts\nfunc (p *ClaimBountyProposal) Execute(_ realm) error {\n\tapp := GetApplication(p.ApplicationID)\n\tif app == nil {\n\t\treturn ufmt.Errorf(\"application not found\")\n\t}\n\n\tbounty := GetBounty(p.BountyID)\n\tif bounty == nil {\n\t\treturn ufmt.Errorf(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\treturn ufmt.Errorf(\"bounty already claimed\")\n\t}\n\n\t// Get vote counts from the DAO proposal\n\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal == nil {\n\t\treturn ufmt.Errorf(\"proposal not found\")\n\t}\n\n\tyesCount := proposal.VotingRecord().VoteCount(commondao.ChoiceYes)\n\tnoCount := proposal.VotingRecord().VoteCount(commondao.ChoiceNo)\n\ttotalMembers := app.DAO.Members().Size()\n\n\t// Check if unanimous approval (all YES, no NO)\n\tif yesCount == totalMembers \u0026\u0026 noCount == 0 {\n\t\t// Approve and transfer funds\n\t\tapp.Status = StatusApproved\n\n\t\tbounty.IsClaimed = true\n\t\tbounty.Claimer = p.Applicant\n\t\tbounty.ClaimedAt = time.Now()\n\n\t\t// Calculate reward split: 5% to validators, 95% to applicant\n\t\tvalidatorReward := (bounty.Amount * validatorRewardPercent) / 100\n\t\tapplicantReward := bounty.Amount - validatorReward\n\n\t\t// Split validator reward equally among all validators who voted\n\t\trewardPerValidator := validatorReward / int64(totalMembers)\n\n\t\t// Transfer rewards\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\n\t\t// Pay each validator their share\n\t\tapp.DAO.Members().IterateByOffset(0, totalMembers, func(member address) bool {\n\t\t\tvalidatorPayout := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: rewardPerValidator}}\n\t\t\tbnk.SendCoins(pkgAddr, member, validatorPayout)\n\t\t\treturn false\n\t\t})\n\n\t\t// Pay the applicant the remaining 95%\n\t\tapplicantPayout := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: applicantReward}}\n\t\tbnk.SendCoins(pkgAddr, p.Applicant, applicantPayout)\n\t} else {\n\t\t// Reject - not unanimous\n\t\tapp.Status = StatusRejected\n\t}\n\n\treturn nil\n}\n"},{"name":"render.gno","body":"package gnobounty\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ListBounties returns all active bounties\nfunc ListBounties() string {\n\tminSend := ufmt.Sprintf(\"%dugnot\", minimumBounty)\n\tcreateBountyLink := txlink.NewLink(\"CreateBounty\").\n\t\tAddArgs(\n\t\t\t\"title\", \"\",\n\t\t\t\"issueURL\", \"\",\n\t\t\t\"description\", \"\",\n\t\t).\n\t\tSetSend(minSend).\n\t\tURL()\n\n\toutput := \"# GnoBounty - Decentralized Bounty System\\n\\n\"\n\n\toutput += \"## üéØ Quick Actions\\n\\n\"\n\toutput += md.Link(\"üí∞ Create a new bounty\", createBountyLink)\n\toutput += ufmt.Sprintf(\" _(minimum reward: %s)_\", minSend)\n\toutput += \" | \"\n\toutput += md.Link(\"üìã View All Validators\", \"/\"+pkgPath+\":validators\")\n\toutput += \" | \"\n\toutput += md.Link(\"üèÜ Leaderboard\", \"/\"+pkgPath+\":leaderboard\")\n\toutput += \"\\n\\n\"\n\n\t// Add validator stats\n\tactiveValidatorCount := GetActiveValidatorCount()\n\toutput += ufmt.Sprintf(\"**Active Validators:** %d | **Total Bounties:** %d\\n\\n\", activeValidatorCount, bountyCount)\n\n\toutput += \"---\\n\\n\"\n\toutput += \"## üíé Active Bounties\\n\\n\"\n\toutput += \"**How to apply:** To apply to a bounty, you need to give your **MERGED PR** (important) URL in the transaction. You also need to write your Gno address in the description of your PR to verify your identity. If no address is written, the bounty can be refused.\\n\\n\"\n\n\tif bountyCount == 0 {\n\t\toutput += \"No bounties available\"\n\t\treturn output\n\t}\n\n\tbounties.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tbounty := value.(*Bounty)\n\t\tif !bounty.IsClaimed {\n\t\t\toutput += ufmt.Sprintf(\"## Bounty #%d: %s\\n\", bounty.ID, bounty.Title)\n\t\t\toutput += ufmt.Sprintf(\"**Issue:** %s\\n\", bounty.IssueURL)\n\t\t\toutput += ufmt.Sprintf(\"**Description:** %s\\n\", bounty.Description)\n\t\t\toutput += ufmt.Sprintf(\"**Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\t\t\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\", bounty.Creator)\n\t\t\toutput += ufmt.Sprintf(\"**Created:** %s\\n\\n\", bounty.CreatedAt.Format(\"2006-01-02 15:04:05\"))\n\n\t\t\t// Add apply button for this bounty\n\t\t\tapplyLink := txlink.NewLink(\"ApplyForBounty\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"bountyID\", ufmt.Sprintf(\"%d\", bounty.ID),\n\t\t\t\t\t\"prLink\", \"\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\toutput += md.Link(\"üìù Apply for this bounty\", applyLink)\n\t\t\toutput += \" | \"\n\n\t\t\t// Add view details link\n\t\t\tdetailsPath := ufmt.Sprintf(\"/%s:%d\", pkgPath, bounty.ID)\n\t\t\toutput += md.Link(\"üîç View details\", detailsPath)\n\t\t\toutput += \"\\n\\n\"\n\t\t}\n\t\treturn false\n\t})\n\n\treturn output\n}\n\n// GetBountyDetails returns detailed information about a specific bounty\nfunc GetBountyDetails(id uint64) string {\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\treturn \"Bounty not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Bounty #%d: %s\\n\\n\", bounty.ID, bounty.Title)\n\toutput += ufmt.Sprintf(\"**Issue URL:** %s\\n\", bounty.IssueURL)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\", bounty.Description)\n\toutput += ufmt.Sprintf(\"**Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\", bounty.Creator)\n\toutput += ufmt.Sprintf(\"**Created:** %s\\n\", bounty.CreatedAt.Format(\"2006-01-02 15:04:05\"))\n\n\tif bounty.IsClaimed {\n\t\toutput += ufmt.Sprintf(\"**Status:** CLAIMED\\n\")\n\t\toutput += ufmt.Sprintf(\"**Claimed by:** %s\\n\", bounty.Claimer)\n\t\toutput += ufmt.Sprintf(\"**Claimed at:** %s\\n\", bounty.ClaimedAt.Format(\"2006-01-02 15:04:05\"))\n\t} else {\n\t\toutput += ufmt.Sprintf(\"**Status:** OPEN\\n\\n\")\n\t\toutput += \"**How to apply:** To apply to a bounty, you need to give your **MERGED PR** (important) URL in the transaction. You also need to write your Gno address in the description of your PR to verify your identity. If no address is written, the bounty can be refused.\\n\\n\"\n\n\t\t// Add apply button\n\t\tapplyLink := txlink.NewLink(\"ApplyForBounty\").\n\t\t\tAddArgs(\n\t\t\t\t\"bountyID\", ufmt.Sprintf(\"%d\", id),\n\t\t\t\t\"prLink\", \"\",\n\t\t\t).\n\t\t\tURL()\n\t\toutput += md.Link(\"Apply for this bounty\", applyLink) + \"\\n\\n\"\n\n\t\t// Show existing applications\n\t\tapps := GetApplicationsForBounty(id)\n\t\tif len(apps) \u003e 0 {\n\t\t\toutput += \"### Applications\\n\\n\"\n\t\t\tfor _, app := range apps {\n\t\t\t\toutput += renderApplication(app)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output\n}\n\n// renderApplication renders a single application\nfunc renderApplication(app *Application) string {\n\toutput := ufmt.Sprintf(\"**Application #%d**\\n\", app.ID)\n\toutput += ufmt.Sprintf(\"- Applicant: %s\\n\", app.Applicant)\n\toutput += ufmt.Sprintf(\"- PR Link: %s\\n\", app.PRLink)\n\toutput += ufmt.Sprintf(\"- Applied: %s\\n\", app.AppliedAt.Format(\"2006-01-02 15:04:05\"))\n\n\tstatusStr := \"PENDING\"\n\tif app.Status == StatusApproved {\n\t\tstatusStr = \"APPROVED\"\n\t} else if app.Status == StatusRejected {\n\t\tstatusStr = \"REJECTED\"\n\t}\n\toutput += ufmt.Sprintf(\"- Status: %s\\n\", statusStr)\n\n\t// Show DAO voting information if DAO exists\n\tif app.DAO != nil {\n\t\toutput += ufmt.Sprintf(\"- Proposal ID: %d\\n\", app.ProposalID)\n\n\t\t// Get proposal and show detailed validator voting status\n\t\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\t\tif proposal != nil {\n\t\t\t// Get vote counts\n\t\t\tyesCount := proposal.VotingRecord().VoteCount(commondao.ChoiceYes)\n\t\t\tnoCount := proposal.VotingRecord().VoteCount(commondao.ChoiceNo)\n\t\t\tabstainCount := proposal.VotingRecord().VoteCount(commondao.ChoiceAbstain)\n\t\t\ttotalVotes := proposal.VotingRecord().Size()\n\t\t\ttotalMembers := app.DAO.Members().Size()\n\n\t\t\toutput += ufmt.Sprintf(\"\\n**Voting Progress:** %d/%d validators have voted\\n\", totalVotes, totalMembers)\n\t\t\toutput += ufmt.Sprintf(\"- ‚úÖ YES: %d\\n\", yesCount)\n\t\t\toutput += ufmt.Sprintf(\"- ‚ùå NO: %d\\n\", noCount)\n\t\t\toutput += ufmt.Sprintf(\"- ü§∑ ABSTAIN: %d\\n\", abstainCount)\n\t\t\toutput += ufmt.Sprintf(\"- ‚è≥ PENDING: %d\\n\", totalMembers-totalVotes)\n\t\t}\n\t}\n\n\t// Add vote buttons for validators if application is still pending\n\tif app.Status == StatusPending \u0026\u0026 app.DAO != nil {\n\t\toutput += \"\\n**Vote on this application:**\\n\"\n\n\t\t// Add vote buttons (yes/no/abstain)\n\t\tyesLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"yes\",\n\t\t\t).\n\t\t\tURL()\n\t\tnoLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"no\",\n\t\t\t).\n\t\t\tURL()\n\t\tabstainLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"abstain\",\n\t\t\t).\n\t\t\tURL()\n\n\t\toutput += md.Link(\"‚úÖ Approve\", yesLink) + \" | \" + md.Link(\"‚ùå Reject\", noLink) + \" | \" + md.Link(\"ü§∑ Abstain\", abstainLink) + \"\\n\"\n\t\toutput += \"\\n_Note: Only assigned validators can vote on this application._\\n\"\n\t}\n\toutput += \"\\n\"\n\n\treturn output\n}\n\n// RenderMyVotes shows pending votes for a validator\nfunc RenderMyVotes(validatorAddr address) string {\n\tif !IsValidator(validatorAddr) {\n\t\treturn \"You are not a registered validator\"\n\t}\n\n\toutput := \"# My Pending Votes\\n\\n\"\n\n\tapps := GetApplicationsForValidator(validatorAddr)\n\tpendingCount := 0\n\n\tfor _, app := range apps {\n\t\tif app.Status == StatusPending {\n\t\t\tbounty := GetBounty(app.BountyID)\n\t\t\tif bounty == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpendingCount++\n\t\t\toutput += ufmt.Sprintf(\"## Application #%d for Bounty #%d\\n\", app.ID, app.BountyID)\n\t\t\toutput += ufmt.Sprintf(\"**Bounty:** %s\\n\", bounty.Description)\n\t\t\toutput += ufmt.Sprintf(\"**Bounty Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\t\t\toutput += ufmt.Sprintf(\"**Applicant:** %s\\n\", app.Applicant)\n\t\t\toutput += ufmt.Sprintf(\"**PR Link:** %s\\n\", app.PRLink)\n\n\t\t\t// Show DAO proposal details\n\t\t\tif app.DAO != nil {\n\t\t\t\toutput += ufmt.Sprintf(\"**Proposal ID:** %d\\n\", app.ProposalID)\n\n\t\t\t\t// Get proposal and show vote count\n\t\t\t\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\t\t\t\tif proposal != nil {\n\t\t\t\t\tvoteCount := 0\n\t\t\t\t\tproposal.VotingRecord().Iterate(0, 0, false, func(v commondao.Vote) bool {\n\t\t\t\t\t\tvoteCount++\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\toutput += ufmt.Sprintf(\"**Votes Submitted:** %d/%d\\n\", voteCount, app.DAO.Members().Size())\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput += \"\\n\"\n\n\t\t\t// Add vote buttons (yes/no/abstain)\n\t\t\tyesLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"yes\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\tnoLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"no\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\tabstainLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"abstain\",\n\t\t\t\t).\n\t\t\t\tURL()\n\n\t\t\toutput += md.Link(\"Approve (Yes)\", yesLink) + \" | \" + md.Link(\"Reject (No)\", noLink) + \" | \" + md.Link(\"Abstain\", abstainLink) + \"\\n\\n\"\n\t\t\toutput += \"---\\n\\n\"\n\t\t}\n\t}\n\n\tif pendingCount == 0 {\n\t\toutput += \"No pending votes\"\n\t}\n\n\treturn output\n}\n\n// RenderValidators shows all validators\nfunc RenderValidators() string {\n\treturn ListValidators()\n}\n\n// Render implements the Render() method for the realm\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn ListBounties()\n\t}\n\n\t// Check for special paths\n\tif path == \"validators\" {\n\t\treturn RenderValidators()\n\t}\n\n\tif path == \"leaderboard\" {\n\t\treturn RenderLeaderboard()\n\t}\n\n\t// Parse bounty ID from path\n\tid, err := strconv.Atoi(path)\n\tif err != nil {\n\t\treturn ufmt.Sprintf(\"Invalid path. Use /%s for bounties or /%s:validators for validators list\", pkgPath, pkgPath)\n\t}\n\n\treturn GetBountyDetails(uint64(id))\n}\n"},{"name":"storage.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nvar (\n\tbounties      avl.Tree // uint64 -\u003e *Bounty\n\tbountyCount   uint64\n\tminimumBounty int64 = 1000000 // 1 GNOT minimum\n\n\tapplications     avl.Tree // uint64 -\u003e *Application\n\tapplicationCount uint64\n\n\tvalidators       avl.Tree      // address -\u003e *Validator\n\tvalidatorList    []address     // List of validator addresses for random selection\n\tvalidatorsPerDAO int       = 3 // Number of validators per DAO vote\n\trequiredVotes    int       = 3 // Number of approvals needed (3/3)\n\n\t// Validator reward percentage (5% of bounty split among validators)\n\tvalidatorRewardPercent int64 = 5 // 5% of bounty goes to validators\n\n\townership *ownable.Ownable\n\n\t// Package address - stored for easy redeployment\n\tpkgAddr address\n\n\t// Package path - used in URLs for rendering\n\tpkgPath string = \"gno.land/r/greg007/gnobounty\"\n)\n\nfunc init() {\n\townership = ownable.NewWithOrigin()\n\tpkgAddr = chain.PackageAddress(pkgPath)\n}\n\n// GetBounty returns a bounty by ID\nfunc GetBounty(id uint64) *Bounty {\n\tbountyInterface, exists := bounties.Get(ufmt.Sprintf(\"%d\", id))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn bountyInterface.(*Bounty)\n}\n\n// GetBountyCount returns the total number of bounties created\nfunc GetBountyCount() uint64 {\n\treturn bountyCount\n}\n\n// SetMinimumBounty allows setting minimum bounty amount (admin function)\nfunc SetMinimumBounty(amount int64) {\n\townership.AssertOwnedByPrevious()\n\tminimumBounty = amount\n}\n\n// SetPackagePath allows setting the package path for URLs (admin function)\nfunc SetPackagePath(path string) {\n\townership.AssertOwnedByPrevious()\n\tif path == \"\" {\n\t\tpanic(\"package path cannot be empty\")\n\t}\n\tpkgPath = path\n\tpkgAddr = chain.PackageAddress(path)\n}\n\n// GetApplication returns an application by ID\nfunc GetApplication(id uint64) *Application {\n\tappInterface, exists := applications.Get(ufmt.Sprintf(\"%d\", id))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn appInterface.(*Application)\n}\n\n// GetApplicationCount returns the total number of applications\nfunc GetApplicationCount() uint64 {\n\treturn applicationCount\n}\n\n// IsValidator checks if an address is a validator\nfunc IsValidator(addr address) bool {\n\tvalidatorInterface, exists := validators.Get(string(addr))\n\tif !exists {\n\t\treturn false\n\t}\n\tvalidator := validatorInterface.(*Validator)\n\treturn validator.Active\n}\n\n// GetValidator returns a validator by address\nfunc GetValidator(addr address) *Validator {\n\tvalidatorInterface, exists := validators.Get(string(addr))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn validatorInterface.(*Validator)\n}\n\n// GetActiveValidatorCount returns the number of active validators\nfunc GetActiveValidatorCount() int {\n\tcount := 0\n\tvalidators.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tvalidator := value.(*Validator)\n\t\tif validator.Active {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetOwner returns the owner address (helper function for debugging)\nfunc GetOwner() address {\n\treturn ownership.Owner()\n}\n\n// GetPackagePath returns the current package path\nfunc GetPackagePath() string {\n\treturn pkgPath\n}\n"},{"name":"types.gno","body":"package gnobounty\n\nimport (\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\n// Bounty represents a bounty post for an issue\ntype Bounty struct {\n\tID          uint64\n\tTitle       string // Short title for the bounty\n\tIssueURL    string\n\tDescription string\n\tAmount      int64 // Amount in ugnot\n\tCreator     address\n\tCreatedAt   time.Time\n\tIsClaimed   bool\n\tClaimer     address\n\tClaimedAt   time.Time\n}\n\n// Application represents a claim application for a bounty with a private DAO\ntype Application struct {\n\tID         uint64\n\tBountyID   uint64\n\tApplicant  address\n\tPRLink     string\n\tAppliedAt  time.Time\n\tStatus     ApplicationStatus\n\tDAO        *commondao.CommonDAO // Private DAO for this application\n\tProposalID uint64               // Proposal ID in the DAO\n\tVotes      []VoteRecord         // Local record of votes\n}\n\n// VoteRecord represents a vote cast by a validator\ntype VoteRecord struct {\n\tVoter  address\n\tChoice commondao.VoteChoice\n}\n\n// ApplicationStatus represents the status of an application\ntype ApplicationStatus int\n\nconst (\n\tStatusPending ApplicationStatus = iota\n\tStatusApproved\n\tStatusRejected\n)\n\n// Validator represents a validator who can vote on applications\ntype Validator struct {\n\tAddress address\n\tAddedAt time.Time\n\tActive  bool\n}\n"},{"name":"validators.gno","body":"package gnobounty\n\nimport (\n\t\"time\"\n\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// AddValidator adds a new validator to the system (Admin only)\nfunc AddValidator(_ realm, validatorAddr address) {\n\t// Check if caller is admin\n\townership.AssertOwnedByPrevious()\n\n\t// Check if validator already exists\n\tif _, exists := validators.Get(string(validatorAddr)); exists {\n\t\tpanic(\"validator already exists\")\n\t}\n\n\tvalidator := \u0026Validator{\n\t\tAddress: validatorAddr,\n\t\tAddedAt: time.Now(),\n\t\tActive:  true,\n\t}\n\n\tvalidators.Set(string(validatorAddr), validator)\n\tvalidatorList = append(validatorList, validatorAddr)\n}\n\n// RemoveValidator removes a validator from the system (Admin only)\nfunc RemoveValidator(_ realm, validatorAddr address) {\n\t// Check if caller is admin\n\townership.AssertOwnedByPrevious()\n\n\tvalidatorInterface, exists := validators.Get(string(validatorAddr))\n\tif !exists {\n\t\tpanic(\"validator not found\")\n\t}\n\n\tvalidator := validatorInterface.(*Validator)\n\tvalidator.Active = false\n\n\t// Remove from validator list\n\tnewList := make([]address, 0)\n\tfor _, addr := range validatorList {\n\t\tif addr != validatorAddr {\n\t\t\tnewList = append(newList, addr)\n\t\t}\n\t}\n\tvalidatorList = newList\n}\n\n// selectRandomValidators selects N random validators for voting\n// Uses a simple pseudo-random selection based on application ID\nfunc selectRandomValidators(appID uint64, count int) []address {\n\tactiveValidators := getActiveValidators()\n\n\tif len(activeValidators) \u003c count {\n\t\tpanic(ufmt.Sprintf(\"not enough active validators: need %d, have %d\", count, len(activeValidators)))\n\t}\n\n\t// Simple pseudo-random selection using appID as seed\n\tselected := make([]address, 0, count)\n\tseed := appID\n\n\tfor i := 0; i \u003c count; i++ {\n\t\tindex := int((seed + uint64(i)*7) % uint64(len(activeValidators)))\n\t\tselected = append(selected, activeValidators[index])\n\n\t\t// Remove selected validator to avoid duplicates\n\t\tactiveValidators = append(activeValidators[:index], activeValidators[index+1:]...)\n\t}\n\n\treturn selected\n}\n\n// getActiveValidators returns all active validator addresses\nfunc getActiveValidators() []address {\n\tactive := make([]address, 0)\n\tfor _, addr := range validatorList {\n\t\tif IsValidator(addr) {\n\t\t\tactive = append(active, addr)\n\t\t}\n\t}\n\treturn active\n}\n\n// ListValidators returns information about all validators\nfunc ListValidators() string {\n\toutput := \"# Validators\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"**Total Active Validators:** %d\\n\\n\", GetActiveValidatorCount())\n\n\tif len(validatorList) == 0 {\n\t\toutput += \"No validators registered yet.\\n\\n\"\n\t} else {\n\t\tvalidators.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tvalidator := value.(*Validator)\n\t\t\tstatus := \"‚úÖ ACTIVE\"\n\t\t\tif !validator.Active {\n\t\t\t\tstatus = \"‚ùå INACTIVE\"\n\t\t\t}\n\t\t\toutput += ufmt.Sprintf(\"- %s %s - Added: %s\\n\",\n\t\t\t\tstatus,\n\t\t\t\tvalidator.Address,\n\t\t\t\tvalidator.AddedAt.Format(\"2006-01-02\"))\n\t\t\treturn false\n\t\t})\n\t\toutput += \"\\n\"\n\t}\n\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"JuFlCMLuuVVJlxqcWiVsHBeFZ9yGYOvNYp+nNH5si+eWLPeaXrxryQ3QbT4auD5DnBjid70HTgm0qRNm9fKgCA=="}],"memo":""},"metadata":{"timestamp":"1765549445"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty_v2","func":"AddValidator","args":[""]}],"fee":{"gas_wanted":"4095562","gas_fee":"4096ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"u0oezjHY1ftSy7dCwRJcU58tCVSVMhnlVGkzD8oLyakUXAlwibFga/dkcrPbqHOQcFpz39h0sy0eeyK1excdAQ=="}],"memo":""},"metadata":{"timestamp":"1765549601"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty_v2","func":"AddValidator","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5"]}],"fee":{"gas_wanted":"4162568","gas_fee":"4163ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"LwIvkNItrqVXdDWOmy/Shcoy3KDH1xojjhliKlrn4lmegEiq5kuYY2rs/gOxt84brFUq8dnAQs1PIzC9Ry7MDg=="}],"memo":""},"metadata":{"timestamp":"1765549631"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty_v2","func":"AddValidator","args":["g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0"]}],"fee":{"gas_wanted":"4282573","gas_fee":"4283ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PLppLBhjRJbnJOcQ5ILUh4wfg9F+5pt23UhL7LkHZ5QGIiq+QMG9iZGEAIR1OMH3wRbW14/FUZNQmlWhNn1pDw=="}],"memo":""},"metadata":{"timestamp":"1765549646"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty_v2","func":"AddValidator","args":["g120lcpvxlv9q8hmtwkxzvw9cfzj3pu2hsf02qy7"]}],"fee":{"gas_wanted":"4286543","gas_fee":"4287ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"SLmnK43Dr2YfOuywapZMvw0CJOimi+AF7jRx+ILRckiK+l1g6Xx7mSd04XEGc3c2loXoQUHqGPT6AKyMRJV3Cw=="}],"memo":""},"metadata":{"timestamp":"1765549662"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"1000000ugnot","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty_v2","func":"CreateBounty","args":["test","https://gno.land/r/greg007/gnobounty_v2","its simply a test"]}],"fee":{"gas_wanted":"6570437","gas_fee":"6571ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"saYLzTYLJEj/szy/OUXC613tjaSD20EGzzoCtyi5SgsEuq+VB7yMcXNesjfgb8jDb6iB9yiZfnSXpYtaRIJ5DA=="}],"memo":""},"metadata":{"timestamp":"1765549873"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty_v2","func":"ApplyForBounty","args":["1","https://github.com/gnoverse/community/pull/22"]}],"fee":{"gas_wanted":"12691504","gas_fee":"12692ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"LxPwnhhgOSV9OXBtFB1IAxOa/2uQ91dDNog8qeIetN3USs/GF4Jdj7An8qcd/p4yHnMc0dtYGIxeQO2aNm8lDw=="}],"memo":""},"metadata":{"timestamp":"1765549998"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"EMRORmxmsiGDaP9E3uEAvVb0l2Udjb1hAkVrFe9tUUFIcFlVk4GJWbNf7IrAQRYUj/sQPLH8px0YK4bAZromDw=="}],"memo":""},"metadata":{"timestamp":"1765551652"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"EMRORmxmsiGDaP9E3uEAvVb0l2Udjb1hAkVrFe9tUUFIcFlVk4GJWbNf7IrAQRYUj/sQPLH8px0YK4bAZromDw=="}],"memo":""},"metadata":{"timestamp":"1765551662"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","package":{"name":"gnobounty","path":"gno.land/r/greg007/gnobounty_v3","files":[{"name":"README.md","body":"# GnoBounty\n\nA decentralized bounty system for managing rewards on GitHub issues (or any issue tracker) using the Gno blockchain, with DAO-based validation through validator voting.\n\n## Features\n\n- **Create Bounties**: Post a bounty on any issue by providing the issue URL and sending GNOT tokens\n- **Apply for Bounties**: Submit your merged PR link to apply for a bounty\n- **DAO Validation**: 3 validators are randomly selected to vote on each application\n- **Automatic Claims**: Bounties are automatically claimed when 2/3 validators approve\n- **Validator System**: Decentralized validation through registered validators\n- **Cancel Bounties**: Creators can cancel unclaimed bounties and receive a refund\n- **List Bounties**: Browse all active bounties with reward amounts\n- **Transparent**: All bounties and applications are stored on-chain and publicly viewable\n\n## How to Use\n\n### Creating a Bounty\n\nTo create a bounty, call the `CreateBounty` function with the issue URL and description, and send GNOT tokens:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty_v3\" \\\n  -func \"CreateBounty\" \\\n  -args \"https://github.com/gnolang/gno/issues/1234\" \\\n  -args \"Fix the rendering bug in GRC20 token display\" \\\n  -send \"5000000ugnot\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- `issueURL`: The URL of the issue (GitHub, GitLab, etc.)\n- `description`: A brief description of what needs to be done\n- `send`: The bounty amount in ugnot (1 GNOT = 1,000,000 ugnot)\n\n**Minimum bounty**: 1 GNOT (1,000,000 ugnot)\n\n### Viewing Bounties\n\nVisit the realm in your browser to see all active bounties:\n\n```\nhttps://gno.land/r/greg007/gnobounty_v3\n```\n\nOr view a specific bounty by ID:\n\n```\nhttps://gno.land/r/greg007/gnobounty_v3/1\n```\n\n### Applying for a Bounty\n\nWhen you complete work on a bounty, submit your merged PR link to apply:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty_v3\" \\\n  -func \"ApplyForBounty\" \\\n  -args \"1\" \\\n  -args \"https://github.com/gnolang/gno/pull/5678\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- First arg: Bounty ID\n- Second arg: URL of your merged pull request\n\n**What happens next:**\n1. Your application is created\n2. 3 random validators are selected from the validator pool\n3. Validators review your PR and vote to approve or reject\n4. If 2 out of 3 validators approve, the bounty is automatically transferred to you!\n\n### Validator Voting\n\nIf you're a registered validator, you can vote on applications assigned to you:\n\n```bash\n# Approve an application\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty_v3\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"true\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n\n# Reject an application\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty_v3\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"false\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Parameters:**\n- First arg: Application ID\n- Second arg: \"true\" to approve, \"false\" to reject\n\n### Legacy: Manual Claiming (deprecated)\n\nThe old manual claim system is still available but deprecated in favor of DAO validation:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty_v3\" \\\n  -func \"ClaimBounty\" \\\n  -args \"1\" \\\n  -args \"g1abc123...xyz\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n### Cancelling a Bounty\n\nIf you need to cancel a bounty and get your funds back:\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/greg007/gnobounty_v3\" \\\n  -func \"CancelBounty\" \\\n  -args \"1\" \\\n  -gas-fee \"1000000ugnot\" \\\n  -gas-wanted \"2000000\" \\\n  -broadcast \\\n  -chainid \"dev\" \\\n  -remote \"localhost:26657\" \\\n  mykey\n```\n\n**Note:** You can only cancel bounties that haven't been claimed yet.\n\n## API Reference\n\n### Bounty Functions\n\n#### `CreateBounty(cur realm, issueURL, description string) uint64`\nCreates a new bounty and returns the bounty ID. Must send GNOT with the transaction.\n\n#### `GetBounty(id uint64) *Bounty`\nReturns bounty details by ID.\n\n#### `CancelBounty(cur realm, id uint64)`\nCancels a bounty and refunds the creator. Only callable by the bounty creator on unclaimed bounties.\n\n#### `ListBounties() string`\nReturns a formatted list of all active bounties.\n\n#### `GetBountyDetails(id uint64) string`\nReturns detailed information about a specific bounty with apply button.\n\n#### `GetBountyCount() uint64`\nReturns the total number of bounties created.\n\n### Application \u0026 Voting Functions\n\n#### `ApplyForBounty(cur realm, bountyID uint64, prLink string) uint64`\nSubmit an application for a bounty with your merged PR link. Returns the application ID.\n- Automatically selects 3 random validators\n- Creates a pending application\n- Returns application ID\n\n#### `Vote(cur realm, applicationID uint64, approve bool)`\nVote on an application (validator only). Must be one of the selected validators.\n- `approve`: true to approve, false to reject\n- Automatically claims bounty if 2/3 validators approve\n\n#### `GetApplication(id uint64) *Application`\nReturns application details by ID.\n\n#### `GetApplicationsForBounty(bountyID uint64) []*Application`\nReturns all applications for a specific bounty.\n\n#### `GetApplicationsForValidator(validatorAddr address) []*Application`\nReturns all applications assigned to a validator for voting.\n\n#### `GetApplicationCount() uint64`\nReturns the total number of applications created.\n\n### Validator Management Functions\n\n#### `AddValidator(cur realm, validatorAddr address)`\nAdds a new validator to the system (admin function).\n\n#### `RemoveValidator(cur realm, validatorAddr address)`\nDeactivates a validator (admin function).\n\n#### `IsValidator(addr address) bool`\nChecks if an address is an active validator.\n\n#### `GetActiveValidatorCount() int`\nReturns the number of active validators.\n\n#### `ListValidators() string`\nReturns a formatted list of all validators and their status.\n\n### Rendering Functions\n\n#### `RenderMyVotes(validatorAddr address) string`\nShows pending applications that need votes from the specified validator, with approve/reject buttons.\n\n#### `Render(path string) string`\nMain render function for the realm.\n\n### Bounty Structure\n\n```go\ntype Bounty struct {\n    ID          uint64    // Unique bounty identifier\n    IssueURL    string    // Link to the issue\n    Description string    // Description of the work\n    Amount      int64     // Reward amount in ugnot\n    Creator     address   // Address of the bounty creator\n    CreatedAt   time.Time // When the bounty was created\n    IsClaimed   bool      // Whether the bounty has been claimed\n    Claimer     address   // Address of the claimer (if claimed)\n    ClaimedAt   time.Time // When the bounty was claimed\n}\n```\n\n## Example Workflow\n\n1. **Alice creates a bounty** for fixing a bug, sending 5 GNOT:\n   ```\n   CreateBounty(\"https://github.com/project/repo/issues/42\", \"Fix memory leak in parser\")\n   ```\n\n2. **Bob sees the bounty** and decides to work on it. He visits the issue URL and starts coding.\n\n3. **Bob completes the work** and submits a pull request fixing the issue.\n\n4. **Alice verifies the fix** and approves Bob's claim:\n   ```\n   ClaimBounty(cross, 1, \"g1bob123...xyz\")\n   ```\n\n5. **Bob receives 5 GNOT** automatically to his address!\n\n## Security Considerations\n\n- Only the bounty creator can approve claims\n- Bounties are locked in the realm contract until claimed or cancelled\n- Once claimed, bounties cannot be cancelled\n- The realm must have sufficient funds to pay out bounties\n\n## Notes\n\n- This implementation uses the new Gno standard library split (post-#3874)\n- Amounts are stored in ugnot (micro-GNOT): 1 GNOT = 1,000,000 ugnot\n- The `address` type is used as a builtin instead of `std.Address`\n- Uses new imports:\n  - `gno.land/r/sys/chain` for `Coin` and `Coins` types\n  - `gno.land/r/sys/chain/banker` for banker operations (`NewBanker`, `BankerType*`, `OriginSend`)\n  - `gno.land/r/sys/chain/runtime` for realm functions (`PreviousRealm`, `CurrentRealm`)\n\n## License\n\nMIT\n"},{"name":"application.gno","body":"package gnobounty\n\nimport (\n\t\"chain/runtime\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ApplyForBounty allows a user to apply for a bounty with their merged PR link\n// This creates an application with a private DAO for 3 random validators to vote\nfunc ApplyForBounty(_ realm, bountyID uint64, prLink string) uint64 {\n\tcaller := runtime.OriginCaller()\n\n\t// Validate inputs\n\tif prLink == \"\" {\n\t\tpanic(\"PR link cannot be empty\")\n\t}\n\n\t// Check bounty exists and is not claimed\n\tbounty := GetBounty(bountyID)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"bounty already claimed\")\n\t}\n\n\t// Check if there are enough validators\n\tactiveValidatorCount := GetActiveValidatorCount()\n\tif activeValidatorCount \u003c validatorsPerDAO {\n\t\tpanic(ufmt.Sprintf(\"not enough validators: need %d, have %d\", validatorsPerDAO, activeValidatorCount))\n\t}\n\n\t// Check if user already has a pending application for this bounty\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\tif app.BountyID == bountyID \u0026\u0026 app.Applicant == caller \u0026\u0026 app.Status == StatusPending {\n\t\t\tpanic(\"you already have a pending application for this bounty\")\n\t\t}\n\t\treturn false\n\t})\n\n\t// Select 3 random validators for this application\n\tselectedValidators := selectRandomValidators(applicationCount+1, validatorsPerDAO)\n\n\t// Create the DAO for this application\n\tapplicationCount++\n\tdaoName := ufmt.Sprintf(\"Bounty #%d Application #%d Review DAO\", bountyID, applicationCount)\n\tdaoDesc := ufmt.Sprintf(\"Private DAO to review application for bounty #%d\", bountyID)\n\n\t// Create DAO with selected validators as members\n\t// DisableVotingDeadlineCheck allows immediate execution after votes\n\tdao := commondao.New(\n\t\tcommondao.WithID(applicationCount),\n\t\tcommondao.WithName(daoName),\n\t\tcommondao.WithDescription(daoDesc),\n\t\tcommondao.DisableVotingDeadlineCheck(),\n\t)\n\n\t// Add selected validators as members\n\tfor _, validatorAddr := range selectedValidators {\n\t\tdao.Members().Add(validatorAddr)\n\t}\n\n\t// Create a proposal in the DAO to approve this application BEFORE creating the Application struct\n\tproposalDef := NewClaimBountyProposal(bountyID, applicationCount, caller, prLink)\n\tproposal := dao.MustPropose(caller, proposalDef)\n\n\t// Create the application with the correct proposalID from the start\n\tapplication := \u0026Application{\n\t\tID:         applicationCount,\n\t\tBountyID:   bountyID,\n\t\tApplicant:  caller,\n\t\tPRLink:     prLink,\n\t\tAppliedAt:  time.Now(),\n\t\tStatus:     StatusPending,\n\t\tDAO:        dao,\n\t\tProposalID: proposal.ID(),\n\t}\n\n\t// Store application\n\tapplications.Set(ufmt.Sprintf(\"%d\", applicationCount), application)\n\n\treturn applicationCount\n}\n\n// Vote allows a selected validator to vote on an application via the DAO\nfunc Vote(_ realm, applicationID uint64, vote string) {\n\tcaller := runtime.OriginCaller()\n\n\t// Check if caller is a validator\n\tif !IsValidator(caller) {\n\t\tpanic(\"only validators can vote\")\n\t}\n\n\t// Get application\n\tapp := GetApplication(applicationID)\n\tif app == nil {\n\t\tpanic(\"application not found\")\n\t}\n\n\tif app.Status != StatusPending {\n\t\tpanic(\"application is no longer pending\")\n\t}\n\n\t// Check if caller is a member of this application's DAO\n\tif !app.DAO.Members().Has(caller) {\n\t\tpanic(\"you are not a validator for this application\")\n\t}\n\n\t// Get the proposal\n\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal == nil {\n\t\tpanic(\"proposal not found\")\n\t}\n\n\t// Convert string vote to VoteChoice\n\tvar voteChoice commondao.VoteChoice\n\tswitch vote {\n\tcase \"yes\", \"true\", \"approve\":\n\t\tvoteChoice = commondao.ChoiceYes\n\tcase \"no\", \"false\", \"reject\":\n\t\tvoteChoice = commondao.ChoiceNo\n\tcase \"abstain\":\n\t\tvoteChoice = commondao.ChoiceAbstain\n\tdefault:\n\t\tpanic(\"invalid vote: must be 'yes', 'no', or 'abstain'\")\n\t}\n\n\t// Vote on the proposal using CommonDAO's Vote method\n\t// This method validates membership, deadline, and vote choice\n\terr := app.DAO.Vote(caller, app.ProposalID, voteChoice, \"\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Record vote locally\n\tapp.Votes = append(app.Votes, VoteRecord{\n\t\tVoter:  caller,\n\t\tChoice: voteChoice,\n\t})\n\n\t// Try to execute the proposal\n\t// Tally() will return true when all validators have voted\n\t// Execute() will handle both approval and rejection\n\tproposal = app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal != nil {\n\t\ttotalMembers := app.DAO.Members().Size()\n\t\ttotalVotes := proposal.VotingRecord().Size()\n\n\t\t// If all validators have voted, execute to finalize\n\t\tif totalVotes == totalMembers {\n\t\t\terr = app.DAO.Execute(app.ProposalID)\n\t\t\t// Ignore errors - proposal might already be executed or failed\n\t\t\t// The status will be updated in Execute() regardless\n\t\t}\n\t}\n}\n\n// GetApplicationsForBounty returns all applications for a specific bounty\nfunc GetApplicationsForBounty(bountyID uint64) []*Application {\n\tapps := make([]*Application, 0)\n\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\tif app.BountyID == bountyID {\n\t\t\tapps = append(apps, app)\n\t\t}\n\t\treturn false\n\t})\n\n\treturn apps\n}\n\n// GetApplicationsForValidator returns all applications assigned to a validator\nfunc GetApplicationsForValidator(validatorAddr address) []*Application {\n\tapps := make([]*Application, 0)\n\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tapp := value.(*Application)\n\t\t// Check if validator is a member of the application's DAO\n\t\tif app.DAO != nil \u0026\u0026 app.Status == StatusPending \u0026\u0026 app.DAO.Members().Has(validatorAddr) {\n\t\t\tapps = append(apps, app)\n\t\t}\n\t\treturn false\n\t})\n\n\treturn apps\n}\n"},{"name":"application_test.gno","body":"package gnobounty\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/testutils\"\n)\n\nfunc TestAddValidator(t *testing.T) {\n\t// Setup owner - use testing.SetOriginCaller to set who is calling\n\tadminAddr := testutils.TestAddress(\"admin\")\n\ttesting.SetOriginCaller(adminAddr)\n\n\t// Initialize ownership with current caller as owner\n\townership = ownable.New()\n\n\t// Add a validator\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tAddValidator(cross, validator1)\n\n\tif !IsValidator(validator1) {\n\t\tt.Error(\"Validator should be active\")\n\t}\n\n\tcount := GetActiveValidatorCount()\n\tif count \u003c 1 {\n\t\tt.Error(\"Expected at least 1 active validator\")\n\t}\n}\n\nfunc TestValidatorList(t *testing.T) {\n\t// Setup owner - reuse same admin from previous test\n\tadminAddr := testutils.TestAddress(\"admin\")\n\ttesting.SetOriginCaller(adminAddr)\n\n\t// Add more validators\n\tvalidator2 := testutils.TestAddress(\"validator2\")\n\n\t// Check if already exists before adding\n\tif !IsValidator(validator2) {\n\t\tAddValidator(cross, validator2)\n\t}\n\n\tif !IsValidator(validator2) {\n\t\tt.Error(\"Validator2 should be active\")\n\t}\n\n\tcount := GetActiveValidatorCount()\n\tif count \u003c 2 {\n\t\tt.Errorf(\"Expected at least 2 active validators, got %d\", count)\n\t}\n}\n\nfunc TestListValidators(t *testing.T) {\n\tlist := ListValidators()\n\tif list == \"\" {\n\t\tt.Error(\"Expected non-empty validators list\")\n\t}\n}\n\nfunc TestIsValidatorCheck(t *testing.T) {\n\t// Test a non-validator address\n\tnonValidator := testutils.TestAddress(\"nonvalidator\")\n\tif IsValidator(nonValidator) {\n\t\tt.Error(\"Non-validator should not be recognized as validator\")\n\t}\n\n\t// Test existing validator\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tif !IsValidator(validator1) {\n\t\tt.Error(\"validator1 should be recognized as validator\")\n\t}\n}\n\nfunc TestGetValidator(t *testing.T) {\n\tvalidator1 := testutils.TestAddress(\"validator1\")\n\tv := GetValidator(validator1)\n\n\tif v == nil {\n\t\tt.Fatal(\"Expected to find validator1\")\n\t}\n\n\tif v.Address != validator1 {\n\t\tt.Error(\"Validator address mismatch\")\n\t}\n\n\tif !v.Active {\n\t\tt.Error(\"Validator should be active\")\n\t}\n}\n"},{"name":"gnobounty_test.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"testing\"\n\n\t\"gno.land/p/nt/testutils\"\n)\n\nfunc TestCreateBounty(t *testing.T) {\n\t// Setup test environment\n\ttesting.SetOriginCaller(testutils.TestAddress(\"alice\"))\n\ttesting.SetOriginSend(chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: 5000000}})\n\n\t// Create a bounty\n\tbountyID := CreateBounty(\n\t\tcross,\n\t\t\"Fix Rendering Bug\",\n\t\t\"https://github.com/gnolang/gno/issues/1234\",\n\t\t\"Fix the rendering issue in the GRC20 token display\",\n\t)\n\n\tif bountyID != 1 {\n\t\tt.Errorf(\"Expected bounty ID 1, got %d\", bountyID)\n\t}\n\n\t// Check bounty was created\n\tbounty := GetBounty(bountyID)\n\tif bounty == nil {\n\t\tt.Fatal(\"Bounty not found\")\n\t}\n\n\tif bounty.Amount != 5000000 {\n\t\tt.Errorf(\"Expected amount 5000000, got %d\", bounty.Amount)\n\t}\n\n\tif bounty.IsClaimed {\n\t\tt.Error(\"Bounty should not be claimed yet\")\n\t}\n\n\tif bounty.Title != \"Fix Rendering Bug\" {\n\t\tt.Errorf(\"Expected title 'Fix Rendering Bug', got %s\", bounty.Title)\n\t}\n}\n\nfunc TestGetBountyCount(t *testing.T) {\n\tcount := GetBountyCount()\n\tif count \u003c 1 {\n\t\tt.Error(\"Expected at least 1 bounty from previous test\")\n\t}\n}\n\nfunc TestListBounties(t *testing.T) {\n\tlist := ListBounties()\n\tif list == \"\" {\n\t\tt.Error(\"Expected non-empty bounties list\")\n\t}\n\tif list == \"No bounties available\" {\n\t\tt.Error(\"Expected bounties to be listed\")\n\t}\n}\n\nfunc TestGetBountyDetails(t *testing.T) {\n\t// Test getting details for existing bounty\n\tdetails := GetBountyDetails(1)\n\tif details == \"\" {\n\t\tt.Error(\"Expected non-empty bounty details\")\n\t}\n\tif details == \"Bounty not found\" {\n\t\tt.Error(\"Bounty #1 should exist\")\n\t}\n}\n\nfunc TestGetBountyDetailsNotFound(t *testing.T) {\n\t// Test getting details for non-existent bounty\n\tdetails := GetBountyDetails(99999)\n\tif details != \"Bounty not found\" {\n\t\tt.Error(\"Expected 'Bounty not found' for non-existent bounty\")\n\t}\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/greg007/gnobounty_v3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0\"\n"},{"name":"leaderboard.gno","body":"package gnobounty\n\nimport (\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// LeaderboardEntry holds the stats for a user\ntype LeaderboardEntry struct {\n\tAddress              address\n\tBountiesCreated      int\n\tBountiesApplied      int\n\tValidationsPerformed int\n\tScore                int\n}\n\n// GetLeaderboard aggregates stats for all users\nfunc GetLeaderboard() []LeaderboardEntry {\n\tvar stats avl.Tree // address -\u003e *LeaderboardEntry\n\n\t// Count bounties created (10 points)\n\tbounties.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tif value == nil {\n\t\t\treturn false\n\t\t}\n\t\tbounty, ok := value.(*Bounty)\n\t\tif !ok || bounty == nil {\n\t\t\treturn false\n\t\t}\n\t\tentry := getEntry(\u0026stats, bounty.Creator)\n\t\tentry.BountiesCreated++\n\t\tentry.Score += 10\n\t\treturn false\n\t})\n\n\t// Count applications and validations\n\tapplications.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tif value == nil {\n\t\t\treturn false\n\t\t}\n\t\tapp, ok := value.(*Application)\n\t\tif !ok || app == nil {\n\t\t\treturn false\n\t\t}\n\n\t\t// Only count approved applications (20 points)\n\t\tif app.Status == StatusApproved {\n\t\t\tentry := getEntry(\u0026stats, app.Applicant)\n\t\t\tentry.BountiesApplied++\n\t\t\tentry.Score += 20\n\t\t}\n\n\t\t// Count validations from local record (5 points)\n\t\tfor _, vote := range app.Votes {\n\t\t\tentry := getEntry(\u0026stats, vote.Voter)\n\t\t\tentry.ValidationsPerformed++\n\t\t\tentry.Score += 5\n\t\t}\n\n\t\treturn false\n\t})\n\n\t// Convert tree to slice\n\tvar result []LeaderboardEntry\n\tstats.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tentry := value.(*LeaderboardEntry)\n\t\tresult = append(result, *entry)\n\t\treturn false\n\t})\n\n\t// Sort by Score descending\n\t// Manual bubble sort since sort.Slice is not available\n\tfor i := 0; i \u003c len(result)-1; i++ {\n\t\tfor j := 0; j \u003c len(result)-i-1; j++ {\n\t\t\tif result[j].Score \u003c result[j+1].Score {\n\t\t\t\t// Swap\n\t\t\t\tresult[j], result[j+1] = result[j+1], result[j]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n// RenderLeaderboard renders the leaderboard page\nfunc RenderLeaderboard() string {\n\tentries := GetLeaderboard()\n\n\toutput := md.H1(\"üèÜ Community Leaderboard\")\n\toutput += \"Top contributors to the GnoBounty ecosystem.\\n\\n\"\n\toutput += md.Bold(\"Scoring:\") + \" Bounty Creation (10pts) | Approved Application (20pts) | Validation (5pts)\\n\\n\"\n\n\tif len(entries) == 0 {\n\t\toutput += \"No activity recorded yet.\"\n\t\treturn output\n\t}\n\n\t// Table header\n\toutput += \"| Rank | User | Score | üí∞ Bounties | üìù Applications | ‚öñÔ∏è Validations |\\n\"\n\toutput += \"|---|---|---|---|---|---|\\n\"\n\n\t// Table rows\n\tfor i, entry := range entries {\n\t\trank := getRankDisplay(i)\n\t\toutput += tableRow(\n\t\t\trank,\n\t\t\tstring(entry.Address),\n\t\t\tmd.Bold(ufmt.Sprintf(\"%d\", entry.Score)),\n\t\t\tufmt.Sprintf(\"%d\", entry.BountiesCreated),\n\t\t\tufmt.Sprintf(\"%d\", entry.BountiesApplied),\n\t\t\tufmt.Sprintf(\"%d\", entry.ValidationsPerformed),\n\t\t)\n\t}\n\n\treturn output\n}\n\n// getRankDisplay returns the rank display (medal for top 3, number otherwise)\nfunc getRankDisplay(position int) string {\n\tswitch position {\n\tcase 0:\n\t\treturn \"ü•á\"\n\tcase 1:\n\t\treturn \"ü•à\"\n\tcase 2:\n\t\treturn \"ü•â\"\n\tdefault:\n\t\treturn ufmt.Sprintf(\"%d\", position+1)\n\t}\n}\n\n// tableRow creates a markdown table row\nfunc tableRow(cells ...string) string {\n\toutput := \"|\"\n\tfor _, cell := range cells {\n\t\toutput += \" \" + cell + \" |\"\n\t}\n\treturn output + \"\\n\"\n}\n\nfunc getEntry(stats *avl.Tree, addr address) *LeaderboardEntry {\n\tkey := string(addr)\n\tval, ok := stats.Get(key)\n\tif !ok {\n\t\tentry := \u0026LeaderboardEntry{Address: addr}\n\t\tstats.Set(key, entry)\n\t\treturn entry\n\t}\n\treturn val.(*LeaderboardEntry)\n}\n"},{"name":"logic.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"time\"\n\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// CreateBounty creates a new bounty post\n// title: short title for the bounty\n// issueURL: link to the GitHub issue or other issue tracker\n// description: description of what needs to be done\n// Caller must send GNOT tokens with this transaction\nfunc CreateBounty(_ realm, title, issueURL, description string) uint64 {\n\t// Validate inputs\n\tif title == \"\" {\n\t\tpanic(\"title is required\")\n\t}\n\tif issueURL == \"\" {\n\t\tpanic(\"issue URL is required\")\n\t}\n\tif description == \"\" {\n\t\tpanic(\"description is required\")\n\t}\n\n\t// Get the sent coins\n\tsent := banker.OriginSend()\n\tif len(sent) == 0 {\n\t\tpanic(\"no coins sent with bounty\")\n\t}\n\n\t// Find GNOT amount\n\tvar gnotAmount int64\n\tfor _, coin := range sent {\n\t\tif coin.Denom == \"ugnot\" {\n\t\t\tgnotAmount = coin.Amount\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif gnotAmount \u003c minimumBounty {\n\t\tpanic(ufmt.Sprintf(\"bounty amount must be at least %d ugnot\", minimumBounty))\n\t}\n\n\t// Create bounty\n\tbountyCount++\n\tbounty := \u0026Bounty{\n\t\tID:          bountyCount,\n\t\tTitle:       title,\n\t\tIssueURL:    issueURL,\n\t\tDescription: description,\n\t\tAmount:      gnotAmount,\n\t\tCreator:     runtime.OriginCaller(),\n\t\tCreatedAt:   time.Now(),\n\t\tIsClaimed:   false,\n\t}\n\n\t// Store bounty\n\tbounties.Set(ufmt.Sprintf(\"%d\", bountyCount), bounty)\n\n\treturn bountyCount\n}\n\n// ClaimBounty allows someone to claim a bounty\n// Only the creator can approve and transfer funds\nfunc ClaimBounty(_ realm, id uint64, claimer address) {\n\tcaller := runtime.OriginCaller()\n\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"bounty already claimed\")\n\t}\n\n\tif caller != bounty.Creator {\n\t\tpanic(\"only bounty creator can approve claims\")\n\t}\n\n\tif claimer == \"\" {\n\t\tpanic(\"claimer address cannot be empty\")\n\t}\n\n\t// Mark as claimed\n\tbounty.IsClaimed = true\n\tbounty.Claimer = claimer\n\tbounty.ClaimedAt = time.Now()\n\n\t// Transfer bounty amount to claimer\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\tsend := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: bounty.Amount}}\n\tbnk.SendCoins(pkgAddr, claimer, send)\n}\n\n// CancelBounty allows creator to cancel and get refund\nfunc CancelBounty(_ realm, id uint64) {\n\tcaller := runtime.OriginCaller()\n\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\tpanic(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\tpanic(\"cannot cancel claimed bounty\")\n\t}\n\n\tif caller != bounty.Creator {\n\t\tpanic(\"only bounty creator can cancel\")\n\t}\n\n\t// Remove bounty first (Checks-Effects-Interactions)\n\tbounties.Remove(ufmt.Sprintf(\"%d\", id))\n\n\t// Refund the creator\n\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\tsend := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: bounty.Amount}}\n\tbnk.SendCoins(pkgAddr, bounty.Creator, send)\n}\n"},{"name":"proposal.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ClaimBountyProposal implements commondao.ProposalDefinition for bounty claim proposals\ntype ClaimBountyProposal struct {\n\tBountyID      uint64\n\tApplicationID uint64\n\tApplicant     address\n\tPRLink        string\n\ttitle         string\n\tdescription   string\n}\n\n// NewClaimBountyProposal creates a new bounty claim proposal definition\nfunc NewClaimBountyProposal(bountyID, applicationID uint64, applicant address, prLink string) *ClaimBountyProposal {\n\treturn \u0026ClaimBountyProposal{\n\t\tBountyID:      bountyID,\n\t\tApplicationID: applicationID,\n\t\tApplicant:     applicant,\n\t\tPRLink:        prLink,\n\t\ttitle:         ufmt.Sprintf(\"Approve Application #%d for Bounty #%d\", applicationID, bountyID),\n\t\tdescription:   ufmt.Sprintf(\"Review PR: %s\\nApplicant: %s\", prLink, applicant),\n\t}\n}\n\n// Title returns proposal title\nfunc (p *ClaimBountyProposal) Title() string {\n\treturn p.title\n}\n\n// Body returns proposal's body\nfunc (p *ClaimBountyProposal) Body() string {\n\treturn p.description\n}\n\n// VotingPeriod returns the period where votes are allowed after proposal creation\nfunc (p *ClaimBountyProposal) VotingPeriod() time.Duration {\n\t// 7 days voting period\n\treturn 7 * 24 * time.Hour\n}\n\n// Tally counts votes and determines if proposal is ready to execute\n// Returns true when all validators have voted (regardless of outcome)\nfunc (p *ClaimBountyProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\ttotalMembers := ctx.Members.Size()\n\tif totalMembers == 0 {\n\t\treturn false, ufmt.Errorf(\"no members in DAO\")\n\t}\n\n\ttotalVotes := ctx.VotingRecord.Size()\n\n\t// Return true when all validators have voted\n\t// This allows Execute to be called and handle approval/rejection\n\tif totalVotes == totalMembers {\n\t\treturn true, nil\n\t}\n\n\t// Not ready yet - waiting for more votes\n\treturn false, nil\n}\n\n// Execute executes the proposal after all votes are in\n// Determines approval or rejection based on vote counts\nfunc (p *ClaimBountyProposal) Execute(_ realm) error {\n\tapp := GetApplication(p.ApplicationID)\n\tif app == nil {\n\t\treturn ufmt.Errorf(\"application not found\")\n\t}\n\n\tbounty := GetBounty(p.BountyID)\n\tif bounty == nil {\n\t\treturn ufmt.Errorf(\"bounty not found\")\n\t}\n\n\tif bounty.IsClaimed {\n\t\treturn ufmt.Errorf(\"bounty already claimed\")\n\t}\n\n\t// Get vote counts from the DAO proposal\n\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\tif proposal == nil {\n\t\treturn ufmt.Errorf(\"proposal not found\")\n\t}\n\n\tyesCount := proposal.VotingRecord().VoteCount(commondao.ChoiceYes)\n\tnoCount := proposal.VotingRecord().VoteCount(commondao.ChoiceNo)\n\ttotalMembers := app.DAO.Members().Size()\n\n\t// Check if unanimous approval (all YES, no NO)\n\tif yesCount == totalMembers \u0026\u0026 noCount == 0 {\n\t\t// Approve and transfer funds\n\t\tapp.Status = StatusApproved\n\n\t\tbounty.IsClaimed = true\n\t\tbounty.Claimer = p.Applicant\n\t\tbounty.ClaimedAt = time.Now()\n\n\t\t// Calculate reward split: 5% to validators, 95% to applicant\n\t\tvalidatorReward := (bounty.Amount * validatorRewardPercent) / 100\n\t\tapplicantReward := bounty.Amount - validatorReward\n\n\t\t// Split validator reward equally among all validators who voted\n\t\trewardPerValidator := validatorReward / int64(totalMembers)\n\n\t\t// Transfer rewards\n\t\tbnk := banker.NewBanker(banker.BankerTypeRealmSend)\n\n\t\t// Pay each validator their share\n\t\tapp.DAO.Members().IterateByOffset(0, totalMembers, func(member address) bool {\n\t\t\tvalidatorPayout := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: rewardPerValidator}}\n\t\t\tbnk.SendCoins(pkgAddr, member, validatorPayout)\n\t\t\treturn false\n\t\t})\n\n\t\t// Pay the applicant the remaining 95%\n\t\tapplicantPayout := chain.Coins{chain.Coin{Denom: \"ugnot\", Amount: applicantReward}}\n\t\tbnk.SendCoins(pkgAddr, p.Applicant, applicantPayout)\n\t} else {\n\t\t// Reject - not unanimous\n\t\tapp.Status = StatusRejected\n\t}\n\n\treturn nil\n}\n"},{"name":"render.gno","body":"package gnobounty\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ListBounties returns all active bounties\nfunc ListBounties() string {\n\tminSend := ufmt.Sprintf(\"%dugnot\", minimumBounty)\n\tcreateBountyLink := txlink.NewLink(\"CreateBounty\").\n\t\tAddArgs(\n\t\t\t\"title\", \"\",\n\t\t\t\"issueURL\", \"\",\n\t\t\t\"description\", \"\",\n\t\t).\n\t\tSetSend(minSend).\n\t\tURL()\n\n\toutput := \"# GnoBounty - Decentralized Bounty System\\n\\n\"\n\n\toutput += \"## üéØ Quick Actions\\n\\n\"\n\toutput += md.Link(\"üí∞ Create a new bounty\", createBountyLink)\n\toutput += ufmt.Sprintf(\" _(minimum reward: %s)_\", minSend)\n\toutput += \" | \"\n\toutput += md.Link(\"üìã View All Validators\", \"/\"+pkgPath+\":validators\")\n\toutput += \" | \"\n\toutput += md.Link(\"üèÜ Leaderboard\", \"/\"+pkgPath+\":leaderboard\")\n\toutput += \"\\n\\n\"\n\n\t// Add validator stats\n\tactiveValidatorCount := GetActiveValidatorCount()\n\toutput += ufmt.Sprintf(\"**Active Validators:** %d | **Total Bounties:** %d\\n\\n\", activeValidatorCount, bountyCount)\n\n\toutput += \"---\\n\\n\"\n\toutput += \"## üíé Active Bounties\\n\\n\"\n\toutput += \"**How to apply:** To apply to a bounty, you need to give your **MERGED PR** (important) URL in the transaction. You also need to write your Gno address in the description of your PR to verify your identity. If no address is written, the bounty can be refused.\\n\\n\"\n\n\tif bountyCount == 0 {\n\t\toutput += \"No bounties available\"\n\t\treturn output\n\t}\n\n\tbounties.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tbounty := value.(*Bounty)\n\t\tif !bounty.IsClaimed {\n\t\t\toutput += ufmt.Sprintf(\"## Bounty #%d: %s\\n\", bounty.ID, bounty.Title)\n\t\t\toutput += ufmt.Sprintf(\"**Issue:** %s\\n\", bounty.IssueURL)\n\t\t\toutput += ufmt.Sprintf(\"**Description:** %s\\n\", bounty.Description)\n\t\t\toutput += ufmt.Sprintf(\"**Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\t\t\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\", bounty.Creator)\n\t\t\toutput += ufmt.Sprintf(\"**Created:** %s\\n\\n\", bounty.CreatedAt.Format(\"2006-01-02 15:04:05\"))\n\n\t\t\t// Add apply button for this bounty\n\t\t\tapplyLink := txlink.NewLink(\"ApplyForBounty\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"bountyID\", ufmt.Sprintf(\"%d\", bounty.ID),\n\t\t\t\t\t\"prLink\", \"\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\toutput += md.Link(\"üìù Apply for this bounty\", applyLink)\n\t\t\toutput += \" | \"\n\n\t\t\t// Add view details link\n\t\t\tdetailsPath := ufmt.Sprintf(\"/%s:%d\", pkgPath, bounty.ID)\n\t\t\toutput += md.Link(\"üîç View details\", detailsPath)\n\t\t\toutput += \"\\n\\n\"\n\t\t}\n\t\treturn false\n\t})\n\n\treturn output\n}\n\n// GetBountyDetails returns detailed information about a specific bounty\nfunc GetBountyDetails(id uint64) string {\n\tbounty := GetBounty(id)\n\tif bounty == nil {\n\t\treturn \"Bounty not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Bounty #%d: %s\\n\\n\", bounty.ID, bounty.Title)\n\toutput += ufmt.Sprintf(\"**Issue URL:** %s\\n\", bounty.IssueURL)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\", bounty.Description)\n\toutput += ufmt.Sprintf(\"**Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\", bounty.Creator)\n\toutput += ufmt.Sprintf(\"**Created:** %s\\n\", bounty.CreatedAt.Format(\"2006-01-02 15:04:05\"))\n\n\tif bounty.IsClaimed {\n\t\toutput += ufmt.Sprintf(\"**Status:** CLAIMED\\n\")\n\t\toutput += ufmt.Sprintf(\"**Claimed by:** %s\\n\", bounty.Claimer)\n\t\toutput += ufmt.Sprintf(\"**Claimed at:** %s\\n\", bounty.ClaimedAt.Format(\"2006-01-02 15:04:05\"))\n\t} else {\n\t\toutput += ufmt.Sprintf(\"**Status:** OPEN\\n\\n\")\n\t\toutput += \"**How to apply:** To apply to a bounty, you need to give your **MERGED PR** (important) URL in the transaction. You also need to write your Gno address in the description of your PR to verify your identity. If no address is written, the bounty can be refused.\\n\\n\"\n\n\t\t// Add apply button\n\t\tapplyLink := txlink.NewLink(\"ApplyForBounty\").\n\t\t\tAddArgs(\n\t\t\t\t\"bountyID\", ufmt.Sprintf(\"%d\", id),\n\t\t\t\t\"prLink\", \"\",\n\t\t\t).\n\t\t\tURL()\n\t\toutput += md.Link(\"Apply for this bounty\", applyLink) + \"\\n\\n\"\n\n\t\t// Show existing applications\n\t\tapps := GetApplicationsForBounty(id)\n\t\tif len(apps) \u003e 0 {\n\t\t\toutput += \"### Applications\\n\\n\"\n\t\t\tfor _, app := range apps {\n\t\t\t\toutput += renderApplication(app)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output\n}\n\n// renderApplication renders a single application\nfunc renderApplication(app *Application) string {\n\toutput := ufmt.Sprintf(\"**Application #%d**\\n\", app.ID)\n\toutput += ufmt.Sprintf(\"- Applicant: %s\\n\", app.Applicant)\n\toutput += ufmt.Sprintf(\"- PR Link: %s\\n\", app.PRLink)\n\toutput += ufmt.Sprintf(\"- Applied: %s\\n\", app.AppliedAt.Format(\"2006-01-02 15:04:05\"))\n\n\tstatusStr := \"PENDING\"\n\tif app.Status == StatusApproved {\n\t\tstatusStr = \"APPROVED\"\n\t} else if app.Status == StatusRejected {\n\t\tstatusStr = \"REJECTED\"\n\t}\n\toutput += ufmt.Sprintf(\"- Status: %s\\n\", statusStr)\n\n\t// Show DAO voting information if DAO exists\n\tif app.DAO != nil {\n\t\toutput += ufmt.Sprintf(\"- Proposal ID: %d\\n\", app.ProposalID)\n\n\t\t// Get proposal and show detailed validator voting status\n\t\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\t\tif proposal != nil {\n\t\t\t// Get vote counts\n\t\t\tyesCount := proposal.VotingRecord().VoteCount(commondao.ChoiceYes)\n\t\t\tnoCount := proposal.VotingRecord().VoteCount(commondao.ChoiceNo)\n\t\t\tabstainCount := proposal.VotingRecord().VoteCount(commondao.ChoiceAbstain)\n\t\t\ttotalVotes := proposal.VotingRecord().Size()\n\t\t\ttotalMembers := app.DAO.Members().Size()\n\n\t\t\toutput += ufmt.Sprintf(\"\\n**Voting Progress:** %d/%d validators have voted\\n\", totalVotes, totalMembers)\n\t\t\toutput += ufmt.Sprintf(\"- ‚úÖ YES: %d\\n\", yesCount)\n\t\t\toutput += ufmt.Sprintf(\"- ‚ùå NO: %d\\n\", noCount)\n\t\t\toutput += ufmt.Sprintf(\"- ü§∑ ABSTAIN: %d\\n\", abstainCount)\n\t\t\toutput += ufmt.Sprintf(\"- ‚è≥ PENDING: %d\\n\", totalMembers-totalVotes)\n\t\t}\n\t}\n\n\t// Add vote buttons for validators if application is still pending\n\tif app.Status == StatusPending \u0026\u0026 app.DAO != nil {\n\t\toutput += \"\\n**Vote on this application:**\\n\"\n\n\t\t// Add vote buttons (yes/no/abstain)\n\t\tyesLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"yes\",\n\t\t\t).\n\t\t\tURL()\n\t\tnoLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"no\",\n\t\t\t).\n\t\t\tURL()\n\t\tabstainLink := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\n\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\"vote\", \"abstain\",\n\t\t\t).\n\t\t\tURL()\n\n\t\toutput += md.Link(\"‚úÖ Approve\", yesLink) + \" | \" + md.Link(\"‚ùå Reject\", noLink) + \" | \" + md.Link(\"ü§∑ Abstain\", abstainLink) + \"\\n\"\n\t\toutput += \"\\n_Note: Only assigned validators can vote on this application._\\n\"\n\t}\n\toutput += \"\\n\"\n\n\treturn output\n}\n\n// RenderMyVotes shows pending votes for a validator\nfunc RenderMyVotes(validatorAddr address) string {\n\tif !IsValidator(validatorAddr) {\n\t\treturn \"You are not a registered validator\"\n\t}\n\n\toutput := \"# My Pending Votes\\n\\n\"\n\n\tapps := GetApplicationsForValidator(validatorAddr)\n\tpendingCount := 0\n\n\tfor _, app := range apps {\n\t\tif app.Status == StatusPending {\n\t\t\tbounty := GetBounty(app.BountyID)\n\t\t\tif bounty == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpendingCount++\n\t\t\toutput += ufmt.Sprintf(\"## Application #%d for Bounty #%d\\n\", app.ID, app.BountyID)\n\t\t\toutput += ufmt.Sprintf(\"**Bounty:** %s\\n\", bounty.Description)\n\t\t\toutput += ufmt.Sprintf(\"**Bounty Reward:** %d ugnot (%.2f GNOT)\\n\", bounty.Amount, float64(bounty.Amount)/1000000.0)\n\t\t\toutput += ufmt.Sprintf(\"**Applicant:** %s\\n\", app.Applicant)\n\t\t\toutput += ufmt.Sprintf(\"**PR Link:** %s\\n\", app.PRLink)\n\n\t\t\t// Show DAO proposal details\n\t\t\tif app.DAO != nil {\n\t\t\t\toutput += ufmt.Sprintf(\"**Proposal ID:** %d\\n\", app.ProposalID)\n\n\t\t\t\t// Get proposal and show vote count\n\t\t\t\tproposal := app.DAO.ActiveProposals().Get(app.ProposalID)\n\t\t\t\tif proposal != nil {\n\t\t\t\t\tvoteCount := 0\n\t\t\t\t\tproposal.VotingRecord().Iterate(0, 0, false, func(v commondao.Vote) bool {\n\t\t\t\t\t\tvoteCount++\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\toutput += ufmt.Sprintf(\"**Votes Submitted:** %d/%d\\n\", voteCount, app.DAO.Members().Size())\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput += \"\\n\"\n\n\t\t\t// Add vote buttons (yes/no/abstain)\n\t\t\tyesLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"yes\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\tnoLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"no\",\n\t\t\t\t).\n\t\t\t\tURL()\n\t\t\tabstainLink := txlink.NewLink(\"Vote\").\n\t\t\t\tAddArgs(\n\t\t\t\t\t\"applicationID\", ufmt.Sprintf(\"%d\", app.ID),\n\t\t\t\t\t\"vote\", \"abstain\",\n\t\t\t\t).\n\t\t\t\tURL()\n\n\t\t\toutput += md.Link(\"Approve (Yes)\", yesLink) + \" | \" + md.Link(\"Reject (No)\", noLink) + \" | \" + md.Link(\"Abstain\", abstainLink) + \"\\n\\n\"\n\t\t\toutput += \"---\\n\\n\"\n\t\t}\n\t}\n\n\tif pendingCount == 0 {\n\t\toutput += \"No pending votes\"\n\t}\n\n\treturn output\n}\n\n// RenderValidators shows all validators\nfunc RenderValidators() string {\n\treturn ListValidators()\n}\n\n// Render implements the Render() method for the realm\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn ListBounties()\n\t}\n\n\t// Check for special paths\n\tif path == \"validators\" {\n\t\treturn RenderValidators()\n\t}\n\n\tif path == \"leaderboard\" {\n\t\treturn RenderLeaderboard()\n\t}\n\n\t// Parse bounty ID from path\n\tid, err := strconv.Atoi(path)\n\tif err != nil {\n\t\treturn ufmt.Sprintf(\"Invalid path. Use /%s for bounties or /%s:validators for validators list\", pkgPath, pkgPath)\n\t}\n\n\treturn GetBountyDetails(uint64(id))\n}\n"},{"name":"storage.gno","body":"package gnobounty\n\nimport (\n\t\"chain\"\n\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nvar (\n\tbounties      avl.Tree // uint64 -\u003e *Bounty\n\tbountyCount   uint64\n\tminimumBounty int64 = 1000000 // 1 GNOT minimum\n\n\tapplications     avl.Tree // uint64 -\u003e *Application\n\tapplicationCount uint64\n\n\tvalidators       avl.Tree      // address -\u003e *Validator\n\tvalidatorList    []address     // List of validator addresses for random selection\n\tvalidatorsPerDAO int       = 3 // Number of validators per DAO vote\n\trequiredVotes    int       = 3 // Number of approvals needed (3/3)\n\n\t// Validator reward percentage (5% of bounty split among validators)\n\tvalidatorRewardPercent int64 = 5 // 5% of bounty goes to validators\n\n\townership *ownable.Ownable\n\n\t// Package address - stored for easy redeployment\n\tpkgAddr address\n\n\t// Package path - used in URLs for rendering\n\tpkgPath string = \"gno.land/r/greg007/gnobounty_v3\"\n)\n\nfunc init() {\n\townership = ownable.NewWithOrigin()\n\tpkgAddr = chain.PackageAddress(pkgPath)\n}\n\n// GetBounty returns a bounty by ID\nfunc GetBounty(id uint64) *Bounty {\n\tbountyInterface, exists := bounties.Get(ufmt.Sprintf(\"%d\", id))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn bountyInterface.(*Bounty)\n}\n\n// GetBountyCount returns the total number of bounties created\nfunc GetBountyCount() uint64 {\n\treturn bountyCount\n}\n\n// SetMinimumBounty allows setting minimum bounty amount (admin function)\nfunc SetMinimumBounty(amount int64) {\n\townership.AssertOwnedByPrevious()\n\tminimumBounty = amount\n}\n\n// SetPackagePath allows setting the package path for URLs (admin function)\nfunc SetPackagePath(path string) {\n\townership.AssertOwnedByPrevious()\n\tif path == \"\" {\n\t\tpanic(\"package path cannot be empty\")\n\t}\n\tpkgPath = path\n\tpkgAddr = chain.PackageAddress(path)\n}\n\n// GetApplication returns an application by ID\nfunc GetApplication(id uint64) *Application {\n\tappInterface, exists := applications.Get(ufmt.Sprintf(\"%d\", id))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn appInterface.(*Application)\n}\n\n// GetApplicationCount returns the total number of applications\nfunc GetApplicationCount() uint64 {\n\treturn applicationCount\n}\n\n// IsValidator checks if an address is a validator\nfunc IsValidator(addr address) bool {\n\tvalidatorInterface, exists := validators.Get(string(addr))\n\tif !exists {\n\t\treturn false\n\t}\n\tvalidator := validatorInterface.(*Validator)\n\treturn validator.Active\n}\n\n// GetValidator returns a validator by address\nfunc GetValidator(addr address) *Validator {\n\tvalidatorInterface, exists := validators.Get(string(addr))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn validatorInterface.(*Validator)\n}\n\n// GetActiveValidatorCount returns the number of active validators\nfunc GetActiveValidatorCount() int {\n\tcount := 0\n\tvalidators.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tvalidator := value.(*Validator)\n\t\tif validator.Active {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetOwner returns the owner address (helper function for debugging)\nfunc GetOwner() address {\n\treturn ownership.Owner()\n}\n\n// GetPackagePath returns the current package path\nfunc GetPackagePath() string {\n\treturn pkgPath\n}\n"},{"name":"types.gno","body":"package gnobounty\n\nimport (\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\n// Bounty represents a bounty post for an issue\ntype Bounty struct {\n\tID          uint64\n\tTitle       string // Short title for the bounty\n\tIssueURL    string\n\tDescription string\n\tAmount      int64 // Amount in ugnot\n\tCreator     address\n\tCreatedAt   time.Time\n\tIsClaimed   bool\n\tClaimer     address\n\tClaimedAt   time.Time\n}\n\n// Application represents a claim application for a bounty with a private DAO\ntype Application struct {\n\tID         uint64\n\tBountyID   uint64\n\tApplicant  address\n\tPRLink     string\n\tAppliedAt  time.Time\n\tStatus     ApplicationStatus\n\tDAO        *commondao.CommonDAO // Private DAO for this application\n\tProposalID uint64               // Proposal ID in the DAO\n\tVotes      []VoteRecord         // Local record of votes\n}\n\n// VoteRecord represents a vote cast by a validator\ntype VoteRecord struct {\n\tVoter  address\n\tChoice commondao.VoteChoice\n}\n\n// ApplicationStatus represents the status of an application\ntype ApplicationStatus int\n\nconst (\n\tStatusPending ApplicationStatus = iota\n\tStatusApproved\n\tStatusRejected\n)\n\n// Validator represents a validator who can vote on applications\ntype Validator struct {\n\tAddress address\n\tAddedAt time.Time\n\tActive  bool\n}\n"},{"name":"validators.gno","body":"package gnobounty\n\nimport (\n\t\"time\"\n\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// AddValidator adds a new validator to the system (Admin only)\nfunc AddValidator(_ realm, validatorAddr address) {\n\t// Check if caller is admin\n\townership.AssertOwnedByPrevious()\n\n\t// Check if validator already exists\n\tif _, exists := validators.Get(string(validatorAddr)); exists {\n\t\tpanic(\"validator already exists\")\n\t}\n\n\tvalidator := \u0026Validator{\n\t\tAddress: validatorAddr,\n\t\tAddedAt: time.Now(),\n\t\tActive:  true,\n\t}\n\n\tvalidators.Set(string(validatorAddr), validator)\n\tvalidatorList = append(validatorList, validatorAddr)\n}\n\n// RemoveValidator removes a validator from the system (Admin only)\nfunc RemoveValidator(_ realm, validatorAddr address) {\n\t// Check if caller is admin\n\townership.AssertOwnedByPrevious()\n\n\tvalidatorInterface, exists := validators.Get(string(validatorAddr))\n\tif !exists {\n\t\tpanic(\"validator not found\")\n\t}\n\n\tvalidator := validatorInterface.(*Validator)\n\tvalidator.Active = false\n\n\t// Remove from validator list\n\tnewList := make([]address, 0)\n\tfor _, addr := range validatorList {\n\t\tif addr != validatorAddr {\n\t\t\tnewList = append(newList, addr)\n\t\t}\n\t}\n\tvalidatorList = newList\n}\n\n// selectRandomValidators selects N random validators for voting\n// Uses a simple pseudo-random selection based on application ID\nfunc selectRandomValidators(appID uint64, count int) []address {\n\tactiveValidators := getActiveValidators()\n\n\tif len(activeValidators) \u003c count {\n\t\tpanic(ufmt.Sprintf(\"not enough active validators: need %d, have %d\", count, len(activeValidators)))\n\t}\n\n\t// Simple pseudo-random selection using appID as seed\n\tselected := make([]address, 0, count)\n\tseed := appID\n\n\tfor i := 0; i \u003c count; i++ {\n\t\tindex := int((seed + uint64(i)*7) % uint64(len(activeValidators)))\n\t\tselected = append(selected, activeValidators[index])\n\n\t\t// Remove selected validator to avoid duplicates\n\t\tactiveValidators = append(activeValidators[:index], activeValidators[index+1:]...)\n\t}\n\n\treturn selected\n}\n\n// getActiveValidators returns all active validator addresses\nfunc getActiveValidators() []address {\n\tactive := make([]address, 0)\n\tfor _, addr := range validatorList {\n\t\tif IsValidator(addr) {\n\t\t\tactive = append(active, addr)\n\t\t}\n\t}\n\treturn active\n}\n\n// ListValidators returns information about all validators\nfunc ListValidators() string {\n\toutput := \"# Validators\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"**Total Active Validators:** %d\\n\\n\", GetActiveValidatorCount())\n\n\tif len(validatorList) == 0 {\n\t\toutput += \"No validators registered yet.\\n\\n\"\n\t} else {\n\t\tvalidators.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tvalidator := value.(*Validator)\n\t\t\tstatus := \"‚úÖ ACTIVE\"\n\t\t\tif !validator.Active {\n\t\t\t\tstatus = \"‚ùå INACTIVE\"\n\t\t\t}\n\t\t\toutput += ufmt.Sprintf(\"- %s %s - Added: %s\\n\",\n\t\t\t\tstatus,\n\t\t\t\tvalidator.Address,\n\t\t\t\tvalidator.AddedAt.Format(\"2006-01-02\"))\n\t\t\treturn false\n\t\t})\n\t\toutput += \"\\n\"\n\t}\n\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"KAX8QrIAOjlKhiSqrKECt/19ZQfM7/N4w+DBNUcClVy14rcTH7YPQaL/VLvX9jJypsXaTZs01GMg8gEbbpRdDg=="}],"memo":""},"metadata":{"timestamp":"1765551677"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"daoregistry2","path":"gno.land/r/pierre115/daoregistry2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/daoregistry2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"joinregistry.gno","body":"package daoregistry2\n\nimport (\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tregistryDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 100_000 // 0.1 GNOT minimum to join registry DAO\n)\n\nfunc initRegistryDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tregistryDAO = commondao.New(\n\t\tcommondao.WithID(2), // Different ID from marketplace DAO\n\t\tcommondao.WithName(\"NFT Registry DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for NFT Registry\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinRegistryDAO - Join the NFT Registry DAO by staking GNOT\nfunc JoinRegistryDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\tsent := banker.OriginSend()\n\n\tamount := sent.AmountOf(\"ugnot\")\n\tif amount \u003c MIN_STAKE_UGNOT {\n\t\tpanic(\"minimum 10 GNOT required to join Registry DAO\")\n\t}\n\n\tif registryDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tregistryDAO.Members().Add(caller)\n\n\treturn \"Successfully joined NFT Registry DAO\"\n}\n\n// IsRegistryDAOMember - Check if an address is a registry DAO member\nfunc IsRegistryDAOMember(addr address) bool {\n\treturn registryDAO.Members().Has(addr)\n}\n\n// GetTotalRegistryMembers - Returns total number of registry DAO members\nfunc GetTotalRegistryMembers() int {\n\treturn registryDAO.Members().Size()\n}\n"},{"name":"proposals.gno","body":"package daoregistry2\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_VERIFY_COLLECTION   = \"verify_collection\"\n\tPROPOSAL_TYPE_UNVERIFY_COLLECTION = \"unverify_collection\"\n\n\tREGISTRY_VOTING_PERIOD = 5 * time.Minute\n\tREGISTRY_QUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// VerifyCollectionProposal - Proposal to verify a collection\ntype VerifyCollectionProposal struct {\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc NewVerifyCollectionProposal(addr address, name string, reason string) *VerifyCollectionProposal {\n\treturn \u0026VerifyCollectionProposal{\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *VerifyCollectionProposal) Title() string {\n\treturn \"Verify Collection: \" + p.collectionName\n}\n\nfunc (p *VerifyCollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Collection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to verify, NO to reject\",\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *VerifyCollectionProposal) VotingPeriod() time.Duration {\n\treturn REGISTRY_VOTING_PERIOD\n}\n\nfunc (p *VerifyCollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(REGISTRY_QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *VerifyCollectionProposal) Execute(realm) error {\n\tinfo := GetCollection(p.collectionAddr)\n\tif info == nil {\n\t\treturn errors.New(\"collection not found\")\n\t}\n\n\tif info.Verified {\n\t\treturn errors.New(\"collection already verified\")\n\t}\n\n\tinfo.Verified = true\n\tcollections.Set(p.collectionAddr.String(), info)\n\n\tp.executed = true\n\treturn nil\n}\n\n// UnverifyCollectionProposal - Proposal to unverify a collection\ntype UnverifyCollectionProposal struct {\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc NewUnverifyCollectionProposal(addr address, name string, reason string) *UnverifyCollectionProposal {\n\treturn \u0026UnverifyCollectionProposal{\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *UnverifyCollectionProposal) Title() string {\n\treturn \"Unverify Collection: \" + p.collectionName\n}\n\nfunc (p *UnverifyCollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Collection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to unverify, NO to reject\",\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *UnverifyCollectionProposal) VotingPeriod() time.Duration {\n\treturn REGISTRY_VOTING_PERIOD\n}\n\nfunc (p *UnverifyCollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(REGISTRY_QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *UnverifyCollectionProposal) Execute(realm) error {\n\tinfo := GetCollection(p.collectionAddr)\n\tif info == nil {\n\t\treturn errors.New(\"collection not found\")\n\t}\n\n\tif !info.Verified {\n\t\treturn errors.New(\"collection not verified\")\n\t}\n\n\tinfo.Verified = false\n\tcollections.Set(p.collectionAddr.String(), info)\n\n\tp.executed = true\n\treturn nil\n}\n"},{"name":"registry.gno","body":"package daoregistry2\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n)\n\n// CollectionInfo - Extended metadata stored in the registry\ntype CollectionInfo struct {\n\tAddress          address\n\tName             string\n\tSymbol           string\n\tCreator          address\n\tRegisteredAt     int64\n\tVerified         bool\n\tCategory         string\n\tDescription      string\n\tExternalURL      string\n\tNFTGetter        grc721.NFTGetter\n\tSupportsMetadata bool\n}\n\nvar (\n\tcollections     avl.Tree\n\tcategoriesIndex avl.Tree\n\tregistrationFee int64 = 1000000\n)\n\nfunc init() {\n\tinitRegistryDAO()\n}\n\n// RegisterCollection - Register a new NFT collection\nfunc RegisterCollection(\n\trealmAddr address,\n\tname string,\n\tsymbol string,\n\tcategory string,\n\tdescription string,\n\texternalURL string,\n\tsupportsMetadata bool,\n\tgetter grc721.NFTGetter,\n) {\n\tcreator := runtime.OriginCaller()\n\n\t// Check if collection already registered\n\tif collections.Has(realmAddr.String()) {\n\t\tpanic(\"Collection already registered\")\n\t}\n\n\tif getter == nil {\n\t\tpanic(\"NFT getter function is required\")\n\t}\n\n\tif name == \"\" || symbol == \"\" {\n\t\tpanic(\"Name and symbol cannot be empty\")\n\t}\n\n\tinfo := \u0026CollectionInfo{\n\t\tAddress:          realmAddr,\n\t\tCreator:          creator,\n\t\tName:             name,\n\t\tSymbol:           symbol,\n\t\tRegisteredAt:     runtime.ChainHeight(),\n\t\tVerified:         false,\n\t\tCategory:         category,\n\t\tDescription:      description,\n\t\tExternalURL:      externalURL,\n\t\tNFTGetter:        getter,\n\t\tSupportsMetadata: supportsMetadata,\n\t}\n\n\tcollections.Set(realmAddr.String(), info)\n}\n\n// IsRegistered - Check if a collection is registered\nfunc IsRegistered(collectionAddr address) bool {\n\treturn collections.Has(collectionAddr.String())\n}\n\n// GetTotalCollections - Total number of registered collections\nfunc GetTotalCollections() int {\n\tcount := 0\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcount++\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetVerifiedCount - Count of verified collections\nfunc GetVerifiedCount() int {\n\tcount := 0\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tinfo := value.(*CollectionInfo)\n\t\tif info.Verified {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetCollection - Retrieve collection info by address\nfunc GetCollection(collectionAddr address) *CollectionInfo {\n\tval, exists := collections.Get(collectionAddr.String())\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn val.(*CollectionInfo)\n}\n\n// GetNFTGetter - Retrieve the NFTGetter function for a collection\nfunc GetNFTGetter(collectionAddr address) (grc721.NFTGetter, bool) {\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\treturn nil, false\n\t}\n\treturn info.NFTGetter, true\n}\n\n// GetTokenMetadata - Retrieve onchain metadata for a token\nfunc GetTokenMetadata(collectionAddr address, tokenId grc721.TokenID) (grc721.Metadata, error) {\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"Collection not registered\")\n\t}\n\n\tif !info.SupportsMetadata {\n\t\tpanic(\"Collection does not support onchain metadata\")\n\t}\n\n\tnftInstance := info.NFTGetter()\n\tmetadataCollection := nftInstance.(grc721.IGRC721MetadataOnchain)\n\n\treturn metadataCollection.TokenMetadata(tokenId)\n}\n\n// UpdateCollectionInfo - Update collection metadata\nfunc UpdateCollectionInfo(category, description, externalURL string) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tinfo := GetCollection(caller)\n\tif info == nil {\n\t\tpanic(\"Collection not registered\")\n\t}\n\n\tinfo.Category = category\n\tinfo.Description = description\n\tinfo.ExternalURL = externalURL\n\tcollections.Set(caller.String(), info)\n}\n"},{"name":"render.gno","body":"package daoregistry2\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"collection/\") {\n\t\taddrStr := strings.TrimPrefix(path, \"collection/\")\n\t\taddr := address(addrStr)\n\t\treturn renderCollection(addr)\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# NFT Registry\\n\\n\"\n\toutput += \"Decentralized NFT Collection Registry with DAO Governance\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\toutput += \"## Statistics\\n\\n\"\n\toutput += ufmt.Sprintf(\"- Total registered collections: %d\\n\", GetTotalCollections())\n\toutput += ufmt.Sprintf(\"- Verified collections: %d\\n\\n\", GetVerifiedCount())\n\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalRegistryMembers())\n\n\tactiveProposals := registryDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/daoregistry:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"[View proposals](/r/pierre115/daoregistry:proposals) | \"\n\t}\n\n\tfinishedProposals := registryDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/daoregistry:archive)\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinRegistryDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join DAO\", linkjoin) + \"\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// Collections list\n\toutput += \"## Registered Collections\\n\\n\"\n\n\thasCollections := false\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\thasCollections = true\n\t\tinfo := value.(*CollectionInfo)\n\t\toutput += renderCollectionPreview(info)\n\t\treturn false\n\t})\n\n\tif !hasCollections {\n\t\toutput += \"No collections registered yet.\\n\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderCollectionPreview(info *CollectionInfo) string {\n\toutput := ufmt.Sprintf(\"### %s (%s)\\n\\n\", info.Name, info.Symbol)\n\n\tif info.Verified {\n\t\toutput += \"Status: VERIFIED\\n\\n\"\n\t} else {\n\t\toutput += \"Status: Not verified\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"Category: %s\\n\\n\", info.Category)\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/daoregistry:collection/%s)\\n\\n\", info.Address.String())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderCollection(addr address) string {\n\tinfo := GetCollection(addr)\n\tif info == nil {\n\t\treturn \"# Collection not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", info.Name)\n\n\tif info.Verified {\n\t\toutput += \"**Status:** VERIFIED\\n\\n\"\n\t} else {\n\t\toutput += \"**Status:** Not verified\\n\\n\"\n\t}\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Symbol:** %s\\n\\n\", info.Symbol)\n\toutput += ufmt.Sprintf(\"**Address:** %s\\n\\n\", info.Address.String())\n\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\\n\", info.Creator.String())\n\toutput += ufmt.Sprintf(\"**Category:** %s\\n\\n\", info.Category)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\\n\", info.Description)\n\n\tif info.ExternalURL != \"\" {\n\t\toutput += ufmt.Sprintf(\"**External URL:** %s\\n\\n\", info.ExternalURL)\n\t}\n\n\toutput += ufmt.Sprintf(\"**Registered at block:** %d\\n\\n\", info.RegisteredAt)\n\toutput += ufmt.Sprintf(\"**Supports onchain metadata:** %t\\n\\n\", info.SupportsMetadata)\n\n\toutput += \"[Back to registry](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderProposals() string {\n\toutput := \"# Active Registry Proposals\\n\\n\"\n\n\tproposals := registryDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"No active proposals at the moment.\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Verify collections\\n\"\n\t\toutput += \"- Unverify collections\\n\\n\"\n\t\toutput += \"[Back](/r/pierre115/daoregistry)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[View archive](/r/pierre115/daoregistry:archive) | [Back](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"Status: Voting ended\\n\\n\"\n\t} else {\n\t\toutput += \"Status: Voting open\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View and Vote](/r/pierre115/daoregistry:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := registryDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalRegistryMembers()\n\tquorumRequired := int(float64(totalMembers) * REGISTRY_QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"**Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"**Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"VoteRegistry\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"VoteRegistry\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[Back to proposals](/r/pierre115/daoregistry:proposals) | [Home](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := registryDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"No finished proposals yet.\\n\\n\"\n\t\toutput += \"[Back](/r/pierre115/daoregistry)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[Back](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusLabel := \"PASSED\"\n\tif p.Status() == \"failed\" {\n\t\tstatusLabel = \"FAILED\"\n\t}\n\toutput += ufmt.Sprintf(\"**Status:** %s\\n\\n\", statusLabel)\n\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/daoregistry:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := registryDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalRegistryMembers()\n\tquorumRequired := int(float64(totalMembers) * REGISTRY_QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusLabel := \"PASSED\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusLabel = \"FAILED\"\n\t}\n\toutput += ufmt.Sprintf(\"**Final Status:** %s\\n\\n\", statusLabel)\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[Back to archive](/r/pierre115/daoregistry:archive) | [Home](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n"},{"name":"voting.gno","body":"package daoregistry2\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeVerifyCollection - Create proposal to verify a collection\nfunc ProposeVerifyCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsRegistryDAOMember(caller) {\n\t\tpanic(\"only Registry DAO members can create proposals\")\n\t}\n\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"collection not registered\")\n\t}\n\n\tif info.Verified {\n\t\tpanic(\"collection already verified\")\n\t}\n\n\tpropDef := NewVerifyCollectionProposal(collectionAddr, collectionName, reason)\n\n\tproposal, err := registryDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUnverifyCollection - Create proposal to unverify a collection\nfunc ProposeUnverifyCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsRegistryDAOMember(caller) {\n\t\tpanic(\"only Registry DAO members can create proposals\")\n\t}\n\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"collection not registered\")\n\t}\n\n\tif !info.Verified {\n\t\tpanic(\"collection not verified\")\n\t}\n\n\tpropDef := NewUnverifyCollectionProposal(collectionAddr, collectionName, reason)\n\n\tproposal, err := registryDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// VoteRegistry - Vote on a registry proposal\nfunc VoteRegistry(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif choice != \"yes\" \u0026\u0026 choice != \"no\" {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - handles all validations automatically\n\terr := registryDAO.Vote(caller, proposalID, commondao.VoteChoice(choice), \"\")\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyRegistryProposal - Execute a registry proposal\nfunc TallyRegistryProposal(_ realm, proposalID uint64) string {\n\terr := registryDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1VzTiwCNb6lbHMgUmPnWxnrSWSiiSTpR+iP/qNLiyOgLjyIsbZR6cvQcpS0Au+XLZ0SFc+JS7jm0dz0DgkP4CA=="}],"memo":""},"metadata":{"timestamp":"1765552245"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765552305"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"mynft2","path":"gno.land/r/pierre115/mynft2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/mynft2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"nft.gno","body":"package mynft2\n\nimport (\n\t\"strconv\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry2\"\n)\n\ntype NFTCollection interface {\n\tgrc721.IGRC721\n\tMint(to address, tid grc721.TokenID) error\n\tGetter() grc721.NFTGetter\n}\n\nvar (\n\tnft         NFTCollection\n\tnextTokenId = 1\n\tmyRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n\tnft = grc721.NewBasicNFT(\"Test NFT Collection\", \"TEST\")\n}\n\n// Register registers this collection on the NFT registry\nfunc Register(_ realm) {\n\tdaoregistry2.RegisterCollection(\n\t\tmyRealmAddr,\n\t\t\"Test NFT Collection\",\n\t\t\"TEST\",\n\t\t\"art\",\n\t\t\"First wars\",\n\t\t\"https://example.com\",\n\t\tfalse,\n\t\tnft.Getter(),\n\t)\n}\n\nfunc MintNFT(_ realm) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\nfunc SetApprovalForAll(_ realm, operator address, approved bool) {\n\terr := nft.SetApprovalForAll(operator, approved)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc Getter() grc721.NFTGetter {\n\treturn nft.Getter()\n}\n\nfunc Render(path string) string {\n\toutput := \"# My test collection\\n\\n\"\n\toutput += \"## test\\n\\n\"\n\toutput += ufmt.Sprintf(\"**NftRealmAddr:** %d\\n\\n\", myRealmAddr.String())\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1FI451M+M71qOXof2/XsrnJzh7adxWZQsu7iHbgPxEt1CTlZXAvzIU1ZxhCpIlc9Vx+QC5MLTrHYOoZoOotJAg=="}],"memo":""},"metadata":{"timestamp":"1765552320"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"daoregistry3","path":"gno.land/r/pierre115/daoregistry3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/daoregistry3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"joinregistry.gno","body":"package daoregistry3\n\nimport (\n\t//\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tregistryDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 0 // 0 GNOT minimum to join registry DAO\n)\n\nfunc initRegistryDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tregistryDAO = commondao.New(\n\t\tcommondao.WithID(2), // Different ID from marketplace DAO\n\t\tcommondao.WithName(\"NFT Registry DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for NFT Registry\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinRegistryDAO - Join the NFT Registry DAO by staking GNOT\nfunc JoinRegistryDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\t//sent := banker.OriginSend()\n\n\t//amount := sent.AmountOf(\"ugnot\")\n\t//if amount \u003c MIN_STAKE_UGNOT {\n\t//\tpanic(\"minimum 10 GNOT required to join Registry DAO\")\n\t//}\n\n\tif registryDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tregistryDAO.Members().Add(caller)\n\n\treturn \"Successfully joined NFT Registry DAO\"\n}\n\n// IsRegistryDAOMember - Check if an address is a registry DAO member\nfunc IsRegistryDAOMember(addr address) bool {\n\treturn registryDAO.Members().Has(addr)\n}\n\n// GetTotalRegistryMembers - Returns total number of registry DAO members\nfunc GetTotalRegistryMembers() int {\n\treturn registryDAO.Members().Size()\n}\n"},{"name":"proposals.gno","body":"package daoregistry3\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_VERIFY_COLLECTION   = \"verify_collection\"\n\tPROPOSAL_TYPE_UNVERIFY_COLLECTION = \"unverify_collection\"\n\n\tREGISTRY_VOTING_PERIOD = 5 * time.Minute\n\tREGISTRY_QUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// VerifyCollectionProposal - Proposal to verify a collection\ntype VerifyCollectionProposal struct {\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc NewVerifyCollectionProposal(addr address, name string, reason string) *VerifyCollectionProposal {\n\treturn \u0026VerifyCollectionProposal{\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *VerifyCollectionProposal) Title() string {\n\treturn \"Verify Collection: \" + p.collectionName\n}\n\nfunc (p *VerifyCollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Collection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to verify, NO to reject\",\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *VerifyCollectionProposal) VotingPeriod() time.Duration {\n\treturn REGISTRY_VOTING_PERIOD\n}\n\nfunc (p *VerifyCollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(REGISTRY_QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *VerifyCollectionProposal) Execute(realm) error {\n\tinfo := GetCollection(p.collectionAddr)\n\tif info == nil {\n\t\treturn errors.New(\"collection not found\")\n\t}\n\n\tif info.Verified {\n\t\treturn errors.New(\"collection already verified\")\n\t}\n\n\tinfo.Verified = true\n\tcollections.Set(p.collectionAddr.String(), info)\n\n\tp.executed = true\n\treturn nil\n}\n\n// UnverifyCollectionProposal - Proposal to unverify a collection\ntype UnverifyCollectionProposal struct {\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc NewUnverifyCollectionProposal(addr address, name string, reason string) *UnverifyCollectionProposal {\n\treturn \u0026UnverifyCollectionProposal{\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *UnverifyCollectionProposal) Title() string {\n\treturn \"Unverify Collection: \" + p.collectionName\n}\n\nfunc (p *UnverifyCollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Collection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to unverify, NO to reject\",\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *UnverifyCollectionProposal) VotingPeriod() time.Duration {\n\treturn REGISTRY_VOTING_PERIOD\n}\n\nfunc (p *UnverifyCollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(REGISTRY_QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *UnverifyCollectionProposal) Execute(realm) error {\n\tinfo := GetCollection(p.collectionAddr)\n\tif info == nil {\n\t\treturn errors.New(\"collection not found\")\n\t}\n\n\tif !info.Verified {\n\t\treturn errors.New(\"collection not verified\")\n\t}\n\n\tinfo.Verified = false\n\tcollections.Set(p.collectionAddr.String(), info)\n\n\tp.executed = true\n\treturn nil\n}\n"},{"name":"registry.gno","body":"package daoregistry3\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n)\n\n// CollectionInfo - Extended metadata stored in the registry\ntype CollectionInfo struct {\n\tAddress          address\n\tName             string\n\tSymbol           string\n\tCreator          address\n\tRegisteredAt     int64\n\tVerified         bool\n\tCategory         string\n\tDescription      string\n\tExternalURL      string\n\tNFTGetter        grc721.NFTGetter\n\tSupportsMetadata bool\n}\n\nvar (\n\tcollections     avl.Tree\n\tcategoriesIndex avl.Tree\n\tregistrationFee int64 = 1000000\n)\n\nfunc init() {\n\tinitRegistryDAO()\n}\n\n// RegisterCollection - Register a new NFT collection\nfunc RegisterCollection(\n\trealmAddr address,\n\tname string,\n\tsymbol string,\n\tcategory string,\n\tdescription string,\n\texternalURL string,\n\tsupportsMetadata bool,\n\tgetter grc721.NFTGetter,\n) {\n\tcreator := runtime.OriginCaller()\n\n\t// Check if collection already registered\n\tif collections.Has(realmAddr.String()) {\n\t\tpanic(\"Collection already registered\")\n\t}\n\n\tif getter == nil {\n\t\tpanic(\"NFT getter function is required\")\n\t}\n\n\tif name == \"\" || symbol == \"\" {\n\t\tpanic(\"Name and symbol cannot be empty\")\n\t}\n\n\tinfo := \u0026CollectionInfo{\n\t\tAddress:          realmAddr,\n\t\tCreator:          creator,\n\t\tName:             name,\n\t\tSymbol:           symbol,\n\t\tRegisteredAt:     runtime.ChainHeight(),\n\t\tVerified:         false,\n\t\tCategory:         category,\n\t\tDescription:      description,\n\t\tExternalURL:      externalURL,\n\t\tNFTGetter:        getter,\n\t\tSupportsMetadata: supportsMetadata,\n\t}\n\n\tcollections.Set(realmAddr.String(), info)\n}\n\n// IsRegistered - Check if a collection is registered\nfunc IsRegistered(collectionAddr address) bool {\n\treturn collections.Has(collectionAddr.String())\n}\n\n// GetTotalCollections - Total number of registered collections\nfunc GetTotalCollections() int {\n\tcount := 0\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcount++\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetVerifiedCount - Count of verified collections\nfunc GetVerifiedCount() int {\n\tcount := 0\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tinfo := value.(*CollectionInfo)\n\t\tif info.Verified {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetCollection - Retrieve collection info by address\nfunc GetCollection(collectionAddr address) *CollectionInfo {\n\tval, exists := collections.Get(collectionAddr.String())\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn val.(*CollectionInfo)\n}\n\n// GetNFTGetter - Retrieve the NFTGetter function for a collection\nfunc GetNFTGetter(collectionAddr address) (grc721.NFTGetter, bool) {\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\treturn nil, false\n\t}\n\treturn info.NFTGetter, true\n}\n\n// GetTokenMetadata - Retrieve onchain metadata for a token\nfunc GetTokenMetadata(collectionAddr address, tokenId grc721.TokenID) (grc721.Metadata, error) {\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"Collection not registered\")\n\t}\n\n\tif !info.SupportsMetadata {\n\t\tpanic(\"Collection does not support onchain metadata\")\n\t}\n\n\tnftInstance := info.NFTGetter()\n\tmetadataCollection := nftInstance.(grc721.IGRC721MetadataOnchain)\n\n\treturn metadataCollection.TokenMetadata(tokenId)\n}\n\n// UpdateCollectionInfo - Update collection metadata\nfunc UpdateCollectionInfo(category, description, externalURL string) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tinfo := GetCollection(caller)\n\tif info == nil {\n\t\tpanic(\"Collection not registered\")\n\t}\n\n\tinfo.Category = category\n\tinfo.Description = description\n\tinfo.ExternalURL = externalURL\n\tcollections.Set(caller.String(), info)\n}\n"},{"name":"render.gno","body":"package daoregistry3\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"collection/\") {\n\t\taddrStr := strings.TrimPrefix(path, \"collection/\")\n\t\taddr := address(addrStr)\n\t\treturn renderCollection(addr)\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# NFT Registry\\n\\n\"\n\toutput += \"Decentralized NFT Collection Registry with DAO Governance\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\toutput += \"## Statistics\\n\\n\"\n\toutput += ufmt.Sprintf(\"- Total registered collections: %d\\n\", GetTotalCollections())\n\toutput += ufmt.Sprintf(\"- Verified collections: %d\\n\\n\", GetVerifiedCount())\n\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalRegistryMembers())\n\n\tactiveProposals := registryDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/daoregistry:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"[View proposals](/r/pierre115/daoregistry:proposals) | \"\n\t}\n\n\tfinishedProposals := registryDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/daoregistry:archive)\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinRegistryDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join DAO\", linkjoin) + \"\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// Collections list\n\toutput += \"## Registered Collections\\n\\n\"\n\n\thasCollections := false\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\thasCollections = true\n\t\tinfo := value.(*CollectionInfo)\n\t\toutput += renderCollectionPreview(info)\n\t\treturn false\n\t})\n\n\tif !hasCollections {\n\t\toutput += \"No collections registered yet.\\n\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderCollectionPreview(info *CollectionInfo) string {\n\toutput := ufmt.Sprintf(\"### %s (%s)\\n\\n\", info.Name, info.Symbol)\n\n\tif info.Verified {\n\t\toutput += \"Status: VERIFIED\\n\\n\"\n\t} else {\n\t\toutput += \"Status: Not verified\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"Category: %s\\n\\n\", info.Category)\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/daoregistry:collection/%s)\\n\\n\", info.Address.String())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderCollection(addr address) string {\n\tinfo := GetCollection(addr)\n\tif info == nil {\n\t\treturn \"# Collection not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", info.Name)\n\n\tif info.Verified {\n\t\toutput += \"**Status:** VERIFIED\\n\\n\"\n\t} else {\n\t\toutput += \"**Status:** Not verified\\n\\n\"\n\t}\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Symbol:** %s\\n\\n\", info.Symbol)\n\toutput += ufmt.Sprintf(\"**Address:** %s\\n\\n\", info.Address.String())\n\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\\n\", info.Creator.String())\n\toutput += ufmt.Sprintf(\"**Category:** %s\\n\\n\", info.Category)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\\n\", info.Description)\n\n\tif info.ExternalURL != \"\" {\n\t\toutput += ufmt.Sprintf(\"**External URL:** %s\\n\\n\", info.ExternalURL)\n\t}\n\n\toutput += ufmt.Sprintf(\"**Registered at block:** %d\\n\\n\", info.RegisteredAt)\n\toutput += ufmt.Sprintf(\"**Supports onchain metadata:** %t\\n\\n\", info.SupportsMetadata)\n\n\toutput += \"[Back to registry](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderProposals() string {\n\toutput := \"# Active Registry Proposals\\n\\n\"\n\n\tproposals := registryDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"No active proposals at the moment.\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Verify collections\\n\"\n\t\toutput += \"- Unverify collections\\n\\n\"\n\t\toutput += \"[Back](/r/pierre115/daoregistry)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[View archive](/r/pierre115/daoregistry:archive) | [Back](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"Status: Voting ended\\n\\n\"\n\t} else {\n\t\toutput += \"Status: Voting open\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View and Vote](/r/pierre115/daoregistry:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := registryDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalRegistryMembers()\n\tquorumRequired := int(float64(totalMembers) * REGISTRY_QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"**Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"**Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"VoteRegistry\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"VoteRegistry\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[Back to proposals](/r/pierre115/daoregistry:proposals) | [Home](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := registryDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"No finished proposals yet.\\n\\n\"\n\t\toutput += \"[Back](/r/pierre115/daoregistry)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[Back](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusLabel := \"PASSED\"\n\tif p.Status() == \"failed\" {\n\t\tstatusLabel = \"FAILED\"\n\t}\n\toutput += ufmt.Sprintf(\"**Status:** %s\\n\\n\", statusLabel)\n\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/daoregistry:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := registryDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalRegistryMembers()\n\tquorumRequired := int(float64(totalMembers) * REGISTRY_QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusLabel := \"PASSED\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusLabel = \"FAILED\"\n\t}\n\toutput += ufmt.Sprintf(\"**Final Status:** %s\\n\\n\", statusLabel)\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[Back to archive](/r/pierre115/daoregistry:archive) | [Home](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n"},{"name":"voting.gno","body":"package daoregistry3\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeVerifyCollection - Create proposal to verify a collection\nfunc ProposeVerifyCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsRegistryDAOMember(caller) {\n\t\tpanic(\"only Registry DAO members can create proposals\")\n\t}\n\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"collection not registered\")\n\t}\n\n\tif info.Verified {\n\t\tpanic(\"collection already verified\")\n\t}\n\n\tpropDef := NewVerifyCollectionProposal(collectionAddr, collectionName, reason)\n\n\tproposal, err := registryDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUnverifyCollection - Create proposal to unverify a collection\nfunc ProposeUnverifyCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsRegistryDAOMember(caller) {\n\t\tpanic(\"only Registry DAO members can create proposals\")\n\t}\n\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"collection not registered\")\n\t}\n\n\tif !info.Verified {\n\t\tpanic(\"collection not verified\")\n\t}\n\n\tpropDef := NewUnverifyCollectionProposal(collectionAddr, collectionName, reason)\n\n\tproposal, err := registryDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// VoteRegistry - Vote on a registry proposal\nfunc VoteRegistry(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif choice != \"yes\" \u0026\u0026 choice != \"no\" {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - handles all validations automatically\n\terr := registryDAO.Vote(caller, proposalID, commondao.VoteChoice(choice), \"\")\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyRegistryProposal - Execute a registry proposal\nfunc TallyRegistryProposal(_ realm, proposalID uint64) string {\n\terr := registryDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"RxflzxTrZxHAWC+W0cr+OVnVujeTIyU8BDCer8AyHS2fBDNQ5If6cdJ1c7j1zfokcBgjxci2/FCaW6t7OZ/nAw=="}],"memo":""},"metadata":{"timestamp":"1765552562"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765552602"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"mynft3","path":"gno.land/r/pierre115/mynft3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/mynft3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"nft.gno","body":"package mynft3\n\nimport (\n\t\"strconv\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry3\"\n)\n\ntype NFTCollection interface {\n\tgrc721.IGRC721\n\tMint(to address, tid grc721.TokenID) error\n\tGetter() grc721.NFTGetter\n}\n\nvar (\n\tnft         NFTCollection\n\tnextTokenId = 1\n\tmyRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n\tnft = grc721.NewBasicNFT(\"Test NFT Collection\", \"TEST\")\n}\n\n// Register registers this collection on the NFT registry\nfunc Register(_ realm) {\n\tdaoregistry3.RegisterCollection(\n\t\tmyRealmAddr,\n\t\t\"Test NFT Collection\",\n\t\t\"TEST\",\n\t\t\"art\",\n\t\t\"First wars\",\n\t\t\"https://example.com\",\n\t\tfalse,\n\t\tnft.Getter(),\n\t)\n}\n\nfunc MintNFT(_ realm) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\nfunc SetApprovalForAll(_ realm, operator address, approved bool) {\n\terr := nft.SetApprovalForAll(operator, approved)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc Getter() grc721.NFTGetter {\n\treturn nft.Getter()\n}\n\nfunc Render(path string) string {\n\toutput := \"# My test collection\\n\\n\"\n\toutput += \"## test\\n\\n\"\n\toutput += ufmt.Sprintf(\"**NftRealmAddr:** %d\\n\\n\", myRealmAddr.String())\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"sZW7nnAsrmuG7po0me5ayUALwl6zNeWS7ZKokre1CmY6LzHvR3Hvq4G95J8g6wapKxR74bfUW6zynZd82eOWDA=="}],"memo":""},"metadata":{"timestamp":"1765552617"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty_v2","func":"Vote","args":["1","yes"]}],"fee":{"gas_wanted":"9821308","gas_fee":"9822ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"P+R+nQIP/g6LyLTE0ahJFolOFsT4fAbZkyRDCI88L1POQkS9yebGTlJwomj1ThN/FiFVOJ3kqi2urhpE+J07Bg=="}],"memo":""},"metadata":{"timestamp":"1765552788"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1r20afxaccdszhknt8t88skmjjngg3ck8kpycs0","send":"","max_deposit":"","pkg_path":"gno.land/r/greg007/gnobounty_v2","func":"Vote","args":["1","yes"]}],"fee":{"gas_wanted":"9973484","gas_fee":"9974ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"AxACAxrbmF6UFMItpdWKnoIxMoCH6m39UqWFk37qez6mXqWvgLcQ6lEcEV8SbhUMTSETygPiRGbb+VPQKXk9DQ=="}],"memo":""},"metadata":{"timestamp":"1765552803"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g120lcpvxlv9q8hmtwkxzvw9cfzj3pu2hsf02qy7","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6oMTEOmYbiBBjNnIvkBfx5PVSagFLTTYYJEMz91R0D2jXsL3em5G96IfTVUbXuME5822hezaO7gqDlX1SrjLCQ=="}],"memo":""},"metadata":{"timestamp":"1765552868"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/daoregistry3","func":"JoinRegistryDAO"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"8GUVv41s1gB5PrPqX5fL64ZJjOCUvEcrqhiGcHIuv4RNHUKhafTap0KqX+5CQg9upyBAFRyzvoowHkmSRalZAQ=="}],"memo":""},"metadata":{"timestamp":"1765552898"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"mynft4","path":"gno.land/r/pierre115/mynft4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/mynft4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"nft.gno","body":"package mynft4\n\nimport (\n\t\"strconv\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry3\"\n)\n\ntype NFTCollection interface {\n\tgrc721.IGRC721\n\tMint(to address, tid grc721.TokenID) error\n\tGetter() grc721.NFTGetter\n}\n\nvar (\n\tnft         NFTCollection\n\tnextTokenId = 1\n\tmyRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n\tnft = grc721.NewBasicNFT(\"Test NFT Collection\", \"TEST\")\n}\n\n// Register registers this collection on the NFT registry\nfunc Register(_ realm) {\n\tdaoregistry3.RegisterCollection(\n\t\tmyRealmAddr,\n\t\t\"Test NFT Collection\",\n\t\t\"TEST\",\n\t\t\"art\",\n\t\t\"First wars\",\n\t\t\"https://example.com\",\n\t\tfalse,\n\t\tnft.Getter(),\n\t)\n}\n\nfunc MintNFT(_ realm) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\nfunc SetApprovalForAll(_ realm, operator address, approved bool) {\n\terr := nft.SetApprovalForAll(operator, approved)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc Getter() grc721.NFTGetter {\n\treturn nft.Getter()\n}\n\nfunc Render(path string) string {\n\toutput := \"# My test collection\\n\\n\"\n\toutput += \"## test\\n\\n\"\n\toutput += ufmt.Sprintf(\"**NftRealmAddr:** %d\\n\\n\", myRealmAddr.String())\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"MIjGqr2qZR8B+nYB1QV7G9nOLV3nSBIHJZMfHi1jFzzTiSQlo5jkM2e74JSM/QS10FNcTWktfi4bYGqRfl9EDA=="}],"memo":""},"metadata":{"timestamp":"1765554647"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynft4","func":"Register"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"fPoklNni42cSAbDGcyI3mMq4Fa0IWpuw9nsHLS6sl7JYPwbfm4JZECWJK2i7qQ1pw9MyJvVrw3Ahb7X0lm4FAQ=="}],"memo":""},"metadata":{"timestamp":"1765554949"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/daoregistry3","func":"ProposeVerifyCollection","args":["g1s28k2qk0ed7xv2e97n68xsxh4qu5eldf2cxf5h","collection de test","tkt"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"cM5PdGshWpQFtwnCr23WQ5yzYvusi3RBpGxAdIfJexnNGpufbm8Zw+zioG7ClOVYjMWO4TOM2OQWONXuir2wDw=="}],"memo":""},"metadata":{"timestamp":"1765555019"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765555065"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"daoregistry4","path":"gno.land/r/pierre115/daoregistry4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/daoregistry4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"joinregistry.gno","body":"package daoregistry4\n\nimport (\n\t//\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tregistryDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 0 // 0 GNOT minimum to join registry DAO\n)\n\nfunc initRegistryDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tregistryDAO = commondao.New(\n\t\tcommondao.WithID(2), // Different ID from marketplace DAO\n\t\tcommondao.WithName(\"NFT Registry DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for NFT Registry\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinRegistryDAO - Join the NFT Registry DAO by staking GNOT\nfunc JoinRegistryDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\t//sent := banker.OriginSend()\n\n\t//amount := sent.AmountOf(\"ugnot\")\n\t//if amount \u003c MIN_STAKE_UGNOT {\n\t//\tpanic(\"minimum 10 GNOT required to join Registry DAO\")\n\t//}\n\n\tif registryDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tregistryDAO.Members().Add(caller)\n\n\treturn \"Successfully joined NFT Registry DAO\"\n}\n\n// IsRegistryDAOMember - Check if an address is a registry DAO member\nfunc IsRegistryDAOMember(addr address) bool {\n\treturn registryDAO.Members().Has(addr)\n}\n\n// GetTotalRegistryMembers - Returns total number of registry DAO members\nfunc GetTotalRegistryMembers() int {\n\treturn registryDAO.Members().Size()\n}\n"},{"name":"proposals.gno","body":"package daoregistry4\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_VERIFY_COLLECTION   = \"verify_collection\"\n\tPROPOSAL_TYPE_UNVERIFY_COLLECTION = \"unverify_collection\"\n\n\tREGISTRY_VOTING_PERIOD = 5 * time.Minute\n\tREGISTRY_QUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// VerifyCollectionProposal - Proposal to verify a collection\ntype VerifyCollectionProposal struct {\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc NewVerifyCollectionProposal(addr address, name string, reason string) *VerifyCollectionProposal {\n\treturn \u0026VerifyCollectionProposal{\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *VerifyCollectionProposal) Title() string {\n\treturn \"Verify Collection: \" + p.collectionName\n}\n\nfunc (p *VerifyCollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Collection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to verify, NO to reject\",\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *VerifyCollectionProposal) VotingPeriod() time.Duration {\n\treturn REGISTRY_VOTING_PERIOD\n}\n\nfunc (p *VerifyCollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(REGISTRY_QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *VerifyCollectionProposal) Execute(realm) error {\n\tinfo := GetCollection(p.collectionAddr)\n\tif info == nil {\n\t\treturn errors.New(\"collection not found\")\n\t}\n\n\tif info.Verified {\n\t\treturn errors.New(\"collection already verified\")\n\t}\n\n\tinfo.Verified = true\n\tcollections.Set(p.collectionAddr.String(), info)\n\n\tp.executed = true\n\treturn nil\n}\n\n// UnverifyCollectionProposal - Proposal to unverify a collection\ntype UnverifyCollectionProposal struct {\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc NewUnverifyCollectionProposal(addr address, name string, reason string) *UnverifyCollectionProposal {\n\treturn \u0026UnverifyCollectionProposal{\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *UnverifyCollectionProposal) Title() string {\n\treturn \"Unverify Collection: \" + p.collectionName\n}\n\nfunc (p *UnverifyCollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Collection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to unverify, NO to reject\",\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *UnverifyCollectionProposal) VotingPeriod() time.Duration {\n\treturn REGISTRY_VOTING_PERIOD\n}\n\nfunc (p *UnverifyCollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(REGISTRY_QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *UnverifyCollectionProposal) Execute(realm) error {\n\tinfo := GetCollection(p.collectionAddr)\n\tif info == nil {\n\t\treturn errors.New(\"collection not found\")\n\t}\n\n\tif !info.Verified {\n\t\treturn errors.New(\"collection not verified\")\n\t}\n\n\tinfo.Verified = false\n\tcollections.Set(p.collectionAddr.String(), info)\n\n\tp.executed = true\n\treturn nil\n}\n"},{"name":"registry.gno","body":"package daoregistry4\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n)\n\n// CollectionInfo - Extended metadata stored in the registry\ntype CollectionInfo struct {\n\tAddress          address\n\tName             string\n\tSymbol           string\n\tCreator          address\n\tRegisteredAt     int64\n\tVerified         bool\n\tCategory         string\n\tDescription      string\n\tExternalURL      string\n\tNFTGetter        grc721.NFTGetter\n\tSupportsMetadata bool\n}\n\nvar (\n\tcollections     avl.Tree\n\tcategoriesIndex avl.Tree\n\tregistrationFee int64 = 1000000\n)\n\nfunc init() {\n\tinitRegistryDAO()\n}\n\n// RegisterCollection - Register a new NFT collection\nfunc RegisterCollection(\n\trealmAddr address,\n\tname string,\n\tsymbol string,\n\tcategory string,\n\tdescription string,\n\texternalURL string,\n\tsupportsMetadata bool,\n\tgetter grc721.NFTGetter,\n) {\n\tcreator := runtime.OriginCaller()\n\n\t// Check if collection already registered\n\tif collections.Has(realmAddr.String()) {\n\t\tpanic(\"Collection already registered\")\n\t}\n\n\tif getter == nil {\n\t\tpanic(\"NFT getter function is required\")\n\t}\n\n\tif name == \"\" || symbol == \"\" {\n\t\tpanic(\"Name and symbol cannot be empty\")\n\t}\n\n\tinfo := \u0026CollectionInfo{\n\t\tAddress:          realmAddr,\n\t\tCreator:          creator,\n\t\tName:             name,\n\t\tSymbol:           symbol,\n\t\tRegisteredAt:     runtime.ChainHeight(),\n\t\tVerified:         false,\n\t\tCategory:         category,\n\t\tDescription:      description,\n\t\tExternalURL:      externalURL,\n\t\tNFTGetter:        getter,\n\t\tSupportsMetadata: supportsMetadata,\n\t}\n\n\tcollections.Set(realmAddr.String(), info)\n}\n\n// IsRegistered - Check if a collection is registered\nfunc IsRegistered(collectionAddr address) bool {\n\treturn collections.Has(collectionAddr.String())\n}\n\n// GetTotalCollections - Total number of registered collections\nfunc GetTotalCollections() int {\n\tcount := 0\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcount++\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetVerifiedCount - Count of verified collections\nfunc GetVerifiedCount() int {\n\tcount := 0\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tinfo := value.(*CollectionInfo)\n\t\tif info.Verified {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\n// GetCollection - Retrieve collection info by address\nfunc GetCollection(collectionAddr address) *CollectionInfo {\n\tval, exists := collections.Get(collectionAddr.String())\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn val.(*CollectionInfo)\n}\n\n// GetNFTGetter - Retrieve the NFTGetter function for a collection\nfunc GetNFTGetter(collectionAddr address) (grc721.NFTGetter, bool) {\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\treturn nil, false\n\t}\n\treturn info.NFTGetter, true\n}\n\n// GetTokenMetadata - Retrieve onchain metadata for a token\nfunc GetTokenMetadata(collectionAddr address, tokenId grc721.TokenID) (grc721.Metadata, error) {\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"Collection not registered\")\n\t}\n\n\tif !info.SupportsMetadata {\n\t\tpanic(\"Collection does not support onchain metadata\")\n\t}\n\n\tnftInstance := info.NFTGetter()\n\tmetadataCollection := nftInstance.(grc721.IGRC721MetadataOnchain)\n\n\treturn metadataCollection.TokenMetadata(tokenId)\n}\n\n// UpdateCollectionInfo - Update collection metadata\nfunc UpdateCollectionInfo(category, description, externalURL string) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tinfo := GetCollection(caller)\n\tif info == nil {\n\t\tpanic(\"Collection not registered\")\n\t}\n\n\tinfo.Category = category\n\tinfo.Description = description\n\tinfo.ExternalURL = externalURL\n\tcollections.Set(caller.String(), info)\n}\n"},{"name":"render.gno","body":"package daoregistry4\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"collection/\") {\n\t\taddrStr := strings.TrimPrefix(path, \"collection/\")\n\t\taddr := address(addrStr)\n\t\treturn renderCollection(addr)\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# NFT Registry\\n\\n\"\n\toutput += \"Decentralized NFT Collection Registry with DAO Governance\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\toutput += \"## Statistics\\n\\n\"\n\toutput += ufmt.Sprintf(\"- Total registered collections: %d\\n\", GetTotalCollections())\n\toutput += ufmt.Sprintf(\"- Verified collections: %d\\n\\n\", GetVerifiedCount())\n\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalRegistryMembers())\n\n\tactiveProposals := registryDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/daoregistry:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"[View proposals](/r/pierre115/daoregistry:proposals) | \"\n\t}\n\n\tfinishedProposals := registryDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/daoregistry:archive)\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinRegistryDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join DAO\", linkjoin) + \"\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// Collections list\n\toutput += \"## Registered Collections\\n\\n\"\n\n\thasCollections := false\n\tcollections.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\thasCollections = true\n\t\tinfo := value.(*CollectionInfo)\n\t\toutput += renderCollectionPreview(info)\n\t\treturn false\n\t})\n\n\tif !hasCollections {\n\t\toutput += \"No collections registered yet.\\n\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderCollectionPreview(info *CollectionInfo) string {\n\toutput := ufmt.Sprintf(\"### %s (%s)\\n\\n\", info.Name, info.Symbol)\n\n\tif info.Verified {\n\t\toutput += \"Status: VERIFIED\\n\\n\"\n\t} else {\n\t\toutput += \"Status: Not verified\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"Category: %s\\n\\n\", info.Category)\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/daoregistry:collection/%s)\\n\\n\", info.Address.String())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderCollection(addr address) string {\n\tinfo := GetCollection(addr)\n\tif info == nil {\n\t\treturn \"# Collection not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", info.Name)\n\n\tif info.Verified {\n\t\toutput += \"**Status:** VERIFIED\\n\\n\"\n\t} else {\n\t\toutput += \"**Status:** Not verified\\n\\n\"\n\t}\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Symbol:** %s\\n\\n\", info.Symbol)\n\toutput += ufmt.Sprintf(\"**Address:** %s\\n\\n\", info.Address.String())\n\toutput += ufmt.Sprintf(\"**Creator:** %s\\n\\n\", info.Creator.String())\n\toutput += ufmt.Sprintf(\"**Category:** %s\\n\\n\", info.Category)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\\n\", info.Description)\n\n\tif info.ExternalURL != \"\" {\n\t\toutput += ufmt.Sprintf(\"**External URL:** %s\\n\\n\", info.ExternalURL)\n\t}\n\n\toutput += ufmt.Sprintf(\"**Registered at block:** %d\\n\\n\", info.RegisteredAt)\n\toutput += ufmt.Sprintf(\"**Supports onchain metadata:** %t\\n\\n\", info.SupportsMetadata)\n\n\toutput += \"[Back to registry](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderProposals() string {\n\toutput := \"# Active Registry Proposals\\n\\n\"\n\n\tproposals := registryDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"No active proposals at the moment.\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Verify collections\\n\"\n\t\toutput += \"- Unverify collections\\n\\n\"\n\t\toutput += \"[Back](/r/pierre115/daoregistry)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[View archive](/r/pierre115/daoregistry:archive) | [Back](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"Status: Voting ended\\n\\n\"\n\t} else {\n\t\toutput += \"Status: Voting open\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View and Vote](/r/pierre115/daoregistry:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := registryDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalRegistryMembers()\n\tquorumRequired := int(float64(totalMembers) * REGISTRY_QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"**Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"**Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"VoteRegistry\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"VoteRegistry\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[Back to proposals](/r/pierre115/daoregistry:proposals) | [Home](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := registryDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"No finished proposals yet.\\n\\n\"\n\t\toutput += \"[Back](/r/pierre115/daoregistry)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[Back](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusLabel := \"PASSED\"\n\tif p.Status() == \"failed\" {\n\t\tstatusLabel = \"FAILED\"\n\t}\n\toutput += ufmt.Sprintf(\"**Status:** %s\\n\\n\", statusLabel)\n\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/daoregistry:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := registryDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalRegistryMembers()\n\tquorumRequired := int(float64(totalMembers) * REGISTRY_QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusLabel := \"PASSED\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusLabel = \"FAILED\"\n\t}\n\toutput += ufmt.Sprintf(\"**Final Status:** %s\\n\\n\", statusLabel)\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[Back to archive](/r/pierre115/daoregistry:archive) | [Home](/r/pierre115/daoregistry)\\n\"\n\n\treturn output\n}\n"},{"name":"voting.gno","body":"package daoregistry4\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeVerifyCollection - Create proposal to verify a collection\nfunc ProposeVerifyCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsRegistryDAOMember(caller) {\n\t\tpanic(\"only Registry DAO members can create proposals\")\n\t}\n\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"collection not registered\")\n\t}\n\n\tif info.Verified {\n\t\tpanic(\"collection already verified\")\n\t}\n\n\tpropDef := NewVerifyCollectionProposal(collectionAddr, collectionName, reason)\n\n\tproposal, err := registryDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUnverifyCollection - Create proposal to unverify a collection\nfunc ProposeUnverifyCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsRegistryDAOMember(caller) {\n\t\tpanic(\"only Registry DAO members can create proposals\")\n\t}\n\n\tinfo := GetCollection(collectionAddr)\n\tif info == nil {\n\t\tpanic(\"collection not registered\")\n\t}\n\n\tif !info.Verified {\n\t\tpanic(\"collection not verified\")\n\t}\n\n\tpropDef := NewUnverifyCollectionProposal(collectionAddr, collectionName, reason)\n\n\tproposal, err := registryDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// VoteRegistry - Vote on a registry proposal yes/no\nfunc VoteRegistry(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tvar voteChoice commondao.VoteChoice\n\tif choice == \"yes\" {\n\t\tvoteChoice = commondao.ChoiceYes\n\t} else if choice == \"no\" {\n\t\tvoteChoice = commondao.ChoiceNo\n\t} else {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - handles all validations automatically\n\terr := registryDAO.Vote(caller, proposalID, voteChoice, \"\")\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyRegistryProposal - Execute a registry proposal\nfunc TallyRegistryProposal(_ realm, proposalID uint64) string {\n\terr := registryDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"JwCArpmzKaPSkcMHZKkhh5mXsmK+f1haXH+ijKuJ586m5LF+sy8i9EyB/ix7glhm9pDQa/imLJ6OkeiJeiVdBg=="}],"memo":""},"metadata":{"timestamp":"1765555557"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"mynft5","path":"gno.land/r/pierre115/mynft5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/mynft5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"nft.gno","body":"package mynft5\n\nimport (\n\t\"strconv\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry4\"\n)\n\ntype NFTCollection interface {\n\tgrc721.IGRC721\n\tMint(to address, tid grc721.TokenID) error\n\tGetter() grc721.NFTGetter\n}\n\nvar (\n\tnft         NFTCollection\n\tnextTokenId = 1\n\tmyRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n\tnft = grc721.NewBasicNFT(\"Test NFT Collection\", \"TEST\")\n}\n\n// Register registers this collection on the NFT registry\nfunc Register(_ realm) {\n\tdaoregistry4.RegisterCollection(\n\t\tmyRealmAddr,\n\t\t\"Test NFT Collection\",\n\t\t\"TEST\",\n\t\t\"art\",\n\t\t\"First wars\",\n\t\t\"https://example.com\",\n\t\tfalse,\n\t\tnft.Getter(),\n\t)\n}\n\nfunc MintNFT(_ realm) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\nfunc SetApprovalForAll(_ realm, operator address, approved bool) {\n\terr := nft.SetApprovalForAll(operator, approved)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc Getter() grc721.NFTGetter {\n\treturn nft.Getter()\n}\n\nfunc Render(path string) string {\n\toutput := \"# My test collection\\n\\n\"\n\toutput += \"## test\\n\\n\"\n\toutput += ufmt.Sprintf(\"**NftRealmAddr:** %d\\n\\n\", myRealmAddr.String())\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"r92DKRuveNtY9mK1f84qoRk+JwcSZO1zZUc09NrMLtrfXrr/NwNWn2sNmhlIiRFbGIu4jtgv00ZoJy4nZn+wCA=="}],"memo":""},"metadata":{"timestamp":"1765555597"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765556623"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynft5","func":"Register"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"yJoTTJ5bxywQj7eO56K6B/G1BkOPvlcHiA0E2sffaWegNTLaC/5Rld0An7fFZWqVbd6ULJpjbf/Van6L9YPRDQ=="}],"memo":""},"metadata":{"timestamp":"1765556638"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/daoregistry4","func":"JoinRegistryDAO"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"sEL5L/Xl0Npl0AC6YOHumoat6SVE+hdwoIz4uLEco2+UqDJEE/LyWhErXOT8y7eZFWQvr8fmSyQXcyrZ659ACg=="}],"memo":""},"metadata":{"timestamp":"1765556698"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/daoregistry4","func":"ProposeVerifyCollection","args":["g1chp76pw0s3j6r92c38cltr8kkkgaejlvlexs8x","tkt","tkt"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"KHO6LPKudyDaSObX0hXF9bq1MmnfDXv/sCmgCY6ZOVc+K4K43LhamXfM1g1A62kky4aWo+Pl0o6OEfg1lYq3DQ=="}],"memo":""},"metadata":{"timestamp":"1765556739"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/daoregistry4","func":"VoteRegistry","args":["1","yes"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"wFjU8DdwwsQp+M7Wc9wlYugwmvg3FpvIDzcUWQLTkflpZPHs9Dt3q+I/nCr3xnJ5Bo3bDB0ihrFkV06VwznhBA=="}],"memo":""},"metadata":{"timestamp":"1765556774"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/daoregistry4","func":"TallyRegistryProposal","args":["1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"tuPruE8rk1YEyqVttN+WbxyEG8KTm7kJxJ/nSC5CUHn794V6csy7nVkatSlkMR4PtBJAgqJFLPRjhLzrcIavAQ=="}],"memo":""},"metadata":{"timestamp":"1765557100"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765559493"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"gnopendao","path":"gno.land/r/pierre115/gnopendao","files":[{"name":"README.md","body":"# GnopenSea - NFT Marketplace\n\nMarketplace NFT d√©centralis√© sur Gno.land avec gouvernance DAO.\n\n## üöÄ Comment lister votre NFT en 3 √©tapes\n\n### √âtape 1 : Enregistrer votre collection\n\n**Depuis votre package NFT**, appelez la fonction `Register()` :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"Register\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  votre-wallet\n```\n\nCela enregistre votre collection dans le **Registry DAO** (statut: non v√©rifi√©).\n\n### √âtape 2 : Approuver le marketplace\n\nDonnez la permission au marketplace de transf√©rer vos NFTs :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"SetApprovalForAll\" \\\n  -args \"g1[adresse-du-marketplace]\" \\\n  -args \"true\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### √âtape 3 : Cr√©er votre listing\n\nListez votre NFT √† vendre :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CreateListing\" \\\n  -args \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -args \"1\" \\\n  -args \"5000000\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n**Param√®tres :**\n- 1er arg : Adresse de votre package NFT\n- 2√®me arg : Token ID √† vendre\n- 3√®me arg : Prix en ugnot (5000000 = 5 GNOT)\n\n---\n\n## üõí Acheter un NFT\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"BuyNFT\" \\\n  -args \"1\" \\\n  -send \"5000000ugnot\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üìã G√©rer vos listings\n\n### Modifier le prix\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"UpdatePrice\" \\\n  -args \"1\" \\\n  -args \"10000000\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n### Annuler un listing\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CancelListing\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üé® Faire v√©rifier votre collection (badge v√©rifi√©)\n\n### 1. Cr√©er une proposal au Registry DAO\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"ProposeVerifyCollection\" \\\n  -args \"g1[adresse-de-votre-nft]\" \\\n  -args \"Nom de la collection\" \\\n  -args \"Raison de la v√©rification\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### 2. Les membres du DAO votent\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"VoteRegistry\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### 3. Ex√©cuter la proposal (apr√®s quorum)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"TallyRegistryProposal\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üí∞ Distribution des paiements\n\nExemple avec frais marketplace 2.5% et royalties 10% :\n\n```\nPrix de vente : 100 GNOT\n‚îú‚îÄ‚îÄ Frais marketplace (2.5%) : 2.5 GNOT\n‚îú‚îÄ‚îÄ Royalties cr√©ateur (10%) : 10 GNOT\n‚îî‚îÄ‚îÄ Vendeur re√ßoit : 87.5 GNOT\n```\n\n---\n\n## üèõÔ∏è Gouvernance DAO\n\nLe marketplace est gouvern√© par un DAO. Les membres peuvent cr√©er des proposals pour :\n\n- ‚úÖ Approuver/retirer des collections\n- ‚úÖ Modifier les frais du marketplace\n- ‚úÖ Retirer des fonds du tr√©sor\n- ‚úÖ Annuler un listing probl√©matique\n\n### Cr√©er une proposal (exemple: modifier les frais)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"ProposeUpdateFees\" \\\n  -args \"300\" \\\n  -args \"R√©duction des frais √† 3%\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### Voter sur une proposal\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n---\n\n## üîß Configuration NFT minimale\n\nVotre package NFT doit avoir une fonction `Register()` :\n\n```go\npackage mynft\n\nimport (\n    \"gno.land/p/demo/tokens/grc721\"\n    \"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n    nft         *grc721.basicNFT\n    myRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n    nft = grc721.NewBasicNFT(\"My Collection\", \"MC\")\n}\n\n// Register dans le registry\nfunc Register(_ realm) {\n    daoregistry4.RegisterCollection(\n        myRealmAddr,\n        \"My Collection\",\n        \"MC\",\n        \"art\",\n        \"Description de ma collection\",\n        \"https://mon-site.com\",\n        false,\n        nft.Getter(),\n    )\n}\n\n// Fonction obligatoire pour le marketplace\nfunc Getter() grc721.NFTGetter {\n    return nft.Getter()\n}\n```\n\n---\n\n## üìä Fonctions de lecture\n\n```bash\n# Voir tous les listings actifs\ncurl https://rpc.gno.land/r/pierre115/gnopendao:\n\n# Statistiques du marketplace\ncurl https://rpc.gno.land/r/pierre115/gnopendao:stats\n\n# D√©tails d'un listing\ncurl https://rpc.gno.land/r/pierre115/gnopendao:listing/1\n\n# Collections enregistr√©es\ncurl https://rpc.gno.land/r/pierre115/daoregistry4:\n```\n\n---\n\n## üîê S√©curit√©\n\n- ‚úÖ V√©rification de propri√©t√© avant listing\n- ‚úÖ V√©rification d'approbation avant vente\n- ‚úÖ Transferts atomiques\n- ‚úÖ Remboursement automatique des surplus\n- ‚úÖ Limites de frais (max 10%)\n- ‚úÖ Gouvernance d√©centralis√©e\n\n---\n\n## üÜò Probl√®mes courants\n\n**\"Collection not registered\"**\n‚Üí Vous devez d'abord appeler `Register()` sur votre NFT\n\n**\"Insufficient payment\"**\n‚Üí Le montant envoy√© doit correspondre au prix du listing\n\n**\"Not approved\"**\n‚Üí Appelez `SetApprovalForAll()` avant de cr√©er un listing\n\n**\"Not owner\"**\n‚Üí Seul le propri√©taire du NFT peut le lister\n"},{"name":"dao.gno","body":"package gnopendao\n\nimport (\n\t//\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tmarketplaceDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 0 // 0 GNOT minimum to join DAO\n)\n\nfunc initDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tmarketplaceDAO = commondao.New(\n\t\tcommondao.WithID(1),\n\t\tcommondao.WithName(\"GnopenSea DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for GnopenSea marketplace\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinDAO - Join the marketplace DAO by staking GNOT\nfunc JoinDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\t//sent := banker.OriginSend()\n\n\t//amount := sent.AmountOf(\"ugnot\")\n\t//if amount \u003c MIN_STAKE_UGNOT {\n\t//\tpanic(\"minimum 1 GNOT required to join DAO\")\n\t//}\n\n\tif marketplaceDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tmarketplaceDAO.Members().Add(caller)\n\n\treturn \"Successfully joined GnopenSea DAO\"\n}\n\n// IsDAOMember - Check if an address is a DAO member\nfunc IsDAOMember(addr address) bool {\n\treturn marketplaceDAO.Members().Has(addr)\n}\n\n// GetTotalMembers - Returns total number of DAO members\nfunc GetTotalMembers() int {\n\treturn marketplaceDAO.Members().Size()\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/gnopendao\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"gnopensea.gno","body":"package gnopendao\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n\tlistings      avl.Tree\n\tsales         avl.Tree\n\tnextListingId = 1\n\tnextSaleId    = 1\n\n\tmarketplaceFee      = int64(250) // 250 basis points = 2.5%\n\tmarketplaceAddr     = runtime.CurrentRealm().Address()\n\tapprovedCollections avl.Tree // Whitelist of approved collections\n)\n\nfunc init() {\n\tinitDAO()\n}\n\n// CreateListing - List an NFT for sale using the global NFT Registry\nfunc CreateListing(_ realm, nftRealmAddress address, tokenId grc721.TokenID, price int64) int {\n\tcaller := runtime.OriginCaller()\n\n\tif price \u003c= 0 || price \u003e 99999999999 {\n\t\tpanic(\"Price not valid\")\n\t}\n\n\t// Check if collection is registered in the GLOBAL NFT Registry (technical check)\n\tif !daoregistry4.IsRegistered(nftRealmAddress) {\n\t\tpanic(\"NFT collection not registered in the global NFT Registry. The collection must call nftregistry.RegisterCollection() first.\")\n\t}\n\t// Check if collection is approved by DAO (governance check)\n\tif !approvedCollections.Has(nftRealmAddress.String()) {\n\t\tpanic(\"Collection not approved by DAO. A DAO proposal must be created and passed first.\")\n\t}\n\n\t// Get NFT getter from the global registry\n\tgetter, exists := daoregistry4.GetNFTGetter(nftRealmAddress)\n\tif !exists {\n\t\tpanic(\"Failed to get NFT getter from registry\")\n\t}\n\n\tnftInstance := getter()\n\n\t// Verify caller is the owner\n\towner, err := nftInstance.OwnerOf(tokenId)\n\tif err != nil {\n\t\tpanic(\"Token not found: \" + err.Error())\n\t}\n\n\tif owner != caller {\n\t\tpanic(\"You are not the owner of this NFT\")\n\t}\n\n\t// Verify approvals\n\tmarketplaceAddr := runtime.CurrentRealm().Address()\n\tapprovedAddr, err := nftInstance.GetApproved(tokenId)\n\tisApprovedForToken := (err == nil \u0026\u0026 approvedAddr == marketplaceAddr)\n\tisApprovedForAll := nftInstance.IsApprovedForAll(owner, marketplaceAddr)\n\n\tif !isApprovedForToken \u0026\u0026 !isApprovedForAll {\n\t\tpanic(\"You must first approve the marketplace.\\nUse Approve() or SetApprovalForAll()\")\n\t}\n\n\t// Create listing\n\tlisting := \u0026Listing{\n\t\tListingId:       nextListingId,\n\t\tNFTGetter:       getter,\n\t\tTokenId:         tokenId,\n\t\tSeller:          caller,\n\t\tPrice:           price,\n\t\tActive:          true,\n\t\tListedAt:        runtime.ChainHeight(),\n\t\tNFTRealmAddress: nftRealmAddress,\n\t}\n\n\tlistings.Set(strconv.Itoa(nextListingId), listing)\n\tnextListingId++\n\n\treturn listing.ListingId\n}\n\n// BuyNFT - Purchase a listed NFT with automatic royalty calculation\nfunc BuyNFT(_ realm, listingId int) {\n\tcaller := runtime.OriginCaller()\n\tsent := banker.OriginSend()\n\n\t// Get listing\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\t// Verify payment\n\tamount := sent.AmountOf(\"ugnot\")\n\tif amount \u003c listing.Price {\n\t\tpanic(ufmt.Sprintf(\"Insufficient amount. Price: %d ugnot\", listing.Price))\n\t}\n\n\t// Get NFT instance\n\tnftInstance := listing.NFTGetter()\n\n\t// Verify seller still owns the NFT\n\tcurrentOwner, err := nftInstance.OwnerOf(listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"NFT not found: \" + err.Error())\n\t}\n\tif currentOwner != listing.Seller {\n\t\tpanic(\"Seller no longer owns this NFT\")\n\t}\n\n\t// Calculate royalties\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\t// Check if NFT supports royalties\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate what seller receives\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\tif sellerAmount \u003c 0 {\n\t\tpanic(\"Error: fees + royalties exceed sale price\")\n\t}\n\n\t// Distribute payments\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\t// 1. Pay seller\n\tif sellerAmount \u003e 0 {\n\t\tsellerCoins := chain.Coins{chain.Coin{\"ugnot\", sellerAmount}}\n\t\tbnkr.SendCoins(realmAddr, listing.Seller, sellerCoins)\n\t}\n\n\t// 2. Pay royalties to creator\n\tif royaltyAmount \u003e 0 \u0026\u0026 royaltyReceiver != \"\" {\n\t\troyaltyCoins := chain.Coins{chain.Coin{\"ugnot\", royaltyAmount}}\n\t\tbnkr.SendCoins(realmAddr, royaltyReceiver, royaltyCoins)\n\t}\n\n\t// 3. TODO : Marketplace fees remain in contract\n\n\t// 4. Refund excess\n\tif amount \u003e listing.Price {\n\t\texcess := amount - listing.Price\n\t\texcessCoins := chain.Coins{chain.Coin{\"ugnot\", excess}}\n\t\tbnkr.SendCoins(realmAddr, caller, excessCoins)\n\t}\n\n\t// Transfer NFT\n\terr = nftInstance.TransferFrom(listing.Seller, caller, listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"Transfer error: \" + err.Error())\n\t}\n\n\t// Record sale\n\tsale := \u0026Sale{\n\t\tListingId:       listingId,\n\t\tTokenId:         listing.TokenId.String(),\n\t\tBuyer:           caller,\n\t\tSeller:          listing.Seller,\n\t\tPrice:           listing.Price,\n\t\tMarketplaceFee:  marketplaceFeeAmount,\n\t\tRoyaltyFee:      royaltyAmount,\n\t\tRoyaltyReceiver: royaltyReceiver,\n\t\tSoldAt:          runtime.ChainHeight(),\n\t}\n\n\tsales.Set(strconv.Itoa(nextSaleId), sale)\n\tnextSaleId++\n\n\t// Deactivate listing\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// CancelListing - Cancel own listing (seller only)\nfunc CancelListing(_realm, listingId int) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\t// Only seller can cancel their own listing\n\t// DAO use ProposeForceCancelListing instead\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can cancel this listing. DAO members can create a ProposeForceCancelListing proposal.\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// UpdatePrice - Update listing price\nfunc UpdatePrice(_ realm, listingId int, newPrice int64) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif newPrice \u003c= 0 {\n\t\tpanic(\"Price must be positive\")\n\t}\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can modify this listing\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\tlisting.Price = newPrice\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// ============= READ FUNCTIONS =============\n\nfunc GetListing(listingId int) (int, string, int64, string, bool, int64) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, \"\", 0, \"\", false, 0\n\t}\n\n\treturn listing.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tlisting.ListedAt\n}\n\nfunc GetSale(saleId int) (int, string, string, string, int64, int64, int64, string, int64) {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn 0, \"\", \"\", \"\", 0, 0, 0, \"\", 0\n\t}\n\n\tsale := value.(*Sale)\n\treturn sale.ListingId,\n\t\tsale.TokenId,\n\t\tsale.Buyer.String(),\n\t\tsale.Seller.String(),\n\t\tsale.Price,\n\t\tsale.MarketplaceFee,\n\t\tsale.RoyaltyFee,\n\t\tsale.RoyaltyReceiver.String(),\n\t\tsale.SoldAt\n}\n\nfunc GetActiveListingsCount() int {\n\tcount := 0\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\nfunc GetTotalSales() int {\n\treturn sales.Size()\n}\n\nfunc GetTotalVolume() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.Price\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetTotalRoyaltiesPaid() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.RoyaltyFee\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetMarketplaceFee() int64 {\n\treturn marketplaceFee\n}\n\nfunc GetMarketplaceAddress() address {\n\treturn runtime.CurrentRealm().Address()\n}\n\n// GetRoyaltyBreakdown - Calculate distribution for a listing\nfunc GetRoyaltyBreakdown(listingId int) (int64, int64, int64, address) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, 0, 0, \"\"\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate royalties if supported\n\tnftInstance := listing.NFTGetter()\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\treturn sellerAmount, marketplaceFeeAmount, royaltyAmount, royaltyReceiver\n}\n\nfunc GetBalance() int64 {\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\tbalance := bnkr.GetCoins(realmAddr)\n\treturn balance.AmountOf(\"ugnot\")\n}\n\n// ============= READ FUNCTIONS FOR FRONTEND =============\n\n// GetAllListings - Return all active listings\nfunc GetAllListings() string {\n\tvar listingsData []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\t// Format: listingId|nftAddress|tokenId|price|seller\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%s|%d|%s\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.NFTRealmAddress.String(),\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t\tlisting.Seller.String(),\n\t\t\t)\n\t\t\tlistingsData = append(listingsData, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(listingsData) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(listingsData, \"\\n\")\n}\n\n// GetListingDetails - Get detailed info about a listing\nfunc GetListingDetails(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"Listing not found\"\n\t}\n\n\tnftInstance := listing.NFTGetter()\n\n\t// Get NFT metadata if available\n\tvar name, uri string\n\tif metaNFT, ok := nftInstance.(grc721.IGRC721Metadata); ok {\n\t\tname = metaNFT.Name()\n\t\tif tokenURI, err := metaNFT.TokenURI(listing.TokenId); err == nil {\n\t\t\turi = tokenURI\n\t\t}\n\t}\n\n\t// Format JSON-like response\n\toutput := ufmt.Sprintf(`{\n  \"listingId\": %d,\n  \"tokenId\": \"%s\",\n  \"price\": %d,\n  \"seller\": \"%s\",\n  \"active\": %t,\n  \"name\": \"%s\",\n  \"uri\": \"%s\",\n  \"listedAt\": %d\n}`,\n\t\tlisting.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tname,\n\t\turi,\n\t\tlisting.ListedAt,\n\t)\n\n\treturn output\n}\n\n// GetUserListings - Get all listings by a specific seller\nfunc GetUserListings(sellerAddr address) string {\n\tvar userListings []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Seller == sellerAddr \u0026\u0026 listing.Active {\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%d\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t)\n\t\t\tuserListings = append(userListings, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(userListings) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(userListings, \"\\n\")\n}\n\n// GetMarketplaceStats - Get overall marketplace statistics\nfunc GetMarketplaceStats() string {\n\tactiveCount := GetActiveListingsCount()\n\ttotalSales := GetTotalSales()\n\ttotalVolume := GetTotalVolume()\n\n\toutput := ufmt.Sprintf(`{\n  \"activeListings\": %d,\n  \"totalSales\": %d,\n  \"totalVolume\": %d,\n  \"marketplaceFee\": %d\n}`,\n\t\tactiveCount,\n\t\ttotalSales,\n\t\ttotalVolume,\n\t\tmarketplaceFee,\n\t)\n\n\treturn output\n}\n\n// ============= HELPERS =============\n\nfunc getListing(listingId int) *Listing {\n\tvalue, exists := listings.Get(strconv.Itoa(listingId))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn value.(*Listing)\n}\n\nfunc formatPrice(ugnot int64) string {\n\tgnot := float64(ugnot) / 1000000.0\n\treturn ufmt.Sprintf(\"%.2f GNOT\", gnot)\n}\n\nfunc formatFee(basisPoints int64) string {\n\tpercent := float64(basisPoints) / 100.0\n\treturn ufmt.Sprintf(\"%.2f%%\", percent)\n}\n\nfunc formatPercentage(value, total int64) string {\n\tif total == 0 {\n\t\treturn \"0%\"\n\t}\n\tpercent := (float64(value) / float64(total)) * 100.0\n\treturn ufmt.Sprintf(\"%.1f%%\", percent)\n}\n"},{"name":"gnopensea_test.gno","body":"package gnopendao\n\nimport (\n\t\"testing\"\n)\n\n// Test marketplace initialization values\nfunc TestMarketplaceInit(t *testing.T) {\n\t// Check marketplace fee is set to default (2.5%)\n\tfee := GetMarketplaceFee()\n\tif fee != 250 {\n\t\tt.Errorf(\"Expected marketplace fee to be 250, got %d\", fee)\n\t}\n}\n\n// Test marketplace fee getter\nfunc TestGetMarketplaceFee(t *testing.T) {\n\tfee := GetMarketplaceFee()\n\tif fee \u003c 0 || fee \u003e 1000 {\n\t\tt.Errorf(\"Marketplace fee out of valid range (0-1000): %d\", fee)\n\t}\n}\n\n// Test active listings count (should not panic)\nfunc TestGetActiveListingsCount(t *testing.T) {\n\tcount := GetActiveListingsCount()\n\tif count \u003c 0 {\n\t\tt.Errorf(\"Active listings count should not be negative: %d\", count)\n\t}\n}\n\n// Test total sales (should not panic)\nfunc TestGetTotalSales(t *testing.T) {\n\tsales := GetTotalSales()\n\tif sales \u003c 0 {\n\t\tt.Errorf(\"Total sales should not be negative: %d\", sales)\n\t}\n}\n\n// Test total volume (should not panic)\nfunc TestGetTotalVolume(t *testing.T) {\n\tvolume := GetTotalVolume()\n\tif volume \u003c 0 {\n\t\tt.Errorf(\"Total volume should not be negative: %d\", volume)\n\t}\n}\n\n// Test total royalties paid (should not panic)\nfunc TestGetTotalRoyaltiesPaid(t *testing.T) {\n\troyalties := GetTotalRoyaltiesPaid()\n\tif royalties \u003c 0 {\n\t\tt.Errorf(\"Total royalties should not be negative: %d\", royalties)\n\t}\n}\n\n// Test marketplace address getter (should not panic)\nfunc TestGetMarketplaceAddress(t *testing.T) {\n\taddr := GetMarketplaceAddress()\n\tif addr == \"\" {\n\t\tt.Error(\"Marketplace address should not be empty\")\n\t}\n}\n\n// Test balance getter (should not panic)\nfunc TestGetBalance(t *testing.T) {\n\tbalance := GetBalance()\n\tif balance \u003c 0 {\n\t\tt.Errorf(\"Balance should not be negative: %d\", balance)\n\t}\n}\n\n// Test render home page (should not panic)\nfunc TestRenderHome(t *testing.T) {\n\toutput := Render(\"\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Home render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Marketplace\") {\n\t\tt.Error(\"Home render should contain 'Marketplace'\")\n\t}\n}\n\n// Test render stats page (should not panic)\nfunc TestRenderStats(t *testing.T) {\n\toutput := Render(\"stats\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Stats render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Statistics\") {\n\t\tt.Error(\"Stats render should contain 'Statistics'\")\n\t}\n}\n\n// Test render invalid path\nfunc TestRenderInvalidPath(t *testing.T) {\n\toutput := Render(\"invalid/path/test\")\n\tif output != \"Page not found\" {\n\t\tt.Errorf(\"Expected 'Page not found', got '%s'\", output)\n\t}\n}\n\n// Test format price function\nfunc TestFormatPrice(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{1000000, \"1.00 GNOT\"},\n\t\t{5000000, \"5.00 GNOT\"},\n\t\t{100, \"0.00 GNOT\"},\n\t\t{0, \"0.00 GNOT\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPrice(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPrice(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format fee function\nfunc TestFormatFee(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{250, \"2.50%\"},\n\t\t{500, \"5.00%\"},\n\t\t{1000, \"10.00%\"},\n\t\t{0, \"0.00%\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatFee(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatFee(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format percentage function\nfunc TestFormatPercentage(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    int64\n\t\ttotal    int64\n\t\texpected string\n\t}{\n\t\t{25, 100, \"25.0%\"},\n\t\t{50, 100, \"50.0%\"},\n\t\t{0, 100, \"0.0%\"},\n\t\t{100, 100, \"100.0%\"},\n\t\t{0, 0, \"0%\"}, // Division by zero case\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPercentage(tt.value, tt.total)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPercentage(%d, %d) = %s, expected %s\",\n\t\t\t\ttt.value, tt.total, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test GetListing with invalid ID (should return zeros)\nfunc TestGetListingInvalid(t *testing.T) {\n\tid, tokenId, price, seller, active, listedAt := GetListing(999999)\n\n\tif id != 0 || tokenId != \"\" || price != 0 || seller != \"\" || active != false || listedAt != 0 {\n\t\tt.Error(\"GetListing with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetSale with invalid ID (should return zeros)\nfunc TestGetSaleInvalid(t *testing.T) {\n\tlistingId, tokenId, buyer, seller, price, marketFee, royaltyFee, royaltyReceiver, soldAt := GetSale(999999)\n\n\tif listingId != 0 || tokenId != \"\" || buyer != \"\" || seller != \"\" ||\n\t\tprice != 0 || marketFee != 0 || royaltyFee != 0 || royaltyReceiver != \"\" || soldAt != 0 {\n\t\tt.Error(\"GetSale with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetRoyaltyBreakdown with invalid ID (should return zeros)\nfunc TestGetRoyaltyBreakdownInvalid(t *testing.T) {\n\tsellerAmount, marketFee, royalty, royaltyReceiver := GetRoyaltyBreakdown(999999)\n\n\tif sellerAmount != 0 || marketFee != 0 || royalty != 0 || royaltyReceiver != \"\" {\n\t\tt.Error(\"GetRoyaltyBreakdown with invalid ID should return zero values\")\n\t}\n}\n\n// Helper function to check if string contains substring\nfunc contains(s, substr string) bool {\n\treturn len(s) \u003e= len(substr) \u0026\u0026 (s == substr ||\n\t\tlen(s) \u003e len(substr) \u0026\u0026 indexOf(s, substr) \u003e= 0)\n}\n\n// Helper function to find substring index\nfunc indexOf(s, substr string) int {\n\tfor i := 0; i \u003c= len(s)-len(substr); i++ {\n\t\tif s[i:i+len(substr)] == substr {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"},{"name":"proposal.gno","body":"package gnopendao\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"errors\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_APPROVE_COLLECTION   = \"approve_collection\"\n\tPROPOSAL_TYPE_REMOVE_COLLECTION    = \"remove_collection\"\n\tPROPOSAL_TYPE_UPDATE_FEES          = \"update_fees\"\n\tPROPOSAL_TYPE_WITHDRAW_TREASURY    = \"withdraw_treasury\"\n\tPROPOSAL_TYPE_FORCE_CANCEL_LISTING = \"force_cancel_listing\"\n\n\tVOTING_PERIOD = 10 * time.Minute\n\tQUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// CollectionProposal - Proposal to approve or remove a collection\ntype CollectionProposal struct {\n\tproposalType   string\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc newCollectionProposal(propType string, addr address, name string, reason string) *CollectionProposal {\n\treturn \u0026CollectionProposal{\n\t\tproposalType:   propType,\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *CollectionProposal) Title() string {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\treturn \"Approve Collection: \" + p.collectionName\n\t}\n\treturn \"Remove Collection: \" + p.collectionName\n}\n\nfunc (p *CollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Type: %s\\nCollection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tp.proposalType,\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *CollectionProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *CollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *CollectionProposal) Execute(realm) error {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\tapprovedCollections.Set(p.collectionAddr.String(), true)\n\t} else if p.proposalType == PROPOSAL_TYPE_REMOVE_COLLECTION {\n\t\tapprovedCollections.Remove(p.collectionAddr.String())\n\t}\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *CollectionProposal) GetCollectionAddr() address {\n\treturn p.collectionAddr\n}\n\n// FeesProposal - Proposal to update marketplace fees\ntype FeesProposal struct {\n\tnewFee   int64\n\treason   string\n\tapproved bool\n\texecuted bool\n}\n\nfunc newFeesProposal(newFee int64, reason string) *FeesProposal {\n\treturn \u0026FeesProposal{\n\t\tnewFee:   newFee,\n\t\treason:   reason,\n\t\tapproved: false,\n\t\texecuted: false,\n\t}\n}\n\nfunc (p *FeesProposal) Title() string {\n\treturn ufmt.Sprintf(\"Update Marketplace Fee to %d basis points\", p.newFee)\n}\n\nfunc (p *FeesProposal) Body() string {\n\tcurrentFeePercent := float64(marketplaceFee) / 100.0\n\tnewFeePercent := float64(p.newFee) / 100.0\n\n\treturn ufmt.Sprintf(\n\t\t\"Current Fee: %.2f%%\\nProposed Fee: %.2f%%\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tcurrentFeePercent,\n\t\tnewFeePercent,\n\t\tp.reason,\n\t)\n}\n\nfunc (p *FeesProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *FeesProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *FeesProposal) Execute(realm) error {\n\tmarketplaceFee = p.newFee\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *FeesProposal) GetNewFee() int64 {\n\treturn p.newFee\n}\n\n// TreasuryProposal - Proposal to withdraw funds from treasury\ntype TreasuryProposal struct {\n\tamount    int64\n\trecipient address\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewTreasuryProposal(amount int64, recipient address, reason string) *TreasuryProposal {\n\treturn \u0026TreasuryProposal{\n\t\tamount:    amount,\n\t\trecipient: recipient,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *TreasuryProposal) Title() string {\n\treturn ufmt.Sprintf(\"Withdraw %d ugnot from Treasury\", p.amount)\n}\n\nfunc (p *TreasuryProposal) Body() string {\n\tcurrentBalance := GetBalance()\n\n\treturn ufmt.Sprintf(\n\t\t\"Withdraw: %s\\nRecipient: %s\\nCurrent Treasury: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tformatPrice(p.amount),\n\t\tp.recipient.String(),\n\t\tformatPrice(currentBalance),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *TreasuryProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *TreasuryProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *TreasuryProposal) Execute(realm) error {\n\tcurrentBalance := GetBalance()\n\tif currentBalance \u003c p.amount {\n\t\treturn errors.New(\"insufficient treasury balance\")\n\t}\n\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tcoins := chain.Coins{chain.Coin{\"ugnot\", p.amount}}\n\tbnkr.SendCoins(realmAddr, p.recipient, coins)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *TreasuryProposal) GetAmount() int64 {\n\treturn p.amount\n}\n\nfunc (p *TreasuryProposal) GetRecipient() address {\n\treturn p.recipient\n}\n\n// ForceCancelListingProposal - Proposal to force cancel a problematic listing\ntype ForceCancelListingProposal struct {\n\tlistingId int\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewForceCancelListingProposal(listingId int, reason string) *ForceCancelListingProposal {\n\treturn \u0026ForceCancelListingProposal{\n\t\tlistingId: listingId,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *ForceCancelListingProposal) Title() string {\n\treturn ufmt.Sprintf(\"Force Cancel Listing #%d\", p.listingId)\n}\n\nfunc (p *ForceCancelListingProposal) Body() string {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn ufmt.Sprintf(\"Listing #%d\\nStatus: NOT FOUND\\nReason: %s\\n\\nVote YES to approve, NO to reject\", p.listingId, p.reason)\n\t}\n\n\treturn ufmt.Sprintf(\n\t\t\"Listing ID: %d\\nToken ID: %s\\nSeller: %s\\nPrice: %s\\nReason for cancellation: %s\\n\\nVote YES to force cancel, NO to reject\",\n\t\tp.listingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Seller.String(),\n\t\tformatPrice(listing.Price),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *ForceCancelListingProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *ForceCancelListingProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *ForceCancelListingProposal) Execute(realm) error {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn errors.New(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\treturn errors.New(\"listing already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(p.listingId), listing)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *ForceCancelListingProposal) GetListingId() int {\n\treturn p.listingId\n}\n"},{"name":"render.gno","body":"package gnopendao\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ============= RENDER =============\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif strings.HasPrefix(path, \"listing/\") {\n\t\tidStr := strings.TrimPrefix(path, \"listing/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderListing(id)\n\t}\n\n\tif strings.HasPrefix(path, \"sale/\") {\n\t\tidStr := strings.TrimPrefix(path, \"sale/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderSale(id)\n\t}\n\n\tif path == \"stats\" {\n\t\treturn renderStats()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# GNOPENSEA DAO 10\\n\\n\"\n\toutput += \"Decentralized NFT Marketplace with DAO Governance\\n\\n\"\n\toutput += \"Compatible **GRC-721** + **GRC-2981** (Automatic Royalties)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += \"[View detailed statistics](/r/pierre115/gnopendao:stats)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalMembers())\n\n\tactiveProposals := marketplaceDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/gnopendao:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"*No active proposals*\\n\\n\"\n\t}\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/gnopendao:archive)\\n\\n\", finishedProposals.Size())\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join !\", linkjoin) + \"\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\t// Active listings\n\tif GetActiveListingsCount() \u003e 0 {\n\t\toutput += \"## NFTs for sale\\n\\n\"\n\n\t\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tlisting := value.(*Listing)\n\t\t\tif listing.Active {\n\t\t\t\toutput += renderListingPreview(listing)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t} else {\n\t\toutput += \"## No NFTs for sale\\n\\n\"\n\t\toutput += \"*Be the first to list an NFT!*\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderListingPreview(listing *Listing) string {\n\t// Calculate breakdown\n\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listing.ListingId)\n\n\toutput := ufmt.Sprintf(\"### Listing #%d\\n\\n\", listing.ListingId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\n\tif royalty \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"Royalty: %s (%s)\\n\\n\",\n\t\t\tformatPrice(royalty),\n\t\t\tformatPercentage(royalty, listing.Price))\n\t}\n\n\toutput += ufmt.Sprintf(\"**Seller receives:** %s\\n\\n\", formatPrice(sellerGets))\n\toutput += ufmt.Sprintf(\"**Market Fees:** %s\\n\\n\", formatPrice(marketFee))\n\toutput += ufmt.Sprintf(\"**Royalty Address:** %s\\n\\n\", royaltyAddr.String())\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao:listing/%d)\\n\\n\", listing.ListingId)\n\toutput += \"---\\n\\n\"\n\treturn output\n}\n\nfunc renderListing(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"# Listing not found\"\n\t}\n\n\tstatus := \"Active\"\n\tif !listing.Active {\n\t\tstatus = \"Sold/Cancelled\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Listing #%d - %s\\n\\n\", listingId, status)\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", listing.Seller.String())\n\toutput += ufmt.Sprintf(\"**Listed at block:** %d\\n\\n\", listing.ListedAt)\n\n\tif listing.Active {\n\t\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listingId)\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Price breakdown\\n\\n\"\n\t\toutput += ufmt.Sprintf(\"- **Total price:** %s (100%%)\\n\", formatPrice(listing.Price))\n\t\toutput += ufmt.Sprintf(\"- **Marketplace fee (%s):** %s\\n\",\n\t\t\tformatFee(marketplaceFee), formatPrice(marketFee))\n\n\t\tif royalty \u003e 0 {\n\t\t\toutput += ufmt.Sprintf(\"- **Creator royalty (%s):** %s\\n\",\n\t\t\t\tformatPercentage(royalty, listing.Price), formatPrice(royalty))\n\t\t\toutput += ufmt.Sprintf(\"  - Beneficiary: `%s`\\n\", royaltyAddr.String())\n\t\t} else {\n\t\t\toutput += \"- **Royalty:** None\\n\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"- **Seller receives:** %s (%s)\\n\\n\",\n\t\t\tformatPrice(sellerGets), formatPercentage(sellerGets, listing.Price))\n\n\t\toutput += \"## Purchase\\n\\n\"\n\t\toutput += \"```bash\\n\"\n\t\toutput += \"gnokey maketx call \\\\\\n\"\n\t\toutput += \"  -pkgpath \\\"gno.land/r/pierre115/gnopendao\\\" \\\\\\n\"\n\t\toutput += \"  -func \\\"BuyNFT\\\" \\\\\\n\"\n\t\toutput += ufmt.Sprintf(\"  -args \\\"%d\\\" \\\\\\n\", listingId)\n\t\toutput += ufmt.Sprintf(\"  -send \\\"%dugnot\\\" \\\\\\n\", listing.Price)\n\t\toutput += \"  -broadcast yourkey\\n\"\n\t\toutput += \"```\\n\"\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao)\\n\"\n\n\treturn output\n}\n\nfunc renderSale(saleId int) string {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn \"# Sale not found\"\n\t}\n\n\tsale := value.(*Sale)\n\n\toutput := ufmt.Sprintf(\"# Sale #%d\\n\\n\", saleId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", sale.TokenId)\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(sale.Price))\n\toutput += ufmt.Sprintf(\"**Buyer:** `%s`\\n\\n\", sale.Buyer.String())\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", sale.Seller.String())\n\toutput += ufmt.Sprintf(\"**Block:** %d\\n\\n\", sale.SoldAt)\n\n\toutput += \"## Distribution\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Marketplace fee:** %s\\n\", formatPrice(sale.MarketplaceFee))\n\n\tif sale.RoyaltyFee \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- **Royalty:** %s ‚Üí `%s`\\n\",\n\t\t\tformatPrice(sale.RoyaltyFee), sale.RoyaltyReceiver.String())\n\t}\n\n\tsellerReceived := sale.Price - sale.MarketplaceFee - sale.RoyaltyFee\n\toutput += ufmt.Sprintf(\"- **Seller received:** %s\\n\", formatPrice(sellerReceived))\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"# Marketplace Statistics\\n\\n\"\n\n\ttotalVolume := GetTotalVolume()\n\ttotalSales := GetTotalSales()\n\ttotalRoyalties := GetTotalRoyaltiesPaid()\n\n\toutput += ufmt.Sprintf(\"**Total volume:** %s\\n\\n\", formatPrice(totalVolume))\n\toutput += ufmt.Sprintf(\"**Number of sales:** %d\\n\\n\", totalSales)\n\toutput += ufmt.Sprintf(\"**Royalties paid:** %s (%s of volume)\\n\\n\",\n\t\tformatPrice(totalRoyalties), formatPercentage(totalRoyalties, totalVolume))\n\n\tif totalSales \u003e 0 {\n\t\tavgPrice := totalVolume / int64(totalSales)\n\t\toutput += ufmt.Sprintf(\"**Average price:** %s\\n\\n\", formatPrice(avgPrice))\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao)\\n\"\n\n\treturn output\n}\n\n// ============= DAO RENDER FUNCTIONS =============\n\nfunc renderProposals() string {\n\toutput := \"# Active DAO Proposals\\n\\n\"\n\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"*No active proposals at the moment*\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Approve new NFT collections\\n\"\n\t\toutput += \"- Remove existing collections\\n\"\n\t\toutput += \"- Update marketplace fees\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting open**\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View \u0026 Vote](/r/pierre115/gnopendao:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to proposals](/r/pierre115/gnopendao:proposals) | [‚Üê Home](/r/pierre115/gnopendao)\\n\"\n\n\treturn output\n}\n\n// ============= ARCHIVE RENDER FUNCTIONS =============\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"*No finished proposals yet*\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif p.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Status:** %s\\n\\n\", statusEmoji, string(p.Status()))\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Final Status:** %s\\n\\n\", statusEmoji, string(proposal.Status()))\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to archive](/r/pierre115/gnopendao:archive) | [‚Üê Home](/r/pierre115/gnopendao)\\n\"\n\n\treturn output\n}\n"},{"name":"type.gno","body":"package gnopendao\n\nimport (\n\t\"gno.land/p/demo/tokens/grc721\"\n)\n\n// Listing structure\ntype Listing struct {\n\tListingId       int\n\tNFTGetter       grc721.NFTGetter\n\tTokenId         grc721.TokenID\n\tSeller          address\n\tPrice           int64\n\tActive          bool\n\tListedAt        int64\n\tNFTRealmAddress address\n}\n\n// Sale statistics\ntype Sale struct {\n\tListingId       int\n\tTokenId         string\n\tBuyer           address\n\tSeller          address\n\tPrice           int64\n\tMarketplaceFee  int64\n\tRoyaltyFee      int64\n\tRoyaltyReceiver address\n\tSoldAt          int64\n}\n"},{"name":"voting.gno","body":"package gnopendao\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeApproveCollection - Create a proposal to approve a new collection\nfunc ProposeApproveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_APPROVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeRemoveCollection - Create a proposal to remove a collection\nfunc ProposeRemoveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_REMOVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUpdateFees - Create a proposal to update marketplace fees\nfunc ProposeUpdateFees(_ realm, newFeeBasisPoints int64, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif newFeeBasisPoints \u003c 0 || newFeeBasisPoints \u003e 1000 {\n\t\tpanic(\"fees must be between 0 and 1000 basis points (0-10%)\")\n\t}\n\n\tpropDef := newFeesProposal(newFeeBasisPoints, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeWithdrawTreasury - Create a proposal to withdraw funds from treasury\nfunc ProposeWithdrawTreasury(_ realm, amount int64, recipient address, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif amount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\n\tif !recipient.IsValid() {\n\t\tpanic(\"invalid recipient address\")\n\t}\n\n\tcurrentBalance := GetBalance()\n\tif amount \u003e currentBalance {\n\t\tpanic(ufmt.Sprintf(\"insufficient treasury balance (available: %d ugnot)\", currentBalance))\n\t}\n\n\tpropDef := NewTreasuryProposal(amount, recipient, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeForceCancelListing - Create a proposal to force cancel a listing\nfunc ProposeForceCancelListing(_ realm, listingId int, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\t// Verify listing exists and is active\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"listing is already inactive\")\n\t}\n\n\tpropDef := NewForceCancelListingProposal(listingId, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// Vote - Vote on a proposal (yes or no)\nfunc Vote(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif choice != \"yes\" \u0026\u0026 choice != \"no\" {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - it handles all validations automatically\n\terr := marketplaceDAO.Vote(\n\t\tcaller,\n\t\tproposalID,\n\t\tcommondao.VoteChoice(choice),\n\t\t\"\", // reason (optional)\n\t)\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyProposal - Execute a proposal after voting period\nfunc TallyProposal(_ realm, proposalID uint64) string {\n\terr := marketplaceDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n\n// GetProposalInfo - Get information about a proposal\nfunc GetProposalInfo(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"Proposal not found\"\n\t}\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput := ufmt.Sprintf(`Proposal #%d\nTitle: %s\nBody: %s\nYes Votes: %d\nNo Votes: %d\nTotal Votes: %d\nVoting Ended: %t`,\n\t\tproposalID,\n\t\tproposal.Definition().Title(),\n\t\tproposal.Definition().Body(),\n\t\tyesVotes,\n\t\tnoVotes,\n\t\tyesVotes+noVotes,\n\t\tproposal.HasVotingDeadlinePassed(),\n\t)\n\n\treturn output\n}\n\n// GetAllActiveProposals - Get all active proposals\nfunc GetAllActiveProposals() string {\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\treturn \"No active proposals\"\n\t}\n\n\toutput := \"=== Active Proposals ===\\n\\n\"\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += ufmt.Sprintf(\"ID: %d | %s\\n\", p.ID(), p.Definition().Title())\n\t\treturn false\n\t})\n\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"400000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6q9AvbjfNfDcvt+aM7u5Avm8EqLlx81BpD3xIQIWfMfS7d8SoDf+vOQtNNylx/DfMIVt5Z6TKzNo149Rz649Cw=="}],"memo":""},"metadata":{"timestamp":"1765559508"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynft5","func":"SetApprovalForAll","args":["g1sedrj0kyvkxwhee3e5q7d8fskuu8ul8mnetj5v","true"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"xcOG1t0EWpH8aOMiSpBi3xa5Hq2SM7wIXomMrCnsQYiulwyqzcA6xhU3yJWLf2lZaQ+sF7oJOKm71QI9I2wvBg=="}],"memo":""},"metadata":{"timestamp":"1765559649"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao","func":"JoinDAO"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"FtOT0lkbYay7gg1YzJ/TdIvIzT19WScI7Av7WOYwNibfEoSGWJ4ivBJgpXGGHrnNL+sbdZLnMuCFIMlJl0QnAA=="}],"memo":""},"metadata":{"timestamp":"1765559684"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765559850"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao","func":"ProposeApproveCollection","args":["g1chp76pw0s3j6r92c38cltr8kkkgaejlvlexs8x","la collection de fou","parceque"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"i94y+ZYfeEhO5UMSB9XrBErIWC48NEuetFTuTl7USaszGTJi29dWYj13xJiSTol6mmCODhgG+raKyiLz34P8DQ=="}],"memo":""},"metadata":{"timestamp":"1765559880"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765560317"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"gnopendao2","path":"gno.land/r/pierre115/gnopendao2","files":[{"name":"README.md","body":"# GnopenSea - NFT Marketplace\n\nMarketplace NFT d√©centralis√© sur Gno.land avec gouvernance DAO.\n\n## üöÄ Comment lister votre NFT en 3 √©tapes\n\n### √âtape 1 : Enregistrer votre collection\n\n**Depuis votre package NFT**, appelez la fonction `Register()` :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"Register\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  votre-wallet\n```\n\nCela enregistre votre collection dans le **Registry DAO** (statut: non v√©rifi√©).\n\n### √âtape 2 : Approuver le marketplace\n\nDonnez la permission au marketplace de transf√©rer vos NFTs :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"SetApprovalForAll\" \\\n  -args \"g1[adresse-du-marketplace]\" \\\n  -args \"true\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### √âtape 3 : Cr√©er votre listing\n\nListez votre NFT √† vendre :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CreateListing\" \\\n  -args \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -args \"1\" \\\n  -args \"5000000\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n**Param√®tres :**\n- 1er arg : Adresse de votre package NFT\n- 2√®me arg : Token ID √† vendre\n- 3√®me arg : Prix en ugnot (5000000 = 5 GNOT)\n\n---\n\n## üõí Acheter un NFT\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"BuyNFT\" \\\n  -args \"1\" \\\n  -send \"5000000ugnot\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üìã G√©rer vos listings\n\n### Modifier le prix\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"UpdatePrice\" \\\n  -args \"1\" \\\n  -args \"10000000\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n### Annuler un listing\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CancelListing\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üé® Faire v√©rifier votre collection (badge v√©rifi√©)\n\n### 1. Cr√©er une proposal au Registry DAO\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"ProposeVerifyCollection\" \\\n  -args \"g1[adresse-de-votre-nft]\" \\\n  -args \"Nom de la collection\" \\\n  -args \"Raison de la v√©rification\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### 2. Les membres du DAO votent\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"VoteRegistry\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### 3. Ex√©cuter la proposal (apr√®s quorum)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"TallyRegistryProposal\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üí∞ Distribution des paiements\n\nExemple avec frais marketplace 2.5% et royalties 10% :\n\n```\nPrix de vente : 100 GNOT\n‚îú‚îÄ‚îÄ Frais marketplace (2.5%) : 2.5 GNOT\n‚îú‚îÄ‚îÄ Royalties cr√©ateur (10%) : 10 GNOT\n‚îî‚îÄ‚îÄ Vendeur re√ßoit : 87.5 GNOT\n```\n\n---\n\n## üèõÔ∏è Gouvernance DAO\n\nLe marketplace est gouvern√© par un DAO. Les membres peuvent cr√©er des proposals pour :\n\n- ‚úÖ Approuver/retirer des collections\n- ‚úÖ Modifier les frais du marketplace\n- ‚úÖ Retirer des fonds du tr√©sor\n- ‚úÖ Annuler un listing probl√©matique\n\n### Cr√©er une proposal (exemple: modifier les frais)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"ProposeUpdateFees\" \\\n  -args \"300\" \\\n  -args \"R√©duction des frais √† 3%\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### Voter sur une proposal\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n---\n\n## üîß Configuration NFT minimale\n\nVotre package NFT doit avoir une fonction `Register()` :\n\n```go\npackage mynft\n\nimport (\n    \"gno.land/p/demo/tokens/grc721\"\n    \"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n    nft         *grc721.basicNFT\n    myRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n    nft = grc721.NewBasicNFT(\"My Collection\", \"MC\")\n}\n\n// Register dans le registry\nfunc Register(_ realm) {\n    daoregistry4.RegisterCollection(\n        myRealmAddr,\n        \"My Collection\",\n        \"MC\",\n        \"art\",\n        \"Description de ma collection\",\n        \"https://mon-site.com\",\n        false,\n        nft.Getter(),\n    )\n}\n\n// Fonction obligatoire pour le marketplace\nfunc Getter() grc721.NFTGetter {\n    return nft.Getter()\n}\n```\n\n---\n\n## üìä Fonctions de lecture\n\n```bash\n# Voir tous les listings actifs\ncurl https://rpc.gno.land/r/pierre115/gnopendao:\n\n# Statistiques du marketplace\ncurl https://rpc.gno.land/r/pierre115/gnopendao:stats\n\n# D√©tails d'un listing\ncurl https://rpc.gno.land/r/pierre115/gnopendao:listing/1\n\n# Collections enregistr√©es\ncurl https://rpc.gno.land/r/pierre115/daoregistry4:\n```\n\n---\n\n## üîê S√©curit√©\n\n- ‚úÖ V√©rification de propri√©t√© avant listing\n- ‚úÖ V√©rification d'approbation avant vente\n- ‚úÖ Transferts atomiques\n- ‚úÖ Remboursement automatique des surplus\n- ‚úÖ Limites de frais (max 10%)\n- ‚úÖ Gouvernance d√©centralis√©e\n\n---\n\n## üÜò Probl√®mes courants\n\n**\"Collection not registered\"**\n‚Üí Vous devez d'abord appeler `Register()` sur votre NFT\n\n**\"Insufficient payment\"**\n‚Üí Le montant envoy√© doit correspondre au prix du listing\n\n**\"Not approved\"**\n‚Üí Appelez `SetApprovalForAll()` avant de cr√©er un listing\n\n**\"Not owner\"**\n‚Üí Seul le propri√©taire du NFT peut le lister\n"},{"name":"dao.gno","body":"package gnopendao2\n\nimport (\n\t//\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tmarketplaceDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 0 // 0 GNOT minimum to join DAO\n)\n\nfunc initDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tmarketplaceDAO = commondao.New(\n\t\tcommondao.WithID(1),\n\t\tcommondao.WithName(\"GnopenSea DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for GnopenSea marketplace\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinDAO - Join the marketplace DAO by staking GNOT\nfunc JoinDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\t//sent := banker.OriginSend()\n\n\t//amount := sent.AmountOf(\"ugnot\")\n\t//if amount \u003c MIN_STAKE_UGNOT {\n\t//\tpanic(\"minimum 1 GNOT required to join DAO\")\n\t//}\n\n\tif marketplaceDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tmarketplaceDAO.Members().Add(caller)\n\n\treturn \"Successfully joined GnopenSea DAO\"\n}\n\n// IsDAOMember - Check if an address is a DAO member\nfunc IsDAOMember(addr address) bool {\n\treturn marketplaceDAO.Members().Has(addr)\n}\n\n// GetTotalMembers - Returns total number of DAO members\nfunc GetTotalMembers() int {\n\treturn marketplaceDAO.Members().Size()\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/gnopendao2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"gnopensea.gno","body":"package gnopendao2\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n\tlistings      avl.Tree\n\tsales         avl.Tree\n\tnextListingId = 1\n\tnextSaleId    = 1\n\n\tmarketplaceFee      = int64(250) // 250 basis points = 2.5%\n\tmarketplaceAddr     = runtime.CurrentRealm().Address()\n\tapprovedCollections avl.Tree // Whitelist of approved collections\n)\n\nfunc init() {\n\tinitDAO()\n}\n\n// CreateListing - List an NFT for sale using the global NFT Registry\nfunc CreateListing(_ realm, nftRealmAddress address, tokenId grc721.TokenID, price int64) int {\n\tcaller := runtime.OriginCaller()\n\n\tif price \u003c= 0 || price \u003e 99999999999 {\n\t\tpanic(\"Price not valid\")\n\t}\n\n\t// Check if collection is registered in the GLOBAL NFT Registry (technical check)\n\tif !daoregistry4.IsRegistered(nftRealmAddress) {\n\t\tpanic(\"NFT collection not registered in the global NFT Registry. The collection must call nftregistry.RegisterCollection() first.\")\n\t}\n\t// Check if collection is approved by DAO (governance check)\n\tif !approvedCollections.Has(nftRealmAddress.String()) {\n\t\tpanic(\"Collection not approved by DAO. A DAO proposal must be created and passed first.\")\n\t}\n\n\t// Get NFT getter from the global registry\n\tgetter, exists := daoregistry4.GetNFTGetter(nftRealmAddress)\n\tif !exists {\n\t\tpanic(\"Failed to get NFT getter from registry\")\n\t}\n\n\tnftInstance := getter()\n\n\t// Verify caller is the owner\n\towner, err := nftInstance.OwnerOf(tokenId)\n\tif err != nil {\n\t\tpanic(\"Token not found: \" + err.Error())\n\t}\n\n\tif owner != caller {\n\t\tpanic(\"You are not the owner of this NFT\")\n\t}\n\n\t// Verify approvals\n\tmarketplaceAddr := runtime.CurrentRealm().Address()\n\tapprovedAddr, err := nftInstance.GetApproved(tokenId)\n\tisApprovedForToken := (err == nil \u0026\u0026 approvedAddr == marketplaceAddr)\n\tisApprovedForAll := nftInstance.IsApprovedForAll(owner, marketplaceAddr)\n\n\tif !isApprovedForToken \u0026\u0026 !isApprovedForAll {\n\t\tpanic(\"You must first approve the marketplace.\\nUse Approve() or SetApprovalForAll()\")\n\t}\n\n\t// Create listing\n\tlisting := \u0026Listing{\n\t\tListingId:       nextListingId,\n\t\tNFTGetter:       getter,\n\t\tTokenId:         tokenId,\n\t\tSeller:          caller,\n\t\tPrice:           price,\n\t\tActive:          true,\n\t\tListedAt:        runtime.ChainHeight(),\n\t\tNFTRealmAddress: nftRealmAddress,\n\t}\n\n\tlistings.Set(strconv.Itoa(nextListingId), listing)\n\tnextListingId++\n\n\treturn listing.ListingId\n}\n\n// BuyNFT - Purchase a listed NFT with automatic royalty calculation\nfunc BuyNFT(_ realm, listingId int) {\n\tcaller := runtime.OriginCaller()\n\tsent := banker.OriginSend()\n\n\t// Get listing\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\t// Verify payment\n\tamount := sent.AmountOf(\"ugnot\")\n\tif amount \u003c listing.Price {\n\t\tpanic(ufmt.Sprintf(\"Insufficient amount. Price: %d ugnot\", listing.Price))\n\t}\n\n\t// Get NFT instance\n\tnftInstance := listing.NFTGetter()\n\n\t// Verify seller still owns the NFT\n\tcurrentOwner, err := nftInstance.OwnerOf(listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"NFT not found: \" + err.Error())\n\t}\n\tif currentOwner != listing.Seller {\n\t\tpanic(\"Seller no longer owns this NFT\")\n\t}\n\n\t// Calculate royalties\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\t// Check if NFT supports royalties\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate what seller receives\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\tif sellerAmount \u003c 0 {\n\t\tpanic(\"Error: fees + royalties exceed sale price\")\n\t}\n\n\t// Distribute payments\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\t// 1. Pay seller\n\tif sellerAmount \u003e 0 {\n\t\tsellerCoins := chain.Coins{chain.Coin{\"ugnot\", sellerAmount}}\n\t\tbnkr.SendCoins(realmAddr, listing.Seller, sellerCoins)\n\t}\n\n\t// 2. Pay royalties to creator\n\tif royaltyAmount \u003e 0 \u0026\u0026 royaltyReceiver != \"\" {\n\t\troyaltyCoins := chain.Coins{chain.Coin{\"ugnot\", royaltyAmount}}\n\t\tbnkr.SendCoins(realmAddr, royaltyReceiver, royaltyCoins)\n\t}\n\n\t// 3. TODO : Marketplace fees remain in contract\n\n\t// 4. Refund excess\n\tif amount \u003e listing.Price {\n\t\texcess := amount - listing.Price\n\t\texcessCoins := chain.Coins{chain.Coin{\"ugnot\", excess}}\n\t\tbnkr.SendCoins(realmAddr, caller, excessCoins)\n\t}\n\n\t// Transfer NFT\n\terr = nftInstance.TransferFrom(listing.Seller, caller, listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"Transfer error: \" + err.Error())\n\t}\n\n\t// Record sale\n\tsale := \u0026Sale{\n\t\tListingId:       listingId,\n\t\tTokenId:         listing.TokenId.String(),\n\t\tBuyer:           caller,\n\t\tSeller:          listing.Seller,\n\t\tPrice:           listing.Price,\n\t\tMarketplaceFee:  marketplaceFeeAmount,\n\t\tRoyaltyFee:      royaltyAmount,\n\t\tRoyaltyReceiver: royaltyReceiver,\n\t\tSoldAt:          runtime.ChainHeight(),\n\t}\n\n\tsales.Set(strconv.Itoa(nextSaleId), sale)\n\tnextSaleId++\n\n\t// Deactivate listing\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// CancelListing - Cancel own listing (seller only)\nfunc CancelListing(_realm, listingId int) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\t// Only seller can cancel their own listing\n\t// DAO use ProposeForceCancelListing instead\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can cancel this listing. DAO members can create a ProposeForceCancelListing proposal.\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// UpdatePrice - Update listing price\nfunc UpdatePrice(_ realm, listingId int, newPrice int64) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif newPrice \u003c= 0 {\n\t\tpanic(\"Price must be positive\")\n\t}\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can modify this listing\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\tlisting.Price = newPrice\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// ============= READ FUNCTIONS =============\n\nfunc GetListing(listingId int) (int, string, int64, string, bool, int64) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, \"\", 0, \"\", false, 0\n\t}\n\n\treturn listing.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tlisting.ListedAt\n}\n\nfunc GetSale(saleId int) (int, string, string, string, int64, int64, int64, string, int64) {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn 0, \"\", \"\", \"\", 0, 0, 0, \"\", 0\n\t}\n\n\tsale := value.(*Sale)\n\treturn sale.ListingId,\n\t\tsale.TokenId,\n\t\tsale.Buyer.String(),\n\t\tsale.Seller.String(),\n\t\tsale.Price,\n\t\tsale.MarketplaceFee,\n\t\tsale.RoyaltyFee,\n\t\tsale.RoyaltyReceiver.String(),\n\t\tsale.SoldAt\n}\n\nfunc GetActiveListingsCount() int {\n\tcount := 0\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\nfunc GetTotalSales() int {\n\treturn sales.Size()\n}\n\nfunc GetTotalVolume() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.Price\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetTotalRoyaltiesPaid() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.RoyaltyFee\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetMarketplaceFee() int64 {\n\treturn marketplaceFee\n}\n\nfunc GetMarketplaceAddress() address {\n\treturn runtime.CurrentRealm().Address()\n}\n\n// GetRoyaltyBreakdown - Calculate distribution for a listing\nfunc GetRoyaltyBreakdown(listingId int) (int64, int64, int64, address) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, 0, 0, \"\"\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate royalties if supported\n\tnftInstance := listing.NFTGetter()\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\treturn sellerAmount, marketplaceFeeAmount, royaltyAmount, royaltyReceiver\n}\n\nfunc GetBalance() int64 {\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\tbalance := bnkr.GetCoins(realmAddr)\n\treturn balance.AmountOf(\"ugnot\")\n}\n\n// ============= READ FUNCTIONS FOR FRONTEND =============\n\n// GetAllListings - Return all active listings\nfunc GetAllListings() string {\n\tvar listingsData []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\t// Format: listingId|nftAddress|tokenId|price|seller\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%s|%d|%s\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.NFTRealmAddress.String(),\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t\tlisting.Seller.String(),\n\t\t\t)\n\t\t\tlistingsData = append(listingsData, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(listingsData) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(listingsData, \"\\n\")\n}\n\n// GetListingDetails - Get detailed info about a listing\nfunc GetListingDetails(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"Listing not found\"\n\t}\n\n\tnftInstance := listing.NFTGetter()\n\n\t// Get NFT metadata if available\n\tvar name, uri string\n\tif metaNFT, ok := nftInstance.(grc721.IGRC721Metadata); ok {\n\t\tname = metaNFT.Name()\n\t\tif tokenURI, err := metaNFT.TokenURI(listing.TokenId); err == nil {\n\t\t\turi = tokenURI\n\t\t}\n\t}\n\n\t// Format JSON-like response\n\toutput := ufmt.Sprintf(`{\n  \"listingId\": %d,\n  \"tokenId\": \"%s\",\n  \"price\": %d,\n  \"seller\": \"%s\",\n  \"active\": %t,\n  \"name\": \"%s\",\n  \"uri\": \"%s\",\n  \"listedAt\": %d\n}`,\n\t\tlisting.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tname,\n\t\turi,\n\t\tlisting.ListedAt,\n\t)\n\n\treturn output\n}\n\n// GetUserListings - Get all listings by a specific seller\nfunc GetUserListings(sellerAddr address) string {\n\tvar userListings []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Seller == sellerAddr \u0026\u0026 listing.Active {\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%d\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t)\n\t\t\tuserListings = append(userListings, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(userListings) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(userListings, \"\\n\")\n}\n\n// GetMarketplaceStats - Get overall marketplace statistics\nfunc GetMarketplaceStats() string {\n\tactiveCount := GetActiveListingsCount()\n\ttotalSales := GetTotalSales()\n\ttotalVolume := GetTotalVolume()\n\n\toutput := ufmt.Sprintf(`{\n  \"activeListings\": %d,\n  \"totalSales\": %d,\n  \"totalVolume\": %d,\n  \"marketplaceFee\": %d\n}`,\n\t\tactiveCount,\n\t\ttotalSales,\n\t\ttotalVolume,\n\t\tmarketplaceFee,\n\t)\n\n\treturn output\n}\n\n// ============= HELPERS =============\n\nfunc getListing(listingId int) *Listing {\n\tvalue, exists := listings.Get(strconv.Itoa(listingId))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn value.(*Listing)\n}\n\nfunc formatPrice(ugnot int64) string {\n\tgnot := float64(ugnot) / 1000000.0\n\treturn ufmt.Sprintf(\"%.2f GNOT\", gnot)\n}\n\nfunc formatFee(basisPoints int64) string {\n\tpercent := float64(basisPoints) / 100.0\n\treturn ufmt.Sprintf(\"%.2f%%\", percent)\n}\n\nfunc formatPercentage(value, total int64) string {\n\tif total == 0 {\n\t\treturn \"0%\"\n\t}\n\tpercent := (float64(value) / float64(total)) * 100.0\n\treturn ufmt.Sprintf(\"%.1f%%\", percent)\n}\n"},{"name":"gnopensea_test.gno","body":"package gnopendao2\n\nimport (\n\t\"testing\"\n)\n\n// Test marketplace initialization values\nfunc TestMarketplaceInit(t *testing.T) {\n\t// Check marketplace fee is set to default (2.5%)\n\tfee := GetMarketplaceFee()\n\tif fee != 250 {\n\t\tt.Errorf(\"Expected marketplace fee to be 250, got %d\", fee)\n\t}\n}\n\n// Test marketplace fee getter\nfunc TestGetMarketplaceFee(t *testing.T) {\n\tfee := GetMarketplaceFee()\n\tif fee \u003c 0 || fee \u003e 1000 {\n\t\tt.Errorf(\"Marketplace fee out of valid range (0-1000): %d\", fee)\n\t}\n}\n\n// Test active listings count (should not panic)\nfunc TestGetActiveListingsCount(t *testing.T) {\n\tcount := GetActiveListingsCount()\n\tif count \u003c 0 {\n\t\tt.Errorf(\"Active listings count should not be negative: %d\", count)\n\t}\n}\n\n// Test total sales (should not panic)\nfunc TestGetTotalSales(t *testing.T) {\n\tsales := GetTotalSales()\n\tif sales \u003c 0 {\n\t\tt.Errorf(\"Total sales should not be negative: %d\", sales)\n\t}\n}\n\n// Test total volume (should not panic)\nfunc TestGetTotalVolume(t *testing.T) {\n\tvolume := GetTotalVolume()\n\tif volume \u003c 0 {\n\t\tt.Errorf(\"Total volume should not be negative: %d\", volume)\n\t}\n}\n\n// Test total royalties paid (should not panic)\nfunc TestGetTotalRoyaltiesPaid(t *testing.T) {\n\troyalties := GetTotalRoyaltiesPaid()\n\tif royalties \u003c 0 {\n\t\tt.Errorf(\"Total royalties should not be negative: %d\", royalties)\n\t}\n}\n\n// Test marketplace address getter (should not panic)\nfunc TestGetMarketplaceAddress(t *testing.T) {\n\taddr := GetMarketplaceAddress()\n\tif addr == \"\" {\n\t\tt.Error(\"Marketplace address should not be empty\")\n\t}\n}\n\n// Test balance getter (should not panic)\nfunc TestGetBalance(t *testing.T) {\n\tbalance := GetBalance()\n\tif balance \u003c 0 {\n\t\tt.Errorf(\"Balance should not be negative: %d\", balance)\n\t}\n}\n\n// Test render home page (should not panic)\nfunc TestRenderHome(t *testing.T) {\n\toutput := Render(\"\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Home render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Marketplace\") {\n\t\tt.Error(\"Home render should contain 'Marketplace'\")\n\t}\n}\n\n// Test render stats page (should not panic)\nfunc TestRenderStats(t *testing.T) {\n\toutput := Render(\"stats\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Stats render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Statistics\") {\n\t\tt.Error(\"Stats render should contain 'Statistics'\")\n\t}\n}\n\n// Test render invalid path\nfunc TestRenderInvalidPath(t *testing.T) {\n\toutput := Render(\"invalid/path/test\")\n\tif output != \"Page not found\" {\n\t\tt.Errorf(\"Expected 'Page not found', got '%s'\", output)\n\t}\n}\n\n// Test format price function\nfunc TestFormatPrice(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{1000000, \"1.00 GNOT\"},\n\t\t{5000000, \"5.00 GNOT\"},\n\t\t{100, \"0.00 GNOT\"},\n\t\t{0, \"0.00 GNOT\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPrice(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPrice(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format fee function\nfunc TestFormatFee(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{250, \"2.50%\"},\n\t\t{500, \"5.00%\"},\n\t\t{1000, \"10.00%\"},\n\t\t{0, \"0.00%\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatFee(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatFee(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format percentage function\nfunc TestFormatPercentage(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    int64\n\t\ttotal    int64\n\t\texpected string\n\t}{\n\t\t{25, 100, \"25.0%\"},\n\t\t{50, 100, \"50.0%\"},\n\t\t{0, 100, \"0.0%\"},\n\t\t{100, 100, \"100.0%\"},\n\t\t{0, 0, \"0%\"}, // Division by zero case\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPercentage(tt.value, tt.total)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPercentage(%d, %d) = %s, expected %s\",\n\t\t\t\ttt.value, tt.total, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test GetListing with invalid ID (should return zeros)\nfunc TestGetListingInvalid(t *testing.T) {\n\tid, tokenId, price, seller, active, listedAt := GetListing(999999)\n\n\tif id != 0 || tokenId != \"\" || price != 0 || seller != \"\" || active != false || listedAt != 0 {\n\t\tt.Error(\"GetListing with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetSale with invalid ID (should return zeros)\nfunc TestGetSaleInvalid(t *testing.T) {\n\tlistingId, tokenId, buyer, seller, price, marketFee, royaltyFee, royaltyReceiver, soldAt := GetSale(999999)\n\n\tif listingId != 0 || tokenId != \"\" || buyer != \"\" || seller != \"\" ||\n\t\tprice != 0 || marketFee != 0 || royaltyFee != 0 || royaltyReceiver != \"\" || soldAt != 0 {\n\t\tt.Error(\"GetSale with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetRoyaltyBreakdown with invalid ID (should return zeros)\nfunc TestGetRoyaltyBreakdownInvalid(t *testing.T) {\n\tsellerAmount, marketFee, royalty, royaltyReceiver := GetRoyaltyBreakdown(999999)\n\n\tif sellerAmount != 0 || marketFee != 0 || royalty != 0 || royaltyReceiver != \"\" {\n\t\tt.Error(\"GetRoyaltyBreakdown with invalid ID should return zero values\")\n\t}\n}\n\n// Helper function to check if string contains substring\nfunc contains(s, substr string) bool {\n\treturn len(s) \u003e= len(substr) \u0026\u0026 (s == substr ||\n\t\tlen(s) \u003e len(substr) \u0026\u0026 indexOf(s, substr) \u003e= 0)\n}\n\n// Helper function to find substring index\nfunc indexOf(s, substr string) int {\n\tfor i := 0; i \u003c= len(s)-len(substr); i++ {\n\t\tif s[i:i+len(substr)] == substr {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"},{"name":"proposal.gno","body":"package gnopendao2\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"errors\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_APPROVE_COLLECTION   = \"approve_collection\"\n\tPROPOSAL_TYPE_REMOVE_COLLECTION    = \"remove_collection\"\n\tPROPOSAL_TYPE_UPDATE_FEES          = \"update_fees\"\n\tPROPOSAL_TYPE_WITHDRAW_TREASURY    = \"withdraw_treasury\"\n\tPROPOSAL_TYPE_FORCE_CANCEL_LISTING = \"force_cancel_listing\"\n\n\tVOTING_PERIOD = 10 * time.Minute\n\tQUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// CollectionProposal - Proposal to approve or remove a collection\ntype CollectionProposal struct {\n\tproposalType   string\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc newCollectionProposal(propType string, addr address, name string, reason string) *CollectionProposal {\n\treturn \u0026CollectionProposal{\n\t\tproposalType:   propType,\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *CollectionProposal) Title() string {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\treturn \"Approve Collection: \" + p.collectionName\n\t}\n\treturn \"Remove Collection: \" + p.collectionName\n}\n\nfunc (p *CollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Type: %s\\nCollection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tp.proposalType,\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *CollectionProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *CollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *CollectionProposal) Execute(realm) error {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\tapprovedCollections.Set(p.collectionAddr.String(), true)\n\t} else if p.proposalType == PROPOSAL_TYPE_REMOVE_COLLECTION {\n\t\tapprovedCollections.Remove(p.collectionAddr.String())\n\t}\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *CollectionProposal) GetCollectionAddr() address {\n\treturn p.collectionAddr\n}\n\n// FeesProposal - Proposal to update marketplace fees\ntype FeesProposal struct {\n\tnewFee   int64\n\treason   string\n\tapproved bool\n\texecuted bool\n}\n\nfunc newFeesProposal(newFee int64, reason string) *FeesProposal {\n\treturn \u0026FeesProposal{\n\t\tnewFee:   newFee,\n\t\treason:   reason,\n\t\tapproved: false,\n\t\texecuted: false,\n\t}\n}\n\nfunc (p *FeesProposal) Title() string {\n\treturn ufmt.Sprintf(\"Update Marketplace Fee to %d basis points\", p.newFee)\n}\n\nfunc (p *FeesProposal) Body() string {\n\tcurrentFeePercent := float64(marketplaceFee) / 100.0\n\tnewFeePercent := float64(p.newFee) / 100.0\n\n\treturn ufmt.Sprintf(\n\t\t\"Current Fee: %.2f%%\\nProposed Fee: %.2f%%\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tcurrentFeePercent,\n\t\tnewFeePercent,\n\t\tp.reason,\n\t)\n}\n\nfunc (p *FeesProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *FeesProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *FeesProposal) Execute(realm) error {\n\tmarketplaceFee = p.newFee\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *FeesProposal) GetNewFee() int64 {\n\treturn p.newFee\n}\n\n// TreasuryProposal - Proposal to withdraw funds from treasury\ntype TreasuryProposal struct {\n\tamount    int64\n\trecipient address\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewTreasuryProposal(amount int64, recipient address, reason string) *TreasuryProposal {\n\treturn \u0026TreasuryProposal{\n\t\tamount:    amount,\n\t\trecipient: recipient,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *TreasuryProposal) Title() string {\n\treturn ufmt.Sprintf(\"Withdraw %d ugnot from Treasury\", p.amount)\n}\n\nfunc (p *TreasuryProposal) Body() string {\n\tcurrentBalance := GetBalance()\n\n\treturn ufmt.Sprintf(\n\t\t\"Withdraw: %s\\nRecipient: %s\\nCurrent Treasury: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tformatPrice(p.amount),\n\t\tp.recipient.String(),\n\t\tformatPrice(currentBalance),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *TreasuryProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *TreasuryProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *TreasuryProposal) Execute(realm) error {\n\tcurrentBalance := GetBalance()\n\tif currentBalance \u003c p.amount {\n\t\treturn errors.New(\"insufficient treasury balance\")\n\t}\n\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tcoins := chain.Coins{chain.Coin{\"ugnot\", p.amount}}\n\tbnkr.SendCoins(realmAddr, p.recipient, coins)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *TreasuryProposal) GetAmount() int64 {\n\treturn p.amount\n}\n\nfunc (p *TreasuryProposal) GetRecipient() address {\n\treturn p.recipient\n}\n\n// ForceCancelListingProposal - Proposal to force cancel a problematic listing\ntype ForceCancelListingProposal struct {\n\tlistingId int\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewForceCancelListingProposal(listingId int, reason string) *ForceCancelListingProposal {\n\treturn \u0026ForceCancelListingProposal{\n\t\tlistingId: listingId,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *ForceCancelListingProposal) Title() string {\n\treturn ufmt.Sprintf(\"Force Cancel Listing #%d\", p.listingId)\n}\n\nfunc (p *ForceCancelListingProposal) Body() string {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn ufmt.Sprintf(\"Listing #%d\\nStatus: NOT FOUND\\nReason: %s\\n\\nVote YES to approve, NO to reject\", p.listingId, p.reason)\n\t}\n\n\treturn ufmt.Sprintf(\n\t\t\"Listing ID: %d\\nToken ID: %s\\nSeller: %s\\nPrice: %s\\nReason for cancellation: %s\\n\\nVote YES to force cancel, NO to reject\",\n\t\tp.listingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Seller.String(),\n\t\tformatPrice(listing.Price),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *ForceCancelListingProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *ForceCancelListingProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *ForceCancelListingProposal) Execute(realm) error {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn errors.New(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\treturn errors.New(\"listing already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(p.listingId), listing)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *ForceCancelListingProposal) GetListingId() int {\n\treturn p.listingId\n}\n"},{"name":"render.gno","body":"package gnopendao2\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ============= RENDER =============\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif strings.HasPrefix(path, \"listing/\") {\n\t\tidStr := strings.TrimPrefix(path, \"listing/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderListing(id)\n\t}\n\n\tif strings.HasPrefix(path, \"sale/\") {\n\t\tidStr := strings.TrimPrefix(path, \"sale/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderSale(id)\n\t}\n\n\tif path == \"stats\" {\n\t\treturn renderStats()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# GNOPENSEA DAO 10\\n\\n\"\n\toutput += \"Decentralized NFT Marketplace with DAO Governance\\n\\n\"\n\toutput += \"Compatible **GRC-721** + **GRC-2981** (Automatic Royalties)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += \"[View detailed statistics](/r/pierre115/gnopendao2:stats)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalMembers())\n\n\tactiveProposals := marketplaceDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/gnopendao2:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"*No active proposals*\\n\\n\"\n\t}\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/gnopendao2:archive)\\n\\n\", finishedProposals.Size())\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join !\", linkjoin) + \"\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\t// Active listings\n\tif GetActiveListingsCount() \u003e 0 {\n\t\toutput += \"## NFTs for sale\\n\\n\"\n\n\t\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tlisting := value.(*Listing)\n\t\t\tif listing.Active {\n\t\t\t\toutput += renderListingPreview(listing)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t} else {\n\t\toutput += \"## No NFTs for sale\\n\\n\"\n\t\toutput += \"*Be the first to list an NFT!*\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderListingPreview(listing *Listing) string {\n\t// Calculate breakdown\n\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listing.ListingId)\n\n\toutput := ufmt.Sprintf(\"### Listing #%d\\n\\n\", listing.ListingId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\n\tif royalty \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"Royalty: %s (%s)\\n\\n\",\n\t\t\tformatPrice(royalty),\n\t\t\tformatPercentage(royalty, listing.Price))\n\t}\n\n\toutput += ufmt.Sprintf(\"**Seller receives:** %s\\n\\n\", formatPrice(sellerGets))\n\toutput += ufmt.Sprintf(\"**Market Fees:** %s\\n\\n\", formatPrice(marketFee))\n\toutput += ufmt.Sprintf(\"**Royalty Address:** %s\\n\\n\", royaltyAddr.String())\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao2:listing/%d)\\n\\n\", listing.ListingId)\n\toutput += \"---\\n\\n\"\n\treturn output\n}\n\nfunc renderListing(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"# Listing not found\"\n\t}\n\n\tstatus := \"Active\"\n\tif !listing.Active {\n\t\tstatus = \"Sold/Cancelled\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Listing #%d - %s\\n\\n\", listingId, status)\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", listing.Seller.String())\n\toutput += ufmt.Sprintf(\"**Listed at block:** %d\\n\\n\", listing.ListedAt)\n\n\tif listing.Active {\n\t\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listingId)\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Price breakdown\\n\\n\"\n\t\toutput += ufmt.Sprintf(\"- **Total price:** %s (100%%)\\n\", formatPrice(listing.Price))\n\t\toutput += ufmt.Sprintf(\"- **Marketplace fee (%s):** %s\\n\",\n\t\t\tformatFee(marketplaceFee), formatPrice(marketFee))\n\n\t\tif royalty \u003e 0 {\n\t\t\toutput += ufmt.Sprintf(\"- **Creator royalty (%s):** %s\\n\",\n\t\t\t\tformatPercentage(royalty, listing.Price), formatPrice(royalty))\n\t\t\toutput += ufmt.Sprintf(\"  - Beneficiary: `%s`\\n\", royaltyAddr.String())\n\t\t} else {\n\t\t\toutput += \"- **Royalty:** None\\n\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"- **Seller receives:** %s (%s)\\n\\n\",\n\t\t\tformatPrice(sellerGets), formatPercentage(sellerGets, listing.Price))\n\n\t\toutput += \"## Purchase\\n\\n\"\n\t\toutput += \"```bash\\n\"\n\t\toutput += \"gnokey maketx call \\\\\\n\"\n\t\toutput += \"  -pkgpath \\\"gno.land/r/pierre115/gnopendao2\\\" \\\\\\n\"\n\t\toutput += \"  -func \\\"BuyNFT\\\" \\\\\\n\"\n\t\toutput += ufmt.Sprintf(\"  -args \\\"%d\\\" \\\\\\n\", listingId)\n\t\toutput += ufmt.Sprintf(\"  -send \\\"%dugnot\\\" \\\\\\n\", listing.Price)\n\t\toutput += \"  -broadcast yourkey\\n\"\n\t\toutput += \"```\\n\"\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao2)\\n\"\n\n\treturn output\n}\n\nfunc renderSale(saleId int) string {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn \"# Sale not found\"\n\t}\n\n\tsale := value.(*Sale)\n\n\toutput := ufmt.Sprintf(\"# Sale #%d\\n\\n\", saleId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", sale.TokenId)\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(sale.Price))\n\toutput += ufmt.Sprintf(\"**Buyer:** `%s`\\n\\n\", sale.Buyer.String())\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", sale.Seller.String())\n\toutput += ufmt.Sprintf(\"**Block:** %d\\n\\n\", sale.SoldAt)\n\n\toutput += \"## Distribution\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Marketplace fee:** %s\\n\", formatPrice(sale.MarketplaceFee))\n\n\tif sale.RoyaltyFee \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- **Royalty:** %s ‚Üí `%s`\\n\",\n\t\t\tformatPrice(sale.RoyaltyFee), sale.RoyaltyReceiver.String())\n\t}\n\n\tsellerReceived := sale.Price - sale.MarketplaceFee - sale.RoyaltyFee\n\toutput += ufmt.Sprintf(\"- **Seller received:** %s\\n\", formatPrice(sellerReceived))\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"# Marketplace Statistics\\n\\n\"\n\n\ttotalVolume := GetTotalVolume()\n\ttotalSales := GetTotalSales()\n\ttotalRoyalties := GetTotalRoyaltiesPaid()\n\n\toutput += ufmt.Sprintf(\"**Total volume:** %s\\n\\n\", formatPrice(totalVolume))\n\toutput += ufmt.Sprintf(\"**Number of sales:** %d\\n\\n\", totalSales)\n\toutput += ufmt.Sprintf(\"**Royalties paid:** %s (%s of volume)\\n\\n\",\n\t\tformatPrice(totalRoyalties), formatPercentage(totalRoyalties, totalVolume))\n\n\tif totalSales \u003e 0 {\n\t\tavgPrice := totalVolume / int64(totalSales)\n\t\toutput += ufmt.Sprintf(\"**Average price:** %s\\n\\n\", formatPrice(avgPrice))\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao2)\\n\"\n\n\treturn output\n}\n\n// ============= DAO RENDER FUNCTIONS =============\n\nfunc renderProposals() string {\n\toutput := \"# Active DAO Proposals\\n\\n\"\n\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"*No active proposals at the moment*\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Approve new NFT collections\\n\"\n\t\toutput += \"- Remove existing collections\\n\"\n\t\toutput += \"- Update marketplace fees\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao2)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao2)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting open**\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View \u0026 Vote](/r/pierre115/gnopendao2:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to proposals](/r/pierre115/gnopendao2:proposals) | [‚Üê Home](/r/pierre115/gnopendao2)\\n\"\n\n\treturn output\n}\n\n// ============= ARCHIVE RENDER FUNCTIONS =============\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"*No finished proposals yet*\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao2)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao2)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif p.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Status:** %s\\n\\n\", statusEmoji, string(p.Status()))\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao2:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Final Status:** %s\\n\\n\", statusEmoji, string(proposal.Status()))\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to archive](/r/pierre115/gnopendao2:archive) | [‚Üê Home](/r/pierre115/gnopendao2)\\n\"\n\n\treturn output\n}\n"},{"name":"type.gno","body":"package gnopendao2\n\nimport (\n\t\"gno.land/p/demo/tokens/grc721\"\n)\n\n// Listing structure\ntype Listing struct {\n\tListingId       int\n\tNFTGetter       grc721.NFTGetter\n\tTokenId         grc721.TokenID\n\tSeller          address\n\tPrice           int64\n\tActive          bool\n\tListedAt        int64\n\tNFTRealmAddress address\n}\n\n// Sale statistics\ntype Sale struct {\n\tListingId       int\n\tTokenId         string\n\tBuyer           address\n\tSeller          address\n\tPrice           int64\n\tMarketplaceFee  int64\n\tRoyaltyFee      int64\n\tRoyaltyReceiver address\n\tSoldAt          int64\n}\n"},{"name":"voting.gno","body":"package gnopendao2\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeApproveCollection - Create a proposal to approve a new collection\nfunc ProposeApproveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_APPROVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeRemoveCollection - Create a proposal to remove a collection\nfunc ProposeRemoveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_REMOVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUpdateFees - Create a proposal to update marketplace fees\nfunc ProposeUpdateFees(_ realm, newFeeBasisPoints int64, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif newFeeBasisPoints \u003c 0 || newFeeBasisPoints \u003e 1000 {\n\t\tpanic(\"fees must be between 0 and 1000 basis points (0-10%)\")\n\t}\n\n\tpropDef := newFeesProposal(newFeeBasisPoints, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeWithdrawTreasury - Create a proposal to withdraw funds from treasury\nfunc ProposeWithdrawTreasury(_ realm, amount int64, recipient address, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif amount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\n\tif !recipient.IsValid() {\n\t\tpanic(\"invalid recipient address\")\n\t}\n\n\tcurrentBalance := GetBalance()\n\tif amount \u003e currentBalance {\n\t\tpanic(ufmt.Sprintf(\"insufficient treasury balance (available: %d ugnot)\", currentBalance))\n\t}\n\n\tpropDef := NewTreasuryProposal(amount, recipient, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeForceCancelListing - Create a proposal to force cancel a listing\nfunc ProposeForceCancelListing(_ realm, listingId int, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\t// Verify listing exists and is active\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"listing is already inactive\")\n\t}\n\n\tpropDef := NewForceCancelListingProposal(listingId, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// Vote - Vote on a proposal (yes or no)\nfunc Vote(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tvar voteChoice commondao.VoteChoice\n\tif choice == \"yes\" {\n\t\tvoteChoice = commondao.ChoiceYes\n\t} else if choice == \"no\" {\n\t\tvoteChoice = commondao.ChoiceNo\n\t} else {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - it handles all validations automatically\n\terr := marketplaceDAO.Vote(\n\t\tcaller,\n\t\tproposalID,\n\t\tvoteChoice,\n\t\t\"\", // reason (optional)\n\t)\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyProposal - Execute a proposal after voting period\nfunc TallyProposal(_ realm, proposalID uint64) string {\n\terr := marketplaceDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n\n// GetProposalInfo - Get information about a proposal\nfunc GetProposalInfo(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"Proposal not found\"\n\t}\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput := ufmt.Sprintf(`Proposal #%d\nTitle: %s\nBody: %s\nYes Votes: %d\nNo Votes: %d\nTotal Votes: %d\nVoting Ended: %t`,\n\t\tproposalID,\n\t\tproposal.Definition().Title(),\n\t\tproposal.Definition().Body(),\n\t\tyesVotes,\n\t\tnoVotes,\n\t\tyesVotes+noVotes,\n\t\tproposal.HasVotingDeadlinePassed(),\n\t)\n\n\treturn output\n}\n\n// GetAllActiveProposals - Get all active proposals\nfunc GetAllActiveProposals() string {\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\treturn \"No active proposals\"\n\t}\n\n\toutput := \"=== Active Proposals ===\\n\\n\"\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += ufmt.Sprintf(\"ID: %d | %s\\n\", p.ID(), p.Definition().Title())\n\t\treturn false\n\t})\n\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"400000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gSkrHu5WZ6DYb+llS7l8nAsetg5EYFzVJ6nTNYx+lQvaShU0XF/soZV68W0uCxUeYHAtmjWICAWT0sIMxUhvAQ=="}],"memo":""},"metadata":{"timestamp":"1765560327"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynft5","func":"SetApprovalForAll","args":["g1086cd0fm7lepuqdv2u8kfnzemfj6n3x9ggr3kk","true"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Rke7HQA5/4P5W6aolqu8//IV4qMbfAyj/MlcpBY5emu1LRpiAgpd8/5bePRhDqRaaMH4A9wFMw8iFiyo+0TcCA=="}],"memo":""},"metadata":{"timestamp":"1765560362"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao2","func":"JoinDAO"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"0ZsLfH1TgKlReGPphNRfAeq1CUX8KHO7pZI2dGc4KVs36ZIIKPbiSTWJkw3P4753xWEMjlOzF4Y/YzV2yh3YAg=="}],"memo":""},"metadata":{"timestamp":"1765560408"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao2","func":"ProposeApproveCollection","args":["g1chp76pw0s3j6r92c38cltr8kkkgaejlvlexs8x","tktt","tkt"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"/RpQjWMlsb+Gcj0vrX+R/lCo0YHXpleqQhrrkN3scftIrrS7WXVSuJP6umNMQ+SFnYT50FTCICyP7NWt/tSRBA=="}],"memo":""},"metadata":{"timestamp":"1765560438"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao2","func":"Vote","args":["1","yes"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Qo19YTtPRIcQmF2TGdJQd+K83Idh0o8wPZ5+O90U0AOjpF335WtItxCoLDePT4BDc8tcocV6hYy9Jl8lDvAnCQ=="}],"memo":""},"metadata":{"timestamp":"1765560473"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao2","func":"TallyProposal","args":["1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PZ4ueB2uqtr9DA4xWy0rDtqeAgGAy6D+UsaaDZwIRPAtDYreTuC1r+BlMQUtKeFefpkx0MXGdB4AhJ1yaNEoCg=="}],"memo":""},"metadata":{"timestamp":"1765561237"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynft5","func":"MintNFT"}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1+MKjP7wEzedeUcJqd9iosxo89q4Lc2L4Sk5cpHeW+kosfK4lApXxpuA44BHB3UQE40ebPCs316H1+YsWFgtCg=="}],"memo":""},"metadata":{"timestamp":"1765561322"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765561413"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao2","func":"CreateListing","args":["g1chp76pw0s3j6r92c38cltr8kkkgaejlvlexs8x","1","1000000"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"si9zPHYoGAxTkVb2/XGpf+deN5kpTi5SMDG9XQnMCJdlMsrk6NYNREBbLu7E7tqIHMjthZqbhvHk4I7L1aYgCw=="}],"memo":""},"metadata":{"timestamp":"1765561478"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765564966"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"gnopendao3","path":"gno.land/r/pierre115/gnopendao3","files":[{"name":"README.md","body":"# GnopenSea - NFT Marketplace\n\nMarketplace NFT d√©centralis√© sur Gno.land avec gouvernance DAO.\n\n## üöÄ Comment lister votre NFT en 3 √©tapes\n\n### √âtape 1 : Enregistrer votre collection\n\n**Depuis votre package NFT**, appelez la fonction `Register()` :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"Register\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  votre-wallet\n```\n\nCela enregistre votre collection dans le **Registry DAO** (statut: non v√©rifi√©).\n\n### √âtape 2 : Approuver le marketplace\n\nDonnez la permission au marketplace de transf√©rer vos NFTs :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"SetApprovalForAll\" \\\n  -args \"g1[adresse-du-marketplace]\" \\\n  -args \"true\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### √âtape 3 : Cr√©er votre listing\n\nListez votre NFT √† vendre :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CreateListing\" \\\n  -args \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -args \"1\" \\\n  -args \"5000000\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n**Param√®tres :**\n- 1er arg : Adresse de votre package NFT\n- 2√®me arg : Token ID √† vendre\n- 3√®me arg : Prix en ugnot (5000000 = 5 GNOT)\n\n---\n\n## üõí Acheter un NFT\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"BuyNFT\" \\\n  -args \"1\" \\\n  -send \"5000000ugnot\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üìã G√©rer vos listings\n\n### Modifier le prix\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"UpdatePrice\" \\\n  -args \"1\" \\\n  -args \"10000000\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n### Annuler un listing\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CancelListing\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üé® Faire v√©rifier votre collection (badge v√©rifi√©)\n\n### 1. Cr√©er une proposal au Registry DAO\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"ProposeVerifyCollection\" \\\n  -args \"g1[adresse-de-votre-nft]\" \\\n  -args \"Nom de la collection\" \\\n  -args \"Raison de la v√©rification\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### 2. Les membres du DAO votent\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"VoteRegistry\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### 3. Ex√©cuter la proposal (apr√®s quorum)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"TallyRegistryProposal\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üí∞ Distribution des paiements\n\nExemple avec frais marketplace 2.5% et royalties 10% :\n\n```\nPrix de vente : 100 GNOT\n‚îú‚îÄ‚îÄ Frais marketplace (2.5%) : 2.5 GNOT\n‚îú‚îÄ‚îÄ Royalties cr√©ateur (10%) : 10 GNOT\n‚îî‚îÄ‚îÄ Vendeur re√ßoit : 87.5 GNOT\n```\n\n---\n\n## üèõÔ∏è Gouvernance DAO\n\nLe marketplace est gouvern√© par un DAO. Les membres peuvent cr√©er des proposals pour :\n\n- ‚úÖ Approuver/retirer des collections\n- ‚úÖ Modifier les frais du marketplace\n- ‚úÖ Retirer des fonds du tr√©sor\n- ‚úÖ Annuler un listing probl√©matique\n\n### Cr√©er une proposal (exemple: modifier les frais)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"ProposeUpdateFees\" \\\n  -args \"300\" \\\n  -args \"R√©duction des frais √† 3%\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### Voter sur une proposal\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n---\n\n## üîß Configuration NFT minimale\n\nVotre package NFT doit avoir une fonction `Register()` :\n\n```go\npackage mynft\n\nimport (\n    \"gno.land/p/demo/tokens/grc721\"\n    \"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n    nft         *grc721.basicNFT\n    myRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n    nft = grc721.NewBasicNFT(\"My Collection\", \"MC\")\n}\n\n// Register dans le registry\nfunc Register(_ realm) {\n    daoregistry4.RegisterCollection(\n        myRealmAddr,\n        \"My Collection\",\n        \"MC\",\n        \"art\",\n        \"Description de ma collection\",\n        \"https://mon-site.com\",\n        false,\n        nft.Getter(),\n    )\n}\n\n// Fonction obligatoire pour le marketplace\nfunc Getter() grc721.NFTGetter {\n    return nft.Getter()\n}\n```\n\n---\n\n## üìä Fonctions de lecture\n\n```bash\n# Voir tous les listings actifs\ncurl https://rpc.gno.land/r/pierre115/gnopendao:\n\n# Statistiques du marketplace\ncurl https://rpc.gno.land/r/pierre115/gnopendao:stats\n\n# D√©tails d'un listing\ncurl https://rpc.gno.land/r/pierre115/gnopendao:listing/1\n\n# Collections enregistr√©es\ncurl https://rpc.gno.land/r/pierre115/daoregistry4:\n```\n\n---\n\n## üîê S√©curit√©\n\n- ‚úÖ V√©rification de propri√©t√© avant listing\n- ‚úÖ V√©rification d'approbation avant vente\n- ‚úÖ Transferts atomiques\n- ‚úÖ Remboursement automatique des surplus\n- ‚úÖ Limites de frais (max 10%)\n- ‚úÖ Gouvernance d√©centralis√©e\n\n---\n\n## üÜò Probl√®mes courants\n\n**\"Collection not registered\"**\n‚Üí Vous devez d'abord appeler `Register()` sur votre NFT\n\n**\"Insufficient payment\"**\n‚Üí Le montant envoy√© doit correspondre au prix du listing\n\n**\"Not approved\"**\n‚Üí Appelez `SetApprovalForAll()` avant de cr√©er un listing\n\n**\"Not owner\"**\n‚Üí Seul le propri√©taire du NFT peut le lister\n"},{"name":"dao.gno","body":"package gnopendao3\n\nimport (\n\t//\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tmarketplaceDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 0 // 0 GNOT minimum to join DAO\n)\n\nfunc initDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tmarketplaceDAO = commondao.New(\n\t\tcommondao.WithID(1),\n\t\tcommondao.WithName(\"GnopenSea DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for GnopenSea marketplace\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinDAO - Join the marketplace DAO by staking GNOT\nfunc JoinDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\t//sent := banker.OriginSend()\n\n\t//amount := sent.AmountOf(\"ugnot\")\n\t//if amount \u003c MIN_STAKE_UGNOT {\n\t//\tpanic(\"minimum 1 GNOT required to join DAO\")\n\t//}\n\n\tif marketplaceDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tmarketplaceDAO.Members().Add(caller)\n\n\treturn \"Successfully joined GnopenSea DAO\"\n}\n\n// IsDAOMember - Check if an address is a DAO member\nfunc IsDAOMember(addr address) bool {\n\treturn marketplaceDAO.Members().Has(addr)\n}\n\n// GetTotalMembers - Returns total number of DAO members\nfunc GetTotalMembers() int {\n\treturn marketplaceDAO.Members().Size()\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/gnopendao3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"gnopensea.gno","body":"package gnopendao3\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n\tlistings      avl.Tree\n\tsales         avl.Tree\n\tnextListingId = 1\n\tnextSaleId    = 1\n\n\tmarketplaceFee      = int64(250) // 250 basis points = 2.5%\n\tmarketplaceAddr     = runtime.CurrentRealm().Address()\n\tapprovedCollections avl.Tree // Whitelist of approved collections\n)\n\nfunc init() {\n\tinitDAO()\n}\n\n// CreateListing - List an NFT for sale using the global NFT Registry\nfunc CreateListing(_ realm, nftRealmAddress address, tokenId grc721.TokenID, price int64) int {\n\tcaller := runtime.OriginCaller()\n\n\tif price \u003c= 0 || price \u003e 99999999999 {\n\t\tpanic(\"Price not valid\")\n\t}\n\n\t// Check if collection is registered in the GLOBAL NFT Registry (technical check)\n\tif !daoregistry4.IsRegistered(nftRealmAddress) {\n\t\tpanic(\"NFT collection not registered in the global NFT Registry. The collection must call nftregistry.RegisterCollection() first.\")\n\t}\n\t// Check if collection is approved by DAO (governance check)\n\tif !approvedCollections.Has(nftRealmAddress.String()) {\n\t\tpanic(\"Collection not approved by DAO. A DAO proposal must be created and passed first.\")\n\t}\n\n\t// Get NFT getter from the global registry\n\tgetter, exists := daoregistry4.GetNFTGetter(nftRealmAddress)\n\tif !exists {\n\t\tpanic(\"Failed to get NFT getter from registry\")\n\t}\n\n\tnftInstance := getter()\n\n\t// Verify caller is the owner\n\towner, err := nftInstance.OwnerOf(tokenId)\n\tif err != nil {\n\t\tpanic(\"Token not found: \" + err.Error())\n\t}\n\n\tif owner != caller {\n\t\tpanic(\"You are not the owner of this NFT\")\n\t}\n\n\t// Verify approvals\n\tmarketplaceAddr := runtime.CurrentRealm().Address()\n\tapprovedAddr, err := nftInstance.GetApproved(tokenId)\n\tisApprovedForToken := (err == nil \u0026\u0026 approvedAddr == marketplaceAddr)\n\tisApprovedForAll := nftInstance.IsApprovedForAll(owner, marketplaceAddr)\n\n\tif !isApprovedForToken \u0026\u0026 !isApprovedForAll {\n\t\tpanic(\"You must first approve the marketplace.\\nUse Approve() or SetApprovalForAll()\")\n\t}\n\n\t// Create listing\n\tlisting := \u0026Listing{\n\t\tListingId:       nextListingId,\n\t\tNFTGetter:       getter,\n\t\tTokenId:         tokenId,\n\t\tSeller:          caller,\n\t\tPrice:           price,\n\t\tActive:          true,\n\t\tListedAt:        runtime.ChainHeight(),\n\t\tNFTRealmAddress: nftRealmAddress,\n\t}\n\n\tlistings.Set(strconv.Itoa(nextListingId), listing)\n\tnextListingId++\n\n\treturn listing.ListingId\n}\n\n// BuyNFT - Purchase a listed NFT with automatic royalty calculation\nfunc BuyNFT(_ realm, listingId int) {\n\tcaller := runtime.OriginCaller()\n\tsent := banker.OriginSend()\n\n\t// Get listing\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\t// Verify payment\n\tamount := sent.AmountOf(\"ugnot\")\n\tif amount \u003c listing.Price {\n\t\tpanic(ufmt.Sprintf(\"Insufficient amount. Price: %d ugnot\", listing.Price))\n\t}\n\n\t// Get NFT instance\n\tnftInstance := listing.NFTGetter()\n\n\t// Verify seller still owns the NFT\n\tcurrentOwner, err := nftInstance.OwnerOf(listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"NFT not found: \" + err.Error())\n\t}\n\tif currentOwner != listing.Seller {\n\t\tpanic(\"Seller no longer owns this NFT\")\n\t}\n\n\t// Calculate royalties\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\t// Check if NFT supports royalties\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate what seller receives\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\tif sellerAmount \u003c 0 {\n\t\tpanic(\"Error: fees + royalties exceed sale price\")\n\t}\n\n\t// Distribute payments\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\t// 1. Pay seller\n\tif sellerAmount \u003e 0 {\n\t\tsellerCoins := chain.Coins{chain.Coin{\"ugnot\", sellerAmount}}\n\t\tbnkr.SendCoins(realmAddr, listing.Seller, sellerCoins)\n\t}\n\n\t// 2. Pay royalties to creator\n\tif royaltyAmount \u003e 0 \u0026\u0026 royaltyReceiver != \"\" {\n\t\troyaltyCoins := chain.Coins{chain.Coin{\"ugnot\", royaltyAmount}}\n\t\tbnkr.SendCoins(realmAddr, royaltyReceiver, royaltyCoins)\n\t}\n\n\t// 3. TODO : Marketplace fees remain in contract\n\n\t// 4. Refund excess\n\tif amount \u003e listing.Price {\n\t\texcess := amount - listing.Price\n\t\texcessCoins := chain.Coins{chain.Coin{\"ugnot\", excess}}\n\t\tbnkr.SendCoins(realmAddr, caller, excessCoins)\n\t}\n\n\t// Transfer NFT\n\terr = nftInstance.TransferFrom(listing.Seller, caller, listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"Transfer error: \" + err.Error())\n\t}\n\n\t// Record sale\n\tsale := \u0026Sale{\n\t\tListingId:       listingId,\n\t\tTokenId:         listing.TokenId.String(),\n\t\tBuyer:           caller,\n\t\tSeller:          listing.Seller,\n\t\tPrice:           listing.Price,\n\t\tMarketplaceFee:  marketplaceFeeAmount,\n\t\tRoyaltyFee:      royaltyAmount,\n\t\tRoyaltyReceiver: royaltyReceiver,\n\t\tSoldAt:          runtime.ChainHeight(),\n\t}\n\n\tsales.Set(strconv.Itoa(nextSaleId), sale)\n\tnextSaleId++\n\n\t// Deactivate listing\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// CancelListing - Cancel own listing (seller only)\nfunc CancelListing(_realm, listingId int) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\t// Only seller can cancel their own listing\n\t// DAO use ProposeForceCancelListing instead\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can cancel this listing. DAO members can create a ProposeForceCancelListing proposal.\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// UpdatePrice - Update listing price\nfunc UpdatePrice(_ realm, listingId int, newPrice int64) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif newPrice \u003c= 0 {\n\t\tpanic(\"Price must be positive\")\n\t}\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can modify this listing\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\tlisting.Price = newPrice\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// ============= READ FUNCTIONS =============\n\nfunc GetListing(listingId int) (int, string, int64, string, bool, int64) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, \"\", 0, \"\", false, 0\n\t}\n\n\treturn listing.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tlisting.ListedAt\n}\n\nfunc GetSale(saleId int) (int, string, string, string, int64, int64, int64, string, int64) {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn 0, \"\", \"\", \"\", 0, 0, 0, \"\", 0\n\t}\n\n\tsale := value.(*Sale)\n\treturn sale.ListingId,\n\t\tsale.TokenId,\n\t\tsale.Buyer.String(),\n\t\tsale.Seller.String(),\n\t\tsale.Price,\n\t\tsale.MarketplaceFee,\n\t\tsale.RoyaltyFee,\n\t\tsale.RoyaltyReceiver.String(),\n\t\tsale.SoldAt\n}\n\nfunc GetActiveListingsCount() int {\n\tcount := 0\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\nfunc GetTotalSales() int {\n\treturn sales.Size()\n}\n\nfunc GetTotalVolume() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.Price\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetTotalRoyaltiesPaid() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.RoyaltyFee\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetMarketplaceFee() int64 {\n\treturn marketplaceFee\n}\n\nfunc GetMarketplaceAddress() address {\n\treturn runtime.CurrentRealm().Address()\n}\n\n// GetRoyaltyBreakdown - Calculate distribution for a listing\nfunc GetRoyaltyBreakdown(listingId int) (int64, int64, int64, address) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, 0, 0, \"\"\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate royalties if supported\n\tnftInstance := listing.NFTGetter()\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\treturn sellerAmount, marketplaceFeeAmount, royaltyAmount, royaltyReceiver\n}\n\nfunc GetBalance() int64 {\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\tbalance := bnkr.GetCoins(realmAddr)\n\treturn balance.AmountOf(\"ugnot\")\n}\n\n// ============= READ FUNCTIONS FOR FRONTEND =============\n\n// GetAllListings - Return all active listings with metadata\nfunc GetAllListings() string {\n\tvar listingsData []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\t// Get NFT instance to fetch metadata\n\t\t\tnftInstance := listing.NFTGetter()\n\n\t\t\t// Try to get image and name from onchain metadata\n\t\t\tvar image, name string\n\t\t\tif metaNFT, ok := nftInstance.(grc721.IGRC721MetadataOnchain); ok {\n\t\t\t\tif metadata, err := metaNFT.TokenMetadata(listing.TokenId); err == nil {\n\t\t\t\t\timage = metadata.Image\n\t\t\t\t\tname = metadata.Name\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no image, use placeholder\n\t\t\tif image == \"\" {\n\t\t\t\timage = \"https://via.placeholder.com/400\"\n\t\t\t}\n\n\t\t\t// Format: listingId|nftAddress|tokenId|price|seller|image|name\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%s|%d|%s|%s|%s\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.NFTRealmAddress.String(),\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t\tlisting.Seller.String(),\n\t\t\t\timage,\n\t\t\t\tname,\n\t\t\t)\n\t\t\tlistingsData = append(listingsData, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(listingsData) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(listingsData, \"\\n\")\n}\n\n// GetListingDetails - Get detailed info about a listing\nfunc GetListingDetails(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"Listing not found\"\n\t}\n\n\tnftInstance := listing.NFTGetter()\n\n\t// Get NFT metadata - prioritize onchain metadata over TokenURI\n\tvar name, description, image, uri string\n\tvar attributes []grc721.Trait\n\n\t// Try onchain metadata first (supports Image, Description, Attributes)\n\tif metaNFT, ok := nftInstance.(grc721.IGRC721MetadataOnchain); ok {\n\t\tif metadata, err := metaNFT.TokenMetadata(listing.TokenId); err == nil {\n\t\t\tname = metadata.Name\n\t\t\tdescription = metadata.Description\n\t\t\timage = metadata.Image\n\t\t\tattributes = metadata.Attributes\n\t\t}\n\t} else if metaNFT, ok := nftInstance.(grc721.IGRC721Metadata); ok {\n\t\t// Fallback to TokenURI for old NFTs\n\t\tname = metaNFT.Name()\n\t\tif tokenURI, err := metaNFT.TokenURI(listing.TokenId); err == nil {\n\t\t\turi = tokenURI\n\t\t}\n\t}\n\n\t// Format attributes as JSON array\n\tattributesJSON := \"[]\"\n\tif len(attributes) \u003e 0 {\n\t\tattrStr := \"[\"\n\t\tfor i, attr := range attributes {\n\t\t\tif i \u003e 0 {\n\t\t\t\tattrStr += \",\"\n\t\t\t}\n\t\t\tattrStr += ufmt.Sprintf(`{\"trait_type\":\"%s\",\"value\":\"%s\"}`, attr.TraitType, attr.Value)\n\t\t}\n\t\tattrStr += \"]\"\n\t\tattributesJSON = attrStr\n\t}\n\n\t// Format JSON-like response\n\toutput := ufmt.Sprintf(`{\n  \"listingId\": %d,\n  \"tokenId\": \"%s\",\n  \"price\": %d,\n  \"seller\": \"%s\",\n  \"active\": %t,\n  \"name\": \"%s\",\n  \"description\": \"%s\",\n  \"image\": \"%s\",\n  \"uri\": \"%s\",\n  \"attributes\": %s,\n  \"listedAt\": %d\n}`,\n\t\tlisting.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tname,\n\t\tdescription,\n\t\timage,\n\t\turi,\n\t\tattributesJSON,\n\t\tlisting.ListedAt,\n\t)\n\n\treturn output\n}\n\n// GetUserListings - Get all listings by a specific seller\nfunc GetUserListings(sellerAddr address) string {\n\tvar userListings []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Seller == sellerAddr \u0026\u0026 listing.Active {\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%d\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t)\n\t\t\tuserListings = append(userListings, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(userListings) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(userListings, \"\\n\")\n}\n\n// GetMarketplaceStats - Get overall marketplace statistics\nfunc GetMarketplaceStats() string {\n\tactiveCount := GetActiveListingsCount()\n\ttotalSales := GetTotalSales()\n\ttotalVolume := GetTotalVolume()\n\n\toutput := ufmt.Sprintf(`{\n  \"activeListings\": %d,\n  \"totalSales\": %d,\n  \"totalVolume\": %d,\n  \"marketplaceFee\": %d\n}`,\n\t\tactiveCount,\n\t\ttotalSales,\n\t\ttotalVolume,\n\t\tmarketplaceFee,\n\t)\n\n\treturn output\n}\n\n// ============= HELPERS =============\n\nfunc getListing(listingId int) *Listing {\n\tvalue, exists := listings.Get(strconv.Itoa(listingId))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn value.(*Listing)\n}\n\nfunc formatPrice(ugnot int64) string {\n\tgnot := float64(ugnot) / 1000000.0\n\treturn ufmt.Sprintf(\"%.2f GNOT\", gnot)\n}\n\nfunc formatFee(basisPoints int64) string {\n\tpercent := float64(basisPoints) / 100.0\n\treturn ufmt.Sprintf(\"%.2f%%\", percent)\n}\n\nfunc formatPercentage(value, total int64) string {\n\tif total == 0 {\n\t\treturn \"0%\"\n\t}\n\tpercent := (float64(value) / float64(total)) * 100.0\n\treturn ufmt.Sprintf(\"%.1f%%\", percent)\n}\n"},{"name":"gnopensea_test.gno","body":"package gnopendao3\n\nimport (\n\t\"testing\"\n)\n\n// Test marketplace initialization values\nfunc TestMarketplaceInit(t *testing.T) {\n\t// Check marketplace fee is set to default (2.5%)\n\tfee := GetMarketplaceFee()\n\tif fee != 250 {\n\t\tt.Errorf(\"Expected marketplace fee to be 250, got %d\", fee)\n\t}\n}\n\n// Test marketplace fee getter\nfunc TestGetMarketplaceFee(t *testing.T) {\n\tfee := GetMarketplaceFee()\n\tif fee \u003c 0 || fee \u003e 1000 {\n\t\tt.Errorf(\"Marketplace fee out of valid range (0-1000): %d\", fee)\n\t}\n}\n\n// Test active listings count (should not panic)\nfunc TestGetActiveListingsCount(t *testing.T) {\n\tcount := GetActiveListingsCount()\n\tif count \u003c 0 {\n\t\tt.Errorf(\"Active listings count should not be negative: %d\", count)\n\t}\n}\n\n// Test total sales (should not panic)\nfunc TestGetTotalSales(t *testing.T) {\n\tsales := GetTotalSales()\n\tif sales \u003c 0 {\n\t\tt.Errorf(\"Total sales should not be negative: %d\", sales)\n\t}\n}\n\n// Test total volume (should not panic)\nfunc TestGetTotalVolume(t *testing.T) {\n\tvolume := GetTotalVolume()\n\tif volume \u003c 0 {\n\t\tt.Errorf(\"Total volume should not be negative: %d\", volume)\n\t}\n}\n\n// Test total royalties paid (should not panic)\nfunc TestGetTotalRoyaltiesPaid(t *testing.T) {\n\troyalties := GetTotalRoyaltiesPaid()\n\tif royalties \u003c 0 {\n\t\tt.Errorf(\"Total royalties should not be negative: %d\", royalties)\n\t}\n}\n\n// Test marketplace address getter (should not panic)\nfunc TestGetMarketplaceAddress(t *testing.T) {\n\taddr := GetMarketplaceAddress()\n\tif addr == \"\" {\n\t\tt.Error(\"Marketplace address should not be empty\")\n\t}\n}\n\n// Test balance getter (should not panic)\nfunc TestGetBalance(t *testing.T) {\n\tbalance := GetBalance()\n\tif balance \u003c 0 {\n\t\tt.Errorf(\"Balance should not be negative: %d\", balance)\n\t}\n}\n\n// Test render home page (should not panic)\nfunc TestRenderHome(t *testing.T) {\n\toutput := Render(\"\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Home render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Marketplace\") {\n\t\tt.Error(\"Home render should contain 'Marketplace'\")\n\t}\n}\n\n// Test render stats page (should not panic)\nfunc TestRenderStats(t *testing.T) {\n\toutput := Render(\"stats\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Stats render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Statistics\") {\n\t\tt.Error(\"Stats render should contain 'Statistics'\")\n\t}\n}\n\n// Test render invalid path\nfunc TestRenderInvalidPath(t *testing.T) {\n\toutput := Render(\"invalid/path/test\")\n\tif output != \"Page not found\" {\n\t\tt.Errorf(\"Expected 'Page not found', got '%s'\", output)\n\t}\n}\n\n// Test format price function\nfunc TestFormatPrice(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{1000000, \"1.00 GNOT\"},\n\t\t{5000000, \"5.00 GNOT\"},\n\t\t{100, \"0.00 GNOT\"},\n\t\t{0, \"0.00 GNOT\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPrice(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPrice(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format fee function\nfunc TestFormatFee(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{250, \"2.50%\"},\n\t\t{500, \"5.00%\"},\n\t\t{1000, \"10.00%\"},\n\t\t{0, \"0.00%\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatFee(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatFee(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format percentage function\nfunc TestFormatPercentage(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    int64\n\t\ttotal    int64\n\t\texpected string\n\t}{\n\t\t{25, 100, \"25.0%\"},\n\t\t{50, 100, \"50.0%\"},\n\t\t{0, 100, \"0.0%\"},\n\t\t{100, 100, \"100.0%\"},\n\t\t{0, 0, \"0%\"}, // Division by zero case\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPercentage(tt.value, tt.total)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPercentage(%d, %d) = %s, expected %s\",\n\t\t\t\ttt.value, tt.total, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test GetListing with invalid ID (should return zeros)\nfunc TestGetListingInvalid(t *testing.T) {\n\tid, tokenId, price, seller, active, listedAt := GetListing(999999)\n\n\tif id != 0 || tokenId != \"\" || price != 0 || seller != \"\" || active != false || listedAt != 0 {\n\t\tt.Error(\"GetListing with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetSale with invalid ID (should return zeros)\nfunc TestGetSaleInvalid(t *testing.T) {\n\tlistingId, tokenId, buyer, seller, price, marketFee, royaltyFee, royaltyReceiver, soldAt := GetSale(999999)\n\n\tif listingId != 0 || tokenId != \"\" || buyer != \"\" || seller != \"\" ||\n\t\tprice != 0 || marketFee != 0 || royaltyFee != 0 || royaltyReceiver != \"\" || soldAt != 0 {\n\t\tt.Error(\"GetSale with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetRoyaltyBreakdown with invalid ID (should return zeros)\nfunc TestGetRoyaltyBreakdownInvalid(t *testing.T) {\n\tsellerAmount, marketFee, royalty, royaltyReceiver := GetRoyaltyBreakdown(999999)\n\n\tif sellerAmount != 0 || marketFee != 0 || royalty != 0 || royaltyReceiver != \"\" {\n\t\tt.Error(\"GetRoyaltyBreakdown with invalid ID should return zero values\")\n\t}\n}\n\n// Helper function to check if string contains substring\nfunc contains(s, substr string) bool {\n\treturn len(s) \u003e= len(substr) \u0026\u0026 (s == substr ||\n\t\tlen(s) \u003e len(substr) \u0026\u0026 indexOf(s, substr) \u003e= 0)\n}\n\n// Helper function to find substring index\nfunc indexOf(s, substr string) int {\n\tfor i := 0; i \u003c= len(s)-len(substr); i++ {\n\t\tif s[i:i+len(substr)] == substr {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"},{"name":"proposal.gno","body":"package gnopendao3\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"errors\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_APPROVE_COLLECTION   = \"approve_collection\"\n\tPROPOSAL_TYPE_REMOVE_COLLECTION    = \"remove_collection\"\n\tPROPOSAL_TYPE_UPDATE_FEES          = \"update_fees\"\n\tPROPOSAL_TYPE_WITHDRAW_TREASURY    = \"withdraw_treasury\"\n\tPROPOSAL_TYPE_FORCE_CANCEL_LISTING = \"force_cancel_listing\"\n\n\tVOTING_PERIOD = 10 * time.Minute\n\tQUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// CollectionProposal - Proposal to approve or remove a collection\ntype CollectionProposal struct {\n\tproposalType   string\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc newCollectionProposal(propType string, addr address, name string, reason string) *CollectionProposal {\n\treturn \u0026CollectionProposal{\n\t\tproposalType:   propType,\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *CollectionProposal) Title() string {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\treturn \"Approve Collection: \" + p.collectionName\n\t}\n\treturn \"Remove Collection: \" + p.collectionName\n}\n\nfunc (p *CollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Type: %s\\nCollection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tp.proposalType,\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *CollectionProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *CollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *CollectionProposal) Execute(realm) error {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\tapprovedCollections.Set(p.collectionAddr.String(), true)\n\t} else if p.proposalType == PROPOSAL_TYPE_REMOVE_COLLECTION {\n\t\tapprovedCollections.Remove(p.collectionAddr.String())\n\t}\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *CollectionProposal) GetCollectionAddr() address {\n\treturn p.collectionAddr\n}\n\n// FeesProposal - Proposal to update marketplace fees\ntype FeesProposal struct {\n\tnewFee   int64\n\treason   string\n\tapproved bool\n\texecuted bool\n}\n\nfunc newFeesProposal(newFee int64, reason string) *FeesProposal {\n\treturn \u0026FeesProposal{\n\t\tnewFee:   newFee,\n\t\treason:   reason,\n\t\tapproved: false,\n\t\texecuted: false,\n\t}\n}\n\nfunc (p *FeesProposal) Title() string {\n\treturn ufmt.Sprintf(\"Update Marketplace Fee to %d basis points\", p.newFee)\n}\n\nfunc (p *FeesProposal) Body() string {\n\tcurrentFeePercent := float64(marketplaceFee) / 100.0\n\tnewFeePercent := float64(p.newFee) / 100.0\n\n\treturn ufmt.Sprintf(\n\t\t\"Current Fee: %.2f%%\\nProposed Fee: %.2f%%\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tcurrentFeePercent,\n\t\tnewFeePercent,\n\t\tp.reason,\n\t)\n}\n\nfunc (p *FeesProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *FeesProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *FeesProposal) Execute(realm) error {\n\tmarketplaceFee = p.newFee\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *FeesProposal) GetNewFee() int64 {\n\treturn p.newFee\n}\n\n// TreasuryProposal - Proposal to withdraw funds from treasury\ntype TreasuryProposal struct {\n\tamount    int64\n\trecipient address\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewTreasuryProposal(amount int64, recipient address, reason string) *TreasuryProposal {\n\treturn \u0026TreasuryProposal{\n\t\tamount:    amount,\n\t\trecipient: recipient,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *TreasuryProposal) Title() string {\n\treturn ufmt.Sprintf(\"Withdraw %d ugnot from Treasury\", p.amount)\n}\n\nfunc (p *TreasuryProposal) Body() string {\n\tcurrentBalance := GetBalance()\n\n\treturn ufmt.Sprintf(\n\t\t\"Withdraw: %s\\nRecipient: %s\\nCurrent Treasury: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tformatPrice(p.amount),\n\t\tp.recipient.String(),\n\t\tformatPrice(currentBalance),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *TreasuryProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *TreasuryProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *TreasuryProposal) Execute(realm) error {\n\tcurrentBalance := GetBalance()\n\tif currentBalance \u003c p.amount {\n\t\treturn errors.New(\"insufficient treasury balance\")\n\t}\n\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tcoins := chain.Coins{chain.Coin{\"ugnot\", p.amount}}\n\tbnkr.SendCoins(realmAddr, p.recipient, coins)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *TreasuryProposal) GetAmount() int64 {\n\treturn p.amount\n}\n\nfunc (p *TreasuryProposal) GetRecipient() address {\n\treturn p.recipient\n}\n\n// ForceCancelListingProposal - Proposal to force cancel a problematic listing\ntype ForceCancelListingProposal struct {\n\tlistingId int\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewForceCancelListingProposal(listingId int, reason string) *ForceCancelListingProposal {\n\treturn \u0026ForceCancelListingProposal{\n\t\tlistingId: listingId,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *ForceCancelListingProposal) Title() string {\n\treturn ufmt.Sprintf(\"Force Cancel Listing #%d\", p.listingId)\n}\n\nfunc (p *ForceCancelListingProposal) Body() string {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn ufmt.Sprintf(\"Listing #%d\\nStatus: NOT FOUND\\nReason: %s\\n\\nVote YES to approve, NO to reject\", p.listingId, p.reason)\n\t}\n\n\treturn ufmt.Sprintf(\n\t\t\"Listing ID: %d\\nToken ID: %s\\nSeller: %s\\nPrice: %s\\nReason for cancellation: %s\\n\\nVote YES to force cancel, NO to reject\",\n\t\tp.listingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Seller.String(),\n\t\tformatPrice(listing.Price),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *ForceCancelListingProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *ForceCancelListingProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *ForceCancelListingProposal) Execute(realm) error {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn errors.New(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\treturn errors.New(\"listing already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(p.listingId), listing)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *ForceCancelListingProposal) GetListingId() int {\n\treturn p.listingId\n}\n"},{"name":"render.gno","body":"package gnopendao3\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ============= RENDER =============\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif strings.HasPrefix(path, \"listing/\") {\n\t\tidStr := strings.TrimPrefix(path, \"listing/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderListing(id)\n\t}\n\n\tif strings.HasPrefix(path, \"sale/\") {\n\t\tidStr := strings.TrimPrefix(path, \"sale/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderSale(id)\n\t}\n\n\tif path == \"stats\" {\n\t\treturn renderStats()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# GNOPENSEA DAO 10\\n\\n\"\n\toutput += \"Decentralized NFT Marketplace with DAO Governance\\n\\n\"\n\toutput += \"Compatible **GRC-721** + **GRC-2981** (Automatic Royalties)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += \"[View detailed statistics](/r/pierre115/gnopendao3:stats)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalMembers())\n\n\tactiveProposals := marketplaceDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/gnopendao3:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"*No active proposals*\\n\\n\"\n\t}\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/gnopendao3:archive)\\n\\n\", finishedProposals.Size())\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join !\", linkjoin) + \"\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\t// Active listings\n\tif GetActiveListingsCount() \u003e 0 {\n\t\toutput += \"## NFTs for sale\\n\\n\"\n\n\t\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tlisting := value.(*Listing)\n\t\t\tif listing.Active {\n\t\t\t\toutput += renderListingPreview(listing)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t} else {\n\t\toutput += \"## No NFTs for sale\\n\\n\"\n\t\toutput += \"*Be the first to list an NFT!*\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderListingPreview(listing *Listing) string {\n\t// Calculate breakdown\n\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listing.ListingId)\n\n\toutput := ufmt.Sprintf(\"### Listing #%d\\n\\n\", listing.ListingId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\n\tif royalty \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"Royalty: %s (%s)\\n\\n\",\n\t\t\tformatPrice(royalty),\n\t\t\tformatPercentage(royalty, listing.Price))\n\t}\n\n\toutput += ufmt.Sprintf(\"**Seller receives:** %s\\n\\n\", formatPrice(sellerGets))\n\toutput += ufmt.Sprintf(\"**Market Fees:** %s\\n\\n\", formatPrice(marketFee))\n\toutput += ufmt.Sprintf(\"**Royalty Address:** %s\\n\\n\", royaltyAddr.String())\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao3:listing/%d)\\n\\n\", listing.ListingId)\n\toutput += \"---\\n\\n\"\n\treturn output\n}\n\nfunc renderListing(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"# Listing not found\"\n\t}\n\n\tstatus := \"Active\"\n\tif !listing.Active {\n\t\tstatus = \"Sold/Cancelled\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Listing #%d - %s\\n\\n\", listingId, status)\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", listing.Seller.String())\n\toutput += ufmt.Sprintf(\"**Listed at block:** %d\\n\\n\", listing.ListedAt)\n\n\tif listing.Active {\n\t\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listingId)\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Price breakdown\\n\\n\"\n\t\toutput += ufmt.Sprintf(\"- **Total price:** %s (100%%)\\n\", formatPrice(listing.Price))\n\t\toutput += ufmt.Sprintf(\"- **Marketplace fee (%s):** %s\\n\",\n\t\t\tformatFee(marketplaceFee), formatPrice(marketFee))\n\n\t\tif royalty \u003e 0 {\n\t\t\toutput += ufmt.Sprintf(\"- **Creator royalty (%s):** %s\\n\",\n\t\t\t\tformatPercentage(royalty, listing.Price), formatPrice(royalty))\n\t\t\toutput += ufmt.Sprintf(\"  - Beneficiary: `%s`\\n\", royaltyAddr.String())\n\t\t} else {\n\t\t\toutput += \"- **Royalty:** None\\n\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"- **Seller receives:** %s (%s)\\n\\n\",\n\t\t\tformatPrice(sellerGets), formatPercentage(sellerGets, listing.Price))\n\n\t\toutput += \"## Purchase\\n\\n\"\n\t\toutput += \"```bash\\n\"\n\t\toutput += \"gnokey maketx call \\\\\\n\"\n\t\toutput += \"  -pkgpath \\\"gno.land/r/pierre115/gnopendao3\\\" \\\\\\n\"\n\t\toutput += \"  -func \\\"BuyNFT\\\" \\\\\\n\"\n\t\toutput += ufmt.Sprintf(\"  -args \\\"%d\\\" \\\\\\n\", listingId)\n\t\toutput += ufmt.Sprintf(\"  -send \\\"%dugnot\\\" \\\\\\n\", listing.Price)\n\t\toutput += \"  -broadcast yourkey\\n\"\n\t\toutput += \"```\\n\"\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao3)\\n\"\n\n\treturn output\n}\n\nfunc renderSale(saleId int) string {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn \"# Sale not found\"\n\t}\n\n\tsale := value.(*Sale)\n\n\toutput := ufmt.Sprintf(\"# Sale #%d\\n\\n\", saleId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", sale.TokenId)\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(sale.Price))\n\toutput += ufmt.Sprintf(\"**Buyer:** `%s`\\n\\n\", sale.Buyer.String())\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", sale.Seller.String())\n\toutput += ufmt.Sprintf(\"**Block:** %d\\n\\n\", sale.SoldAt)\n\n\toutput += \"## Distribution\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Marketplace fee:** %s\\n\", formatPrice(sale.MarketplaceFee))\n\n\tif sale.RoyaltyFee \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- **Royalty:** %s ‚Üí `%s`\\n\",\n\t\t\tformatPrice(sale.RoyaltyFee), sale.RoyaltyReceiver.String())\n\t}\n\n\tsellerReceived := sale.Price - sale.MarketplaceFee - sale.RoyaltyFee\n\toutput += ufmt.Sprintf(\"- **Seller received:** %s\\n\", formatPrice(sellerReceived))\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"# Marketplace Statistics\\n\\n\"\n\n\ttotalVolume := GetTotalVolume()\n\ttotalSales := GetTotalSales()\n\ttotalRoyalties := GetTotalRoyaltiesPaid()\n\n\toutput += ufmt.Sprintf(\"**Total volume:** %s\\n\\n\", formatPrice(totalVolume))\n\toutput += ufmt.Sprintf(\"**Number of sales:** %d\\n\\n\", totalSales)\n\toutput += ufmt.Sprintf(\"**Royalties paid:** %s (%s of volume)\\n\\n\",\n\t\tformatPrice(totalRoyalties), formatPercentage(totalRoyalties, totalVolume))\n\n\tif totalSales \u003e 0 {\n\t\tavgPrice := totalVolume / int64(totalSales)\n\t\toutput += ufmt.Sprintf(\"**Average price:** %s\\n\\n\", formatPrice(avgPrice))\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao3)\\n\"\n\n\treturn output\n}\n\n// ============= DAO RENDER FUNCTIONS =============\n\nfunc renderProposals() string {\n\toutput := \"# Active DAO Proposals\\n\\n\"\n\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"*No active proposals at the moment*\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Approve new NFT collections\\n\"\n\t\toutput += \"- Remove existing collections\\n\"\n\t\toutput += \"- Update marketplace fees\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao3)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao3)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting open**\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View \u0026 Vote](/r/pierre115/gnopendao3:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to proposals](/r/pierre115/gnopendao3:proposals) | [‚Üê Home](/r/pierre115/gnopendao3)\\n\"\n\n\treturn output\n}\n\n// ============= ARCHIVE RENDER FUNCTIONS =============\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"*No finished proposals yet*\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao3)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao3)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif p.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Status:** %s\\n\\n\", statusEmoji, string(p.Status()))\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao3:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Final Status:** %s\\n\\n\", statusEmoji, string(proposal.Status()))\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to archive](/r/pierre115/gnopendao3:archive) | [‚Üê Home](/r/pierre115/gnopendao3)\\n\"\n\n\treturn output\n}\n"},{"name":"type.gno","body":"package gnopendao3\n\nimport (\n\t\"gno.land/p/demo/tokens/grc721\"\n)\n\n// Listing structure\ntype Listing struct {\n\tListingId       int\n\tNFTGetter       grc721.NFTGetter\n\tTokenId         grc721.TokenID\n\tSeller          address\n\tPrice           int64\n\tActive          bool\n\tListedAt        int64\n\tNFTRealmAddress address\n}\n\n// Sale statistics\ntype Sale struct {\n\tListingId       int\n\tTokenId         string\n\tBuyer           address\n\tSeller          address\n\tPrice           int64\n\tMarketplaceFee  int64\n\tRoyaltyFee      int64\n\tRoyaltyReceiver address\n\tSoldAt          int64\n}\n"},{"name":"voting.gno","body":"package gnopendao3\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeApproveCollection - Create a proposal to approve a new collection\nfunc ProposeApproveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_APPROVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeRemoveCollection - Create a proposal to remove a collection\nfunc ProposeRemoveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_REMOVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUpdateFees - Create a proposal to update marketplace fees\nfunc ProposeUpdateFees(_ realm, newFeeBasisPoints int64, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif newFeeBasisPoints \u003c 0 || newFeeBasisPoints \u003e 1000 {\n\t\tpanic(\"fees must be between 0 and 1000 basis points (0-10%)\")\n\t}\n\n\tpropDef := newFeesProposal(newFeeBasisPoints, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeWithdrawTreasury - Create a proposal to withdraw funds from treasury\nfunc ProposeWithdrawTreasury(_ realm, amount int64, recipient address, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif amount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\n\tif !recipient.IsValid() {\n\t\tpanic(\"invalid recipient address\")\n\t}\n\n\tcurrentBalance := GetBalance()\n\tif amount \u003e currentBalance {\n\t\tpanic(ufmt.Sprintf(\"insufficient treasury balance (available: %d ugnot)\", currentBalance))\n\t}\n\n\tpropDef := NewTreasuryProposal(amount, recipient, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeForceCancelListing - Create a proposal to force cancel a listing\nfunc ProposeForceCancelListing(_ realm, listingId int, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\t// Verify listing exists and is active\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"listing is already inactive\")\n\t}\n\n\tpropDef := NewForceCancelListingProposal(listingId, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// Vote - Vote on a proposal (yes or no)\nfunc Vote(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tvar voteChoice commondao.VoteChoice\n\tif choice == \"yes\" {\n\t\tvoteChoice = commondao.ChoiceYes\n\t} else if choice == \"no\" {\n\t\tvoteChoice = commondao.ChoiceNo\n\t} else {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - it handles all validations automatically\n\terr := marketplaceDAO.Vote(\n\t\tcaller,\n\t\tproposalID,\n\t\tvoteChoice,\n\t\t\"\", // reason (optional)\n\t)\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyProposal - Execute a proposal after voting period\nfunc TallyProposal(_ realm, proposalID uint64) string {\n\terr := marketplaceDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n\n// GetProposalInfo - Get information about a proposal\nfunc GetProposalInfo(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"Proposal not found\"\n\t}\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput := ufmt.Sprintf(`Proposal #%d\nTitle: %s\nBody: %s\nYes Votes: %d\nNo Votes: %d\nTotal Votes: %d\nVoting Ended: %t`,\n\t\tproposalID,\n\t\tproposal.Definition().Title(),\n\t\tproposal.Definition().Body(),\n\t\tyesVotes,\n\t\tnoVotes,\n\t\tyesVotes+noVotes,\n\t\tproposal.HasVotingDeadlinePassed(),\n\t)\n\n\treturn output\n}\n\n// GetAllActiveProposals - Get all active proposals\nfunc GetAllActiveProposals() string {\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\treturn \"No active proposals\"\n\t}\n\n\toutput := \"=== Active Proposals ===\\n\\n\"\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += ufmt.Sprintf(\"ID: %d | %s\\n\", p.ID(), p.Definition().Title())\n\t\treturn false\n\t})\n\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"400000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"H1bJg9kahWGTfWjJeKuUFMmRDUl6xYIp8MyTUysLxKq/eBMv5kFY1LT3iOBpYlggFX83o+xlZpmsv93MGT2mCQ=="}],"memo":""},"metadata":{"timestamp":"1765564981"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"mynftcollection","path":"gno.land/r/pierre115/mynftcollection","files":[{"name":"README.md","body":"# My NFT Collection - NFT avec Image Fixe\n\nPackage NFT avec **image fixe** d√©finie dans le code : tous les NFTs de cette collection partagent la m√™me image.\n\n## ‚ú® Fonctionnalit√©s\n\n- ‚úÖ Support de m√©tadonn√©es onchain (GRC721Metadata)\n- ‚úÖ **Image fixe** d√©finie dans le code (tous les NFTs ont la m√™me apparence)\n- ‚úÖ Nom et description personnalis√©s par NFT\n- ‚úÖ Attributs/traits personnalis√©s (optionnel)\n- ‚úÖ Compatible avec GnopenSea marketplace\n\n---\n\n## ‚öôÔ∏è Configuration de l'Image\n\n**AVANT de d√©ployer**, change l'URL de l'image dans [nft.gno](nft.gno#L18) :\n\n```go\nvar (\n    // ...\n    // CHANGE TON URL ICI ‚Üì\n    collectionImageURL = \"https://i.imgur.com/VOTRE_IMAGE.jpg\"\n)\n```\n\n### Comment obtenir une URL d'image :\n\n1. **Imgur** (recommand√© pour tester) :\n   - Va sur [imgur.com](https://imgur.com)\n   - Upload ton image\n   - Clique droit ‚Üí \"Copy image address\"\n   - Colle l'URL dans `collectionImageURL`\n\n2. **IPFS** (d√©centralis√©) :\n   - Upload via [Pinata](https://pinata.cloud) ou [NFT.Storage](https://nft.storage)\n   - Utilise : `https://ipfs.io/ipfs/QmVotreCID/image.png`\n\n---\n\n## üöÄ D√©ploiement\n\n```bash\ngnokey maketx addpkg \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -pkgdir \"./community/packages/r/pierre115/my_nft_collection\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 100000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  -remote \"https://rpc.gno.land:443\" \\\n  votre-wallet\n```\n\n---\n\n## üìù Utilisation\n\n### 1. Enregistrer la collection dans le Registry DAO\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -func \"Register\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  -remote \"https://rpc.gno.land:443\" \\\n  votre-wallet\n```\n\n### 2. Mint un NFT\n\n#### **Option A : NFT Simple (nom + description)**\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -func \"MintNFT\" \\\n  -args \"Cosmic Cat #1\" \\\n  -args \"A mystical cat floating in space\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  votre-wallet\n```\n\n**R√©sultat** : NFT avec :\n- Image : celle d√©finie dans `collectionImageURL`\n- Nom : \"Cosmic Cat #1\"\n- Description : \"A mystical cat floating in space\"\n\n#### **Option B : NFT avec Attributs** (ex: jeu, collection rare)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -func \"MintNFTWithAttributes\" \\\n  -args \"Epic Sword #42\" \\\n  -args \"Legendary weapon forged in dragon fire\" \\\n  -args '[\"Rarity\",\"Power\",\"Element\"]' \\\n  -args '[\"Legendary\",\"95\",\"Fire\"]' \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n**R√©sultat** : NFT avec :\n- Image : celle d√©finie dans `collectionImageURL`\n- Nom : \"Epic Sword #42\"\n- Attributs :\n  - **Rarity**: Legendary\n  - **Power**: 95\n  - **Element**: Fire\n\n### 3. Voir les m√©tadonn√©es d'un NFT\n\n```bash\n# Via render\ncurl https://rpc.gno.land/r/pierre115/mynftcollection:1\n\n# Via fonction\ngnokey query vm/qeval \\\n  -remote \"https://rpc.gno.land:443\" \\\n  -data \"gno.land/r/pierre115/mynftcollection\nGetTokenMetadata(\\\"1\\\")\"\n```\n\n### 4. Approuver le marketplace\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -func \"SetApprovalForAll\" \\\n  -args \"g1[adresse-marketplace]\" \\\n  -args \"true\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üìä Structure de M√©tadonn√©es\n\nTous les NFTs ont la structure suivante :\n\n```go\nMetadata {\n    Name:        \"Nom personnalis√© par mint\",\n    Description: \"Description personnalis√©e par mint\",\n    Image:       \"https://i.imgur.com/VOTRE_IMAGE.jpg\", // ‚Üê FIXE pour tous\n    Attributes:  [\n        { TraitType: \"Rarity\",  Value: \"Legendary\" }, // Optionnel\n        { TraitType: \"Power\",   Value: \"95\" },\n        // ...\n    ]\n}\n```\n\n**Important** : L'image est identique pour tous les NFTs, seuls le nom, la description et les attributs changent.\n\n---\n\n## üîç Fonctions Disponibles\n\n| Fonction | Description |\n|----------|-------------|\n| `Register()` | Enregistrer la collection dans le registry |\n| `MintNFT(name, desc)` | Mint NFT simple (pas besoin de passer l'URL d'image) |\n| `MintNFTWithAttributes(name, desc, traits, values)` | Mint NFT avec attributs personnalis√©s |\n| `GetTokenMetadata(tokenId)` | Voir les m√©tadonn√©es d'un NFT |\n| `SetApprovalForAll(operator, approved)` | Approuver un op√©rateur |\n| `Getter()` | Obtenir le NFTGetter (pour marketplace) |\n| `GetCollectionInfo()` | Informations sur la collection |\n\n---\n\n## üéØ Cas d'Usage\n\n### Collection de Tickets / Memberships\n\nTous les membres ont le m√™me badge visuel :\n\n```bash\n# Tous auront la m√™me image (logo du club)\nMintNFT(\"Member #1\", \"Gold Member\")\nMintNFT(\"Member #2\", \"Silver Member\")\nMintNFT(\"Member #3\", \"Gold Member\")\n```\n\n### Collection de Jeu avec Stats Variables\n\nM√™me apparence mais stats diff√©rentes :\n\n```bash\nMintNFTWithAttributes(\n  \"Warrior #1\",\n  \"Strong warrior\",\n  [\"Attack\", \"Defense\", \"Speed\"],\n  [\"100\", \"50\", \"75\"]\n)\n\nMintNFTWithAttributes(\n  \"Warrior #2\",\n  \"Fast warrior\",\n  [\"Attack\", \"Defense\", \"Speed\"],\n  [\"80\", \"40\", \"95\"]\n)\n```\n\nTous les Warriors ont la m√™me image, mais des stats diff√©rentes !\n\n---\n\n## üîó Int√©gration avec GnopenSea\n\nUne fois d√©ploy√© et enregistr√© :\n1. Tous les NFTs de cette collection afficheront **la m√™me image** sur le marketplace\n2. Les noms et descriptions seront affich√©s dans la carte NFT\n3. Les attributs seront visibles sur la page de d√©tail\n\n---\n\n## üí° Pourquoi une Image Fixe ?\n\n‚úÖ **Avantages** :\n- Plus simple √† mint (pas besoin de passer l'URL √† chaque fois)\n- Parfait pour les collections de \"tickets\" ou \"memberships\"\n- Id√©al pour les jeux o√π l'apparence est fixe mais les stats varient\n- Moins cher en gas (pas besoin de stocker l'URL √† chaque mint)\n\n‚ùå **D√©savantage** :\n- Tous les NFTs ont la m√™me apparence visuelle\n- Pas adapt√© pour collections d'art avec pi√®ces uniques\n\n**Pour des images diff√©rentes par NFT**, utilise plut√¥t le package `my_test_nft` avec imageURL en param√®tre.\n\n---\n\n## üìÑ License\n\nProjet de stage - Tous droits r√©serv√©s\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/mynftcollection\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"nft.gno","body":"package mynftcollection\n\nimport (\n\t\"chain/runtime\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry4\"\n)\n\n// Interface locale qui combine toutes les m√©thodes n√©cessaires\ntype NFTWithMetadata interface {\n\tgrc721.IGRC721\n\tgrc721.IGRC721MetadataOnchain\n\tMint(to address, tid grc721.TokenID) error\n\tSetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error\n\tGetter() grc721.NFTGetter\n}\n\nvar (\n\tnft         NFTWithMetadata\n\tnextTokenId = 1\n\tmyRealmAddr = runtime.CurrentRealm().Address()\n\tcollectionImageURL = \"https://i.imgflip.com/a6o5jb.jpg\"\n)\n\nfunc init() {\n\tnft = grc721.NewNFTWithMetadata(\"My NFT Collection\", \"MNFT\")\n}\n\n// Register registers this collection on the NFT registry\nfunc Register(_ realm) {\n\tdaoregistry4.RegisterCollection(\n\t\tmyRealmAddr,\n\t\t\"My NFT Collection\",\n\t\t\"MNFT\",\n\t\t\"art\",\n\t\t\"NFT Collection with full metadata support\",\n\t\t\"https://example.com\",\n\t\ttrue, // supportsMetadata\n\t\tnft.Getter(),\n\t)\n}\n\n// MintNFT - Mint a new NFT with metadata (image fixe d√©finie dans collectionImageURL)\nfunc MintNFT(_ realm, name string, description string) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\t// Mint the NFT\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\t// Set metadata avec l'image fixe de la collection\n\tmetadata := grc721.Metadata{\n\t\tName:        name,\n\t\tDescription: description,\n\t\tImage:       collectionImageURL, // Image fixe pour tous les NFTs\n\t\tAttributes:  []grc721.Trait{},\n\t}\n\n\terr = nft.SetTokenMetadata(tokenId, metadata)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\n// MintNFTWithAttributes - Mint NFT with custom attributes (image fixe d√©finie dans collectionImageURL)\nfunc MintNFTWithAttributes(\n\t_ realm,\n\tname string,\n\tdescription string,\n\ttraitTypes []string,\n\ttraitValues []string,\n) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\t// Mint the NFT\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\t// Build attributes\n\tvar attributes []grc721.Trait\n\tif len(traitTypes) != len(traitValues) {\n\t\tpanic(\"traitTypes and traitValues must have the same length\")\n\t}\n\n\tfor i := 0; i \u003c len(traitTypes); i++ {\n\t\tattributes = append(attributes, grc721.Trait{\n\t\t\tTraitType: traitTypes[i],\n\t\t\tValue:     traitValues[i],\n\t\t})\n\t}\n\n\t// Set metadata with attributes et image fixe\n\tmetadata := grc721.Metadata{\n\t\tName:        name,\n\t\tDescription: description,\n\t\tImage:       collectionImageURL, // Image fixe pour tous les NFTs\n\t\tAttributes:  attributes,\n\t}\n\n\terr = nft.SetTokenMetadata(tokenId, metadata)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\n// GetTokenMetadata - Get metadata for a token\nfunc GetTokenMetadata(tokenId string) string {\n\ttid := grc721.TokenID(tokenId)\n\n\tmetadata, err := nft.TokenMetadata(tid)\n\tif err != nil {\n\t\treturn \"Error: \" + err.Error()\n\t}\n\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", metadata.Name)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\\n\", metadata.Description)\n\toutput += ufmt.Sprintf(\"**Image:** %s\\n\\n\", metadata.Image)\n\n\tif len(metadata.Attributes) \u003e 0 {\n\t\toutput += \"## Attributes\\n\\n\"\n\t\tfor _, trait := range metadata.Attributes {\n\t\t\toutput += ufmt.Sprintf(\"- **%s:** %s\\n\", trait.TraitType, trait.Value)\n\t\t}\n\t}\n\n\treturn output\n}\n\n// SetApprovalForAll - Approve or revoke operator to manage all caller's NFTs\nfunc SetApprovalForAll(_ realm, operator address, approved bool) {\n\terr := nft.SetApprovalForAll(operator, approved)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\n// Getter - Returns the NFT getter function\nfunc Getter() grc721.NFTGetter {\n\treturn nft.Getter()\n}\n\n// GetCollectionInfo - Returns collection info\nfunc GetCollectionInfo() string {\n\toutput := \"# My NFT Collection\\n\\n\"\n\toutput += \"**Symbol:** MNFT\\n\"\n\toutput += \"**Total Supply:** \" + strconv.Itoa(nextTokenId-1) + \"\\n\"\n\toutput += \"**Realm Address:** \" + myRealmAddr.String() + \"\\n\"\n\toutput += \"**Supports Metadata:** Yes\\n\\n\"\n\toutput += \"This collection supports full onchain metadata including images, descriptions, and custom attributes.\\n\"\n\treturn output\n}\n\n// Render - Render the collection page\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn GetCollectionInfo()\n\t}\n\n\t// If path is a token ID, show token metadata\n\treturn GetTokenMetadata(path)\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"+jkjdLnYOM20kQa9nHCmhSmGZH4lp6BiJGiYVuhKH3He6bgnKdcyYqvkyO98T3etXfvTbwQSt3QN7jg/UQo9Bg=="}],"memo":""},"metadata":{"timestamp":"1765566369"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"gnomas","path":"gno.land/r/meeeshell222/gnomas","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/gnomas\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage gnomas"},{"name":"package.gno","body":"package gnomas\n\nimport (\n\t\"chain\"\n\t\"chain/runtime\"\n\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/moul/addrset\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/pausable\"\n\t\"gno.land/p/nt/seqid\"\n\t\"gno.land/r/leon/config\"\n\t_ \"gno.land/r/leon/hor\" // requested import (side-effect import; avoids unused import errors)\n)\n\nconst (\n\tmaxTitleLength       = 40\n\tmaxDescriptionLength = 140\n\tmaxCategoryLength    = 24\n\tmaxURLLength         = 180\n\n\t// Offset to make score sorting lexicographically safe even when scores go negative.\n\tscoreOffset = 1000000\n\n\tjudgeScoreMin = 0\n\tjudgeScoreMax = 10\n)\n\nvar (\n\texhibition *Exhibition\n\n\tOwnable  *ownable.Ownable\n\tPausable *pausable.Pausable\n)\n\ntype (\n\tExhibition struct {\n\t\titemCounter seqid.ID\n\t\tdescription string\n\n\t\t// Windows (block-based). 0 means \"not enforced\".\n\t\tsubmissionOpenBlock  int64\n\t\tsubmissionCloseBlock int64\n\t\tvotingOpenBlock      int64\n\t\tvotingCloseBlock     int64\n\n\t\t// Judges (addresses derived from runtime)\n\t\tjudges *addrset.Set\n\n\t\t// Primary store\n\t\titems *avl.Tree // pkgPath -\u003e *Item\n\n\t\t// Secondary indexes\n\t\titemsSortedByCreation  *avl.Tree // creationKey -\u003e *Item\n\t\titemsSortedByScore     *avl.Tree // scoreKey    -\u003e *Item\n\t\titemsSortedByUpvotes   *avl.Tree // voteKey     -\u003e *Item\n\t\titemsSortedByDownvotes *avl.Tree // voteKey     -\u003e *Item\n\t}\n\n\tItem struct {\n\t\tid          seqid.ID\n\t\ttitle       string\n\t\tdescription string\n\t\tcategory    string\n\t\tpreviewURL  string\n\n\t\tpkgpath  string\n\t\tblockNum int64\n\n\t\tstatus string // submitted | finalist | winner | disqualified\n\n\t\tupvote   *addrset.Set\n\t\tdownvote *addrset.Set\n\n\t\t// Judge scores: key (string) = judge address string; value (string) = score int as string\n\t\tjudgeScores *avl.Tree\n\t\tjudgeTotal  int\n\t}\n)\n\nfunc init() {\n\texhibition = \u0026Exhibition{\n\t\titems:                  avl.NewTree(),\n\t\titemsSortedByCreation:  avl.NewTree(),\n\t\titemsSortedByScore:     avl.NewTree(),\n\t\titemsSortedByUpvotes:   avl.NewTree(),\n\t\titemsSortedByDownvotes: avl.NewTree(),\n\t\tjudges:                 \u0026addrset.Set{},\n\t}\n\n\tOwnable = ownable.NewWithAddress(config.OwnableMain.Owner())\n\tPausable = pausable.NewFromOwnable(Ownable)\n}\n\n//\n// Admin / configuration\n//\n\nfunc ConfigureCompetition(cur realm, submissionOpen, submissionClose, votingOpen, votingClose int64, description string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif submissionOpen != 0 \u0026\u0026 submissionClose != 0 \u0026\u0026 submissionClose \u003c submissionOpen {\n\t\tpanic(\"invalid submission window\")\n\t}\n\tif votingOpen != 0 \u0026\u0026 votingClose != 0 \u0026\u0026 votingClose \u003c votingOpen {\n\t\tpanic(\"invalid voting window\")\n\t}\n\n\texhibition.submissionOpenBlock = submissionOpen\n\texhibition.submissionCloseBlock = submissionClose\n\texhibition.votingOpenBlock = votingOpen\n\texhibition.votingCloseBlock = votingClose\n\texhibition.description = description\n\n\tchain.Emit(\"CompetitionConfigured\")\n}\n\nfunc Pause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Pause()\n\tchain.Emit(\"Paused\")\n}\n\nfunc Unpause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Unpause()\n\tchain.Emit(\"Unpaused\")\n}\n\n// AddJudge adds the *caller* as a judge (owner-only).\nfunc AddJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Add(judge)\n\tchain.Emit(\"JudgeAdded\")\n}\n\n// RemoveJudge removes the *caller* from judges (owner-only).\nfunc RemoveJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Remove(judge)\n\tchain.Emit(\"JudgeRemoved\")\n}\n\n//\n// Submission\n//\n\n// SubmitDesign: called from within code of the submitting realm/package.\n// If you want to allow user realms, remove the submission.IsUser() guard.\nfunc SubmitDesign(cur realm, title, description, category, previewURL string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\n\tif exhibition.submissionOpenBlock != 0 \u0026\u0026 height \u003c exhibition.submissionOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.submissionCloseBlock != 0 \u0026\u0026 height \u003e exhibition.submissionCloseBlock {\n\t\treturn\n\t}\n\n\tsubmission := runtime.PreviousRealm()\n\tpkgpath := submission.PkgPath()\n\n\t// Require code realm submissions (remove if you want user submissions)\n\tif submission.IsUser() {\n\t\treturn\n\t}\n\n\tif exhibition.items.Has(pkgpath) {\n\t\treturn\n\t}\n\n\tif title == \"\" || len(title) \u003e maxTitleLength {\n\t\treturn\n\t}\n\tif len(description) \u003e maxDescriptionLength {\n\t\treturn\n\t}\n\tif category == \"\" || len(category) \u003e maxCategoryLength {\n\t\treturn\n\t}\n\tif previewURL != \"\" \u0026\u0026 len(previewURL) \u003e maxURLLength {\n\t\treturn\n\t}\n\n\tid := exhibition.itemCounter.Next()\n\titem := \u0026Item{\n\t\tid:          id,\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tcategory:    category,\n\t\tpreviewURL:  previewURL,\n\t\tpkgpath:     pkgpath,\n\t\tblockNum:    height,\n\t\tstatus:      \"submitted\",\n\t\tupvote:      \u0026addrset.Set{},\n\t\tdownvote:    \u0026addrset.Set{},\n\t\tjudgeScores: avl.NewTree(),\n\t\tjudgeTotal:  0,\n\t}\n\n\texhibition.items.Set(pkgpath, item)\n\n\texhibition.itemsSortedByCreation.Set(getCreationSortKey(item.blockNum, item.id), item)\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"DesignSubmitted\")\n}\n\n//\n// Voting\n//\n\nfunc Upvote(cur realm, pkgpath string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.upvote.Has(caller) {\n\t\tpanic(\"double upvote\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.upvote.Add(caller)\n\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Upvoted\")\n}\n\nfunc Downvote(cur realm, pkgpath string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.downvote.Has(caller) {\n\t\tpanic(\"double downvote\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.downvote.Add(caller)\n\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Downvoted\")\n}\n\n//\n// Judge scoring\n//\n\nfunc JudgeScore(cur realm, pkgpath string, score int) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\tif score \u003c judgeScoreMin || score \u003e judgeScoreMax {\n\t\tpanic(\"score out of range (0-10)\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tjudgeAddr := runtime.PreviousRealm().Address()\n\tif !exhibition.judges.Has(judgeAddr) {\n\t\tpanic(\"not a judge\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\tjudgeKey := judgeAddr.String() // avl keys must be strings\n\n\toldRaw, hadOld := item.judgeScores.Get(judgeKey)\n\tif hadOld {\n\t\toldInt, _ := strconv.Atoi(oldRaw.(string))\n\t\titem.judgeTotal -= oldInt\n\t}\n\n\titem.judgeScores.Set(judgeKey, strconv.Itoa(score))\n\titem.judgeTotal += score\n\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"JudgeScored\")\n}\n\n//\n// Status management\n//\n\nfunc SetStatus(cur realm, pkgpath, status string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif status != \"submitted\" \u0026\u0026 status != \"finalist\" \u0026\u0026 status != \"winner\" \u0026\u0026 status != \"disqualified\" {\n\t\tpanic(\"invalid status\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\titem.status = status\n\n\tchain.Emit(\"StatusUpdated\")\n}\n\n//\n// Admin delete\n//\n\nfunc Delete(cur realm, pkgpath string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\texhibition.itemsSortedByCreation.Remove(getCreationSortKey(item.blockNum, item.id))\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(finalScore(item), item.id))\n\n\texhibition.items.Remove(pkgpath)\n\n\tchain.Emit(\"Deleted\")\n}\n\n//\n// Helpers\n//\n\nfunc finalScore(item *Item) int {\n\treturn (item.upvote.Size() - item.downvote.Size()) + item.judgeTotal\n}\n\nfunc getVoteSortKey(votes int, id seqid.ID) string {\n\tvotesStr := strconv.Itoa(votes)\n\tpaddedVotes := strings.Repeat(\"0\", 10-len(votesStr)) + votesStr\n\treturn paddedVotes + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getScoreSortKey(score int, id seqid.ID) string {\n\tnormalized := score + scoreOffset\n\tif normalized \u003c 0 {\n\t\tnormalized = 0\n\t}\n\tscoreStr := strconv.Itoa(normalized)\n\tpadded := strings.Repeat(\"0\", 10-len(scoreStr)) + scoreStr\n\treturn padded + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getCreationSortKey(blockNum int64, id seqid.ID) string {\n\tblockNumStr := strconv.Itoa(int(blockNum))\n\tpaddedBlockNum := strings.Repeat(\"0\", 10-len(blockNumStr)) + blockNumStr\n\treturn paddedBlockNum + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"24975745","gas_fee":"24976ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"jSIXV9CpApYQYAkkuMWoV/2BToSiObUmGruLNJ9NooJ6I4gYz2P7p65GluyVb+njRZ61VM+jM9s+QeTjMApuCQ=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1765568279"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"gnomas1","path":"gno.land/r/meeeshell222/gnomas1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/gnomas1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage gnomas1"},{"name":"package.gno","body":"package gnomas1\n\nimport (\n\t\"chain\"\n\t\"chain/runtime\"\n\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/moul/addrset\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/pausable\"\n\t\"gno.land/p/nt/seqid\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/leon/config\"\n\n\t_ \"gno.land/r/leon/hor\" // requested import (side-effect import; avoids unused import errors)\n)\n\nconst (\n\tmaxTitleLength       = 40\n\tmaxDescriptionLength = 140\n\tmaxCategoryLength    = 24\n\tmaxURLLength         = 180\n\n\t// Offset to make score sorting lexicographically safe even when scores go negative.\n\tscoreOffset = 1000000\n\n\tjudgeScoreMin = 0\n\tjudgeScoreMax = 10\n)\n\nvar (\n\texhibition *Exhibition\n\n\tOwnable  *ownable.Ownable\n\tPausable *pausable.Pausable\n)\n\ntype (\n\tExhibition struct {\n\t\titemCounter seqid.ID\n\t\tdescription string\n\n\t\t// Windows (block-based). 0 means \"not enforced\".\n\t\tsubmissionOpenBlock  int64\n\t\tsubmissionCloseBlock int64\n\t\tvotingOpenBlock      int64\n\t\tvotingCloseBlock     int64\n\n\t\t// Judges (addresses derived from runtime)\n\t\tjudges *addrset.Set\n\n\t\t// Primary store\n\t\titems *avl.Tree // pkgPath -\u003e *Item\n\n\t\t// Secondary indexes\n\t\titemsSortedByCreation  *avl.Tree // creationKey -\u003e *Item\n\t\titemsSortedByScore     *avl.Tree // scoreKey    -\u003e *Item\n\t\titemsSortedByUpvotes   *avl.Tree // voteKey     -\u003e *Item\n\t\titemsSortedByDownvotes *avl.Tree // voteKey     -\u003e *Item\n\t}\n\n\tItem struct {\n\t\tid          seqid.ID\n\t\ttitle       string\n\t\tdescription string\n\t\tcategory    string\n\t\tpreviewURL  string\n\n\t\tpkgpath  string\n\t\tblockNum int64\n\n\t\tstatus string // submitted | finalist | winner | disqualified\n\n\t\tupvote   *addrset.Set\n\t\tdownvote *addrset.Set\n\n\t\t// Judge scores: key (string) = judge address string; value (string) = score int as string\n\t\tjudgeScores *avl.Tree\n\t\tjudgeTotal  int\n\t}\n)\n\nfunc init() {\n\texhibition = \u0026Exhibition{\n\t\titems:                  avl.NewTree(),\n\t\titemsSortedByCreation:  avl.NewTree(),\n\t\titemsSortedByScore:     avl.NewTree(),\n\t\titemsSortedByUpvotes:   avl.NewTree(),\n\t\titemsSortedByDownvotes: avl.NewTree(),\n\t\tjudges:                 \u0026addrset.Set{},\n\t}\n\n\tOwnable = ownable.NewWithAddress(config.OwnableMain.Owner())\n\tPausable = pausable.NewFromOwnable(Ownable)\n}\n\n//\n// Admin / configuration\n//\n\nfunc ConfigureCompetition(cur realm, submissionOpen, submissionClose, votingOpen, votingClose int64, description string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif submissionOpen != 0 \u0026\u0026 submissionClose != 0 \u0026\u0026 submissionClose \u003c submissionOpen {\n\t\tpanic(\"invalid submission window\")\n\t}\n\tif votingOpen != 0 \u0026\u0026 votingClose != 0 \u0026\u0026 votingClose \u003c votingOpen {\n\t\tpanic(\"invalid voting window\")\n\t}\n\n\texhibition.submissionOpenBlock = submissionOpen\n\texhibition.submissionCloseBlock = submissionClose\n\texhibition.votingOpenBlock = votingOpen\n\texhibition.votingCloseBlock = votingClose\n\texhibition.description = description\n\n\tchain.Emit(\"CompetitionConfigured\")\n}\n\nfunc Pause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Pause()\n\tchain.Emit(\"Paused\")\n}\n\nfunc Unpause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Unpause()\n\tchain.Emit(\"Unpaused\")\n}\n\n// AddJudge adds the *caller* as a judge (owner-only).\nfunc AddJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Add(judge)\n\tchain.Emit(\"JudgeAdded\")\n}\n\n// RemoveJudge removes the *caller* from judges (owner-only).\nfunc RemoveJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Remove(judge)\n\tchain.Emit(\"JudgeRemoved\")\n}\n\n//\n// Submission\n//\n\n// SubmitDesign: called from within code of the submitting realm/package.\n// If you want to allow user realms, remove the submission.IsUser() guard.\nfunc SubmitDesign(cur realm, title, description, category, previewURL string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\n\tif exhibition.submissionOpenBlock != 0 \u0026\u0026 height \u003c exhibition.submissionOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.submissionCloseBlock != 0 \u0026\u0026 height \u003e exhibition.submissionCloseBlock {\n\t\treturn\n\t}\n\n\tsubmission := runtime.PreviousRealm()\n\tpkgpath := submission.PkgPath()\n\n\t// Require code realm submissions (remove if you want user submissions)\n\tif submission.IsUser() {\n\t\treturn\n\t}\n\n\tif exhibition.items.Has(pkgpath) {\n\t\treturn\n\t}\n\n\tif title == \"\" || len(title) \u003e maxTitleLength {\n\t\treturn\n\t}\n\tif len(description) \u003e maxDescriptionLength {\n\t\treturn\n\t}\n\tif category == \"\" || len(category) \u003e maxCategoryLength {\n\t\treturn\n\t}\n\tif previewURL != \"\" \u0026\u0026 len(previewURL) \u003e maxURLLength {\n\t\treturn\n\t}\n\n\tid := exhibition.itemCounter.Next()\n\titem := \u0026Item{\n\t\tid:          id,\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tcategory:    category,\n\t\tpreviewURL:  previewURL,\n\t\tpkgpath:     pkgpath,\n\t\tblockNum:    height,\n\t\tstatus:      \"submitted\",\n\t\tupvote:      \u0026addrset.Set{},\n\t\tdownvote:    \u0026addrset.Set{},\n\t\tjudgeScores: avl.NewTree(),\n\t\tjudgeTotal:  0,\n\t}\n\n\texhibition.items.Set(pkgpath, item)\n\n\texhibition.itemsSortedByCreation.Set(getCreationSortKey(item.blockNum, item.id), item)\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"DesignSubmitted\")\n}\n\n//\n// Voting\n//\n\nfunc Upvote(cur realm, pkgpath string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.upvote.Has(caller) {\n\t\tpanic(\"double upvote\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.upvote.Add(caller)\n\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Upvoted\")\n}\n\nfunc Downvote(cur realm, pkgpath string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.downvote.Has(caller) {\n\t\tpanic(\"double downvote\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.downvote.Add(caller)\n\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Downvoted\")\n}\n\n//\n// Judge scoring\n//\n\nfunc JudgeScore(cur realm, pkgpath string, score int) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\tif score \u003c judgeScoreMin || score \u003e judgeScoreMax {\n\t\tpanic(\"score out of range (0-10)\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tjudgeAddr := runtime.PreviousRealm().Address()\n\tif !exhibition.judges.Has(judgeAddr) {\n\t\tpanic(\"not a judge\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\tjudgeKey := judgeAddr.String() // avl keys must be strings\n\n\toldRaw, hadOld := item.judgeScores.Get(judgeKey)\n\tif hadOld {\n\t\toldInt, _ := strconv.Atoi(oldRaw.(string))\n\t\titem.judgeTotal -= oldInt\n\t}\n\n\titem.judgeScores.Set(judgeKey, strconv.Itoa(score))\n\titem.judgeTotal += score\n\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"JudgeScored\")\n}\n\n//\n// Status management\n//\n\nfunc SetStatus(cur realm, pkgpath, status string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif status != \"submitted\" \u0026\u0026 status != \"finalist\" \u0026\u0026 status != \"winner\" \u0026\u0026 status != \"disqualified\" {\n\t\tpanic(\"invalid status\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\titem.status = status\n\n\tchain.Emit(\"StatusUpdated\")\n}\n\n//\n// Admin delete\n//\n\nfunc Delete(cur realm, pkgpath string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\texhibition.itemsSortedByCreation.Remove(getCreationSortKey(item.blockNum, item.id))\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(finalScore(item), item.id))\n\n\texhibition.items.Remove(pkgpath)\n\n\tchain.Emit(\"Deleted\")\n}\n\n//\n// Helpers\n//\n\nfunc finalScore(item *Item) int {\n\treturn (item.upvote.Size() - item.downvote.Size()) + item.judgeTotal\n}\n\nfunc getVoteSortKey(votes int, id seqid.ID) string {\n\tvotesStr := strconv.Itoa(votes)\n\tpaddedVotes := strings.Repeat(\"0\", 10-len(votesStr)) + votesStr\n\treturn paddedVotes + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getScoreSortKey(score int, id seqid.ID) string {\n\tnormalized := score + scoreOffset\n\tif normalized \u003c 0 {\n\t\tnormalized = 0\n\t}\n\tscoreStr := strconv.Itoa(normalized)\n\tpadded := strings.Repeat(\"0\", 10-len(scoreStr)) + scoreStr\n\treturn padded + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getCreationSortKey(blockNum int64, id seqid.ID) string {\n\tblockNumStr := strconv.Itoa(int(blockNum))\n\tpaddedBlockNum := strings.Repeat(\"0\", 10-len(blockNumStr)) + blockNumStr\n\treturn paddedBlockNum + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\n// Render is the GnoWeb entrypoint. It supports routes like :hall and :about.\nfunc Render(path string) string {\n\tswitch path {\n\tcase \"\", \"hall\":\n\t\treturn renderHall()\n\tcase \"about\":\n\t\treturn renderAbout()\n\tdefault:\n\t\treturn \"\u003cdiv\u003e\u003ch3\u003eNot found\u003c/h3\u003e\u003cp\u003eUnknown route: \u003ccode\u003e\" + htmlEscape(path) + \"\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\"\n\t}\n}\n\nfunc renderAbout() string {\n\tout := \"\"\n\tout += \"\u003cdiv style='font-family: ui-sans-serif, system-ui; max-width: 980px;'\u003e\"\n\tout += \"\u003ch2\u003egnomas ‚Äî Design Competition\u003c/h2\u003e\"\n\tif exhibition.description != \"\" {\n\t\tout += \"\u003cp\u003e\" + htmlEscape(exhibition.description) + \"\u003c/p\u003e\"\n\t}\n\tout += \"\u003cp\u003e\u003ca href=':hall'\u003eHall\u003c/a\u003e\u003c/p\u003e\"\n\tout += \"\u003c/div\u003e\"\n\treturn out\n}\n\nfunc renderHall() string {\n\tout := \"\"\n\tout += \"\u003cdiv style='font-family: ui-sans-serif, system-ui; max-width: 980px;'\u003e\"\n\tout += \"\u003ch2\u003eDesign Competition ‚Äî Hall\u003c/h2\u003e\"\n\tout += \"\u003cp\u003e\u003ca href=':hall'\u003eHall\u003c/a\u003e | \u003ca href=':about'\u003eAbout\u003c/a\u003e\u003c/p\u003e\"\n\n\tif exhibition.description != \"\" {\n\t\tout += \"\u003cp\u003e\" + htmlEscape(exhibition.description) + \"\u003c/p\u003e\"\n\t}\n\n\tout += \"\u003cp\u003e\u003csmall\u003eSubmissions: \" + ufmt.Sprintf(\"%d\", exhibition.items.Size()) + \"\u003c/small\u003e\u003c/p\u003e\"\n\n\tout += \"\u003ctable style='width:100%; border-collapse: collapse;'\u003e\"\n\tout += \"\u003cthead\u003e\u003ctr\u003e\"\n\tout += th(\"Rank\")\n\tout += th(\"Title\")\n\tout += th(\"Category\")\n\tout += th(\"Description\")\n\tout += th(\"Score\")\n\tout += th(\"Votes\")\n\tout += th(\"Preview\")\n\tout += th(\"PkgPath\")\n\tout += th(\"Actions\")\n\tout += \"\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\"\n\n\t// itemsSortedByScore is lexicographically ascending by key; show highest first by iterating backwards.\n\tn := exhibition.itemsSortedByScore.Size()\n\trank := 1\n\tif n \u003e 0 {\n\t\tfor i := n - 1; i \u003e= 0; i-- {\n\t\t\t_, v := exhibition.itemsSortedByScore.GetByIndex(i)\n\t\t\titem := v.(*Item)\n\n\t\t\tup := item.upvote.Size()\n\t\t\tdown := item.downvote.Size()\n\t\t\tscore := finalScore(item)\n\n\t\t\tout += \"\u003ctr style='border-top: 1px solid #e5e7eb;'\u003e\"\n\t\t\tout += td(ufmt.Sprintf(\"%d\", rank))\n\t\t\tout += td(\"\u003cstrong\u003e\" + htmlEscape(item.title) + \"\u003c/strong\u003e\")\n\t\t\tout += td(htmlEscape(item.category))\n\t\t\tout += td(htmlEscape(item.description))\n\t\t\tout += td(ufmt.Sprintf(\"%d\", score))\n\t\t\tout += td(ufmt.Sprintf(\"‚è∂ %d \u0026nbsp; ‚è∑ %d\", up, down))\n\n\t\t\tif item.previewURL != \"\" {\n\t\t\t\tout += td(\"\u003ca href='\" + htmlEscapeAttr(item.previewURL) + \"' target='_blank'\u003elink\u003c/a\u003e\")\n\t\t\t} else {\n\t\t\t\tout += td(\"\u003cspan style='color:#6b7280;'\u003e‚Äî\u003c/span\u003e\")\n\t\t\t}\n\n\t\t\tout += td(\"\u003ccode\u003e\" + htmlEscape(item.pkgpath) + \"\u003c/code\u003e\")\n\n\t\t\t// Match leon/hor pattern: link to help+execute page\n\t\t\tupHref := \"$help\u0026func=Upvote\u0026pkgpath=\" + urlEscapeLite(item.pkgpath)\n\t\t\tdownHref := \"$help\u0026func=Downvote\u0026pkgpath=\" + urlEscapeLite(item.pkgpath)\n\n\t\t\tout += td(\"\u003ca href='\" + upHref + \"'\u003eUpvote\u003c/a\u003e \u0026nbsp; \u003ca href='\" + downHref + \"'\u003eDownvote\u003c/a\u003e\")\n\t\t\tout += \"\u003c/tr\u003e\"\n\n\t\t\trank++\n\n\t\t\tif i == 0 {\n\t\t\t\tbreak // prevent i-- underflow on ints\n\t\t\t}\n\t\t}\n\t}\n\n\tout += \"\u003c/tbody\u003e\u003c/table\u003e\"\n\tout += \"\u003c/div\u003e\"\n\treturn out\n}\n\nfunc th(s string) string {\n\treturn \"\u003cth style='text-align:left; padding:10px 8px; font-size:12px; color:#374151;'\u003e\" + htmlEscape(s) + \"\u003c/th\u003e\"\n}\n\nfunc td(s string) string {\n\treturn \"\u003ctd style='vertical-align:top; padding:10px 8px; font-size:13px;'\u003e\" + s + \"\u003c/td\u003e\"\n}\n\n// Minimal HTML escaping.\nfunc htmlEscape(s string) string {\n\ts = strings.ReplaceAll(s, \"\u0026\", \"\u0026amp;\")\n\ts = strings.ReplaceAll(s, \"\u003c\", \"\u0026lt;\")\n\ts = strings.ReplaceAll(s, \"\u003e\", \"\u0026gt;\")\n\ts = strings.ReplaceAll(s, \"\\\"\", \"\u0026quot;\")\n\ts = strings.ReplaceAll(s, \"'\", \"\u0026#39;\")\n\treturn s\n}\n\nfunc htmlEscapeAttr(s string) string {\n\treturn htmlEscape(s)\n}\n\n// Lightweight URL escaping for pkgpath in query strings.\nfunc urlEscapeLite(s string) string {\n\ts = strings.ReplaceAll(s, \"%\", \"%25\")\n\ts = strings.ReplaceAll(s, \" \", \"%20\")\n\ts = strings.ReplaceAll(s, \"?\", \"%3F\")\n\ts = strings.ReplaceAll(s, \"\u0026\", \"%26\")\n\ts = strings.ReplaceAll(s, \"=\", \"%3D\")\n\ts = strings.ReplaceAll(s, \"#\", \"%23\")\n\ts = strings.ReplaceAll(s, \":\", \"%3A\")\n\ts = strings.ReplaceAll(s, \"/\", \"%2F\")\n\treturn s\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"25683196","gas_fee":"25684ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"zaQ8QFxh6WTulKo8pSTPmRWxsHnOHvgHG/lZJxxuAPJP8bfDqNeQsrN71K/8pK/4EUO+2q6A6FIwiiYfhQz8Cw=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1765569098"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"gnomas11","path":"gno.land/r/meeeshell222/gnomas11","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/gnomas11\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage gnomas11"},{"name":"package.gno","body":"package gnomas11\n\nimport (\n\t\"chain\"\n\t\"chain/runtime\"\n\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/moul/addrset\"\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/pausable\"\n\t\"gno.land/p/nt/seqid\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/leon/config\"\n\n\t_ \"gno.land/r/leon/hor\" // requested import (side-effect import; avoids unused import errors)\n)\n\nconst (\n\tmaxTitleLength       = 40\n\tmaxDescriptionLength = 140\n\tmaxCategoryLength    = 24\n\tmaxURLLength         = 180\n\n\t// Offset to make score sorting lexicographically safe even when scores go negative.\n\tscoreOffset = 1000000\n\n\tjudgeScoreMin = 0\n\tjudgeScoreMax = 10\n)\n\nvar (\n\texhibition *Exhibition\n\n\tOwnable  *ownable.Ownable\n\tPausable *pausable.Pausable\n)\n\ntype (\n\tExhibition struct {\n\t\titemCounter seqid.ID\n\t\tdescription string\n\n\t\t// Windows (block-based). 0 means \"not enforced\".\n\t\tsubmissionOpenBlock  int64\n\t\tsubmissionCloseBlock int64\n\t\tvotingOpenBlock      int64\n\t\tvotingCloseBlock     int64\n\n\t\t// Judges (addresses derived from runtime)\n\t\tjudges *addrset.Set\n\n\t\t// Primary store\n\t\titems *avl.Tree // pkgPath -\u003e *Item\n\n\t\t// Secondary indexes\n\t\titemsSortedByCreation  *avl.Tree // creationKey -\u003e *Item\n\t\titemsSortedByScore     *avl.Tree // scoreKey    -\u003e *Item\n\t\titemsSortedByUpvotes   *avl.Tree // voteKey     -\u003e *Item\n\t\titemsSortedByDownvotes *avl.Tree // voteKey     -\u003e *Item\n\t}\n\n\tItem struct {\n\t\tid          seqid.ID\n\t\ttitle       string\n\t\tdescription string\n\t\tcategory    string\n\t\tpreviewURL  string\n\n\t\tpkgpath  string\n\t\tblockNum int64\n\n\t\tstatus string // submitted | finalist | winner | disqualified\n\n\t\tupvote   *addrset.Set\n\t\tdownvote *addrset.Set\n\n\t\t// Judge scores: key (string) = judge address string; value (string) = score int as string\n\t\tjudgeScores *avl.Tree\n\t\tjudgeTotal  int\n\t}\n)\n\nfunc init() {\n\texhibition = \u0026Exhibition{\n\t\titems:                  avl.NewTree(),\n\t\titemsSortedByCreation:  avl.NewTree(),\n\t\titemsSortedByScore:     avl.NewTree(),\n\t\titemsSortedByUpvotes:   avl.NewTree(),\n\t\titemsSortedByDownvotes: avl.NewTree(),\n\t\tjudges:                 \u0026addrset.Set{},\n\t}\n\n\tOwnable = ownable.NewWithAddress(config.OwnableMain.Owner())\n\tPausable = pausable.NewFromOwnable(Ownable)\n}\n\n//\n// Admin / configuration\n//\n\nfunc ConfigureCompetition(cur realm, submissionOpen, submissionClose, votingOpen, votingClose int64, description string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif submissionOpen != 0 \u0026\u0026 submissionClose != 0 \u0026\u0026 submissionClose \u003c submissionOpen {\n\t\tpanic(\"invalid submission window\")\n\t}\n\tif votingOpen != 0 \u0026\u0026 votingClose != 0 \u0026\u0026 votingClose \u003c votingOpen {\n\t\tpanic(\"invalid voting window\")\n\t}\n\n\texhibition.submissionOpenBlock = submissionOpen\n\texhibition.submissionCloseBlock = submissionClose\n\texhibition.votingOpenBlock = votingOpen\n\texhibition.votingCloseBlock = votingClose\n\texhibition.description = description\n\n\tchain.Emit(\"CompetitionConfigured\")\n}\n\nfunc Pause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Pause()\n\tchain.Emit(\"Paused\")\n}\n\nfunc Unpause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Unpause()\n\tchain.Emit(\"Unpaused\")\n}\n\n// AddJudge adds the *caller* as a judge (owner-only).\nfunc AddJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Add(judge)\n\tchain.Emit(\"JudgeAdded\")\n}\n\n// RemoveJudge removes the *caller* from judges (owner-only).\nfunc RemoveJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Remove(judge)\n\tchain.Emit(\"JudgeRemoved\")\n}\n\n//\n// Submission\n//\n\n// SubmitDesign: called from within code of the submitting realm/package.\n// If you want to allow user realms, remove the submission.IsUser() guard.\nfunc SubmitDesign(cur realm, title, description, category, previewURL string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\n\tif exhibition.submissionOpenBlock != 0 \u0026\u0026 height \u003c exhibition.submissionOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.submissionCloseBlock != 0 \u0026\u0026 height \u003e exhibition.submissionCloseBlock {\n\t\treturn\n\t}\n\n\tsubmission := runtime.PreviousRealm()\n\tpkgpath := submission.PkgPath()\n\n\t// Require code realm submissions (remove if you want user submissions)\n\tif submission.IsUser() {\n\t\treturn\n\t}\n\n\tif exhibition.items.Has(pkgpath) {\n\t\treturn\n\t}\n\n\tif title == \"\" || len(title) \u003e maxTitleLength {\n\t\treturn\n\t}\n\tif len(description) \u003e maxDescriptionLength {\n\t\treturn\n\t}\n\tif category == \"\" || len(category) \u003e maxCategoryLength {\n\t\treturn\n\t}\n\tif previewURL != \"\" \u0026\u0026 len(previewURL) \u003e maxURLLength {\n\t\treturn\n\t}\n\n\tid := exhibition.itemCounter.Next()\n\titem := \u0026Item{\n\t\tid:          id,\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tcategory:    category,\n\t\tpreviewURL:  previewURL,\n\t\tpkgpath:     pkgpath,\n\t\tblockNum:    height,\n\t\tstatus:      \"submitted\",\n\t\tupvote:      \u0026addrset.Set{},\n\t\tdownvote:    \u0026addrset.Set{},\n\t\tjudgeScores: avl.NewTree(),\n\t\tjudgeTotal:  0,\n\t}\n\n\texhibition.items.Set(pkgpath, item)\n\n\texhibition.itemsSortedByCreation.Set(getCreationSortKey(item.blockNum, item.id), item)\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"DesignSubmitted\")\n}\n\n//\n// Voting\n//\n\nfunc Upvote(cur realm, pkgpath string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.upvote.Has(caller) {\n\t\tpanic(\"double upvote\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.upvote.Add(caller)\n\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Upvoted\")\n}\n\nfunc Downvote(cur realm, pkgpath string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.downvote.Has(caller) {\n\t\tpanic(\"double downvote\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.downvote.Add(caller)\n\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Downvoted\")\n}\n\n//\n// Judge scoring\n//\n\nfunc JudgeScore(cur realm, pkgpath string, score int) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\tif score \u003c judgeScoreMin || score \u003e judgeScoreMax {\n\t\tpanic(\"score out of range (0-10)\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tjudgeAddr := runtime.PreviousRealm().Address()\n\tif !exhibition.judges.Has(judgeAddr) {\n\t\tpanic(\"not a judge\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\tjudgeKey := judgeAddr.String() // avl keys must be strings\n\n\toldRaw, hadOld := item.judgeScores.Get(judgeKey)\n\tif hadOld {\n\t\toldInt, _ := strconv.Atoi(oldRaw.(string))\n\t\titem.judgeTotal -= oldInt\n\t}\n\n\titem.judgeScores.Set(judgeKey, strconv.Itoa(score))\n\titem.judgeTotal += score\n\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"JudgeScored\")\n}\n\n//\n// Status management\n//\n\nfunc SetStatus(cur realm, pkgpath, status string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif status != \"submitted\" \u0026\u0026 status != \"finalist\" \u0026\u0026 status != \"winner\" \u0026\u0026 status != \"disqualified\" {\n\t\tpanic(\"invalid status\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\titem.status = status\n\n\tchain.Emit(\"StatusUpdated\")\n}\n\n//\n// Admin delete\n//\n\nfunc Delete(cur realm, pkgpath string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\texhibition.itemsSortedByCreation.Remove(getCreationSortKey(item.blockNum, item.id))\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(finalScore(item), item.id))\n\n\texhibition.items.Remove(pkgpath)\n\n\tchain.Emit(\"Deleted\")\n}\n\n//\n// Helpers\n//\n\nfunc finalScore(item *Item) int {\n\treturn (item.upvote.Size() - item.downvote.Size()) + item.judgeTotal\n}\n\nfunc getVoteSortKey(votes int, id seqid.ID) string {\n\tvotesStr := strconv.Itoa(votes)\n\tpaddedVotes := strings.Repeat(\"0\", 10-len(votesStr)) + votesStr\n\treturn paddedVotes + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getScoreSortKey(score int, id seqid.ID) string {\n\tnormalized := score + scoreOffset\n\tif normalized \u003c 0 {\n\t\tnormalized = 0\n\t}\n\tscoreStr := strconv.Itoa(normalized)\n\tpadded := strings.Repeat(\"0\", 10-len(scoreStr)) + scoreStr\n\treturn padded + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getCreationSortKey(blockNum int64, id seqid.ID) string {\n\tblockNumStr := strconv.Itoa(int(blockNum))\n\tpaddedBlockNum := strings.Repeat(\"0\", 10-len(blockNumStr)) + blockNumStr\n\treturn paddedBlockNum + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\n// Render is the GnoWeb entrypoint.\n// Root-only: renders the competition directly at /r/.../gnomas11.\n// No :hall routes, no query parsing.\nfunc Render(path string) string {\n\tout := md.H1(\"gnomas11 ‚Äî Design Competition\\n\\n\")\n\n\tif exhibition.description != \"\" {\n\t\tout += ufmt.Sprintf(\"%s\\n\\n\", exhibition.description)\n\t}\n\n\tout += ufmt.Sprintf(\"Total submissions: **%d**\\n\\n\", exhibition.items.Size())\n\n\tif exhibition.items.Size() == 0 {\n\t\tout += \"No submissions yet.\\n\\n\"\n\t\treturn out\n\t}\n\n\t// Sorted by score index; keys are padded ascending -\u003e show highest first by iterating backwards.\n\ttree := exhibition.itemsSortedByScore\n\tn := tree.Size()\n\trank := 1\n\n\tfor i := n - 1; i \u003e= 0; i-- {\n\t\t_, v := tree.GetByIndex(i)\n\t\titem := v.(*Item)\n\n\t\tout += renderItemCard(item, rank)\n\t\trank++\n\n\t\tif i == 0 {\n\t\t\tbreak // prevent int underflow\n\t\t}\n\t}\n\n\treturn out\n}\n\nfunc renderItemCard(item *Item, rank int) string {\n\tout := \"\"\n\tout += md.H3(ufmt.Sprintf(\"%d. %s\\n\\n\", rank, item.title))\n\n\tif item.description == \"\" {\n\t\tout += \"_No description provided._\\n\\n\"\n\t} else {\n\t\tout += ufmt.Sprintf(\"%s\\n\\n\", item.description)\n\t}\n\n\tout += ufmt.Sprintf(\"Category: **%s**\\n\\n\", item.category)\n\tout += ufmt.Sprintf(\"PkgPath: `%s`\\n\\n\", item.pkgpath)\n\n\tscore := finalScore(item)\n\tout += ufmt.Sprintf(\"Score: **%d** | Votes: **‚è∂ %d - ‚è∑ %d**\\n\\n\",\n\t\tscore, item.upvote.Size(), item.downvote.Size(),\n\t)\n\n\tif item.previewURL != \"\" {\n\t\tout += md.Link(\"Preview\", item.previewURL) + \"\\n\\n\"\n\t}\n\n\t// Transaction links (same pattern as leon/hor)\n\tout += md.Bold(ufmt.Sprintf(\"[%d](%s) - [%d](%s)\",\n\t\titem.upvote.Size(), txlink.Call(\"Upvote\", \"pkgpath\", item.pkgpath),\n\t\titem.downvote.Size(), txlink.Call(\"Downvote\", \"pkgpath\", item.pkgpath),\n\t))\n\tout += \"\\n\\n\"\n\tout += md.HorizontalRule()\n\n\treturn out\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"26132917","gas_fee":"26133ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"VqyVDeW9SBsAW7bc7aoeSajjOWCieb863eEglrfwEGYZmz9IAzG5x96nazbkA9G7WHmL0oYXzh+XJgrYyNx0Cg=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1765569937"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/gnomas11","func":"SubmitDesign","args":["","","",""]}],"fee":{"gas_wanted":"855787","gas_fee":"856ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"TD9OqLhunOxymT0/3++DUDTT3yC+32PiuBb1dPiaYm4kc0wW1xgWge9Mok7DH0nC4wZicitsowbC6vs7x44zBQ=="}],"memo":""},"metadata":{"timestamp":"1765570093"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/gnomas11","func":"SubmitDesign","args":["","","",""]}],"fee":{"gas_wanted":"855787","gas_fee":"856ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"TD9OqLhunOxymT0/3++DUDTT3yC+32PiuBb1dPiaYm4kc0wW1xgWge9Mok7DH0nC4wZicitsowbC6vs7x44zBQ=="}],"memo":""},"metadata":{"timestamp":"1765570234"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynftcollection","func":"SetApprovalForAll","args":["g1n2wl4g4gz9pcspsppnyly75avdc49wswzvz5z3","true"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"5Da17YYiCwNR18wWrMs3v7gaqUbSwSo2PMn13+eWCJ0jmGBqxMJil2lyt0TcXeDwOQhdcTdnjqPxebxViUg1AQ=="}],"memo":""},"metadata":{"timestamp":"1765571269"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao3","func":"JoinDAO"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"tJQ56wZ19dYHj8HAQj0Z3R4in9nBP3NPfklwffuMs1A2vIFMZoYlRsGkSGC/m04jlnQxqn0HopEQInc/uMIZCA=="}],"memo":""},"metadata":{"timestamp":"1765571349"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao3","func":"ProposeApproveCollection","args":["g1c53ppfcgjq65e7gltqusauzh6w4cawvtr7qk90","tkt","tkt"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6vrBfQ7Z4JKZZDqHziNR7x6p/xb1ZDEoeOyp4GwrBgeTHsAGVuedcVxnX3g7jYiXQ6tPxBr/ei1a5pJW6AIlCQ=="}],"memo":""},"metadata":{"timestamp":"1765571380"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765571435"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao3","func":"Vote","args":["1","yes"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Fzkyp7sWs3+V5K/OrJGOm/cPsigNE7HqsrHS2B9i0xrp/R84WwgQyQ1R7OUYpFnT6/aC7OVKTnDg/G/yMT+2Bw=="}],"memo":""},"metadata":{"timestamp":"1765571445"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"gnomas15","path":"gno.land/r/meeeshell222/gnomas15","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/gnomas15\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage gnomas15"},{"name":"package.gno","body":"package gnomas15\n\nimport (\n\t\"chain\"\n\t\"chain/runtime\"\n\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/moul/addrset\"\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/pausable\"\n\t\"gno.land/p/nt/seqid\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/leon/config\"\n\n\t_ \"gno.land/r/leon/hor\" // requested import (side-effect import; avoids unused import errors)\n)\n\nconst (\n\tmaxTitleLength       = 40\n\tmaxDescriptionLength = 140\n\tmaxCategoryLength    = 24\n\tmaxURLLength         = 180\n\n\t// Offset to make score sorting lexicographically safe even when scores go negative.\n\tscoreOffset = 1000000\n\n\tjudgeScoreMin = 0\n\tjudgeScoreMax = 10\n)\n\nvar (\n\texhibition *Exhibition\n\n\tOwnable  *ownable.Ownable\n\tPausable *pausable.Pausable\n)\n\ntype (\n\tExhibition struct {\n\t\titemCounter seqid.ID\n\t\tdescription string\n\n\t\t// Windows (block-based). 0 means \"not enforced\".\n\t\tsubmissionOpenBlock  int64\n\t\tsubmissionCloseBlock int64\n\t\tvotingOpenBlock      int64\n\t\tvotingCloseBlock     int64\n\n\t\t// Judges (addresses derived from runtime)\n\t\tjudges *addrset.Set\n\n\t\t// Primary store\n\t\titems *avl.Tree // pkgPath -\u003e *Item\n\n\t\t// Secondary indexes\n\t\titemsSortedByCreation  *avl.Tree // creationKey -\u003e *Item\n\t\titemsSortedByScore     *avl.Tree // scoreKey    -\u003e *Item\n\t\titemsSortedByUpvotes   *avl.Tree // voteKey     -\u003e *Item\n\t\titemsSortedByDownvotes *avl.Tree // voteKey     -\u003e *Item\n\t}\n\n\tItem struct {\n\t\tid          seqid.ID\n\t\ttitle       string\n\t\tdescription string\n\t\tcategory    string\n\t\tpreviewURL  string\n\n\t\tpkgpath  string\n\t\tblockNum int64\n\n\t\tstatus string // submitted | finalist | winner | disqualified\n\n\t\tupvote   *addrset.Set\n\t\tdownvote *addrset.Set\n\n\t\t// Judge scores: key (string) = judge address string; value (string) = score int as string\n\t\tjudgeScores *avl.Tree\n\t\tjudgeTotal  int\n\t}\n)\n\nfunc init() {\n\texhibition = \u0026Exhibition{\n\t\titems:                  avl.NewTree(),\n\t\titemsSortedByCreation:  avl.NewTree(),\n\t\titemsSortedByScore:     avl.NewTree(),\n\t\titemsSortedByUpvotes:   avl.NewTree(),\n\t\titemsSortedByDownvotes: avl.NewTree(),\n\t\tjudges:                 \u0026addrset.Set{},\n\t}\n\n\tOwnable = ownable.NewWithAddress(config.OwnableMain.Owner())\n\tPausable = pausable.NewFromOwnable(Ownable)\n}\n\n//\n// Admin / configuration\n//\n\nfunc ConfigureCompetition(cur realm, submissionOpen, submissionClose, votingOpen, votingClose int64, description string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif submissionOpen != 0 \u0026\u0026 submissionClose != 0 \u0026\u0026 submissionClose \u003c submissionOpen {\n\t\tpanic(\"invalid submission window\")\n\t}\n\tif votingOpen != 0 \u0026\u0026 votingClose != 0 \u0026\u0026 votingClose \u003c votingOpen {\n\t\tpanic(\"invalid voting window\")\n\t}\n\n\texhibition.submissionOpenBlock = submissionOpen\n\texhibition.submissionCloseBlock = submissionClose\n\texhibition.votingOpenBlock = votingOpen\n\texhibition.votingCloseBlock = votingClose\n\texhibition.description = description\n\n\tchain.Emit(\"CompetitionConfigured\")\n}\n\nfunc Pause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Pause()\n\tchain.Emit(\"Paused\")\n}\n\nfunc Unpause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Unpause()\n\tchain.Emit(\"Unpaused\")\n}\n\n// AddJudge adds the *caller* as a judge (owner-only).\nfunc AddJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Add(judge)\n\tchain.Emit(\"JudgeAdded\")\n}\n\n// RemoveJudge removes the *caller* from judges (owner-only).\nfunc RemoveJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Remove(judge)\n\tchain.Emit(\"JudgeRemoved\")\n}\n\n//\n// Submission\n//\n\n// SubmitDesign: called from within code of the submitting realm/package.\n// If you want to allow user realms, remove the submission.IsUser() guard.\nfunc SubmitDesign(cur realm, title, description, category, previewURL string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\n\tif exhibition.submissionOpenBlock != 0 \u0026\u0026 height \u003c exhibition.submissionOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.submissionCloseBlock != 0 \u0026\u0026 height \u003e exhibition.submissionCloseBlock {\n\t\treturn\n\t}\n\n\tsubmission := runtime.PreviousRealm()\n\tpkgpath := submission.PkgPath()\n\n\t// Require code realm submissions (remove if you want user submissions)\n\tif submission.IsUser() {\n\t\treturn\n\t}\n\n\tif exhibition.items.Has(pkgpath) {\n\t\treturn\n\t}\n\n\tif title == \"\" || len(title) \u003e maxTitleLength {\n\t\treturn\n\t}\n\tif len(description) \u003e maxDescriptionLength {\n\t\treturn\n\t}\n\tif category == \"\" || len(category) \u003e maxCategoryLength {\n\t\treturn\n\t}\n\tif previewURL != \"\" \u0026\u0026 len(previewURL) \u003e maxURLLength {\n\t\treturn\n\t}\n\n\tid := exhibition.itemCounter.Next()\n\titem := \u0026Item{\n\t\tid:          id,\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tcategory:    category,\n\t\tpreviewURL:  previewURL,\n\t\tpkgpath:     pkgpath,\n\t\tblockNum:    height,\n\t\tstatus:      \"submitted\",\n\t\tupvote:      \u0026addrset.Set{},\n\t\tdownvote:    \u0026addrset.Set{},\n\t\tjudgeScores: avl.NewTree(),\n\t\tjudgeTotal:  0,\n\t}\n\n\texhibition.items.Set(pkgpath, item)\n\n\texhibition.itemsSortedByCreation.Set(getCreationSortKey(item.blockNum, item.id), item)\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"DesignSubmitted\")\n}\n\n//\n// Voting\n//\n\nfunc Upvote(cur realm, pkgpath string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.upvote.Has(caller) {\n\t\tpanic(\"double upvote\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.upvote.Add(caller)\n\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Upvoted\")\n}\n\nfunc Downvote(cur realm, pkgpath string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.downvote.Has(caller) {\n\t\tpanic(\"double downvote\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.downvote.Add(caller)\n\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Downvoted\")\n}\n\n//\n// Judge scoring\n//\n\nfunc JudgeScore(cur realm, pkgpath string, score int) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\tif score \u003c judgeScoreMin || score \u003e judgeScoreMax {\n\t\tpanic(\"score out of range (0-10)\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tjudgeAddr := runtime.PreviousRealm().Address()\n\tif !exhibition.judges.Has(judgeAddr) {\n\t\tpanic(\"not a judge\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\tjudgeKey := judgeAddr.String() // avl keys must be strings\n\n\toldRaw, hadOld := item.judgeScores.Get(judgeKey)\n\tif hadOld {\n\t\toldInt, _ := strconv.Atoi(oldRaw.(string))\n\t\titem.judgeTotal -= oldInt\n\t}\n\n\titem.judgeScores.Set(judgeKey, strconv.Itoa(score))\n\titem.judgeTotal += score\n\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"JudgeScored\")\n}\n\n//\n// Status management\n//\n\nfunc SetStatus(cur realm, pkgpath, status string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif status != \"submitted\" \u0026\u0026 status != \"finalist\" \u0026\u0026 status != \"winner\" \u0026\u0026 status != \"disqualified\" {\n\t\tpanic(\"invalid status\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\titem.status = status\n\n\tchain.Emit(\"StatusUpdated\")\n}\n\n//\n// Admin delete\n//\n\nfunc Delete(cur realm, pkgpath string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\n\trawItem, ok := exhibition.items.Get(pkgpath)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\texhibition.itemsSortedByCreation.Remove(getCreationSortKey(item.blockNum, item.id))\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(finalScore(item), item.id))\n\n\texhibition.items.Remove(pkgpath)\n\n\tchain.Emit(\"Deleted\")\n}\n\n//\n// Helpers\n//\n\nfunc finalScore(item *Item) int {\n\treturn (item.upvote.Size() - item.downvote.Size()) + item.judgeTotal\n}\n\nfunc getVoteSortKey(votes int, id seqid.ID) string {\n\tvotesStr := strconv.Itoa(votes)\n\tpaddedVotes := strings.Repeat(\"0\", 10-len(votesStr)) + votesStr\n\treturn paddedVotes + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getScoreSortKey(score int, id seqid.ID) string {\n\tnormalized := score + scoreOffset\n\tif normalized \u003c 0 {\n\t\tnormalized = 0\n\t}\n\tscoreStr := strconv.Itoa(normalized)\n\tpadded := strings.Repeat(\"0\", 10-len(scoreStr)) + scoreStr\n\treturn padded + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getCreationSortKey(blockNum int64, id seqid.ID) string {\n\tblockNumStr := strconv.Itoa(int(blockNum))\n\tpaddedBlockNum := strings.Repeat(\"0\", 10-len(blockNumStr)) + blockNumStr\n\treturn paddedBlockNum + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\n// Render is the GnoWeb entrypoint.\n// Root-only: renders the competition directly at /r/.../gnomas11.\n// No :hall routes, no query parsing.\nfunc Render(path string) string {\n\tout := md.H1(\"gnomas11 ‚Äî Design Competition\\n\\n\")\n\n\tif exhibition.description != \"\" {\n\t\tout += ufmt.Sprintf(\"%s\\n\\n\", exhibition.description)\n\t}\n\n\tout += ufmt.Sprintf(\"Total submissions: **%d**\\n\\n\", exhibition.items.Size())\n\n\tif exhibition.items.Size() == 0 {\n\t\tout += \"No submissions yet.\\n\\n\"\n\t\treturn out\n\t}\n\n\t// Sorted by score index; keys are padded ascending -\u003e show highest first by iterating backwards.\n\ttree := exhibition.itemsSortedByScore\n\tn := tree.Size()\n\trank := 1\n\n\tfor i := n - 1; i \u003e= 0; i-- {\n\t\t_, v := tree.GetByIndex(i)\n\t\titem := v.(*Item)\n\n\t\tout += renderItemCard(item, rank)\n\t\trank++\n\n\t\tif i == 0 {\n\t\t\tbreak // prevent int underflow\n\t\t}\n\t}\n\n\treturn out\n}\n\nfunc renderItemCard(item *Item, rank int) string {\n\tout := \"\"\n\tout += md.H3(ufmt.Sprintf(\"%d. %s\\n\\n\", rank, item.title))\n\n\tif item.description == \"\" {\n\t\tout += \"_No description provided._\\n\\n\"\n\t} else {\n\t\tout += ufmt.Sprintf(\"%s\\n\\n\", item.description)\n\t}\n\n\tout += ufmt.Sprintf(\"Category: **%s**\\n\\n\", item.category)\n\tout += ufmt.Sprintf(\"PkgPath: `%s`\\n\\n\", item.pkgpath)\n\n\tscore := finalScore(item)\n\tout += ufmt.Sprintf(\"Score: **%d** | Votes: **‚è∂ %d - ‚è∑ %d**\\n\\n\",\n\t\tscore, item.upvote.Size(), item.downvote.Size(),\n\t)\n\n\tif item.previewURL != \"\" {\n\t\tout += md.Link(\"Preview\", item.previewURL) + \"\\n\\n\"\n\t}\n\n\t// Transaction links (same pattern as leon/hor)\n\tout += md.Bold(ufmt.Sprintf(\"[%d](%s) - [%d](%s)\",\n\t\titem.upvote.Size(), txlink.Call(\"Upvote\", \"pkgpath\", item.pkgpath),\n\t\titem.downvote.Size(), txlink.Call(\"Downvote\", \"pkgpath\", item.pkgpath),\n\t))\n\tout += \"\\n\\n\"\n\tout += md.HorizontalRule()\n\n\treturn out\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"26132917","gas_fee":"26133ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Waq3cpmKkR+K/h5OngqXFWx2qTMEtHLPW9PNPgP0t9aYiEPG994+xxj41dH7Sv7+OFdUlK3cJnEUIZpqcJJQBQ=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1765571546"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/gnomas15","func":"SubmitDesign","args":["Test","Test","","https://x.com/AtoneZone/status/1999550007947448551"]}],"fee":{"gas_wanted":"856447","gas_fee":"857ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"qObdPvm9PudIXRRzUPU6VXq40hEeAJUyHCp+ZfD7Bg1/NMOFB3hLp19LUTjMWceoiJb4nt/YkZYTdHv6p/uqDA=="}],"memo":""},"metadata":{"timestamp":"1765571621"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynftcollection","func":"Register"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"mx1SW6cWIFgUqP73/DrW6AdPpcEZz1/CTk6ka2Mu4ok/pSyrM4ICoxso5WJYCrEYpxizbX/XF8MBbvSuZm1vDw=="}],"memo":""},"metadata":{"timestamp":"1765571686"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynftcollection","func":"MintNFT","args":["testnft","ma description de neuille"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"5enXcId1hunzxpAbTMSDbw/D8rjyCxCFN5teIeQGZ+YTnLrWCAkXEQLTgkMfMCH9TZ4QGAI/NrTZwJ90mNbpCw=="}],"memo":""},"metadata":{"timestamp":"1765571742"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao3","func":"TallyProposal","args":["1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Wjn3TYmqjr1UyHOKTDrh2pTFs4vXdSmpHiXNwccpMGVDCPBfAkCA1Kma6MnQ+l1dcNNRSEvr6K5ANzOJdVNJCg=="}],"memo":""},"metadata":{"timestamp":"1765572003"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6PM55Eor+MMChmLZpWiu0hlJSFhfSU5v3wv/EozLDo8AHI9n41Orf+sK4DfM3QD5kwxBdfMbx3GSlbmnKXkGBg=="}],"memo":""},"metadata":{"timestamp":"1765572068"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"name":"gnomas16","path":"gno.land/r/meeeshell222/gnomas16","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/meeeshell222/gnomas16\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\"\n"},{"name":"gnostudio.gno","body":"// This file is automatically generated and contains metadata about this\n// package deployment. It serves as a marker that this package was deployed\n// using Gno Studio (or Gno Playground) and may be used by tools for analytics, verification,\n// and ecosystem features.\n//\n// This file does not affect package execution and should not be modified.\npackage gnomas16"},{"name":"package.gno","body":"package gnomas16\n\nimport (\n\t\"chain\"\n\t\"chain/runtime\"\n\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/moul/addrset\"\n\t\"gno.land/p/moul/md\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ownable\"\n\t\"gno.land/p/nt/pausable\"\n\t\"gno.land/p/nt/seqid\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/leon/config\"\n\n\t_ \"gno.land/r/leon/hor\"\n)\n\nconst (\n\tmaxTitleLength       = 40\n\tmaxDescriptionLength = 140\n\tmaxCategoryLength    = 24\n\tmaxURLLength         = 180\n\n\t// Offset to make score sorting lexicographically safe even when scores go negative.\n\tscoreOffset = 1000000\n\n\tjudgeScoreMin = 0\n\tjudgeScoreMax = 10\n)\n\nvar (\n\texhibition *Exhibition\n\n\tOwnable  *ownable.Ownable\n\tPausable *pausable.Pausable\n)\n\ntype (\n\tExhibition struct {\n\t\titemCounter seqid.ID\n\t\tdescription string\n\n\t\t// Windows (block-based). 0 means \"not enforced\".\n\t\tsubmissionOpenBlock  int64\n\t\tsubmissionCloseBlock int64\n\t\tvotingOpenBlock      int64\n\t\tvotingCloseBlock     int64\n\n\t\t// Judges (addresses derived from runtime)\n\t\tjudges *addrset.Set\n\n\t\t// Primary store\n\t\t// Key = submitter address string (user identity)\n\t\titems *avl.Tree // submitterKey -\u003e *Item\n\n\t\t// Secondary indexes\n\t\titemsSortedByCreation  *avl.Tree // creationKey -\u003e *Item\n\t\titemsSortedByScore     *avl.Tree // scoreKey    -\u003e *Item\n\t\titemsSortedByUpvotes   *avl.Tree // voteKey     -\u003e *Item\n\t\titemsSortedByDownvotes *avl.Tree // voteKey     -\u003e *Item\n\t}\n\n\tItem struct {\n\t\tid          seqid.ID\n\t\ttitle       string\n\t\tdescription string\n\t\tcategory    string\n\t\tpreviewURL  string\n\n\t\t// For this user-submission version, this is the submitter identity (address string).\n\t\tsubmitter string\n\n\t\tblockNum int64\n\t\tstatus   string // submitted | finalist | winner | disqualified\n\n\t\tupvote   *addrset.Set\n\t\tdownvote *addrset.Set\n\n\t\t// Judge scores: key (string) = judge address string; value (string) = score int as string\n\t\tjudgeScores *avl.Tree\n\t\tjudgeTotal  int\n\t}\n)\n\nfunc init() {\n\texhibition = \u0026Exhibition{\n\t\titems:                  avl.NewTree(),\n\t\titemsSortedByCreation:  avl.NewTree(),\n\t\titemsSortedByScore:     avl.NewTree(),\n\t\titemsSortedByUpvotes:   avl.NewTree(),\n\t\titemsSortedByDownvotes: avl.NewTree(),\n\t\tjudges:                 \u0026addrset.Set{},\n\t}\n\n\tOwnable = ownable.NewWithAddress(config.OwnableMain.Owner())\n\tPausable = pausable.NewFromOwnable(Ownable)\n}\n\n//\n// Admin / configuration\n//\n\nfunc ConfigureCompetition(cur realm, submissionOpen, submissionClose, votingOpen, votingClose int64, description string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif submissionOpen != 0 \u0026\u0026 submissionClose != 0 \u0026\u0026 submissionClose \u003c submissionOpen {\n\t\tpanic(\"invalid submission window\")\n\t}\n\tif votingOpen != 0 \u0026\u0026 votingClose != 0 \u0026\u0026 votingClose \u003c votingOpen {\n\t\tpanic(\"invalid voting window\")\n\t}\n\n\texhibition.submissionOpenBlock = submissionOpen\n\texhibition.submissionCloseBlock = submissionClose\n\texhibition.votingOpenBlock = votingOpen\n\texhibition.votingCloseBlock = votingClose\n\texhibition.description = description\n\n\tchain.Emit(\"CompetitionConfigured\")\n}\n\nfunc Pause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Pause()\n\tchain.Emit(\"Paused\")\n}\n\nfunc Unpause(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tPausable.Unpause()\n\tchain.Emit(\"Unpaused\")\n}\n\n// AddJudge adds the caller as a judge (owner-only).\nfunc AddJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Add(judge)\n\tchain.Emit(\"JudgeAdded\")\n}\n\n// RemoveJudge removes the caller from judges (owner-only).\nfunc RemoveJudge(cur realm) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tjudge := runtime.PreviousRealm().Address()\n\texhibition.judges.Remove(judge)\n\tchain.Emit(\"JudgeRemoved\")\n}\n\n//\n// Submission (USER-SUBMITTED)\n//\n\n// SubmitDesign stores one submission per user (keyed by address string).\nfunc SubmitDesign(cur realm, title, description, category, previewURL string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.submissionOpenBlock != 0 \u0026\u0026 height \u003c exhibition.submissionOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.submissionCloseBlock != 0 \u0026\u0026 height \u003e exhibition.submissionCloseBlock {\n\t\treturn\n\t}\n\n\tsubmitterKey := runtime.PreviousRealm().Address().String()\n\n\t// One submission per user; change to panic or allow overwrite if desired.\n\tif exhibition.items.Has(submitterKey) {\n\t\treturn\n\t}\n\n\tif title == \"\" || len(title) \u003e maxTitleLength {\n\t\treturn\n\t}\n\tif len(description) \u003e maxDescriptionLength {\n\t\treturn\n\t}\n\tif category == \"\" || len(category) \u003e maxCategoryLength {\n\t\treturn\n\t}\n\tif previewURL != \"\" \u0026\u0026 len(previewURL) \u003e maxURLLength {\n\t\treturn\n\t}\n\n\tid := exhibition.itemCounter.Next()\n\titem := \u0026Item{\n\t\tid:          id,\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tcategory:    category,\n\t\tpreviewURL:  previewURL,\n\t\tsubmitter:   submitterKey,\n\t\tblockNum:    height,\n\t\tstatus:      \"submitted\",\n\t\tupvote:      \u0026addrset.Set{},\n\t\tdownvote:    \u0026addrset.Set{},\n\t\tjudgeScores: avl.NewTree(),\n\t\tjudgeTotal:  0,\n\t}\n\n\texhibition.items.Set(submitterKey, item)\n\n\texhibition.itemsSortedByCreation.Set(getCreationSortKey(item.blockNum, item.id), item)\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(0, item.id), item)\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(0, item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(0, item.id), item)\n\n\tchain.Emit(\"DesignSubmitted\")\n}\n\n//\n// Voting\n//\n\nfunc Upvote(cur realm, submitterKey string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(submitterKey)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.upvote.Has(caller) {\n\t\tpanic(\"double upvote\")\n\t}\n\tif caller.String() == item.submitter {\n\t\tpanic(\"cannot vote own submission\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.upvote.Add(caller)\n\n\texhibition.itemsSortedByUpvotes.Set(getVoteSortKey(item.upvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Upvoted\")\n}\n\nfunc Downvote(cur realm, submitterKey string) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\n\theight := runtime.ChainHeight()\n\tif exhibition.votingOpenBlock != 0 \u0026\u0026 height \u003c exhibition.votingOpenBlock {\n\t\treturn\n\t}\n\tif exhibition.votingCloseBlock != 0 \u0026\u0026 height \u003e exhibition.votingCloseBlock {\n\t\treturn\n\t}\n\n\trawItem, ok := exhibition.items.Get(submitterKey)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tcaller := runtime.PreviousRealm().Address()\n\tif item.downvote.Has(caller) {\n\t\tpanic(\"double downvote\")\n\t}\n\tif caller.String() == item.submitter {\n\t\tpanic(\"cannot vote own submission\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\titem.downvote.Add(caller)\n\n\texhibition.itemsSortedByDownvotes.Set(getVoteSortKey(item.downvote.Size(), item.id), item)\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"Downvoted\")\n}\n\n//\n// Judge scoring\n//\n\nfunc JudgeScore(cur realm, submitterKey string, score int) {\n\tif Pausable.IsPaused() {\n\t\treturn\n\t}\n\tif score \u003c judgeScoreMin || score \u003e judgeScoreMax {\n\t\tpanic(\"score out of range (0-10)\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(submitterKey)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\tjudgeAddr := runtime.PreviousRealm().Address()\n\tif !exhibition.judges.Has(judgeAddr) {\n\t\tpanic(\"not a judge\")\n\t}\n\n\toldFinal := finalScore(item)\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(oldFinal, item.id))\n\n\tjudgeKey := judgeAddr.String()\n\n\toldRaw, hadOld := item.judgeScores.Get(judgeKey)\n\tif hadOld {\n\t\toldInt, _ := strconv.Atoi(oldRaw.(string))\n\t\titem.judgeTotal -= oldInt\n\t}\n\n\titem.judgeScores.Set(judgeKey, strconv.Itoa(score))\n\titem.judgeTotal += score\n\n\texhibition.itemsSortedByScore.Set(getScoreSortKey(finalScore(item), item.id), item)\n\n\tchain.Emit(\"JudgeScored\")\n}\n\n//\n// Status management (owner-only)\n//\n\nfunc SetStatus(cur realm, submitterKey, status string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\tif status != \"submitted\" \u0026\u0026 status != \"finalist\" \u0026\u0026 status != \"winner\" \u0026\u0026 status != \"disqualified\" {\n\t\tpanic(\"invalid status\")\n\t}\n\n\trawItem, ok := exhibition.items.Get(submitterKey)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\titem.status = status\n\n\tchain.Emit(\"StatusUpdated\")\n}\n\n//\n// Admin delete (owner-only)\n//\n\nfunc Delete(cur realm, submitterKey string) {\n\tif !Ownable.OwnedByPrevious() {\n\t\tpanic(ownable.ErrUnauthorized)\n\t}\n\n\trawItem, ok := exhibition.items.Get(submitterKey)\n\tif !ok {\n\t\tpanic(\"no such submission\")\n\t}\n\titem := rawItem.(*Item)\n\n\texhibition.itemsSortedByCreation.Remove(getCreationSortKey(item.blockNum, item.id))\n\texhibition.itemsSortedByUpvotes.Remove(getVoteSortKey(item.upvote.Size(), item.id))\n\texhibition.itemsSortedByDownvotes.Remove(getVoteSortKey(item.downvote.Size(), item.id))\n\texhibition.itemsSortedByScore.Remove(getScoreSortKey(finalScore(item), item.id))\n\n\texhibition.items.Remove(submitterKey)\n\n\tchain.Emit(\"Deleted\")\n}\n\n//\n// Helpers\n//\n\nfunc finalScore(item *Item) int {\n\treturn (item.upvote.Size() - item.downvote.Size()) + item.judgeTotal\n}\n\nfunc getVoteSortKey(votes int, id seqid.ID) string {\n\tvotesStr := strconv.Itoa(votes)\n\tpaddedVotes := strings.Repeat(\"0\", 10-len(votesStr)) + votesStr\n\treturn paddedVotes + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getScoreSortKey(score int, id seqid.ID) string {\n\tnormalized := score + scoreOffset\n\tif normalized \u003c 0 {\n\t\tnormalized = 0\n\t}\n\tscoreStr := strconv.Itoa(normalized)\n\tpadded := strings.Repeat(\"0\", 10-len(scoreStr)) + scoreStr\n\treturn padded + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\nfunc getCreationSortKey(blockNum int64, id seqid.ID) string {\n\tblockNumStr := strconv.Itoa(int(blockNum))\n\tpaddedBlockNum := strings.Repeat(\"0\", 10-len(blockNumStr)) + blockNumStr\n\treturn paddedBlockNum + \":\" + strconv.FormatUint(uint64(id), 10)\n}\n\n//\n// Render (root-only)\n//\n\nfunc Render(path string) string {\n\tout := md.H1(\"gnomas15 ‚Äî Design Competition\\n\\n\")\n\n\tif exhibition.description != \"\" {\n\t\tout += ufmt.Sprintf(\"%s\\n\\n\", exhibition.description)\n\t}\n\n\tout += ufmt.Sprintf(\"Total submissions: **%d**\\n\\n\", exhibition.items.Size())\n\n\t// Convenience \"Submit\" tx link (user edits values on the help page)\n\tout += md.Link(\"Submit a design\", txlink.Call(\"SubmitDesign\",\n\t\t\"title\", \"Your title\",\n\t\t\"description\", \"Your description\",\n\t\t\"category\", \"poster\",\n\t\t\"previewURL\", \"https://...\",\n\t))\n\tout += \"\\n\\n\"\n\tout += md.HorizontalRule()\n\n\tif exhibition.items.Size() == 0 {\n\t\tout += \"No submissions yet.\\n\\n\"\n\t\treturn out\n\t}\n\n\ttree := exhibition.itemsSortedByScore\n\tn := tree.Size()\n\trank := 1\n\n\tfor i := n - 1; i \u003e= 0; i-- {\n\t\t_, v := tree.GetByIndex(i)\n\t\titem := v.(*Item)\n\n\t\tout += renderItemCard(item, rank)\n\t\trank++\n\n\t\tif i == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn out\n}\n\nfunc renderItemCard(item *Item, rank int) string {\n\tout := \"\"\n\tout += md.H3(ufmt.Sprintf(\"%d. %s\\n\\n\", rank, item.title))\n\n\tif item.description == \"\" {\n\t\tout += \"_No description provided._\\n\\n\"\n\t} else {\n\t\tout += ufmt.Sprintf(\"%s\\n\\n\", item.description)\n\t}\n\n\tout += ufmt.Sprintf(\"Category: **%s**\\n\\n\", item.category)\n\tout += ufmt.Sprintf(\"Submitter: `%s`\\n\\n\", item.submitter)\n\n\tscore := finalScore(item)\n\tout += ufmt.Sprintf(\"Score: **%d** | Votes: **‚è∂ %d - ‚è∑ %d**\\n\\n\",\n\t\tscore, item.upvote.Size(), item.downvote.Size(),\n\t)\n\n\tif item.previewURL != \"\" {\n\t\tout += md.Link(\"Preview\", item.previewURL) + \"\\n\\n\"\n\t}\n\n\tout += md.Bold(ufmt.Sprintf(\"%s  |  %s\",\n\t\tmd.Link(\"Upvote\", txlink.Call(\"Upvote\", \"submitterKey\", item.submitter)),\n\t\tmd.Link(\"Downvote\", txlink.Call(\"Downvote\", \"submitterKey\", item.submitter)),\n\t))\n\tout += \"\\n\\n\"\n\tout += md.HorizontalRule()\n\n\treturn out\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"26138153","gas_fee":"26139ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"TeBflP0SEbC3cmHpdeEavkNAREDVRtflUr55e34ga8jHlSoXKd/15yqqalkSCe8lA5Oj/186ukNTfPP1/95TBA=="}],"memo":"Deployed through play.gno.land"},"metadata":{"timestamp":"1765572083"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao3","func":"CreateListing","args":["g1c53ppfcgjq65e7gltqusauzh6w4cawvtr7qk90","1","1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"0R2CykDQLXowx4bqOm9xiwa8RlLh7ac+wYTH1wDX4/dXiHCj1ywX5IaKEnQGdb6lrKNFeRUoW1l0TLcI7MSbBw=="}],"memo":""},"metadata":{"timestamp":"1765572144"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/gnomas16","func":"SubmitDesign","args":["Test","Test","Video","https://x.com/AtoneZone/status/1999550007947448551"]}],"fee":{"gas_wanted":"6306041","gas_fee":"6307ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ixWKbnMMQmxKWBVr1l9fH8YGRX0uBi3Oomfbypp2qiGJhu+6ra6ack0MjkXv1jfQ84Ce6P92bQXDevDBQfG7BQ=="}],"memo":""},"metadata":{"timestamp":"1765572154"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g16jxcfv53vlmu9gh3ty3826x3t966dmps00kx0f","send":"","max_deposit":"","pkg_path":"gno.land/r/meeeshell222/gnomas16","func":"Upvote","args":["g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5"]}],"fee":{"gas_wanted":"6293981","gas_fee":"6294ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"S6zejdBvuQ3qYlgoehNHUzRRBoYD5VQuPiBvAYPitJjOPeugV5+ru23jam/90Izc6tsr6lClxD9TJGAHAfatCg=="}],"memo":""},"metadata":{"timestamp":"1765572475"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"317500ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"4l/uMDMMgPHIgGapxif+6eq1siIkruD6EDtRmr0RWnSOIzgYexXv2x8WlNSFfgg+oXmExbhIKozWpJJV6EcyBg=="}],"memo":""},"metadata":{"timestamp":"1765589454"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"317500ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"oTYt2cs1eRqsGUjbWgsQtjlZxkI2cjFB+qJJZIvsqJoJuksnEJ61faiyf25KTwibXuoKo/OvBfFx3NeLrB58Dw=="}],"memo":""},"metadata":{"timestamp":"1765589459"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"g4BGxvDNUoxFKkqFRnUcC146i2BI3PPU7ul1XUi8mu6NV6ZWriCuu6wL6HX9ad0DbnB8QzZzB4L24cVnFkaUAg=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PukazxjGzhjlvdHGCcpKKIyRP2jqstm8jE6c2jxDXC3tfUhibdb9yvf/GcHmMdcJ5Gs5bUr4bAx8mgfXNmh5CA=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PFNoyjqnwtZD0QITFJjcJQN0mT/lSo2Bmd94AOw4gJLf1w2xAcHR39JjErHhVy60jezfTn2Nym0syM6kzc/UAA=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"oIrbP7XZQ45ARPBuHkMC8xkztDRKsuk2Z7G/yp8KRs/Qrm1wX4PZp7nvk/KEWJy7vHpVO4Pb28RGMCCEvbXbDg=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"/2g1xfXGsPFJweMmrI15ibes063WiMZu7MLDXadwcua8clX7HYRrS/rw+V95hqAbnjIdtWboOpRJLPQWZONsAA=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Ut8pyqnwUy6fmBucT9naI0UPqr3cPnFawqnGHt0Ws1ykV0e3yfTHO9F2uW8WmitAyOP/RVMHLyObh2tO2lj7AQ=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1dIDErOOcfepxL0GEN9Znbr6sisx1dEzs2HvsSCg3k7EWFA3Sf96O8ZIFRa0P4zLllSkWe35Gq4xxrh/4OJpDw=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"rHIWrwLETzXp3pXjSHT6K0c5f7kilJxPMsddenLx6ywRnqjg1fVLQx+2cmQtgi9hdLfAPiU5y2/676S/3eKWAg=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589464_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PG2euSQhNbGvsLxGS5c7p4UwRXcOaD8boAgIBAHA8mhySKYSi5abgh05TBMXruKIHu3C0GuYMw8si+jQ2518AQ=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589464_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"uEY9YLfWS7OAOgRq0Uhcgoed+9wNo8iN09j0q9e4ZzTeHKnpf1rxo7E2E5+PT8rRlsjAOg6mnqvJZzCRuQQqDg=="}],"memo":""},"metadata":{"timestamp":"1765589464"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"2816845ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"I36crwgqEDA2fdXqUXAOlon2gWSjvDoeIouavRCjWtGRbLnns1/Y583bRNrjlDM2ELqrKPcYTzvbIYyMllkLBg=="}],"memo":""},"metadata":{"timestamp":"1765589565"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"2816845ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iDSUN3bQYTs03JJsoXU+0EXDn1wuRTFFLCSaQuy2I1L1hEIdeelQitj8hX327ovMIJ1vnMcDqr+IYWj1PsmxCg=="}],"memo":""},"metadata":{"timestamp":"1765589570"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"deGov9j5zzL10lWD6pwuqht2vUDCFSooT/Mc8K8Rm1MZzfmBnX4KU3meiy4ZPPMWnNgpfBovpeebRRUV7NNGCg=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"WMJP1GJqrHwSl6YSiSt/e4abg4j54H3WjLJKCUBM9xhxsb14NEU6g0olejBJcf3yjWg0Uw+g7HxP1qe31DsOCA=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"n2mK++a4RtXqjVgrpqA6+EXMAyvrYsNdIgVXUuyyn8RP1SYerFF2w4tTyyJjkejXDl+2VJZlggSpgPn080DJDQ=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"TRn51ymYJHFIzFCiPSmlVGVjRCRIsGnFb2nHp5NR/pTuhXSgvO6kL2jiIKT5QfXB+6Ulur4cJCx74/P/FdEPAw=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"w2lTh323JWMaIiMIgeehrOg0W2kv7cAZuR/q8F5dQCkMRVH1Xk6rhwufsnNXYyyUDzZ/LRWO47aYxr1f+7IPCQ=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"FV8r0Q+ylAzgT38wUtwamPyqq6Y/fOu9wtjTjZzUVLjD6uYuy61c2pn14+EtipKJWCfJlynyWtYCHV+3ZQQ3Bg=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"8iq9C9YOjfdBHA/+jF1YaAJMxhCjJbeyFb1MTzJZ465ftoPUEZ/n1RsWruA5f6XvtNdzlsW8EdWHQtuGRsy8Bg=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"p8OWJHPg9o/xBHRrjpY/oB0s3F7CJE2NuiflSPLXBOoNCzasgWx6QRuCSvABQRLfo7msEuoevcCYV99upgoQCA=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765589575_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"VsFOqQ9LWytzvs9tAoWYZHl421LDO7oTVIfghlUiAx7/Xc1328mgzSSU+5B4tCDaUlPzhH3bDhN6IyhIZXUgCQ=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765589575_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"2ila1r0aFMJJ4kNc55yjF2V6t0MkalChjs/dl76Gv7hop1wuvE/jP1Z9FeXTcQVxNT7sxlC4ml9C4R2g7VuKDA=="}],"memo":""},"metadata":{"timestamp":"1765589575"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"runtime","path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"598838","gas_fee":"599ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"5xjusAy6XzoZrKSRhAx5icG7lHC3+5s5lNdiS37/utaWLD3yQBR5XInimA5htoMPa3w0ld60ht2jx7lN2iKBAQ=="}],"memo":""},"metadata":{"timestamp":"1765589655"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-0"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"U/InZkY8QxW/nUmyFO1BwUkRnztxKOHSYwp9vcCCq2xVnhQvLZde6ZcuE/vT8NxPpuNFCDSrU5HqCf5c0X0wAg=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Y+UF6mDi1U2rJbAZzYDKJc5WleX0ZQP41IyekRLQJPKKdBOJwCwFCJB13WQsErhVGHxk8txdXcfkD7n+egiACg=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"2iFMnS5c+ZFg06H1xKMoYTQfTp1+xjQPXQ/+hmZ9PcLux8ABwi/tIIrnv17oFouO9Sq6TA3VF3ge+Kj8x5+IBQ=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"pz31qrBk6ZGBmia30F+HgwH6gBka6qRmbWxolCp++YWbKS9WMKGEGs0Mryejw3VYRF55ZiKj2FkhB6oVDeMhCQ=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gJVlob7LKJHSjUvuiKrF51nZvGBZBX90Bu74S4lSMo9NulRMlQirdu1QL6jYD5oiXxYnwZWZIPK+hVYzEhuwBQ=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"7vvcm14LTLzd5jIOQ3dSXeYOXMnWsKOEW0wIRXpB0ZXyjcC9xDKnrSN/kf8Y0HQ0lU8fMF3vBuOWJDNBDA2eBw=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"tWb3aUFDlzUO5JJizV9l8AdcVNyKROhL3f/FA9JNz0+MdhX2hL3F7zy34a+Cqbb98dGwaUZbeORlhYmrlIjNCw=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Pd2cHGummW9PYQ6ihVBr6qGrfr6jk8bd+MpEWN5h92vPVlfbO5L0SfBA+ZhIWzZNAcN36UkZc5mlNRwX6fXuDA=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"2HPBNetf6UkXwChsKv309o2Gtft5Qjqio8DjGFoZV0I6u1DIM8dCrPKPAUAzdxFB0gfnS3SPpJ6BI/mOMkWLBQ=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765589659","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Kjvq4zD5XAwB/FBG1+BVQNDT+fisDKnZb8PeAX9d1ZfMFH79wM8PpMOvPJP6TMYsx/3U0W+h5rncafdLfpl4Bw=="}],"memo":""},"metadata":{"timestamp":"1765589660"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765611036"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"gnopendao4","path":"gno.land/r/pierre115/gnopendao4","files":[{"name":"README.md","body":"# GnopenSea - NFT Marketplace\n\nMarketplace NFT d√©centralis√© sur Gno.land avec gouvernance DAO.\n\n## üöÄ Comment lister votre NFT en 3 √©tapes\n\n### √âtape 1 : Enregistrer votre collection\n\n**Depuis votre package NFT**, appelez la fonction `Register()` :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"Register\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  votre-wallet\n```\n\nCela enregistre votre collection dans le **Registry DAO** (statut: non v√©rifi√©).\n\n### √âtape 2 : Approuver le marketplace\n\nDonnez la permission au marketplace de transf√©rer vos NFTs :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"SetApprovalForAll\" \\\n  -args \"g1[adresse-du-marketplace]\" \\\n  -args \"true\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### √âtape 3 : Cr√©er votre listing\n\nListez votre NFT √† vendre :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CreateListing\" \\\n  -args \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -args \"1\" \\\n  -args \"5000000\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n**Param√®tres :**\n- 1er arg : Adresse de votre package NFT\n- 2√®me arg : Token ID √† vendre\n- 3√®me arg : Prix en ugnot (5000000 = 5 GNOT)\n\n---\n\n## üõí Acheter un NFT\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"BuyNFT\" \\\n  -args \"1\" \\\n  -send \"5000000ugnot\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üìã G√©rer vos listings\n\n### Modifier le prix\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"UpdatePrice\" \\\n  -args \"1\" \\\n  -args \"10000000\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n### Annuler un listing\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CancelListing\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üé® Faire v√©rifier votre collection (badge v√©rifi√©)\n\n### 1. Cr√©er une proposal au Registry DAO\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"ProposeVerifyCollection\" \\\n  -args \"g1[adresse-de-votre-nft]\" \\\n  -args \"Nom de la collection\" \\\n  -args \"Raison de la v√©rification\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### 2. Les membres du DAO votent\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"VoteRegistry\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### 3. Ex√©cuter la proposal (apr√®s quorum)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"TallyRegistryProposal\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üí∞ Distribution des paiements\n\nExemple avec frais marketplace 2.5% et royalties 10% :\n\n```\nPrix de vente : 100 GNOT\n‚îú‚îÄ‚îÄ Frais marketplace (2.5%) : 2.5 GNOT\n‚îú‚îÄ‚îÄ Royalties cr√©ateur (10%) : 10 GNOT\n‚îî‚îÄ‚îÄ Vendeur re√ßoit : 87.5 GNOT\n```\n\n---\n\n## üèõÔ∏è Gouvernance DAO\n\nLe marketplace est gouvern√© par un DAO. Les membres peuvent cr√©er des proposals pour :\n\n- ‚úÖ Approuver/retirer des collections\n- ‚úÖ Modifier les frais du marketplace\n- ‚úÖ Retirer des fonds du tr√©sor\n- ‚úÖ Annuler un listing probl√©matique\n\n### Cr√©er une proposal (exemple: modifier les frais)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"ProposeUpdateFees\" \\\n  -args \"300\" \\\n  -args \"R√©duction des frais √† 3%\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### Voter sur une proposal\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n---\n\n## üîß Configuration NFT minimale\n\nVotre package NFT doit avoir une fonction `Register()` :\n\n```go\npackage mynft\n\nimport (\n    \"gno.land/p/demo/tokens/grc721\"\n    \"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n    nft         *grc721.basicNFT\n    myRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n    nft = grc721.NewBasicNFT(\"My Collection\", \"MC\")\n}\n\n// Register dans le registry\nfunc Register(_ realm) {\n    daoregistry4.RegisterCollection(\n        myRealmAddr,\n        \"My Collection\",\n        \"MC\",\n        \"art\",\n        \"Description de ma collection\",\n        \"https://mon-site.com\",\n        false,\n        nft.Getter(),\n    )\n}\n\n// Fonction obligatoire pour le marketplace\nfunc Getter() grc721.NFTGetter {\n    return nft.Getter()\n}\n```\n\n---\n\n## üìä Fonctions de lecture\n\n```bash\n# Voir tous les listings actifs\ncurl https://rpc.gno.land/r/pierre115/gnopendao:\n\n# Statistiques du marketplace\ncurl https://rpc.gno.land/r/pierre115/gnopendao:stats\n\n# D√©tails d'un listing\ncurl https://rpc.gno.land/r/pierre115/gnopendao:listing/1\n\n# Collections enregistr√©es\ncurl https://rpc.gno.land/r/pierre115/daoregistry4:\n```\n\n---\n\n## üîê S√©curit√©\n\n- ‚úÖ V√©rification de propri√©t√© avant listing\n- ‚úÖ V√©rification d'approbation avant vente\n- ‚úÖ Transferts atomiques\n- ‚úÖ Remboursement automatique des surplus\n- ‚úÖ Limites de frais (max 10%)\n- ‚úÖ Gouvernance d√©centralis√©e\n\n---\n\n## üÜò Probl√®mes courants\n\n**\"Collection not registered\"**\n‚Üí Vous devez d'abord appeler `Register()` sur votre NFT\n\n**\"Insufficient payment\"**\n‚Üí Le montant envoy√© doit correspondre au prix du listing\n\n**\"Not approved\"**\n‚Üí Appelez `SetApprovalForAll()` avant de cr√©er un listing\n\n**\"Not owner\"**\n‚Üí Seul le propri√©taire du NFT peut le lister\n"},{"name":"dao.gno","body":"package gnopendao4\n\nimport (\n\t//\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tmarketplaceDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 0 // 0 GNOT minimum to join DAO\n)\n\nfunc initDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tmarketplaceDAO = commondao.New(\n\t\tcommondao.WithID(1),\n\t\tcommondao.WithName(\"GnopenSea DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for GnopenSea marketplace\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinDAO - Join the marketplace DAO by staking GNOT\nfunc JoinDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\t//sent := banker.OriginSend()\n\n\t//amount := sent.AmountOf(\"ugnot\")\n\t//if amount \u003c MIN_STAKE_UGNOT {\n\t//\tpanic(\"minimum 1 GNOT required to join DAO\")\n\t//}\n\n\tif marketplaceDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tmarketplaceDAO.Members().Add(caller)\n\n\treturn \"Successfully joined GnopenSea DAO\"\n}\n\n// IsDAOMember - Check if an address is a DAO member\nfunc IsDAOMember(addr address) bool {\n\treturn marketplaceDAO.Members().Has(addr)\n}\n\n// GetTotalMembers - Returns total number of DAO members\nfunc GetTotalMembers() int {\n\treturn marketplaceDAO.Members().Size()\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/gnopendao4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"gnopensea.gno","body":"package gnopendao4\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n\tlistings      avl.Tree\n\tsales         avl.Tree\n\tnextListingId = 1\n\tnextSaleId    = 1\n\n\tmarketplaceFee      = int64(250) // 250 basis points = 2.5%\n\tmarketplaceAddr     = runtime.CurrentRealm().Address()\n\tapprovedCollections avl.Tree // Whitelist of approved collections\n)\n\nfunc init() {\n\tinitDAO()\n}\n\n// CreateListing - List an NFT for sale using the global NFT Registry\nfunc CreateListing(_ realm, nftRealmAddress address, tokenId grc721.TokenID, price int64) int {\n\tcaller := runtime.OriginCaller()\n\n\tif price \u003c= 0 || price \u003e 99999999999 {\n\t\tpanic(\"Price not valid\")\n\t}\n\n\t// Check if collection is registered in the GLOBAL NFT Registry (technical check)\n\tif !daoregistry4.IsRegistered(nftRealmAddress) {\n\t\tpanic(\"NFT collection not registered in the global NFT Registry. The collection must call nftregistry.RegisterCollection() first.\")\n\t}\n\t// Check if collection is approved by DAO (governance check)\n\tif !approvedCollections.Has(nftRealmAddress.String()) {\n\t\tpanic(\"Collection not approved by DAO. A DAO proposal must be created and passed first.\")\n\t}\n\n\t// Get NFT getter from the global registry\n\tgetter, exists := daoregistry4.GetNFTGetter(nftRealmAddress)\n\tif !exists {\n\t\tpanic(\"Failed to get NFT getter from registry\")\n\t}\n\n\tnftInstance := getter()\n\n\t// Verify caller is the owner\n\towner, err := nftInstance.OwnerOf(tokenId)\n\tif err != nil {\n\t\tpanic(\"Token not found: \" + err.Error())\n\t}\n\n\tif owner != caller {\n\t\tpanic(\"You are not the owner of this NFT\")\n\t}\n\n\t// Verify approvals\n\tmarketplaceAddr := runtime.CurrentRealm().Address()\n\tapprovedAddr, err := nftInstance.GetApproved(tokenId)\n\tisApprovedForToken := (err == nil \u0026\u0026 approvedAddr == marketplaceAddr)\n\tisApprovedForAll := nftInstance.IsApprovedForAll(owner, marketplaceAddr)\n\n\tif !isApprovedForToken \u0026\u0026 !isApprovedForAll {\n\t\tpanic(\"You must first approve the marketplace.\\nUse Approve() or SetApprovalForAll()\")\n\t}\n\n\t// Create listing\n\tlisting := \u0026Listing{\n\t\tListingId:       nextListingId,\n\t\tNFTGetter:       getter,\n\t\tTokenId:         tokenId,\n\t\tSeller:          caller,\n\t\tPrice:           price,\n\t\tActive:          true,\n\t\tListedAt:        runtime.ChainHeight(),\n\t\tNFTRealmAddress: nftRealmAddress,\n\t}\n\n\tlistings.Set(strconv.Itoa(nextListingId), listing)\n\tnextListingId++\n\n\treturn listing.ListingId\n}\n\n// BuyNFT - Purchase a listed NFT with automatic royalty calculation\nfunc BuyNFT(_ realm, listingId int) {\n\tcaller := runtime.OriginCaller()\n\tsent := banker.OriginSend()\n\n\t// Get listing\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\t// Verify payment\n\tamount := sent.AmountOf(\"ugnot\")\n\tif amount \u003c listing.Price {\n\t\tpanic(ufmt.Sprintf(\"Insufficient amount. Price: %d ugnot\", listing.Price))\n\t}\n\n\t// Get NFT instance\n\tnftInstance := listing.NFTGetter()\n\n\t// Verify seller still owns the NFT\n\tcurrentOwner, err := nftInstance.OwnerOf(listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"NFT not found: \" + err.Error())\n\t}\n\tif currentOwner != listing.Seller {\n\t\tpanic(\"Seller no longer owns this NFT\")\n\t}\n\n\t// Calculate royalties\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\t// Check if NFT supports royalties\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate what seller receives\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\tif sellerAmount \u003c 0 {\n\t\tpanic(\"Error: fees + royalties exceed sale price\")\n\t}\n\n\t// Distribute payments\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\t// 1. Pay seller\n\tif sellerAmount \u003e 0 {\n\t\tsellerCoins := chain.Coins{chain.Coin{\"ugnot\", sellerAmount}}\n\t\tbnkr.SendCoins(realmAddr, listing.Seller, sellerCoins)\n\t}\n\n\t// 2. Pay royalties to creator\n\tif royaltyAmount \u003e 0 \u0026\u0026 royaltyReceiver != \"\" {\n\t\troyaltyCoins := chain.Coins{chain.Coin{\"ugnot\", royaltyAmount}}\n\t\tbnkr.SendCoins(realmAddr, royaltyReceiver, royaltyCoins)\n\t}\n\n\t// 3. TODO : Marketplace fees remain in contract\n\n\t// 4. Refund excess\n\tif amount \u003e listing.Price {\n\t\texcess := amount - listing.Price\n\t\texcessCoins := chain.Coins{chain.Coin{\"ugnot\", excess}}\n\t\tbnkr.SendCoins(realmAddr, caller, excessCoins)\n\t}\n\n\t// Transfer NFT\n\terr = nftInstance.TransferFrom(listing.Seller, caller, listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"Transfer error: \" + err.Error())\n\t}\n\n\t// Record sale\n\tsale := \u0026Sale{\n\t\tListingId:       listingId,\n\t\tTokenId:         listing.TokenId.String(),\n\t\tBuyer:           caller,\n\t\tSeller:          listing.Seller,\n\t\tPrice:           listing.Price,\n\t\tMarketplaceFee:  marketplaceFeeAmount,\n\t\tRoyaltyFee:      royaltyAmount,\n\t\tRoyaltyReceiver: royaltyReceiver,\n\t\tSoldAt:          runtime.ChainHeight(),\n\t}\n\n\tsales.Set(strconv.Itoa(nextSaleId), sale)\n\tnextSaleId++\n\n\t// Deactivate listing\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// CancelListing - Cancel own listing (seller only)\nfunc CancelListing(_realm, listingId int) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\t// Only seller can cancel their own listing\n\t// DAO use ProposeForceCancelListing instead\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can cancel this listing. DAO members can create a ProposeForceCancelListing proposal.\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// UpdatePrice - Update listing price\nfunc UpdatePrice(_ realm, listingId int, newPrice int64) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif newPrice \u003c= 0 {\n\t\tpanic(\"Price must be positive\")\n\t}\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can modify this listing\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\tlisting.Price = newPrice\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// ============= READ FUNCTIONS =============\n\nfunc GetListing(listingId int) (int, string, int64, string, bool, int64) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, \"\", 0, \"\", false, 0\n\t}\n\n\treturn listing.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tlisting.ListedAt\n}\n\nfunc GetSale(saleId int) (int, string, string, string, int64, int64, int64, string, int64) {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn 0, \"\", \"\", \"\", 0, 0, 0, \"\", 0\n\t}\n\n\tsale := value.(*Sale)\n\treturn sale.ListingId,\n\t\tsale.TokenId,\n\t\tsale.Buyer.String(),\n\t\tsale.Seller.String(),\n\t\tsale.Price,\n\t\tsale.MarketplaceFee,\n\t\tsale.RoyaltyFee,\n\t\tsale.RoyaltyReceiver.String(),\n\t\tsale.SoldAt\n}\n\nfunc GetActiveListingsCount() int {\n\tcount := 0\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\nfunc GetTotalSales() int {\n\treturn sales.Size()\n}\n\nfunc GetTotalVolume() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.Price\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetTotalRoyaltiesPaid() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.RoyaltyFee\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetMarketplaceFee() int64 {\n\treturn marketplaceFee\n}\n\nfunc GetMarketplaceAddress() address {\n\treturn runtime.CurrentRealm().Address()\n}\n\n// GetRoyaltyBreakdown - Calculate distribution for a listing\nfunc GetRoyaltyBreakdown(listingId int) (int64, int64, int64, address) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, 0, 0, \"\"\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate royalties if supported\n\tnftInstance := listing.NFTGetter()\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\treturn sellerAmount, marketplaceFeeAmount, royaltyAmount, royaltyReceiver\n}\n\nfunc GetBalance() int64 {\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\tbalance := bnkr.GetCoins(realmAddr)\n\treturn balance.AmountOf(\"ugnot\")\n}\n\n// ============= READ FUNCTIONS FOR FRONTEND =============\n\n// GetAllListings - Return all active listings with metadata\nfunc GetAllListings() string {\n\tvar listingsData []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\t// Try to get image and name from onchain metadata via the registry\n\t\t\t// The registry can make the type assertion in the collection's realm context\n\t\t\tvar image, name string\n\t\t\tmetadata, err := daoregistry4.GetTokenMetadata(listing.NFTRealmAddress, listing.TokenId)\n\t\t\tif err == nil {\n\t\t\t\timage = metadata.Image\n\t\t\t\tname = metadata.Name\n\t\t\t}\n\n\t\t\t// If no image, use the collection's default image\n\t\t\tif image == \"\" {\n\t\t\t\timage = \"https://i.imgflip.com/a6o5jb.jpg\"\n\t\t\t}\n\n\t\t\t// If no name, use default\n\t\t\tif name == \"\" {\n\t\t\t\tname = ufmt.Sprintf(\"NFT #%s\", listing.TokenId.String())\n\t\t\t}\n\n\t\t\t// Format: listingId|nftAddress|tokenId|price|seller|image|name\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%s|%d|%s|%s|%s\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.NFTRealmAddress.String(),\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t\tlisting.Seller.String(),\n\t\t\t\timage,\n\t\t\t\tname,\n\t\t\t)\n\t\t\tlistingsData = append(listingsData, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(listingsData) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(listingsData, \"\\n\")\n}\n\n// GetListingDetails - Get detailed info about a listing\nfunc GetListingDetails(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"Listing not found\"\n\t}\n\n\t// Get NFT metadata via the registry\n\t// The registry can make the type assertion in the collection's realm context\n\tvar name, description, image, uri string\n\tvar attributes []grc721.Trait\n\n\t// Try onchain metadata via registry\n\tmetadata, err := daoregistry4.GetTokenMetadata(listing.NFTRealmAddress, listing.TokenId)\n\tif err == nil {\n\t\tname = metadata.Name\n\t\tdescription = metadata.Description\n\t\timage = metadata.Image\n\t\tattributes = metadata.Attributes\n\t}\n\n\t// Format attributes as JSON array\n\tattributesJSON := \"[]\"\n\tif len(attributes) \u003e 0 {\n\t\tattrStr := \"[\"\n\t\tfor i, attr := range attributes {\n\t\t\tif i \u003e 0 {\n\t\t\t\tattrStr += \",\"\n\t\t\t}\n\t\t\tattrStr += ufmt.Sprintf(`{\"trait_type\":\"%s\",\"value\":\"%s\"}`, attr.TraitType, attr.Value)\n\t\t}\n\t\tattrStr += \"]\"\n\t\tattributesJSON = attrStr\n\t}\n\n\t// Format JSON-like response\n\toutput := ufmt.Sprintf(`{\n  \"listingId\": %d,\n  \"tokenId\": \"%s\",\n  \"price\": %d,\n  \"seller\": \"%s\",\n  \"active\": %t,\n  \"name\": \"%s\",\n  \"description\": \"%s\",\n  \"image\": \"%s\",\n  \"uri\": \"%s\",\n  \"attributes\": %s,\n  \"listedAt\": %d\n}`,\n\t\tlisting.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tname,\n\t\tdescription,\n\t\timage,\n\t\turi,\n\t\tattributesJSON,\n\t\tlisting.ListedAt,\n\t)\n\n\treturn output\n}\n\n// GetUserListings - Get all listings by a specific seller\nfunc GetUserListings(sellerAddr address) string {\n\tvar userListings []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Seller == sellerAddr \u0026\u0026 listing.Active {\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%d\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t)\n\t\t\tuserListings = append(userListings, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(userListings) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(userListings, \"\\n\")\n}\n\n// GetMarketplaceStats - Get overall marketplace statistics\nfunc GetMarketplaceStats() string {\n\tactiveCount := GetActiveListingsCount()\n\ttotalSales := GetTotalSales()\n\ttotalVolume := GetTotalVolume()\n\n\toutput := ufmt.Sprintf(`{\n  \"activeListings\": %d,\n  \"totalSales\": %d,\n  \"totalVolume\": %d,\n  \"marketplaceFee\": %d\n}`,\n\t\tactiveCount,\n\t\ttotalSales,\n\t\ttotalVolume,\n\t\tmarketplaceFee,\n\t)\n\n\treturn output\n}\n\n// ============= HELPERS =============\n\nfunc getListing(listingId int) *Listing {\n\tvalue, exists := listings.Get(strconv.Itoa(listingId))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn value.(*Listing)\n}\n\nfunc formatPrice(ugnot int64) string {\n\tgnot := float64(ugnot) / 1000000.0\n\treturn ufmt.Sprintf(\"%.2f GNOT\", gnot)\n}\n\nfunc formatFee(basisPoints int64) string {\n\tpercent := float64(basisPoints) / 100.0\n\treturn ufmt.Sprintf(\"%.2f%%\", percent)\n}\n\nfunc formatPercentage(value, total int64) string {\n\tif total == 0 {\n\t\treturn \"0%\"\n\t}\n\tpercent := (float64(value) / float64(total)) * 100.0\n\treturn ufmt.Sprintf(\"%.1f%%\", percent)\n}\n"},{"name":"gnopensea_test.gno","body":"package gnopendao4\n\nimport (\n\t\"testing\"\n)\n\n// Test marketplace initialization values\nfunc TestMarketplaceInit(t *testing.T) {\n\t// Check marketplace fee is set to default (2.5%)\n\tfee := GetMarketplaceFee()\n\tif fee != 250 {\n\t\tt.Errorf(\"Expected marketplace fee to be 250, got %d\", fee)\n\t}\n}\n\n// Test marketplace fee getter\nfunc TestGetMarketplaceFee(t *testing.T) {\n\tfee := GetMarketplaceFee()\n\tif fee \u003c 0 || fee \u003e 1000 {\n\t\tt.Errorf(\"Marketplace fee out of valid range (0-1000): %d\", fee)\n\t}\n}\n\n// Test active listings count (should not panic)\nfunc TestGetActiveListingsCount(t *testing.T) {\n\tcount := GetActiveListingsCount()\n\tif count \u003c 0 {\n\t\tt.Errorf(\"Active listings count should not be negative: %d\", count)\n\t}\n}\n\n// Test total sales (should not panic)\nfunc TestGetTotalSales(t *testing.T) {\n\tsales := GetTotalSales()\n\tif sales \u003c 0 {\n\t\tt.Errorf(\"Total sales should not be negative: %d\", sales)\n\t}\n}\n\n// Test total volume (should not panic)\nfunc TestGetTotalVolume(t *testing.T) {\n\tvolume := GetTotalVolume()\n\tif volume \u003c 0 {\n\t\tt.Errorf(\"Total volume should not be negative: %d\", volume)\n\t}\n}\n\n// Test total royalties paid (should not panic)\nfunc TestGetTotalRoyaltiesPaid(t *testing.T) {\n\troyalties := GetTotalRoyaltiesPaid()\n\tif royalties \u003c 0 {\n\t\tt.Errorf(\"Total royalties should not be negative: %d\", royalties)\n\t}\n}\n\n// Test marketplace address getter (should not panic)\nfunc TestGetMarketplaceAddress(t *testing.T) {\n\taddr := GetMarketplaceAddress()\n\tif addr == \"\" {\n\t\tt.Error(\"Marketplace address should not be empty\")\n\t}\n}\n\n// Test balance getter (should not panic)\nfunc TestGetBalance(t *testing.T) {\n\tbalance := GetBalance()\n\tif balance \u003c 0 {\n\t\tt.Errorf(\"Balance should not be negative: %d\", balance)\n\t}\n}\n\n// Test render home page (should not panic)\nfunc TestRenderHome(t *testing.T) {\n\toutput := Render(\"\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Home render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Marketplace\") {\n\t\tt.Error(\"Home render should contain 'Marketplace'\")\n\t}\n}\n\n// Test render stats page (should not panic)\nfunc TestRenderStats(t *testing.T) {\n\toutput := Render(\"stats\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Stats render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Statistics\") {\n\t\tt.Error(\"Stats render should contain 'Statistics'\")\n\t}\n}\n\n// Test render invalid path\nfunc TestRenderInvalidPath(t *testing.T) {\n\toutput := Render(\"invalid/path/test\")\n\tif output != \"Page not found\" {\n\t\tt.Errorf(\"Expected 'Page not found', got '%s'\", output)\n\t}\n}\n\n// Test format price function\nfunc TestFormatPrice(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{1000000, \"1.00 GNOT\"},\n\t\t{5000000, \"5.00 GNOT\"},\n\t\t{100, \"0.00 GNOT\"},\n\t\t{0, \"0.00 GNOT\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPrice(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPrice(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format fee function\nfunc TestFormatFee(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{250, \"2.50%\"},\n\t\t{500, \"5.00%\"},\n\t\t{1000, \"10.00%\"},\n\t\t{0, \"0.00%\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatFee(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatFee(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format percentage function\nfunc TestFormatPercentage(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    int64\n\t\ttotal    int64\n\t\texpected string\n\t}{\n\t\t{25, 100, \"25.0%\"},\n\t\t{50, 100, \"50.0%\"},\n\t\t{0, 100, \"0.0%\"},\n\t\t{100, 100, \"100.0%\"},\n\t\t{0, 0, \"0%\"}, // Division by zero case\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPercentage(tt.value, tt.total)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPercentage(%d, %d) = %s, expected %s\",\n\t\t\t\ttt.value, tt.total, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test GetListing with invalid ID (should return zeros)\nfunc TestGetListingInvalid(t *testing.T) {\n\tid, tokenId, price, seller, active, listedAt := GetListing(999999)\n\n\tif id != 0 || tokenId != \"\" || price != 0 || seller != \"\" || active != false || listedAt != 0 {\n\t\tt.Error(\"GetListing with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetSale with invalid ID (should return zeros)\nfunc TestGetSaleInvalid(t *testing.T) {\n\tlistingId, tokenId, buyer, seller, price, marketFee, royaltyFee, royaltyReceiver, soldAt := GetSale(999999)\n\n\tif listingId != 0 || tokenId != \"\" || buyer != \"\" || seller != \"\" ||\n\t\tprice != 0 || marketFee != 0 || royaltyFee != 0 || royaltyReceiver != \"\" || soldAt != 0 {\n\t\tt.Error(\"GetSale with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetRoyaltyBreakdown with invalid ID (should return zeros)\nfunc TestGetRoyaltyBreakdownInvalid(t *testing.T) {\n\tsellerAmount, marketFee, royalty, royaltyReceiver := GetRoyaltyBreakdown(999999)\n\n\tif sellerAmount != 0 || marketFee != 0 || royalty != 0 || royaltyReceiver != \"\" {\n\t\tt.Error(\"GetRoyaltyBreakdown with invalid ID should return zero values\")\n\t}\n}\n\n// Helper function to check if string contains substring\nfunc contains(s, substr string) bool {\n\treturn len(s) \u003e= len(substr) \u0026\u0026 (s == substr ||\n\t\tlen(s) \u003e len(substr) \u0026\u0026 indexOf(s, substr) \u003e= 0)\n}\n\n// Helper function to find substring index\nfunc indexOf(s, substr string) int {\n\tfor i := 0; i \u003c= len(s)-len(substr); i++ {\n\t\tif s[i:i+len(substr)] == substr {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"},{"name":"proposal.gno","body":"package gnopendao4\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"errors\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_APPROVE_COLLECTION   = \"approve_collection\"\n\tPROPOSAL_TYPE_REMOVE_COLLECTION    = \"remove_collection\"\n\tPROPOSAL_TYPE_UPDATE_FEES          = \"update_fees\"\n\tPROPOSAL_TYPE_WITHDRAW_TREASURY    = \"withdraw_treasury\"\n\tPROPOSAL_TYPE_FORCE_CANCEL_LISTING = \"force_cancel_listing\"\n\n\tVOTING_PERIOD = 10 * time.Minute\n\tQUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// CollectionProposal - Proposal to approve or remove a collection\ntype CollectionProposal struct {\n\tproposalType   string\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc newCollectionProposal(propType string, addr address, name string, reason string) *CollectionProposal {\n\treturn \u0026CollectionProposal{\n\t\tproposalType:   propType,\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *CollectionProposal) Title() string {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\treturn \"Approve Collection: \" + p.collectionName\n\t}\n\treturn \"Remove Collection: \" + p.collectionName\n}\n\nfunc (p *CollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Type: %s\\nCollection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tp.proposalType,\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *CollectionProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *CollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *CollectionProposal) Execute(realm) error {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\tapprovedCollections.Set(p.collectionAddr.String(), true)\n\t} else if p.proposalType == PROPOSAL_TYPE_REMOVE_COLLECTION {\n\t\tapprovedCollections.Remove(p.collectionAddr.String())\n\t}\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *CollectionProposal) GetCollectionAddr() address {\n\treturn p.collectionAddr\n}\n\n// FeesProposal - Proposal to update marketplace fees\ntype FeesProposal struct {\n\tnewFee   int64\n\treason   string\n\tapproved bool\n\texecuted bool\n}\n\nfunc newFeesProposal(newFee int64, reason string) *FeesProposal {\n\treturn \u0026FeesProposal{\n\t\tnewFee:   newFee,\n\t\treason:   reason,\n\t\tapproved: false,\n\t\texecuted: false,\n\t}\n}\n\nfunc (p *FeesProposal) Title() string {\n\treturn ufmt.Sprintf(\"Update Marketplace Fee to %d basis points\", p.newFee)\n}\n\nfunc (p *FeesProposal) Body() string {\n\tcurrentFeePercent := float64(marketplaceFee) / 100.0\n\tnewFeePercent := float64(p.newFee) / 100.0\n\n\treturn ufmt.Sprintf(\n\t\t\"Current Fee: %.2f%%\\nProposed Fee: %.2f%%\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tcurrentFeePercent,\n\t\tnewFeePercent,\n\t\tp.reason,\n\t)\n}\n\nfunc (p *FeesProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *FeesProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *FeesProposal) Execute(realm) error {\n\tmarketplaceFee = p.newFee\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *FeesProposal) GetNewFee() int64 {\n\treturn p.newFee\n}\n\n// TreasuryProposal - Proposal to withdraw funds from treasury\ntype TreasuryProposal struct {\n\tamount    int64\n\trecipient address\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewTreasuryProposal(amount int64, recipient address, reason string) *TreasuryProposal {\n\treturn \u0026TreasuryProposal{\n\t\tamount:    amount,\n\t\trecipient: recipient,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *TreasuryProposal) Title() string {\n\treturn ufmt.Sprintf(\"Withdraw %d ugnot from Treasury\", p.amount)\n}\n\nfunc (p *TreasuryProposal) Body() string {\n\tcurrentBalance := GetBalance()\n\n\treturn ufmt.Sprintf(\n\t\t\"Withdraw: %s\\nRecipient: %s\\nCurrent Treasury: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tformatPrice(p.amount),\n\t\tp.recipient.String(),\n\t\tformatPrice(currentBalance),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *TreasuryProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *TreasuryProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *TreasuryProposal) Execute(realm) error {\n\tcurrentBalance := GetBalance()\n\tif currentBalance \u003c p.amount {\n\t\treturn errors.New(\"insufficient treasury balance\")\n\t}\n\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tcoins := chain.Coins{chain.Coin{\"ugnot\", p.amount}}\n\tbnkr.SendCoins(realmAddr, p.recipient, coins)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *TreasuryProposal) GetAmount() int64 {\n\treturn p.amount\n}\n\nfunc (p *TreasuryProposal) GetRecipient() address {\n\treturn p.recipient\n}\n\n// ForceCancelListingProposal - Proposal to force cancel a problematic listing\ntype ForceCancelListingProposal struct {\n\tlistingId int\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewForceCancelListingProposal(listingId int, reason string) *ForceCancelListingProposal {\n\treturn \u0026ForceCancelListingProposal{\n\t\tlistingId: listingId,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *ForceCancelListingProposal) Title() string {\n\treturn ufmt.Sprintf(\"Force Cancel Listing #%d\", p.listingId)\n}\n\nfunc (p *ForceCancelListingProposal) Body() string {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn ufmt.Sprintf(\"Listing #%d\\nStatus: NOT FOUND\\nReason: %s\\n\\nVote YES to approve, NO to reject\", p.listingId, p.reason)\n\t}\n\n\treturn ufmt.Sprintf(\n\t\t\"Listing ID: %d\\nToken ID: %s\\nSeller: %s\\nPrice: %s\\nReason for cancellation: %s\\n\\nVote YES to force cancel, NO to reject\",\n\t\tp.listingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Seller.String(),\n\t\tformatPrice(listing.Price),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *ForceCancelListingProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *ForceCancelListingProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *ForceCancelListingProposal) Execute(realm) error {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn errors.New(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\treturn errors.New(\"listing already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(p.listingId), listing)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *ForceCancelListingProposal) GetListingId() int {\n\treturn p.listingId\n}\n"},{"name":"render.gno","body":"package gnopendao4\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ============= RENDER =============\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif strings.HasPrefix(path, \"listing/\") {\n\t\tidStr := strings.TrimPrefix(path, \"listing/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderListing(id)\n\t}\n\n\tif strings.HasPrefix(path, \"sale/\") {\n\t\tidStr := strings.TrimPrefix(path, \"sale/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderSale(id)\n\t}\n\n\tif path == \"stats\" {\n\t\treturn renderStats()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# GNOPENSEA DAO 10\\n\\n\"\n\toutput += \"Decentralized NFT Marketplace with DAO Governance\\n\\n\"\n\toutput += \"Compatible **GRC-721** + **GRC-2981** (Automatic Royalties)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += \"[View detailed statistics](/r/pierre115/gnopendao4:stats)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalMembers())\n\n\tactiveProposals := marketplaceDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/gnopendao4:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"*No active proposals*\\n\\n\"\n\t}\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/gnopendao4:archive)\\n\\n\", finishedProposals.Size())\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join !\", linkjoin) + \"\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\t// Active listings\n\tif GetActiveListingsCount() \u003e 0 {\n\t\toutput += \"## NFTs for sale\\n\\n\"\n\n\t\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tlisting := value.(*Listing)\n\t\t\tif listing.Active {\n\t\t\t\toutput += renderListingPreview(listing)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t} else {\n\t\toutput += \"## No NFTs for sale\\n\\n\"\n\t\toutput += \"*Be the first to list an NFT!*\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderListingPreview(listing *Listing) string {\n\t// Calculate breakdown\n\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listing.ListingId)\n\n\toutput := ufmt.Sprintf(\"### Listing #%d\\n\\n\", listing.ListingId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\n\tif royalty \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"Royalty: %s (%s)\\n\\n\",\n\t\t\tformatPrice(royalty),\n\t\t\tformatPercentage(royalty, listing.Price))\n\t}\n\n\toutput += ufmt.Sprintf(\"**Seller receives:** %s\\n\\n\", formatPrice(sellerGets))\n\toutput += ufmt.Sprintf(\"**Market Fees:** %s\\n\\n\", formatPrice(marketFee))\n\toutput += ufmt.Sprintf(\"**Royalty Address:** %s\\n\\n\", royaltyAddr.String())\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao4:listing/%d)\\n\\n\", listing.ListingId)\n\toutput += \"---\\n\\n\"\n\treturn output\n}\n\nfunc renderListing(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"# Listing not found\"\n\t}\n\n\tstatus := \"Active\"\n\tif !listing.Active {\n\t\tstatus = \"Sold/Cancelled\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Listing #%d - %s\\n\\n\", listingId, status)\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", listing.Seller.String())\n\toutput += ufmt.Sprintf(\"**Listed at block:** %d\\n\\n\", listing.ListedAt)\n\n\tif listing.Active {\n\t\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listingId)\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Price breakdown\\n\\n\"\n\t\toutput += ufmt.Sprintf(\"- **Total price:** %s (100%%)\\n\", formatPrice(listing.Price))\n\t\toutput += ufmt.Sprintf(\"- **Marketplace fee (%s):** %s\\n\",\n\t\t\tformatFee(marketplaceFee), formatPrice(marketFee))\n\n\t\tif royalty \u003e 0 {\n\t\t\toutput += ufmt.Sprintf(\"- **Creator royalty (%s):** %s\\n\",\n\t\t\t\tformatPercentage(royalty, listing.Price), formatPrice(royalty))\n\t\t\toutput += ufmt.Sprintf(\"  - Beneficiary: `%s`\\n\", royaltyAddr.String())\n\t\t} else {\n\t\t\toutput += \"- **Royalty:** None\\n\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"- **Seller receives:** %s (%s)\\n\\n\",\n\t\t\tformatPrice(sellerGets), formatPercentage(sellerGets, listing.Price))\n\n\t\toutput += \"## Purchase\\n\\n\"\n\t\toutput += \"```bash\\n\"\n\t\toutput += \"gnokey maketx call \\\\\\n\"\n\t\toutput += \"  -pkgpath \\\"gno.land/r/pierre115/gnopendao4\\\" \\\\\\n\"\n\t\toutput += \"  -func \\\"BuyNFT\\\" \\\\\\n\"\n\t\toutput += ufmt.Sprintf(\"  -args \\\"%d\\\" \\\\\\n\", listingId)\n\t\toutput += ufmt.Sprintf(\"  -send \\\"%dugnot\\\" \\\\\\n\", listing.Price)\n\t\toutput += \"  -broadcast yourkey\\n\"\n\t\toutput += \"```\\n\"\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao4)\\n\"\n\n\treturn output\n}\n\nfunc renderSale(saleId int) string {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn \"# Sale not found\"\n\t}\n\n\tsale := value.(*Sale)\n\n\toutput := ufmt.Sprintf(\"# Sale #%d\\n\\n\", saleId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", sale.TokenId)\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(sale.Price))\n\toutput += ufmt.Sprintf(\"**Buyer:** `%s`\\n\\n\", sale.Buyer.String())\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", sale.Seller.String())\n\toutput += ufmt.Sprintf(\"**Block:** %d\\n\\n\", sale.SoldAt)\n\n\toutput += \"## Distribution\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Marketplace fee:** %s\\n\", formatPrice(sale.MarketplaceFee))\n\n\tif sale.RoyaltyFee \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- **Royalty:** %s ‚Üí `%s`\\n\",\n\t\t\tformatPrice(sale.RoyaltyFee), sale.RoyaltyReceiver.String())\n\t}\n\n\tsellerReceived := sale.Price - sale.MarketplaceFee - sale.RoyaltyFee\n\toutput += ufmt.Sprintf(\"- **Seller received:** %s\\n\", formatPrice(sellerReceived))\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"# Marketplace Statistics\\n\\n\"\n\n\ttotalVolume := GetTotalVolume()\n\ttotalSales := GetTotalSales()\n\ttotalRoyalties := GetTotalRoyaltiesPaid()\n\n\toutput += ufmt.Sprintf(\"**Total volume:** %s\\n\\n\", formatPrice(totalVolume))\n\toutput += ufmt.Sprintf(\"**Number of sales:** %d\\n\\n\", totalSales)\n\toutput += ufmt.Sprintf(\"**Royalties paid:** %s (%s of volume)\\n\\n\",\n\t\tformatPrice(totalRoyalties), formatPercentage(totalRoyalties, totalVolume))\n\n\tif totalSales \u003e 0 {\n\t\tavgPrice := totalVolume / int64(totalSales)\n\t\toutput += ufmt.Sprintf(\"**Average price:** %s\\n\\n\", formatPrice(avgPrice))\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao4)\\n\"\n\n\treturn output\n}\n\n// ============= DAO RENDER FUNCTIONS =============\n\nfunc renderProposals() string {\n\toutput := \"# Active DAO Proposals\\n\\n\"\n\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"*No active proposals at the moment*\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Approve new NFT collections\\n\"\n\t\toutput += \"- Remove existing collections\\n\"\n\t\toutput += \"- Update marketplace fees\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao4)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao4)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting open**\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View \u0026 Vote](/r/pierre115/gnopendao4:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to proposals](/r/pierre115/gnopendao4:proposals) | [‚Üê Home](/r/pierre115/gnopendao4)\\n\"\n\n\treturn output\n}\n\n// ============= ARCHIVE RENDER FUNCTIONS =============\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"*No finished proposals yet*\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao4)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao4)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif p.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Status:** %s\\n\\n\", statusEmoji, string(p.Status()))\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao4:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Final Status:** %s\\n\\n\", statusEmoji, string(proposal.Status()))\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to archive](/r/pierre115/gnopendao4:archive) | [‚Üê Home](/r/pierre115/gnopendao4)\\n\"\n\n\treturn output\n}\n"},{"name":"type.gno","body":"package gnopendao4\n\nimport (\n\t\"gno.land/p/demo/tokens/grc721\"\n)\n\n// Listing structure\ntype Listing struct {\n\tListingId       int\n\tNFTGetter       grc721.NFTGetter\n\tTokenId         grc721.TokenID\n\tSeller          address\n\tPrice           int64\n\tActive          bool\n\tListedAt        int64\n\tNFTRealmAddress address\n}\n\n// Sale statistics\ntype Sale struct {\n\tListingId       int\n\tTokenId         string\n\tBuyer           address\n\tSeller          address\n\tPrice           int64\n\tMarketplaceFee  int64\n\tRoyaltyFee      int64\n\tRoyaltyReceiver address\n\tSoldAt          int64\n}\n"},{"name":"voting.gno","body":"package gnopendao4\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeApproveCollection - Create a proposal to approve a new collection\nfunc ProposeApproveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_APPROVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeRemoveCollection - Create a proposal to remove a collection\nfunc ProposeRemoveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_REMOVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUpdateFees - Create a proposal to update marketplace fees\nfunc ProposeUpdateFees(_ realm, newFeeBasisPoints int64, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif newFeeBasisPoints \u003c 0 || newFeeBasisPoints \u003e 1000 {\n\t\tpanic(\"fees must be between 0 and 1000 basis points (0-10%)\")\n\t}\n\n\tpropDef := newFeesProposal(newFeeBasisPoints, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeWithdrawTreasury - Create a proposal to withdraw funds from treasury\nfunc ProposeWithdrawTreasury(_ realm, amount int64, recipient address, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif amount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\n\tif !recipient.IsValid() {\n\t\tpanic(\"invalid recipient address\")\n\t}\n\n\tcurrentBalance := GetBalance()\n\tif amount \u003e currentBalance {\n\t\tpanic(ufmt.Sprintf(\"insufficient treasury balance (available: %d ugnot)\", currentBalance))\n\t}\n\n\tpropDef := NewTreasuryProposal(amount, recipient, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeForceCancelListing - Create a proposal to force cancel a listing\nfunc ProposeForceCancelListing(_ realm, listingId int, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\t// Verify listing exists and is active\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"listing is already inactive\")\n\t}\n\n\tpropDef := NewForceCancelListingProposal(listingId, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// Vote - Vote on a proposal (yes or no)\nfunc Vote(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tvar voteChoice commondao.VoteChoice\n\tif choice == \"yes\" {\n\t\tvoteChoice = commondao.ChoiceYes\n\t} else if choice == \"no\" {\n\t\tvoteChoice = commondao.ChoiceNo\n\t} else {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - it handles all validations automatically\n\terr := marketplaceDAO.Vote(\n\t\tcaller,\n\t\tproposalID,\n\t\tvoteChoice,\n\t\t\"\", // reason (optional)\n\t)\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyProposal - Execute a proposal after voting period\nfunc TallyProposal(_ realm, proposalID uint64) string {\n\terr := marketplaceDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n\n// GetProposalInfo - Get information about a proposal\nfunc GetProposalInfo(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"Proposal not found\"\n\t}\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput := ufmt.Sprintf(`Proposal #%d\nTitle: %s\nBody: %s\nYes Votes: %d\nNo Votes: %d\nTotal Votes: %d\nVoting Ended: %t`,\n\t\tproposalID,\n\t\tproposal.Definition().Title(),\n\t\tproposal.Definition().Body(),\n\t\tyesVotes,\n\t\tnoVotes,\n\t\tyesVotes+noVotes,\n\t\tproposal.HasVotingDeadlinePassed(),\n\t)\n\n\treturn output\n}\n\n// GetAllActiveProposals - Get all active proposals\nfunc GetAllActiveProposals() string {\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\treturn \"No active proposals\"\n\t}\n\n\toutput := \"=== Active Proposals ===\\n\\n\"\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += ufmt.Sprintf(\"ID: %d | %s\\n\", p.ID(), p.Definition().Title())\n\t\treturn false\n\t})\n\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"400000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"pY1H0fzuAriMLss5ILUo9v32/PJr/EJZ5OSB3z3Nrs34r4R8n0QUfZaqDcA151J4eTc1VoC1ykqoV288x3vHAA=="}],"memo":""},"metadata":{"timestamp":"1765611056"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynftcollection","func":"SetApprovalForAll","args":["g14g8kdflypqz2994pevn6cqj9zd0p7d68kjhycv","true"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"3SByTOLBg7VUfsZY2J26ISOqNEZiV5IsC3DGH5RfpWOtBRYj49zy3ylUNEzYDVFCOKeMTYx3SHsuQml2Eg5XBQ=="}],"memo":""},"metadata":{"timestamp":"1765611107"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"JoinDAO"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"KWuM595xuVJtiLHNRVcowVa2CrqihYIraUFZgnVbCOwMnvBSLVLFX5WTasfqsaqtiprnB854RVcIt57kvwyxDQ=="}],"memo":""},"metadata":{"timestamp":"1765611147"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"ProposeApproveCollection","args":["g1c53ppfcgjq65e7gltqusauzh6w4cawvtr7qk90","tkt","tkt"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"fPnwxzfPEbPB1h4Ry26H/aL5UD1Rp71ZtdT9x66oNc6YrmhiFfXN2M/a/JW27Veblrk7pTFHivKde1UrwNe/Bw=="}],"memo":""},"metadata":{"timestamp":"1765611182"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765611227"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"Vote","args":["1","yes"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"p107CpMAXFKTor5cvhtOX2k+IjpIvkHizkrL1+GeTZH/5Cmd2QeiSwkO2CKslrlTneIxbo4Vsss2DCJ5a7BaDA=="}],"memo":""},"metadata":{"timestamp":"1765611252"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"TallyProposal","args":["1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"4raBSPRwO7B3FkVjmkjX/xMrqljm8elEc+8XMRQU90ncP8swnzrkrZN/M91IYyVWADWNYiy/4p2CIbOhZ/RNBA=="}],"memo":""},"metadata":{"timestamp":"1765611805"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"CreateListing","args":["g1c53ppfcgjq65e7gltqusauzh6w4cawvtr7qk90","1","1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"w38Nn0AKFjmuQHrl5Eq+F8z3B+NygBgOJYLFx/cXCS/xcPUcfakXNrAcnc13R4MPnXI+GwdQ6M/tz8wIleA9DQ=="}],"memo":""},"metadata":{"timestamp":"1765611871"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"mynftcollection2","path":"gno.land/r/pierre115/mynftcollection2","files":[{"name":"README.md","body":"# My NFT Collection - NFT avec Image Fixe\n\nPackage NFT avec **image fixe** d√©finie dans le code : tous les NFTs de cette collection partagent la m√™me image.\n\n## ‚ú® Fonctionnalit√©s\n\n- ‚úÖ Support de m√©tadonn√©es onchain (GRC721Metadata)\n- ‚úÖ **Image fixe** d√©finie dans le code (tous les NFTs ont la m√™me apparence)\n- ‚úÖ Nom et description personnalis√©s par NFT\n- ‚úÖ Attributs/traits personnalis√©s (optionnel)\n- ‚úÖ Compatible avec GnopenSea marketplace\n\n---\n\n## ‚öôÔ∏è Configuration de l'Image\n\n**AVANT de d√©ployer**, change l'URL de l'image dans [nft.gno](nft.gno#L18) :\n\n```go\nvar (\n    // ...\n    // CHANGE TON URL ICI ‚Üì\n    collectionImageURL = \"https://i.imgur.com/VOTRE_IMAGE.jpg\"\n)\n```\n\n### Comment obtenir une URL d'image :\n\n1. **Imgur** (recommand√© pour tester) :\n   - Va sur [imgur.com](https://imgur.com)\n   - Upload ton image\n   - Clique droit ‚Üí \"Copy image address\"\n   - Colle l'URL dans `collectionImageURL`\n\n2. **IPFS** (d√©centralis√©) :\n   - Upload via [Pinata](https://pinata.cloud) ou [NFT.Storage](https://nft.storage)\n   - Utilise : `https://ipfs.io/ipfs/QmVotreCID/image.png`\n\n---\n\n## üöÄ D√©ploiement\n\n```bash\ngnokey maketx addpkg \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -pkgdir \"./community/packages/r/pierre115/my_nft_collection\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 100000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  -remote \"https://rpc.gno.land:443\" \\\n  votre-wallet\n```\n\n---\n\n## üìù Utilisation\n\n### 1. Enregistrer la collection dans le Registry DAO\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -func \"Register\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  -remote \"https://rpc.gno.land:443\" \\\n  votre-wallet\n```\n\n### 2. Mint un NFT\n\n#### **Option A : NFT Simple (nom + description)**\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -func \"MintNFT\" \\\n  -args \"Cosmic Cat #1\" \\\n  -args \"A mystical cat floating in space\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  votre-wallet\n```\n\n**R√©sultat** : NFT avec :\n- Image : celle d√©finie dans `collectionImageURL`\n- Nom : \"Cosmic Cat #1\"\n- Description : \"A mystical cat floating in space\"\n\n#### **Option B : NFT avec Attributs** (ex: jeu, collection rare)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -func \"MintNFTWithAttributes\" \\\n  -args \"Epic Sword #42\" \\\n  -args \"Legendary weapon forged in dragon fire\" \\\n  -args '[\"Rarity\",\"Power\",\"Element\"]' \\\n  -args '[\"Legendary\",\"95\",\"Fire\"]' \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n**R√©sultat** : NFT avec :\n- Image : celle d√©finie dans `collectionImageURL`\n- Nom : \"Epic Sword #42\"\n- Attributs :\n  - **Rarity**: Legendary\n  - **Power**: 95\n  - **Element**: Fire\n\n### 3. Voir les m√©tadonn√©es d'un NFT\n\n```bash\n# Via render\ncurl https://rpc.gno.land/r/pierre115/mynftcollection:1\n\n# Via fonction\ngnokey query vm/qeval \\\n  -remote \"https://rpc.gno.land:443\" \\\n  -data \"gno.land/r/pierre115/mynftcollection\nGetTokenMetadata(\\\"1\\\")\"\n```\n\n### 4. Approuver le marketplace\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/mynftcollection\" \\\n  -func \"SetApprovalForAll\" \\\n  -args \"g1[adresse-marketplace]\" \\\n  -args \"true\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üìä Structure de M√©tadonn√©es\n\nTous les NFTs ont la structure suivante :\n\n```go\nMetadata {\n    Name:        \"Nom personnalis√© par mint\",\n    Description: \"Description personnalis√©e par mint\",\n    Image:       \"https://i.imgur.com/VOTRE_IMAGE.jpg\", // ‚Üê FIXE pour tous\n    Attributes:  [\n        { TraitType: \"Rarity\",  Value: \"Legendary\" }, // Optionnel\n        { TraitType: \"Power\",   Value: \"95\" },\n        // ...\n    ]\n}\n```\n\n**Important** : L'image est identique pour tous les NFTs, seuls le nom, la description et les attributs changent.\n\n---\n\n## üîç Fonctions Disponibles\n\n| Fonction | Description |\n|----------|-------------|\n| `Register()` | Enregistrer la collection dans le registry |\n| `MintNFT(name, desc)` | Mint NFT simple (pas besoin de passer l'URL d'image) |\n| `MintNFTWithAttributes(name, desc, traits, values)` | Mint NFT avec attributs personnalis√©s |\n| `GetTokenMetadata(tokenId)` | Voir les m√©tadonn√©es d'un NFT |\n| `SetApprovalForAll(operator, approved)` | Approuver un op√©rateur |\n| `Getter()` | Obtenir le NFTGetter (pour marketplace) |\n| `GetCollectionInfo()` | Informations sur la collection |\n\n---\n\n## üéØ Cas d'Usage\n\n### Collection de Tickets / Memberships\n\nTous les membres ont le m√™me badge visuel :\n\n```bash\n# Tous auront la m√™me image (logo du club)\nMintNFT(\"Member #1\", \"Gold Member\")\nMintNFT(\"Member #2\", \"Silver Member\")\nMintNFT(\"Member #3\", \"Gold Member\")\n```\n\n### Collection de Jeu avec Stats Variables\n\nM√™me apparence mais stats diff√©rentes :\n\n```bash\nMintNFTWithAttributes(\n  \"Warrior #1\",\n  \"Strong warrior\",\n  [\"Attack\", \"Defense\", \"Speed\"],\n  [\"100\", \"50\", \"75\"]\n)\n\nMintNFTWithAttributes(\n  \"Warrior #2\",\n  \"Fast warrior\",\n  [\"Attack\", \"Defense\", \"Speed\"],\n  [\"80\", \"40\", \"95\"]\n)\n```\n\nTous les Warriors ont la m√™me image, mais des stats diff√©rentes !\n\n---\n\n## üîó Int√©gration avec GnopenSea\n\nUne fois d√©ploy√© et enregistr√© :\n1. Tous les NFTs de cette collection afficheront **la m√™me image** sur le marketplace\n2. Les noms et descriptions seront affich√©s dans la carte NFT\n3. Les attributs seront visibles sur la page de d√©tail\n\n---\n\n## üí° Pourquoi une Image Fixe ?\n\n‚úÖ **Avantages** :\n- Plus simple √† mint (pas besoin de passer l'URL √† chaque fois)\n- Parfait pour les collections de \"tickets\" ou \"memberships\"\n- Id√©al pour les jeux o√π l'apparence est fixe mais les stats varient\n- Moins cher en gas (pas besoin de stocker l'URL √† chaque mint)\n\n‚ùå **D√©savantage** :\n- Tous les NFTs ont la m√™me apparence visuelle\n- Pas adapt√© pour collections d'art avec pi√®ces uniques\n\n**Pour des images diff√©rentes par NFT**, utilise plut√¥t le package `my_test_nft` avec imageURL en param√®tre.\n\n---\n\n## üìÑ License\n\nProjet de stage - Tous droits r√©serv√©s\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/mynftcollection2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"nft.gno","body":"package mynftcollection2\n\nimport (\n\t\"chain/runtime\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry4\"\n)\n\n// Interface locale qui combine toutes les m√©thodes n√©cessaires\ntype NFTWithMetadata interface {\n\tgrc721.IGRC721\n\tgrc721.IGRC721MetadataOnchain\n\tMint(to address, tid grc721.TokenID) error\n\tSetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error\n\tGetter() grc721.NFTGetter\n}\n\nvar (\n\tnft         NFTWithMetadata\n\tnextTokenId = 1\n\tmyRealmAddr = runtime.CurrentRealm().Address()\n\tcollectionImageURL = \"https://i.imgflip.com/a6o5jb.jpg\"\n)\n\nfunc init() {\n\tnft = grc721.NewNFTWithMetadata(\"My NFT Collection\", \"MNFT\")\n}\n\n// Register registers this collection on the NFT registry\nfunc Register(_ realm) {\n\tdaoregistry4.RegisterCollection(\n\t\tmyRealmAddr,\n\t\t\"My NFT Collection\",\n\t\t\"MNFT\",\n\t\t\"art\",\n\t\t\"NFT Collection with full metadata support\",\n\t\t\"https://example.com\",\n\t\ttrue, // supportsMetadata\n\t\tGetter(),\n\t)\n}\n\n// MintNFT - Mint a new NFT with metadata (image fixe d√©finie dans collectionImageURL)\nfunc MintNFT(_ realm, name string, description string) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\t// Mint the NFT\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\t// Set metadata avec l'image fixe de la collection\n\tmetadata := grc721.Metadata{\n\t\tName:        name,\n\t\tDescription: description,\n\t\tImage:       collectionImageURL, // Image fixe pour tous les NFTs\n\t\tAttributes:  []grc721.Trait{},\n\t}\n\n\terr = nft.SetTokenMetadata(tokenId, metadata)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\n// MintNFTWithAttributes - Mint NFT with custom attributes (image fixe d√©finie dans collectionImageURL)\nfunc MintNFTWithAttributes(\n\t_ realm,\n\tname string,\n\tdescription string,\n\ttraitTypes []string,\n\ttraitValues []string,\n) int {\n\tcaller := runtime.PreviousRealm().Address()\n\ttokenId := grc721.TokenID(strconv.Itoa(nextTokenId))\n\n\t// Mint the NFT\n\terr := nft.Mint(caller, tokenId)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\t// Build attributes\n\tvar attributes []grc721.Trait\n\tif len(traitTypes) != len(traitValues) {\n\t\tpanic(\"traitTypes and traitValues must have the same length\")\n\t}\n\n\tfor i := 0; i \u003c len(traitTypes); i++ {\n\t\tattributes = append(attributes, grc721.Trait{\n\t\t\tTraitType: traitTypes[i],\n\t\t\tValue:     traitValues[i],\n\t\t})\n\t}\n\n\t// Set metadata with attributes et image fixe\n\tmetadata := grc721.Metadata{\n\t\tName:        name,\n\t\tDescription: description,\n\t\tImage:       collectionImageURL, // Image fixe pour tous les NFTs\n\t\tAttributes:  attributes,\n\t}\n\n\terr = nft.SetTokenMetadata(tokenId, metadata)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tnextTokenId++\n\treturn nextTokenId - 1\n}\n\n// GetTokenMetadata - Get metadata for a token\nfunc GetTokenMetadata(tokenId string) string {\n\ttid := grc721.TokenID(tokenId)\n\n\tmetadata, err := nft.TokenMetadata(tid)\n\tif err != nil {\n\t\treturn \"Error: \" + err.Error()\n\t}\n\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", metadata.Name)\n\toutput += ufmt.Sprintf(\"**Description:** %s\\n\\n\", metadata.Description)\n\toutput += ufmt.Sprintf(\"**Image:** %s\\n\\n\", metadata.Image)\n\n\tif len(metadata.Attributes) \u003e 0 {\n\t\toutput += \"## Attributes\\n\\n\"\n\t\tfor _, trait := range metadata.Attributes {\n\t\t\toutput += ufmt.Sprintf(\"- **%s:** %s\\n\", trait.TraitType, trait.Value)\n\t\t}\n\t}\n\n\treturn output\n}\n\n// SetApprovalForAll - Approve or revoke operator to manage all caller's NFTs\nfunc SetApprovalForAll(_ realm, operator address, approved bool) {\n\terr := nft.SetApprovalForAll(operator, approved)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\n// Getter - Returns the NFT getter function\nfunc Getter() grc721.NFTGetter {\n\treturn func() grc721.IGRC721 {\n\t\treturn nft\n\t}\n}\n\n// GetCollectionInfo - Returns collection info\nfunc GetCollectionInfo() string {\n\toutput := \"# My NFT Collection\\n\\n\"\n\toutput += \"**Symbol:** MNFT\\n\"\n\toutput += \"**Total Supply:** \" + strconv.Itoa(nextTokenId-1) + \"\\n\"\n\toutput += \"**Realm Address:** \" + myRealmAddr.String() + \"\\n\"\n\toutput += \"**Supports Metadata:** Yes\\n\\n\"\n\toutput += \"This collection supports full onchain metadata including images, descriptions, and custom attributes.\\n\"\n\treturn output\n}\n\n// Render - Render the collection page\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn GetCollectionInfo()\n\t}\n\n\t// If path is a token ID, show token metadata\n\treturn GetTokenMetadata(path)\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"40000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"huJ44ySv/Mq0gGbLhSz1p/EWuQyRIx/w+amBRqki2Ts4jd5jP4zn+YhI50SR/yY0ZNbR08lmIOJEwwqYJScDAg=="}],"memo":""},"metadata":{"timestamp":"1765614580"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynftcollection2","func":"SetApprovalForAll","args":["g14g8kdflypqz2994pevn6cqj9zd0p7d68kjhycv","true"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"LCw7CiniZja6tVSyhd7BzuuDIfE5s/zVDGaw9as8v5PxPokUUoiEnonSpvK4XkvPS2FeTnagCjQulNjPLGu/Aw=="}],"memo":""},"metadata":{"timestamp":"1765614670"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynftcollection2","func":"Register"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"GwV305VZkvsXf8XEtqi28iJDEbwFjkQOWzCcbpQr4rIGcrEzJ12hLLvwptdzMWF+YR8rSK1lhelSsKusZ3tQCA=="}],"memo":""},"metadata":{"timestamp":"1765614690"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765614736"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynftcollection2","func":"MintNFT","args":["monnft","tkt"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"UWx2yhTy29XmjNektPSmVlA273tjneXc6RHgrFsl6v04on9t4AJE6MVqih1P2DWnEi1cRWain8EG2CcD/mKLAw=="}],"memo":""},"metadata":{"timestamp":"1765614761"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"ProposeApproveCollection","args":["g14aa34n5k3ufr8qudn6ecadwhuqp04mulkdh2vp","monnft","tkt"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"LMZ+xfioNaTZh6El5giDjq2LsOrgUpA59lmPlUns4ryuVI6l+TxRtO47fg/Ocb/RU+27isSHIjD6ISzen27QBQ=="}],"memo":""},"metadata":{"timestamp":"1765614957"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"Vote","args":["2","yes"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"KpX51N0Gud8IEMREH/FgwwIHm2Ex2mydBRk+1lKz7AfivArK5xfT1BRhaq43AYPK3/9AY93owxmJIgXWUDCWCQ=="}],"memo":""},"metadata":{"timestamp":"1765615042"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"TallyProposal","args":["2"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"UHbtDwsTiKMPEmNYC/B3aQBCme4RinXuEQKwKtZlhITAFWAq+PeyCMT71RsFk5UF/cFibXvMj3ADDSwBCBR1CQ=="}],"memo":""},"metadata":{"timestamp":"1765615716"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao4","func":"CreateListing","args":["g14aa34n5k3ufr8qudn6ecadwhuqp04mulkdh2vp","1","1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Jtn6SEUprOMkQktCo6JuldUc+mKfBxbs0U154TcMAd1C4gJrmoLQgLxLaklMMLOS9kS5x/brZJ4me6KP4XmKCw=="}],"memo":""},"metadata":{"timestamp":"1765615771"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765616907"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","package":{"name":"gnopendao5","path":"gno.land/r/pierre115/gnopendao5","files":[{"name":"README.md","body":"# GnopenSea - NFT Marketplace\n\nMarketplace NFT d√©centralis√© sur Gno.land avec gouvernance DAO.\n\n## üöÄ Comment lister votre NFT en 3 √©tapes\n\n### √âtape 1 : Enregistrer votre collection\n\n**Depuis votre package NFT**, appelez la fonction `Register()` :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"Register\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  -chainid \"staging\" \\\n  votre-wallet\n```\n\nCela enregistre votre collection dans le **Registry DAO** (statut: non v√©rifi√©).\n\n### √âtape 2 : Approuver le marketplace\n\nDonnez la permission au marketplace de transf√©rer vos NFTs :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -func \"SetApprovalForAll\" \\\n  -args \"g1[adresse-du-marketplace]\" \\\n  -args \"true\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### √âtape 3 : Cr√©er votre listing\n\nListez votre NFT √† vendre :\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CreateListing\" \\\n  -args \"gno.land/r/[votre-username]/[votre-nft]\" \\\n  -args \"1\" \\\n  -args \"5000000\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n**Param√®tres :**\n- 1er arg : Adresse de votre package NFT\n- 2√®me arg : Token ID √† vendre\n- 3√®me arg : Prix en ugnot (5000000 = 5 GNOT)\n\n---\n\n## üõí Acheter un NFT\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"BuyNFT\" \\\n  -args \"1\" \\\n  -send \"5000000ugnot\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üìã G√©rer vos listings\n\n### Modifier le prix\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"UpdatePrice\" \\\n  -args \"1\" \\\n  -args \"10000000\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n### Annuler un listing\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"CancelListing\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üé® Faire v√©rifier votre collection (badge v√©rifi√©)\n\n### 1. Cr√©er une proposal au Registry DAO\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"ProposeVerifyCollection\" \\\n  -args \"g1[adresse-de-votre-nft]\" \\\n  -args \"Nom de la collection\" \\\n  -args \"Raison de la v√©rification\" \\\n  -gas-fee 1000000ugnot \\\n  -gas-wanted 5000000 \\\n  -broadcast \\\n  votre-wallet\n```\n\n### 2. Les membres du DAO votent\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"VoteRegistry\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### 3. Ex√©cuter la proposal (apr√®s quorum)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/daoregistry4\" \\\n  -func \"TallyRegistryProposal\" \\\n  -args \"1\" \\\n  -broadcast \\\n  votre-wallet\n```\n\n---\n\n## üí∞ Distribution des paiements\n\nExemple avec frais marketplace 2.5% et royalties 10% :\n\n```\nPrix de vente : 100 GNOT\n‚îú‚îÄ‚îÄ Frais marketplace (2.5%) : 2.5 GNOT\n‚îú‚îÄ‚îÄ Royalties cr√©ateur (10%) : 10 GNOT\n‚îî‚îÄ‚îÄ Vendeur re√ßoit : 87.5 GNOT\n```\n\n---\n\n## üèõÔ∏è Gouvernance DAO\n\nLe marketplace est gouvern√© par un DAO. Les membres peuvent cr√©er des proposals pour :\n\n- ‚úÖ Approuver/retirer des collections\n- ‚úÖ Modifier les frais du marketplace\n- ‚úÖ Retirer des fonds du tr√©sor\n- ‚úÖ Annuler un listing probl√©matique\n\n### Cr√©er une proposal (exemple: modifier les frais)\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"ProposeUpdateFees\" \\\n  -args \"300\" \\\n  -args \"R√©duction des frais √† 3%\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n### Voter sur une proposal\n\n```bash\ngnokey maketx call \\\n  -pkgpath \"gno.land/r/pierre115/gnopendao\" \\\n  -func \"Vote\" \\\n  -args \"1\" \\\n  -args \"yes\" \\\n  -broadcast \\\n  membre-dao-wallet\n```\n\n---\n\n## üîß Configuration NFT minimale\n\nVotre package NFT doit avoir une fonction `Register()` :\n\n```go\npackage mynft\n\nimport (\n    \"gno.land/p/demo/tokens/grc721\"\n    \"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n    nft         *grc721.basicNFT\n    myRealmAddr = runtime.CurrentRealm().Address()\n)\n\nfunc init() {\n    nft = grc721.NewBasicNFT(\"My Collection\", \"MC\")\n}\n\n// Register dans le registry\nfunc Register(_ realm) {\n    daoregistry4.RegisterCollection(\n        myRealmAddr,\n        \"My Collection\",\n        \"MC\",\n        \"art\",\n        \"Description de ma collection\",\n        \"https://mon-site.com\",\n        false,\n        nft.Getter(),\n    )\n}\n\n// Fonction obligatoire pour le marketplace\nfunc Getter() grc721.NFTGetter {\n    return nft.Getter()\n}\n```\n\n---\n\n## üìä Fonctions de lecture\n\n```bash\n# Voir tous les listings actifs\ncurl https://rpc.gno.land/r/pierre115/gnopendao:\n\n# Statistiques du marketplace\ncurl https://rpc.gno.land/r/pierre115/gnopendao:stats\n\n# D√©tails d'un listing\ncurl https://rpc.gno.land/r/pierre115/gnopendao:listing/1\n\n# Collections enregistr√©es\ncurl https://rpc.gno.land/r/pierre115/daoregistry4:\n```\n\n---\n\n## üîê S√©curit√©\n\n- ‚úÖ V√©rification de propri√©t√© avant listing\n- ‚úÖ V√©rification d'approbation avant vente\n- ‚úÖ Transferts atomiques\n- ‚úÖ Remboursement automatique des surplus\n- ‚úÖ Limites de frais (max 10%)\n- ‚úÖ Gouvernance d√©centralis√©e\n\n---\n\n## üÜò Probl√®mes courants\n\n**\"Collection not registered\"**\n‚Üí Vous devez d'abord appeler `Register()` sur votre NFT\n\n**\"Insufficient payment\"**\n‚Üí Le montant envoy√© doit correspondre au prix du listing\n\n**\"Not approved\"**\n‚Üí Appelez `SetApprovalForAll()` avant de cr√©er un listing\n\n**\"Not owner\"**\n‚Üí Seul le propri√©taire du NFT peut le lister\n"},{"name":"dao.gno","body":"package gnopendao5\n\nimport (\n\t//\"chain/banker\"\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n)\n\nvar (\n\tmarketplaceDAO *commondao.CommonDAO\n)\n\nconst (\n\tMIN_STAKE_UGNOT = 0 // 0 GNOT minimum to join DAO\n)\n\nfunc initDAO() {\n\tstorage := commondao.NewMemberStorage()\n\n\tmarketplaceDAO = commondao.New(\n\t\tcommondao.WithID(1),\n\t\tcommondao.WithName(\"GnopenSea DAO\"),\n\t\tcommondao.WithDescription(\"Decentralized governance for GnopenSea marketplace\"),\n\t\tcommondao.WithMemberStorage(storage),\n\t)\n}\n\n// JoinDAO - Join the marketplace DAO by staking GNOT\nfunc JoinDAO(_ realm) string {\n\tcaller := runtime.PreviousRealm().Address()\n\t//sent := banker.OriginSend()\n\n\t//amount := sent.AmountOf(\"ugnot\")\n\t//if amount \u003c MIN_STAKE_UGNOT {\n\t//\tpanic(\"minimum 1 GNOT required to join DAO\")\n\t//}\n\n\tif marketplaceDAO.Members().Has(caller) {\n\t\tpanic(\"already a DAO member\")\n\t}\n\n\tmarketplaceDAO.Members().Add(caller)\n\n\treturn \"Successfully joined GnopenSea DAO\"\n}\n\n// IsDAOMember - Check if an address is a DAO member\nfunc IsDAOMember(addr address) bool {\n\treturn marketplaceDAO.Members().Has(addr)\n}\n\n// GetTotalMembers - Returns total number of DAO members\nfunc GetTotalMembers() int {\n\treturn marketplaceDAO.Members().Size()\n}\n"},{"name":"gnomod.toml","body":"module = \"gno.land/r/pierre115/gnopendao5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg\"\n"},{"name":"gnopensea.gno","body":"package gnopendao5\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/tokens/grc721\"\n\t\"gno.land/p/nt/avl\"\n\t\"gno.land/p/nt/ufmt\"\n\t\"gno.land/r/pierre115/daoregistry4\"\n)\n\nvar (\n\tlistings      avl.Tree\n\tsales         avl.Tree\n\tnextListingId = 1\n\tnextSaleId    = 1\n\n\tmarketplaceFee      = int64(250) // 250 basis points = 2.5%\n\tmarketplaceAddr     = runtime.CurrentRealm().Address()\n\tapprovedCollections avl.Tree // Whitelist of approved collections\n)\n\nfunc init() {\n\tinitDAO()\n}\n\n// CreateListing - List an NFT for sale using the global NFT Registry\nfunc CreateListing(_ realm, nftRealmAddress address, tokenId grc721.TokenID, price int64) int {\n\tcaller := runtime.OriginCaller()\n\n\tif price \u003c= 0 || price \u003e 99999999999 {\n\t\tpanic(\"Price not valid\")\n\t}\n\n\t// Check if collection is registered in the GLOBAL NFT Registry (technical check)\n\tif !daoregistry4.IsRegistered(nftRealmAddress) {\n\t\tpanic(\"NFT collection not registered in the global NFT Registry. The collection must call nftregistry.RegisterCollection() first.\")\n\t}\n\t// Check if collection is approved by DAO (governance check)\n\tif !approvedCollections.Has(nftRealmAddress.String()) {\n\t\tpanic(\"Collection not approved by DAO. A DAO proposal must be created and passed first.\")\n\t}\n\n\t// Get NFT getter from the global registry\n\tgetter, exists := daoregistry4.GetNFTGetter(nftRealmAddress)\n\tif !exists {\n\t\tpanic(\"Failed to get NFT getter from registry\")\n\t}\n\n\tnftInstance := getter()\n\n\t// Verify caller is the owner\n\towner, err := nftInstance.OwnerOf(tokenId)\n\tif err != nil {\n\t\tpanic(\"Token not found: \" + err.Error())\n\t}\n\n\tif owner != caller {\n\t\tpanic(\"You are not the owner of this NFT\")\n\t}\n\n\t// Verify approvals\n\tmarketplaceAddr := runtime.CurrentRealm().Address()\n\tapprovedAddr, err := nftInstance.GetApproved(tokenId)\n\tisApprovedForToken := (err == nil \u0026\u0026 approvedAddr == marketplaceAddr)\n\tisApprovedForAll := nftInstance.IsApprovedForAll(owner, marketplaceAddr)\n\n\tif !isApprovedForToken \u0026\u0026 !isApprovedForAll {\n\t\tpanic(\"You must first approve the marketplace.\\nUse Approve() or SetApprovalForAll()\")\n\t}\n\n\t// Create listing\n\tlisting := \u0026Listing{\n\t\tListingId:       nextListingId,\n\t\tNFTGetter:       getter,\n\t\tTokenId:         tokenId,\n\t\tSeller:          caller,\n\t\tPrice:           price,\n\t\tActive:          true,\n\t\tListedAt:        runtime.ChainHeight(),\n\t\tNFTRealmAddress: nftRealmAddress,\n\t}\n\n\tlistings.Set(strconv.Itoa(nextListingId), listing)\n\tnextListingId++\n\n\treturn listing.ListingId\n}\n\n// BuyNFT - Purchase a listed NFT with automatic royalty calculation\nfunc BuyNFT(_ realm, listingId int) {\n\tcaller := runtime.OriginCaller()\n\tsent := banker.OriginSend()\n\n\t// Get listing\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\t// Verify payment\n\tamount := sent.AmountOf(\"ugnot\")\n\tif amount \u003c listing.Price {\n\t\tpanic(ufmt.Sprintf(\"Insufficient amount. Price: %d ugnot\", listing.Price))\n\t}\n\n\t// Get NFT instance\n\tnftInstance := listing.NFTGetter()\n\n\t// Verify seller still owns the NFT\n\tcurrentOwner, err := nftInstance.OwnerOf(listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"NFT not found: \" + err.Error())\n\t}\n\tif currentOwner != listing.Seller {\n\t\tpanic(\"Seller no longer owns this NFT\")\n\t}\n\n\t// Calculate royalties\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\t// Check if NFT supports royalties\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate what seller receives\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\tif sellerAmount \u003c 0 {\n\t\tpanic(\"Error: fees + royalties exceed sale price\")\n\t}\n\n\t// Distribute payments\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\t// 1. Pay seller\n\tif sellerAmount \u003e 0 {\n\t\tsellerCoins := chain.Coins{chain.Coin{\"ugnot\", sellerAmount}}\n\t\tbnkr.SendCoins(realmAddr, listing.Seller, sellerCoins)\n\t}\n\n\t// 2. Pay royalties to creator\n\tif royaltyAmount \u003e 0 \u0026\u0026 royaltyReceiver != \"\" {\n\t\troyaltyCoins := chain.Coins{chain.Coin{\"ugnot\", royaltyAmount}}\n\t\tbnkr.SendCoins(realmAddr, royaltyReceiver, royaltyCoins)\n\t}\n\n\t// 3. TODO : Marketplace fees remain in contract\n\n\t// 4. Refund excess\n\tif amount \u003e listing.Price {\n\t\texcess := amount - listing.Price\n\t\texcessCoins := chain.Coins{chain.Coin{\"ugnot\", excess}}\n\t\tbnkr.SendCoins(realmAddr, caller, excessCoins)\n\t}\n\n\t// Transfer NFT\n\terr = nftInstance.TransferFrom(listing.Seller, caller, listing.TokenId)\n\tif err != nil {\n\t\tpanic(\"Transfer error: \" + err.Error())\n\t}\n\n\t// Record sale\n\tsale := \u0026Sale{\n\t\tListingId:       listingId,\n\t\tTokenId:         listing.TokenId.String(),\n\t\tBuyer:           caller,\n\t\tSeller:          listing.Seller,\n\t\tPrice:           listing.Price,\n\t\tMarketplaceFee:  marketplaceFeeAmount,\n\t\tRoyaltyFee:      royaltyAmount,\n\t\tRoyaltyReceiver: royaltyReceiver,\n\t\tSoldAt:          runtime.ChainHeight(),\n\t}\n\n\tsales.Set(strconv.Itoa(nextSaleId), sale)\n\tnextSaleId++\n\n\t// Deactivate listing\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// CancelListing - Cancel own listing (seller only)\nfunc CancelListing(_ realm, listingId int) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\t// Only seller can cancel their own listing\n\t// DAO use ProposeForceCancelListing instead\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can cancel this listing. DAO members can create a ProposeForceCancelListing proposal.\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// UpdatePrice - Update listing price\nfunc UpdatePrice(_ realm, listingId int, newPrice int64) {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif newPrice \u003c= 0 {\n\t\tpanic(\"Price must be positive\")\n\t}\n\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"Listing not found\")\n\t}\n\n\tif listing.Seller != caller {\n\t\tpanic(\"Only the seller can modify this listing\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"This listing is no longer active\")\n\t}\n\n\tlisting.Price = newPrice\n\tlistings.Set(strconv.Itoa(listingId), listing)\n}\n\n// ============= READ FUNCTIONS =============\n\nfunc GetListing(listingId int) (int, string, int64, string, bool, int64) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, \"\", 0, \"\", false, 0\n\t}\n\n\treturn listing.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tlisting.ListedAt\n}\n\nfunc GetSale(saleId int) (int, string, string, string, int64, int64, int64, string, int64) {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn 0, \"\", \"\", \"\", 0, 0, 0, \"\", 0\n\t}\n\n\tsale := value.(*Sale)\n\treturn sale.ListingId,\n\t\tsale.TokenId,\n\t\tsale.Buyer.String(),\n\t\tsale.Seller.String(),\n\t\tsale.Price,\n\t\tsale.MarketplaceFee,\n\t\tsale.RoyaltyFee,\n\t\tsale.RoyaltyReceiver.String(),\n\t\tsale.SoldAt\n}\n\nfunc GetActiveListingsCount() int {\n\tcount := 0\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\tcount++\n\t\t}\n\t\treturn false\n\t})\n\treturn count\n}\n\nfunc GetTotalSales() int {\n\treturn sales.Size()\n}\n\nfunc GetTotalVolume() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.Price\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetTotalRoyaltiesPaid() int64 {\n\tvar total int64 = 0\n\tsales.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tsale := value.(*Sale)\n\t\ttotal += sale.RoyaltyFee\n\t\treturn false\n\t})\n\treturn total\n}\n\nfunc GetMarketplaceFee() int64 {\n\treturn marketplaceFee\n}\n\nfunc GetMarketplaceAddress() address {\n\treturn runtime.CurrentRealm().Address()\n}\n\n// GetRoyaltyBreakdown - Calculate distribution for a listing\nfunc GetRoyaltyBreakdown(listingId int) (int64, int64, int64, address) {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn 0, 0, 0, \"\"\n\t}\n\n\t// Calculate marketplace fee\n\tmarketplaceFeeAmount := (listing.Price * marketplaceFee) / 10000\n\n\t// Calculate royalties if supported\n\tnftInstance := listing.NFTGetter()\n\tvar royaltyAmount int64 = 0\n\tvar royaltyReceiver address\n\n\tif royaltyNFT, ok := nftInstance.(grc721.IGRC2981); ok {\n\t\taddr, amount, err := royaltyNFT.RoyaltyInfo(listing.TokenId, listing.Price)\n\t\tif err == nil {\n\t\t\troyaltyAmount = amount\n\t\t\troyaltyReceiver = addr\n\t\t}\n\t}\n\n\tsellerAmount := listing.Price - marketplaceFeeAmount - royaltyAmount\n\n\treturn sellerAmount, marketplaceFeeAmount, royaltyAmount, royaltyReceiver\n}\n\nfunc GetBalance() int64 {\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\tbalance := bnkr.GetCoins(realmAddr)\n\treturn balance.AmountOf(\"ugnot\")\n}\n\n// ============= READ FUNCTIONS FOR FRONTEND =============\n\n// GetAllListings - Return all active listings with metadata\nfunc GetAllListings() string {\n\tvar listingsData []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Active {\n\t\t\t// Try to get image and name from onchain metadata via the registry\n\t\t\t// The registry can make the type assertion in the collection's realm context\n\t\t\tvar image, name string\n\t\t\tmetadata, err := daoregistry4.GetTokenMetadata(listing.NFTRealmAddress, listing.TokenId)\n\t\t\tif err == nil {\n\t\t\t\timage = metadata.Image\n\t\t\t\tname = metadata.Name\n\t\t\t}\n\n\t\t\t// If no image, use the collection's default image\n\t\t\tif image == \"\" {\n\t\t\t\timage = \"https://i.imgflip.com/a6o5jb.jpg\"\n\t\t\t}\n\n\t\t\t// If no name, use default\n\t\t\tif name == \"\" {\n\t\t\t\tname = ufmt.Sprintf(\"NFT #%s\", listing.TokenId.String())\n\t\t\t}\n\n\t\t\t// Format: listingId|nftAddress|tokenId|price|seller|image|name\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%s|%d|%s|%s|%s\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.NFTRealmAddress.String(),\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t\tlisting.Seller.String(),\n\t\t\t\timage,\n\t\t\t\tname,\n\t\t\t)\n\t\t\tlistingsData = append(listingsData, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(listingsData) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(listingsData, \"\\n\")\n}\n\n// GetListingDetails - Get detailed info about a listing\nfunc GetListingDetails(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"Listing not found\"\n\t}\n\n\t// Get NFT metadata via the registry\n\t// The registry can make the type assertion in the collection's realm context\n\tvar name, description, image, uri string\n\tvar attributes []grc721.Trait\n\n\t// Try onchain metadata via registry\n\tmetadata, err := daoregistry4.GetTokenMetadata(listing.NFTRealmAddress, listing.TokenId)\n\tif err == nil {\n\t\tname = metadata.Name\n\t\tdescription = metadata.Description\n\t\timage = metadata.Image\n\t\tattributes = metadata.Attributes\n\t}\n\n\t// Format attributes as JSON array\n\tattributesJSON := \"[]\"\n\tif len(attributes) \u003e 0 {\n\t\tattrStr := \"[\"\n\t\tfor i, attr := range attributes {\n\t\t\tif i \u003e 0 {\n\t\t\t\tattrStr += \",\"\n\t\t\t}\n\t\t\tattrStr += ufmt.Sprintf(`{\"trait_type\":\"%s\",\"value\":\"%s\"}`, attr.TraitType, attr.Value)\n\t\t}\n\t\tattrStr += \"]\"\n\t\tattributesJSON = attrStr\n\t}\n\n\t// Format JSON-like response\n\toutput := ufmt.Sprintf(`{\n  \"listingId\": %d,\n  \"tokenId\": \"%s\",\n  \"price\": %d,\n  \"seller\": \"%s\",\n  \"active\": %t,\n  \"name\": \"%s\",\n  \"description\": \"%s\",\n  \"image\": \"%s\",\n  \"uri\": \"%s\",\n  \"attributes\": %s,\n  \"listedAt\": %d\n}`,\n\t\tlisting.ListingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Price,\n\t\tlisting.Seller.String(),\n\t\tlisting.Active,\n\t\tname,\n\t\tdescription,\n\t\timage,\n\t\turi,\n\t\tattributesJSON,\n\t\tlisting.ListedAt,\n\t)\n\n\treturn output\n}\n\n// GetUserListings - Get all listings by a specific seller\nfunc GetUserListings(sellerAddr address) string {\n\tvar userListings []string\n\n\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tlisting := value.(*Listing)\n\t\tif listing.Seller == sellerAddr \u0026\u0026 listing.Active {\n\t\t\tlistingData := ufmt.Sprintf(\"%d|%s|%d\",\n\t\t\t\tlisting.ListingId,\n\t\t\t\tlisting.TokenId.String(),\n\t\t\t\tlisting.Price,\n\t\t\t)\n\t\t\tuserListings = append(userListings, listingData)\n\t\t}\n\t\treturn false\n\t})\n\n\tif len(userListings) == 0 {\n\t\treturn \"No active listings\"\n\t}\n\n\treturn strings.Join(userListings, \"\\n\")\n}\n\n// GetMarketplaceStats - Get overall marketplace statistics\nfunc GetMarketplaceStats() string {\n\tactiveCount := GetActiveListingsCount()\n\ttotalSales := GetTotalSales()\n\ttotalVolume := GetTotalVolume()\n\n\toutput := ufmt.Sprintf(`{\n  \"activeListings\": %d,\n  \"totalSales\": %d,\n  \"totalVolume\": %d,\n  \"marketplaceFee\": %d\n}`,\n\t\tactiveCount,\n\t\ttotalSales,\n\t\ttotalVolume,\n\t\tmarketplaceFee,\n\t)\n\n\treturn output\n}\n\n// ============= HELPERS =============\n\nfunc getListing(listingId int) *Listing {\n\tvalue, exists := listings.Get(strconv.Itoa(listingId))\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn value.(*Listing)\n}\n\nfunc formatPrice(ugnot int64) string {\n\tgnot := float64(ugnot) / 1000000.0\n\treturn ufmt.Sprintf(\"%.2f GNOT\", gnot)\n}\n\nfunc formatFee(basisPoints int64) string {\n\tpercent := float64(basisPoints) / 100.0\n\treturn ufmt.Sprintf(\"%.2f%%\", percent)\n}\n\nfunc formatPercentage(value, total int64) string {\n\tif total == 0 {\n\t\treturn \"0%\"\n\t}\n\tpercent := (float64(value) / float64(total)) * 100.0\n\treturn ufmt.Sprintf(\"%.1f%%\", percent)\n}\n"},{"name":"gnopensea_test.gno","body":"package gnopendao5\n\nimport (\n\t\"testing\"\n)\n\n// Test marketplace initialization values\nfunc TestMarketplaceInit(t *testing.T) {\n\t// Check marketplace fee is set to default (2.5%)\n\tfee := GetMarketplaceFee()\n\tif fee != 250 {\n\t\tt.Errorf(\"Expected marketplace fee to be 250, got %d\", fee)\n\t}\n}\n\n// Test marketplace fee getter\nfunc TestGetMarketplaceFee(t *testing.T) {\n\tfee := GetMarketplaceFee()\n\tif fee \u003c 0 || fee \u003e 1000 {\n\t\tt.Errorf(\"Marketplace fee out of valid range (0-1000): %d\", fee)\n\t}\n}\n\n// Test active listings count (should not panic)\nfunc TestGetActiveListingsCount(t *testing.T) {\n\tcount := GetActiveListingsCount()\n\tif count \u003c 0 {\n\t\tt.Errorf(\"Active listings count should not be negative: %d\", count)\n\t}\n}\n\n// Test total sales (should not panic)\nfunc TestGetTotalSales(t *testing.T) {\n\tsales := GetTotalSales()\n\tif sales \u003c 0 {\n\t\tt.Errorf(\"Total sales should not be negative: %d\", sales)\n\t}\n}\n\n// Test total volume (should not panic)\nfunc TestGetTotalVolume(t *testing.T) {\n\tvolume := GetTotalVolume()\n\tif volume \u003c 0 {\n\t\tt.Errorf(\"Total volume should not be negative: %d\", volume)\n\t}\n}\n\n// Test total royalties paid (should not panic)\nfunc TestGetTotalRoyaltiesPaid(t *testing.T) {\n\troyalties := GetTotalRoyaltiesPaid()\n\tif royalties \u003c 0 {\n\t\tt.Errorf(\"Total royalties should not be negative: %d\", royalties)\n\t}\n}\n\n// Test marketplace address getter (should not panic)\nfunc TestGetMarketplaceAddress(t *testing.T) {\n\taddr := GetMarketplaceAddress()\n\tif addr == \"\" {\n\t\tt.Error(\"Marketplace address should not be empty\")\n\t}\n}\n\n// Test balance getter (should not panic)\nfunc TestGetBalance(t *testing.T) {\n\tbalance := GetBalance()\n\tif balance \u003c 0 {\n\t\tt.Errorf(\"Balance should not be negative: %d\", balance)\n\t}\n}\n\n// Test render home page (should not panic)\nfunc TestRenderHome(t *testing.T) {\n\toutput := Render(\"\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Home render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Marketplace\") {\n\t\tt.Error(\"Home render should contain 'Marketplace'\")\n\t}\n}\n\n// Test render stats page (should not panic)\nfunc TestRenderStats(t *testing.T) {\n\toutput := Render(\"stats\")\n\tif len(output) == 0 {\n\t\tt.Error(\"Stats render should not be empty\")\n\t}\n\n\t// Check for expected content\n\tif !contains(output, \"Statistics\") {\n\t\tt.Error(\"Stats render should contain 'Statistics'\")\n\t}\n}\n\n// Test render invalid path\nfunc TestRenderInvalidPath(t *testing.T) {\n\toutput := Render(\"invalid/path/test\")\n\tif output != \"Page not found\" {\n\t\tt.Errorf(\"Expected 'Page not found', got '%s'\", output)\n\t}\n}\n\n// Test format price function\nfunc TestFormatPrice(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{1000000, \"1.00 GNOT\"},\n\t\t{5000000, \"5.00 GNOT\"},\n\t\t{100, \"0.00 GNOT\"},\n\t\t{0, \"0.00 GNOT\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPrice(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPrice(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format fee function\nfunc TestFormatFee(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{250, \"2.50%\"},\n\t\t{500, \"5.00%\"},\n\t\t{1000, \"10.00%\"},\n\t\t{0, \"0.00%\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatFee(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatFee(%d) = %s, expected %s\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test format percentage function\nfunc TestFormatPercentage(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    int64\n\t\ttotal    int64\n\t\texpected string\n\t}{\n\t\t{25, 100, \"25.0%\"},\n\t\t{50, 100, \"50.0%\"},\n\t\t{0, 100, \"0.0%\"},\n\t\t{100, 100, \"100.0%\"},\n\t\t{0, 0, \"0%\"}, // Division by zero case\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := formatPercentage(tt.value, tt.total)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"formatPercentage(%d, %d) = %s, expected %s\",\n\t\t\t\ttt.value, tt.total, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Test GetListing with invalid ID (should return zeros)\nfunc TestGetListingInvalid(t *testing.T) {\n\tid, tokenId, price, seller, active, listedAt := GetListing(999999)\n\n\tif id != 0 || tokenId != \"\" || price != 0 || seller != \"\" || active != false || listedAt != 0 {\n\t\tt.Error(\"GetListing with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetSale with invalid ID (should return zeros)\nfunc TestGetSaleInvalid(t *testing.T) {\n\tlistingId, tokenId, buyer, seller, price, marketFee, royaltyFee, royaltyReceiver, soldAt := GetSale(999999)\n\n\tif listingId != 0 || tokenId != \"\" || buyer != \"\" || seller != \"\" ||\n\t\tprice != 0 || marketFee != 0 || royaltyFee != 0 || royaltyReceiver != \"\" || soldAt != 0 {\n\t\tt.Error(\"GetSale with invalid ID should return zero values\")\n\t}\n}\n\n// Test GetRoyaltyBreakdown with invalid ID (should return zeros)\nfunc TestGetRoyaltyBreakdownInvalid(t *testing.T) {\n\tsellerAmount, marketFee, royalty, royaltyReceiver := GetRoyaltyBreakdown(999999)\n\n\tif sellerAmount != 0 || marketFee != 0 || royalty != 0 || royaltyReceiver != \"\" {\n\t\tt.Error(\"GetRoyaltyBreakdown with invalid ID should return zero values\")\n\t}\n}\n\n// Helper function to check if string contains substring\nfunc contains(s, substr string) bool {\n\treturn len(s) \u003e= len(substr) \u0026\u0026 (s == substr ||\n\t\tlen(s) \u003e len(substr) \u0026\u0026 indexOf(s, substr) \u003e= 0)\n}\n\n// Helper function to find substring index\nfunc indexOf(s, substr string) int {\n\tfor i := 0; i \u003c= len(s)-len(substr); i++ {\n\t\tif s[i:i+len(substr)] == substr {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"},{"name":"proposal.gno","body":"package gnopendao5\n\nimport (\n\t\"chain\"\n\t\"chain/banker\"\n\t\"chain/runtime\"\n\t\"errors\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\nconst (\n\tPROPOSAL_TYPE_APPROVE_COLLECTION   = \"approve_collection\"\n\tPROPOSAL_TYPE_REMOVE_COLLECTION    = \"remove_collection\"\n\tPROPOSAL_TYPE_UPDATE_FEES          = \"update_fees\"\n\tPROPOSAL_TYPE_WITHDRAW_TREASURY    = \"withdraw_treasury\"\n\tPROPOSAL_TYPE_FORCE_CANCEL_LISTING = \"force_cancel_listing\"\n\n\tVOTING_PERIOD = 10 * time.Minute\n\tQUORUM        = commondao.QuorumOneThird // 33%\n)\n\n// CollectionProposal - Proposal to approve or remove a collection\ntype CollectionProposal struct {\n\tproposalType   string\n\tcollectionAddr address\n\tcollectionName string\n\treason         string\n\tapproved       bool\n\texecuted       bool\n}\n\nfunc newCollectionProposal(propType string, addr address, name string, reason string) *CollectionProposal {\n\treturn \u0026CollectionProposal{\n\t\tproposalType:   propType,\n\t\tcollectionAddr: addr,\n\t\tcollectionName: name,\n\t\treason:         reason,\n\t\tapproved:       false,\n\t\texecuted:       false,\n\t}\n}\n\nfunc (p *CollectionProposal) Title() string {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\treturn \"Approve Collection: \" + p.collectionName\n\t}\n\treturn \"Remove Collection: \" + p.collectionName\n}\n\nfunc (p *CollectionProposal) Body() string {\n\treturn ufmt.Sprintf(\n\t\t\"Type: %s\\nCollection: %s\\nAddress: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tp.proposalType,\n\t\tp.collectionName,\n\t\tp.collectionAddr.String(),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *CollectionProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *CollectionProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *CollectionProposal) Execute(realm) error {\n\tif p.proposalType == PROPOSAL_TYPE_APPROVE_COLLECTION {\n\t\tapprovedCollections.Set(p.collectionAddr.String(), true)\n\t} else if p.proposalType == PROPOSAL_TYPE_REMOVE_COLLECTION {\n\t\tapprovedCollections.Remove(p.collectionAddr.String())\n\t}\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *CollectionProposal) GetCollectionAddr() address {\n\treturn p.collectionAddr\n}\n\n// FeesProposal - Proposal to update marketplace fees\ntype FeesProposal struct {\n\tnewFee   int64\n\treason   string\n\tapproved bool\n\texecuted bool\n}\n\nfunc newFeesProposal(newFee int64, reason string) *FeesProposal {\n\treturn \u0026FeesProposal{\n\t\tnewFee:   newFee,\n\t\treason:   reason,\n\t\tapproved: false,\n\t\texecuted: false,\n\t}\n}\n\nfunc (p *FeesProposal) Title() string {\n\treturn ufmt.Sprintf(\"Update Marketplace Fee to %d basis points\", p.newFee)\n}\n\nfunc (p *FeesProposal) Body() string {\n\tcurrentFeePercent := float64(marketplaceFee) / 100.0\n\tnewFeePercent := float64(p.newFee) / 100.0\n\n\treturn ufmt.Sprintf(\n\t\t\"Current Fee: %.2f%%\\nProposed Fee: %.2f%%\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tcurrentFeePercent,\n\t\tnewFeePercent,\n\t\tp.reason,\n\t)\n}\n\nfunc (p *FeesProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *FeesProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *FeesProposal) Execute(realm) error {\n\tmarketplaceFee = p.newFee\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *FeesProposal) GetNewFee() int64 {\n\treturn p.newFee\n}\n\n// TreasuryProposal - Proposal to withdraw funds from treasury\ntype TreasuryProposal struct {\n\tamount    int64\n\trecipient address\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewTreasuryProposal(amount int64, recipient address, reason string) *TreasuryProposal {\n\treturn \u0026TreasuryProposal{\n\t\tamount:    amount,\n\t\trecipient: recipient,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *TreasuryProposal) Title() string {\n\treturn ufmt.Sprintf(\"Withdraw %d ugnot from Treasury\", p.amount)\n}\n\nfunc (p *TreasuryProposal) Body() string {\n\tcurrentBalance := GetBalance()\n\n\treturn ufmt.Sprintf(\n\t\t\"Withdraw: %s\\nRecipient: %s\\nCurrent Treasury: %s\\nReason: %s\\n\\nVote YES to approve, NO to reject\",\n\t\tformatPrice(p.amount),\n\t\tp.recipient.String(),\n\t\tformatPrice(currentBalance),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *TreasuryProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *TreasuryProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *TreasuryProposal) Execute(realm) error {\n\tcurrentBalance := GetBalance()\n\tif currentBalance \u003c p.amount {\n\t\treturn errors.New(\"insufficient treasury balance\")\n\t}\n\n\tbnkr := banker.NewBanker(banker.BankerTypeRealmSend)\n\trealmAddr := runtime.CurrentRealm().Address()\n\n\tcoins := chain.Coins{chain.Coin{\"ugnot\", p.amount}}\n\tbnkr.SendCoins(realmAddr, p.recipient, coins)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *TreasuryProposal) GetAmount() int64 {\n\treturn p.amount\n}\n\nfunc (p *TreasuryProposal) GetRecipient() address {\n\treturn p.recipient\n}\n\n// ForceCancelListingProposal - Proposal to force cancel a problematic listing\ntype ForceCancelListingProposal struct {\n\tlistingId int\n\treason    string\n\tapproved  bool\n\texecuted  bool\n}\n\nfunc NewForceCancelListingProposal(listingId int, reason string) *ForceCancelListingProposal {\n\treturn \u0026ForceCancelListingProposal{\n\t\tlistingId: listingId,\n\t\treason:    reason,\n\t\tapproved:  false,\n\t\texecuted:  false,\n\t}\n}\n\nfunc (p *ForceCancelListingProposal) Title() string {\n\treturn ufmt.Sprintf(\"Force Cancel Listing #%d\", p.listingId)\n}\n\nfunc (p *ForceCancelListingProposal) Body() string {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn ufmt.Sprintf(\"Listing #%d\\nStatus: NOT FOUND\\nReason: %s\\n\\nVote YES to approve, NO to reject\", p.listingId, p.reason)\n\t}\n\n\treturn ufmt.Sprintf(\n\t\t\"Listing ID: %d\\nToken ID: %s\\nSeller: %s\\nPrice: %s\\nReason for cancellation: %s\\n\\nVote YES to force cancel, NO to reject\",\n\t\tp.listingId,\n\t\tlisting.TokenId.String(),\n\t\tlisting.Seller.String(),\n\t\tformatPrice(listing.Price),\n\t\tp.reason,\n\t)\n}\n\nfunc (p *ForceCancelListingProposal) VotingPeriod() time.Duration {\n\treturn VOTING_PERIOD\n}\n\nfunc (p *ForceCancelListingProposal) Tally(ctx commondao.VotingContext) (bool, error) {\n\tvotes := ctx.VotingRecord\n\tmembers := ctx.Members\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tvotes.Iterate(0, votes.Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\t// Check quorum\n\tif !commondao.IsQuorumReached(QUORUM, votes, members) {\n\t\tp.approved = false\n\t\treturn false, commondao.ErrNoQuorum\n\t}\n\n\t// Simple majority\n\tp.approved = yesVotes \u003e noVotes\n\treturn p.approved, nil\n}\n\nfunc (p *ForceCancelListingProposal) Execute(realm) error {\n\tlisting := getListing(p.listingId)\n\tif listing == nil {\n\t\treturn errors.New(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\treturn errors.New(\"listing already inactive\")\n\t}\n\n\tlisting.Active = false\n\tlistings.Set(strconv.Itoa(p.listingId), listing)\n\n\tp.executed = true\n\treturn nil\n}\n\nfunc (p *ForceCancelListingProposal) GetListingId() int {\n\treturn p.listingId\n}\n"},{"name":"render.gno","body":"package gnopendao5\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/leon/svgbtn\"\n\t\"gno.land/p/moul/txlink\"\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ============= RENDER =============\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t}\n\n\tif strings.HasPrefix(path, \"listing/\") {\n\t\tidStr := strings.TrimPrefix(path, \"listing/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderListing(id)\n\t}\n\n\tif strings.HasPrefix(path, \"sale/\") {\n\t\tidStr := strings.TrimPrefix(path, \"sale/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderSale(id)\n\t}\n\n\tif path == \"stats\" {\n\t\treturn renderStats()\n\t}\n\n\tif path == \"proposals\" {\n\t\treturn renderProposals()\n\t}\n\n\tif path == \"archive\" {\n\t\treturn renderArchive()\n\t}\n\n\tif strings.HasPrefix(path, \"proposal/\") {\n\t\tidStr := strings.TrimPrefix(path, \"proposal/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderProposal(uint64(id))\n\t}\n\n\tif strings.HasPrefix(path, \"archived/\") {\n\t\tidStr := strings.TrimPrefix(path, \"archived/\")\n\t\tid, _ := strconv.Atoi(idStr)\n\t\treturn renderArchivedProposal(uint64(id))\n\t}\n\n\treturn \"Page not found\"\n}\n\nfunc renderHome() string {\n\toutput := \"# GNOPENSEA DAO 10\\n\\n\"\n\toutput += \"Decentralized NFT Marketplace with DAO Governance\\n\\n\"\n\toutput += \"Compatible **GRC-721** + **GRC-2981** (Automatic Royalties)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += \"[View detailed statistics](/r/pierre115/gnopendao5:stats)\\n\\n\"\n\toutput += \"---\\n\\n\"\n\n\t// DAO Section\n\toutput += \"## DAO Governance\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Total DAO Members:** %d\\n\\n\", GetTotalMembers())\n\n\tactiveProposals := marketplaceDAO.ActiveProposals()\n\tif activeProposals.Size() \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"**Active Proposals:** %d\\n\\n\", activeProposals.Size())\n\t\toutput += \"[View all proposals](/r/pierre115/gnopendao5:proposals)\\n\\n\"\n\t} else {\n\t\toutput += \"**Active Proposals:** 0\\n\\n\"\n\t\toutput += \"*No active proposals*\\n\\n\"\n\t}\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\toutput += ufmt.Sprintf(\"[View archive (%d)](/r/pierre115/gnopendao5:archive)\\n\\n\", finishedProposals.Size())\n\n\t// Vote Join button\n\tlinkjoin := txlink.NewLink(\"JoinDAO\").\n\t\tURL()\n\toutput += svgbtn.SuccessButton(100, 30, \"Join !\", linkjoin) + \"\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\t// Active listings\n\tif GetActiveListingsCount() \u003e 0 {\n\t\toutput += \"## NFTs for sale\\n\\n\"\n\n\t\tlistings.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tlisting := value.(*Listing)\n\t\t\tif listing.Active {\n\t\t\t\toutput += renderListingPreview(listing)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t} else {\n\t\toutput += \"## No NFTs for sale\\n\\n\"\n\t\toutput += \"*Be the first to list an NFT!*\\n\"\n\t}\n\n\treturn output\n}\n\nfunc renderListingPreview(listing *Listing) string {\n\t// Calculate breakdown\n\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listing.ListingId)\n\n\toutput := ufmt.Sprintf(\"### Listing #%d\\n\\n\", listing.ListingId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\n\tif royalty \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"Royalty: %s (%s)\\n\\n\",\n\t\t\tformatPrice(royalty),\n\t\t\tformatPercentage(royalty, listing.Price))\n\t}\n\n\toutput += ufmt.Sprintf(\"**Seller receives:** %s\\n\\n\", formatPrice(sellerGets))\n\toutput += ufmt.Sprintf(\"**Market Fees:** %s\\n\\n\", formatPrice(marketFee))\n\toutput += ufmt.Sprintf(\"**Royalty Address:** %s\\n\\n\", royaltyAddr.String())\n\toutput += ufmt.Sprintf(\"**Marketplace Address:** %s\\n\\n\", marketplaceAddr.String())\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao5:listing/%d)\\n\\n\", listing.ListingId)\n\toutput += \"---\\n\\n\"\n\treturn output\n}\n\nfunc renderListing(listingId int) string {\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\treturn \"# Listing not found\"\n\t}\n\n\tstatus := \"Active\"\n\tif !listing.Active {\n\t\tstatus = \"Sold/Cancelled\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Listing #%d - %s\\n\\n\", listingId, status)\n\n\toutput += \"## Details\\n\\n\"\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", listing.TokenId.String())\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(listing.Price))\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", listing.Seller.String())\n\toutput += ufmt.Sprintf(\"**Listed at block:** %d\\n\\n\", listing.ListedAt)\n\n\tif listing.Active {\n\t\tsellerGets, marketFee, royalty, royaltyAddr := GetRoyaltyBreakdown(listingId)\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Price breakdown\\n\\n\"\n\t\toutput += ufmt.Sprintf(\"- **Total price:** %s (100%%)\\n\", formatPrice(listing.Price))\n\t\toutput += ufmt.Sprintf(\"- **Marketplace fee (%s):** %s\\n\",\n\t\t\tformatFee(marketplaceFee), formatPrice(marketFee))\n\n\t\tif royalty \u003e 0 {\n\t\t\toutput += ufmt.Sprintf(\"- **Creator royalty (%s):** %s\\n\",\n\t\t\t\tformatPercentage(royalty, listing.Price), formatPrice(royalty))\n\t\t\toutput += ufmt.Sprintf(\"  - Beneficiary: `%s`\\n\", royaltyAddr.String())\n\t\t} else {\n\t\t\toutput += \"- **Royalty:** None\\n\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"- **Seller receives:** %s (%s)\\n\\n\",\n\t\t\tformatPrice(sellerGets), formatPercentage(sellerGets, listing.Price))\n\n\t\toutput += \"## Purchase\\n\\n\"\n\t\toutput += \"```bash\\n\"\n\t\toutput += \"gnokey maketx call \\\\\\n\"\n\t\toutput += \"  -pkgpath \\\"gno.land/r/pierre115/gnopendao5\\\" \\\\\\n\"\n\t\toutput += \"  -func \\\"BuyNFT\\\" \\\\\\n\"\n\t\toutput += ufmt.Sprintf(\"  -args \\\"%d\\\" \\\\\\n\", listingId)\n\t\toutput += ufmt.Sprintf(\"  -send \\\"%dugnot\\\" \\\\\\n\", listing.Price)\n\t\toutput += \"  -broadcast yourkey\\n\"\n\t\toutput += \"```\\n\"\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao5)\\n\"\n\n\treturn output\n}\n\nfunc renderSale(saleId int) string {\n\tvalue, exists := sales.Get(strconv.Itoa(saleId))\n\tif !exists {\n\t\treturn \"# Sale not found\"\n\t}\n\n\tsale := value.(*Sale)\n\n\toutput := ufmt.Sprintf(\"# Sale #%d\\n\\n\", saleId)\n\toutput += ufmt.Sprintf(\"**Token ID:** %s\\n\\n\", sale.TokenId)\n\toutput += ufmt.Sprintf(\"**Price:** %s\\n\\n\", formatPrice(sale.Price))\n\toutput += ufmt.Sprintf(\"**Buyer:** `%s`\\n\\n\", sale.Buyer.String())\n\toutput += ufmt.Sprintf(\"**Seller:** `%s`\\n\\n\", sale.Seller.String())\n\toutput += ufmt.Sprintf(\"**Block:** %d\\n\\n\", sale.SoldAt)\n\n\toutput += \"## Distribution\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Marketplace fee:** %s\\n\", formatPrice(sale.MarketplaceFee))\n\n\tif sale.RoyaltyFee \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- **Royalty:** %s ‚Üí `%s`\\n\",\n\t\t\tformatPrice(sale.RoyaltyFee), sale.RoyaltyReceiver.String())\n\t}\n\n\tsellerReceived := sale.Price - sale.MarketplaceFee - sale.RoyaltyFee\n\toutput += ufmt.Sprintf(\"- **Seller received:** %s\\n\", formatPrice(sellerReceived))\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"# Marketplace Statistics\\n\\n\"\n\n\ttotalVolume := GetTotalVolume()\n\ttotalSales := GetTotalSales()\n\ttotalRoyalties := GetTotalRoyaltiesPaid()\n\n\toutput += ufmt.Sprintf(\"**Total volume:** %s\\n\\n\", formatPrice(totalVolume))\n\toutput += ufmt.Sprintf(\"**Number of sales:** %d\\n\\n\", totalSales)\n\toutput += ufmt.Sprintf(\"**Royalties paid:** %s (%s of volume)\\n\\n\",\n\t\tformatPrice(totalRoyalties), formatPercentage(totalRoyalties, totalVolume))\n\n\tif totalSales \u003e 0 {\n\t\tavgPrice := totalVolume / int64(totalSales)\n\t\toutput += ufmt.Sprintf(\"**Average price:** %s\\n\\n\", formatPrice(avgPrice))\n\t}\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao5)\\n\"\n\n\treturn output\n}\n\n// ============= DAO RENDER FUNCTIONS =============\n\nfunc renderProposals() string {\n\toutput := \"# Active DAO Proposals\\n\\n\"\n\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\toutput += \"*No active proposals at the moment*\\n\\n\"\n\t\toutput += \"DAO members can create proposals to:\\n\"\n\t\toutput += \"- Approve new NFT collections\\n\"\n\t\toutput += \"- Remove existing collections\\n\"\n\t\toutput += \"- Update marketplace fees\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao5)\\n\"\n\t\treturn output\n\t}\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao5)\\n\"\n\n\treturn output\n}\n\nfunc renderProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d\\n\\n\", p.ID())\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Yes:** %d | **No:** %d | **Total:** %d\\n\\n\", yesVotes, noVotes, yesVotes+noVotes)\n\n\tif p.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting open**\\n\\n\"\n\t}\n\n\toutput += ufmt.Sprintf(\"[View \u0026 Vote](/r/pierre115/gnopendao5:proposal/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d\\n\\n\", proposalID)\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Current Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tif proposal.HasVotingDeadlinePassed() {\n\t\toutput += \"‚è∞ **Voting period has ended**\\n\\n\"\n\t} else {\n\t\toutput += \"‚úÖ **Voting is open**\\n\\n\"\n\n\t\toutput += \"---\\n\\n\"\n\t\toutput += \"## Cast Your Vote\\n\\n\"\n\n\t\t// Vote YES button\n\t\tlinkyes := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"yes\").\n\t\t\tURL()\n\t\toutput += svgbtn.SuccessButton(100, 30, \"YES\", linkyes) + \"\\n\\n\"\n\n\t\t// Vote NO button\n\t\tlinkno := txlink.NewLink(\"Vote\").\n\t\t\tAddArgs(\"proposalID\", ufmt.Sprintf(\"%d\", proposalID)).\n\t\t\tAddArgs(\"choice\", \"no\").\n\t\t\tURL()\n\t\toutput += svgbtn.DangerButton(100, 30, \"NO\", linkno) + \"\\n\\n\"\n\t}\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to proposals](/r/pierre115/gnopendao5:proposals) | [‚Üê Home](/r/pierre115/gnopendao5)\\n\"\n\n\treturn output\n}\n\n// ============= ARCHIVE RENDER FUNCTIONS =============\n\nfunc renderArchive() string {\n\toutput := \"# Proposal Archive\\n\\n\"\n\n\tfinishedProposals := marketplaceDAO.FinishedProposals()\n\n\tif finishedProposals.Size() == 0 {\n\t\toutput += \"*No finished proposals yet*\\n\\n\"\n\t\toutput += \"[‚Üê Back](/r/pierre115/gnopendao5)\\n\"\n\t\treturn output\n\t}\n\n\toutput += ufmt.Sprintf(\"**Total archived proposals:** %d\\n\\n\", finishedProposals.Size())\n\toutput += \"---\\n\\n\"\n\n\tfinishedProposals.Iterate(0, finishedProposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += renderArchivedProposalPreview(p)\n\t\treturn false\n\t})\n\n\toutput += \"\\n[‚Üê Back](/r/pierre115/gnopendao5)\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposalPreview(p *commondao.Proposal) string {\n\toutput := ufmt.Sprintf(\"## Proposal #%d - %s\\n\\n\", p.ID(), string(p.Status()))\n\toutput += ufmt.Sprintf(\"**%s**\\n\\n\", p.Definition().Title())\n\n\t// Count final votes\n\tyesVotes := 0\n\tnoVotes := 0\n\tp.VotingRecord().Iterate(0, p.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput += ufmt.Sprintf(\"**Final Result:** Yes: %d | No: %d\\n\\n\", yesVotes, noVotes)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif p.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Status:** %s\\n\\n\", statusEmoji, string(p.Status()))\n\tif p.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Reason:** %s\\n\\n\", p.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"[View details](/r/pierre115/gnopendao5:archived/%d)\\n\\n\", p.ID())\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\nfunc renderArchivedProposal(proposalID uint64) string {\n\tproposal := marketplaceDAO.FinishedProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"# Archived proposal not found\"\n\t}\n\n\toutput := ufmt.Sprintf(\"# Proposal #%d - %s\\n\\n\", proposalID, string(proposal.Status()))\n\toutput += ufmt.Sprintf(\"## %s\\n\\n\", proposal.Definition().Title())\n\toutput += ufmt.Sprintf(\"%s\\n\\n\", proposal.Definition().Body())\n\n\toutput += \"---\\n\\n\"\n\n\t// Final vote counts\n\tyesVotes := 0\n\tnoVotes := 0\n\ttotalVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif string(v.Choice) == \"yes\" || string(v.Choice) == \"YES\" {\n\t\t\tyesVotes++\n\t\t} else if string(v.Choice) == \"no\" || string(v.Choice) == \"NO\" {\n\t\t\tnoVotes++\n\t\t}\n\t\ttotalVotes++\n\t\treturn false\n\t})\n\n\toutput += \"## Final Results\\n\\n\"\n\toutput += ufmt.Sprintf(\"- **Yes votes:** %d\\n\", yesVotes)\n\toutput += ufmt.Sprintf(\"- **No votes:** %d\\n\", noVotes)\n\toutput += ufmt.Sprintf(\"- **Total votes:** %d\\n\", totalVotes)\n\n\ttotalMembers := GetTotalMembers()\n\tquorumRequired := int(float64(totalMembers) * QUORUM)\n\toutput += ufmt.Sprintf(\"- **Quorum required:** %d/%d votes\\n\\n\", totalVotes, quorumRequired)\n\n\tstatusEmoji := \"‚úÖ\"\n\tif proposal.Status() == \"failed\" {\n\t\tstatusEmoji = \"‚ùå\"\n\t}\n\toutput += ufmt.Sprintf(\"%s **Final Status:** %s\\n\\n\", statusEmoji, string(proposal.Status()))\n\n\tif proposal.StatusReason() != \"\" {\n\t\toutput += ufmt.Sprintf(\"**Status Reason:** %s\\n\\n\", proposal.StatusReason())\n\t}\n\n\toutput += ufmt.Sprintf(\"**Voting Ended:** %s\\n\\n\", proposal.VotingDeadline().Format(\"2006-01-02 15:04:05\"))\n\n\toutput += \"---\\n\\n\"\n\toutput += \"[‚Üê Back to archive](/r/pierre115/gnopendao5:archive) | [‚Üê Home](/r/pierre115/gnopendao5)\\n\"\n\n\treturn output\n}\n"},{"name":"type.gno","body":"package gnopendao5\n\nimport (\n\t\"gno.land/p/demo/tokens/grc721\"\n)\n\n// Listing structure\ntype Listing struct {\n\tListingId       int\n\tNFTGetter       grc721.NFTGetter\n\tTokenId         grc721.TokenID\n\tSeller          address\n\tPrice           int64\n\tActive          bool\n\tListedAt        int64\n\tNFTRealmAddress address\n}\n\n// Sale statistics\ntype Sale struct {\n\tListingId       int\n\tTokenId         string\n\tBuyer           address\n\tSeller          address\n\tPrice           int64\n\tMarketplaceFee  int64\n\tRoyaltyFee      int64\n\tRoyaltyReceiver address\n\tSoldAt          int64\n}\n"},{"name":"voting.gno","body":"package gnopendao5\n\nimport (\n\t\"chain/runtime\"\n\n\t\"gno.land/p/nt/commondao\"\n\t\"gno.land/p/nt/ufmt\"\n)\n\n// ProposeApproveCollection - Create a proposal to approve a new collection\nfunc ProposeApproveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_APPROVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeRemoveCollection - Create a proposal to remove a collection\nfunc ProposeRemoveCollection(_ realm, collectionAddr address, collectionName string, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tpropDef := newCollectionProposal(PROPOSAL_TYPE_REMOVE_COLLECTION, collectionAddr, collectionName, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeUpdateFees - Create a proposal to update marketplace fees\nfunc ProposeUpdateFees(_ realm, newFeeBasisPoints int64, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif newFeeBasisPoints \u003c 0 || newFeeBasisPoints \u003e 1000 {\n\t\tpanic(\"fees must be between 0 and 1000 basis points (0-10%)\")\n\t}\n\n\tpropDef := newFeesProposal(newFeeBasisPoints, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeWithdrawTreasury - Create a proposal to withdraw funds from treasury\nfunc ProposeWithdrawTreasury(_ realm, amount int64, recipient address, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\tif amount \u003c= 0 {\n\t\tpanic(\"amount must be positive\")\n\t}\n\n\tif !recipient.IsValid() {\n\t\tpanic(\"invalid recipient address\")\n\t}\n\n\tcurrentBalance := GetBalance()\n\tif amount \u003e currentBalance {\n\t\tpanic(ufmt.Sprintf(\"insufficient treasury balance (available: %d ugnot)\", currentBalance))\n\t}\n\n\tpropDef := NewTreasuryProposal(amount, recipient, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// ProposeForceCancelListing - Create a proposal to force cancel a listing\nfunc ProposeForceCancelListing(_ realm, listingId int, reason string) uint64 {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tif !IsDAOMember(caller) {\n\t\tpanic(\"only DAO members can create proposals\")\n\t}\n\n\t// Verify listing exists and is active\n\tlisting := getListing(listingId)\n\tif listing == nil {\n\t\tpanic(\"listing not found\")\n\t}\n\n\tif !listing.Active {\n\t\tpanic(\"listing is already inactive\")\n\t}\n\n\tpropDef := NewForceCancelListingProposal(listingId, reason)\n\n\tproposal, err := marketplaceDAO.Propose(caller, propDef)\n\tif err != nil {\n\t\tpanic(\"failed to create proposal: \" + err.Error())\n\t}\n\n\treturn proposal.ID()\n}\n\n// Vote - Vote on a proposal (yes or no)\nfunc Vote(_ realm, proposalID uint64, choice string) string {\n\tcaller := runtime.PreviousRealm().Address()\n\n\tvar voteChoice commondao.VoteChoice\n\tif choice == \"yes\" {\n\t\tvoteChoice = commondao.ChoiceYes\n\t} else if choice == \"no\" {\n\t\tvoteChoice = commondao.ChoiceNo\n\t} else {\n\t\tpanic(\"choice must be 'yes' or 'no'\")\n\t}\n\n\t// Use DAO's Vote method - it handles all validations automatically\n\terr := marketplaceDAO.Vote(\n\t\tcaller,\n\t\tproposalID,\n\t\tvoteChoice,\n\t\t\"\", // reason (optional)\n\t)\n\tif err != nil {\n\t\tpanic(\"vote failed: \" + err.Error())\n\t}\n\n\treturn \"Vote recorded: \" + choice\n}\n\n// TallyProposal - Execute a proposal after voting period\nfunc TallyProposal(_ realm, proposalID uint64) string {\n\terr := marketplaceDAO.Execute(proposalID)\n\tif err != nil {\n\t\tpanic(\"execution failed: \" + err.Error())\n\t}\n\n\treturn ufmt.Sprintf(\"Proposal %d executed successfully\", proposalID)\n}\n\n// GetProposalInfo - Get information about a proposal\nfunc GetProposalInfo(proposalID uint64) string {\n\tproposal := marketplaceDAO.ActiveProposals().Get(proposalID)\n\tif proposal == nil {\n\t\treturn \"Proposal not found\"\n\t}\n\n\tyesVotes := 0\n\tnoVotes := 0\n\n\tproposal.VotingRecord().Iterate(0, proposal.VotingRecord().Size(), false, func(v commondao.Vote) bool {\n\t\tif v.Choice == commondao.ChoiceYes {\n\t\t\tyesVotes++\n\t\t} else if v.Choice == commondao.ChoiceNo {\n\t\t\tnoVotes++\n\t\t}\n\t\treturn false\n\t})\n\n\toutput := ufmt.Sprintf(`Proposal #%d\nTitle: %s\nBody: %s\nYes Votes: %d\nNo Votes: %d\nTotal Votes: %d\nVoting Ended: %t`,\n\t\tproposalID,\n\t\tproposal.Definition().Title(),\n\t\tproposal.Definition().Body(),\n\t\tyesVotes,\n\t\tnoVotes,\n\t\tyesVotes+noVotes,\n\t\tproposal.HasVotingDeadlinePassed(),\n\t)\n\n\treturn output\n}\n\n// GetAllActiveProposals - Get all active proposals\nfunc GetAllActiveProposals() string {\n\tproposals := marketplaceDAO.ActiveProposals()\n\n\tif proposals.Size() == 0 {\n\t\treturn \"No active proposals\"\n\t}\n\n\toutput := \"=== Active Proposals ===\\n\\n\"\n\n\tproposals.Iterate(0, proposals.Size(), false, func(p *commondao.Proposal) bool {\n\t\toutput += ufmt.Sprintf(\"ID: %d | %s\\n\", p.ID(), p.Definition().Title())\n\t\treturn false\n\t})\n\n\treturn output\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"400000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"VxJZLbsiaMdmYGCcPpyJ+ndb6Rza/5zPo0FkTIekAO9JD2Rt3XWH7UGVGnzHUEOytXvm/7RMik7MX8BJNJnNAA=="}],"memo":""},"metadata":{"timestamp":"1765616922"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/mynftcollection2","func":"SetApprovalForAll","args":["g13zfdmynhzgyv3x2504nj44ymud2j5gka0yarxz","true"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"yXGwG5Ilgk1ecqJlWMV4elEEPVODwHgG91mJt8hB28YP0BXSN2G9ms5nXDTiFzx/JkRqVjjvBEsV6z0VLSKKAA=="}],"memo":""},"metadata":{"timestamp":"1765617028"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao5","func":"JoinDAO"}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"nJfhRH2SQQIMJCiX9Jw0CjM2O5NP1S4JJalB2PV/mFIZKqB+1RuY3LwYUFfujnd/R1/c+3CGml5Lxy1O71ccAA=="}],"memo":""},"metadata":{"timestamp":"1765617264"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"gVJHvFJFmxMw9GKhZ8m9NV6xgWxKYovhqi1nLCEMqNv+/DqO4pTxhOmmMJuO6lJjMnl+N90PGbfn8Jib9t0kDg=="}],"memo":""},"metadata":{"timestamp":"1765617299"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao5","func":"ProposeApproveCollection","args":["g14aa34n5k3ufr8qudn6ecadwhuqp04mulkdh2vp","monnft","tkt"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"fLjNnmUQN7Gu4Q0RabsFX7vbOcvtrn4Uf5eBKF23kwz3nmUR8WsmbtT/kPFl44Z/xofmEKJzHNDzO7RxefxxAA=="}],"memo":""},"metadata":{"timestamp":"1765617339"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao5","func":"Vote","args":["1","yes"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6ZTMiBY8JUs9mtzRRcE/OE/0EDTfGMhVL9HrWdlPZ38dg/Xwoj5CKtQYsUpJV8c+Iw9xOSalzsNbqvm33LbgBw=="}],"memo":""},"metadata":{"timestamp":"1765617374"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao5","func":"TallyProposal","args":["1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"NUjiuyJBGVNNnq+bwZeEZzbZ+jUa4myEO+WqVq59EHhZ1kbz7DHJuUT5amvaehEbBSpT0VY0U61L6MLBAWSuDQ=="}],"memo":""},"metadata":{"timestamp":"1765618058"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e7r5eglptfejknps3xv2kxv6pc8wvd3wwtw6tg","send":"","max_deposit":"","pkg_path":"gno.land/r/pierre115/gnopendao5","func":"CreateListing","args":["g14aa34n5k3ufr8qudn6ecadwhuqp04mulkdh2vp","1","1"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ZU99qFT1Pa+aQlEeiaZ5fad10QcjZwjvvVLjbgrG03fhyXmqJumT2jeKe4T5ZGrKzRnFIEYvxZ6yx287KI25CA=="}],"memo":""},"metadata":{"timestamp":"1765618123"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"317420ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"7fBUOLPOY228nHPrL+rqPZ0OZ5T2iIDszfIvHaFxAoeHiiRpA8o1dcT/8EBI1ROhfS0JHUggeIXUHuhJ0V26BA=="}],"memo":""},"metadata":{"timestamp":"1765675890"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"317420ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"3LTqX+g9ePIp5yFWx9TSOqFFOeLUZ6CZaA1QEh6Y0Uz5wgxGxWY0CpiJkOPugfJSFXb2JGG/becJ8pJi0FVGAQ=="}],"memo":""},"metadata":{"timestamp":"1765675895"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iBnsOX/tBkiPkDGHf5CrVpSWNR6kQDSr8lCDYeRyM3nPAdurZicnj4GVoe34dblBlqgUk2hKjYmibXDfKg48AQ=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iiP/h+XGI98mJVZGUGRU9JWdSlzSgCpD3wDiCU87yFEeF9aUxR5tpm70lFPgsm16zxfvJ2YinFgEYP2mLByiAA=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"P+KG/ze6Gl+eO+hLHdqLUy2JNq6H3216PKZ4CDWBuLJoqOHUHPsfgmKmfsqpulUCbmfz1BpQnoVa5ZH1BeAkAQ=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Mv6BW8K/iGWOrcMM0stYKAqSS68/xKJMcHFPRGULDAwuD2Sr2baQAHvx2TITswQvCnaU2ZD+TLgN9MazzIXdBg=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"m31+R42O1HtvSmHTDL1DEyrCm7kBELUeJRXmpQeply3fPqFxMrA3Zu+8c4sGj8q+v6naaOztmON07ZttvQqICw=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"V+9GCEMPLRDFn2oTHkc84+vwUGdRIafHeMO7vqhLhP+od4dUygRDvbUMAq/WPOGVpWwfw962jv2jxyU8x19mCw=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"UM8g5r6CDFKitv4942mRgdVWFdNNpo6p6D1ZmCKxwejkBejfb4buHKkZ0SbjPSlhnijH/AT9F7JSFCrX3iRQCA=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"H6rfi2Qujvr3kHztpAhCma0MS8NnN8BsBn8UlxXcfM8WLz/UXzigPnnELWDGu6R4fvgkVgCv/3mo8fxYmSwyBQ=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675901_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"6sjuCRhcbdgUUXveeac1g4SH2RnvYniUDuJlS/9xi4yhs4wRurCX8VSgR39+ik7k1Di4OjLg0dj4qK6xx0TpCA=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675901_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"MmNsmP1Uxvj/tMqQSPYOqbLmxvOodNpvZqrIrc9uGOss3ve40ll/nlISTtg9NrxumAUXD05pVnvPKcWZOzd1DA=="}],"memo":""},"metadata":{"timestamp":"1765675900"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"2816845ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"I36crwgqEDA2fdXqUXAOlon2gWSjvDoeIouavRCjWtGRbLnns1/Y583bRNrjlDM2ELqrKPcYTzvbIYyMllkLBg=="}],"memo":""},"metadata":{"timestamp":"1765675976"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"2816845ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iDSUN3bQYTs03JJsoXU+0EXDn1wuRTFFLCSaQuy2I1L1hEIdeelQitj8hX327ovMIJ1vnMcDqr+IYWj1PsmxCg=="}],"memo":""},"metadata":{"timestamp":"1765675981"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iYFQqZbR1WeS4zWOCRewsGtQF3NbawDCkQ6SYj+Yulrq93cwMtK4ahhBGDo2y7XYjFYDv5ePJouqWkuErLf2Bw=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"xCSxfkshemC9Jb8bmfK/DP/F/NllVnTcA3Ng2DmKWzx/JRS8VZUgAgEv1/EJ/5fk51vkLrgz9M/oIes8s23kDQ=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"us5zniThBxUvk6F8T0A+7tFDneviMDo1vXMFgsYf1JShOLXi/BMYVO66IWwzH2oeaWaQsZwwBp6gqYhWly0bAw=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"VbL7IQs7f0RhXfL80YEP92cOobnNVgvE/7pKYZd8oZ9dREZwqUpMH8gBOSxoOMqsu7SEcGB4RyCyPrEC9+qICg=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"0c4GsmKzf8oQ2q/CFkXSULmlePjoFMa2AFFi+S0iFNFsRhIxchSbs7JX06llujxvSbVBpixZjrPB0YGcF74+Aw=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"BFuCSrQQoMyz7JXXE/vy8ewvn+ElUKuDsgD6m0cMxRCZq9EgRDqjTwFAAN3Al6AwRkV4zapBPebGSBSuInIsCA=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"riXNOg2cxWuN65mziylXyiApXnI7FDZ0mEMqF4tFmEW6FTFgf9Mi0szjSOzbWai6AxVfHiTw1ZQRZkV+7PDdCQ=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Ot+t97Vh4OXoExFUExQN/BCB2a3P6nVsT4bb7Lg3rMwDSubdqp1Rh0znGeQzGhIjeVG2CH7SapkPVsm/HuwIDA=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765675986_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"buM7VQd76mgOPyrzjYlOMTdZHV6jVkTs+pRoNmz+Lf0MHafUPYq5VTBS9XscTkm8zoJGwtl0v79AhUKiEhboCg=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765675986_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"aN53L3I337ar0ePhN190ORV8yNm3LFXJSaZyYzq2xc+Bh+07Wn1ugyv5SzFeYTVlnd8jGivdykVBIwvvuGegBQ=="}],"memo":""},"metadata":{"timestamp":"1765675986"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"runtime","path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"598838","gas_fee":"599ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PI6dqUOjVb9/via3LSdhXg/I32Fqp4C78V3CK2e8UXhw1tG3jNiiBRP6vdBj5gGrF8CUm9/bsK36LCY5gwYwBQ=="}],"memo":""},"metadata":{"timestamp":"1765676071"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-0"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"LhiTRuByBdZ350pZUUimamUVAamOFVFhEHPyjGr4eT2p2ZdwViQn3NSfwDaUsOI97yYPIrydObFLkkTaw5nkBQ=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"O6e6edEg/H1ldV6pWvTKbjAYKdpM5mxxOUxDCMMIlY/XY+V7fvW3QRyccOoY+rxphfiCc1BmOjg4SpFf91D4DA=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PGyMkOLHDjO2Bq1gPIWYpGSvyh4FGA9MqPUAC5Q/1ZmWzZEzerqkvmS4nXJhR1/IdCarw4QbI8EUibjTdwvDDA=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"xj4EtdNbJPRo5P5/KlpcSBP7wU+D/KZd4XEOBXoPUJ8VgMglawP3WcDu6r6VZqqX9la9nq7+1Xrqb97cN6RUDQ=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PsH0IgNY3sHA8sbmzuchs/b0sDJsraaBsDP4FMRZVV0XJTXu3eAO8r6merYoWCS7k7ZFNgZ3Tqjk1LXs8CidBA=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"/Wcp6BGqW28CuzhcevyQZWmrH7ePWAPYBySeSI2G72g2XjKaweUcTwf0g/ENHOPANfTRSkAAm5J+ry1U0y9oAA=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"IE4wdw+jRTXJ/S67MqZieo5ER3VftFT2Uu93bxZB6hePuFNNKkToIvG0MCx6wlyqpc7fNhhjudEKp6GC7tlXCA=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"9Y1SmtyE8GaIbQvD0AOaZhr7zCftyu6P6O0ieJBdOyObiRzWFgWVyQ2y8G1lN8C7H0ECYWgIbyrDRLcM2tS6DA=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"8Vgexni5ThhnJrGnjZAxZz4rpSleKDnSy1nF7VJAaBmmd/jTS8yBXUpULXRQ5UNV1S1DdGwtGl8wSNShebVbDg=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765676075","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"651CJI0mzdCIft/uFJrulIMfDefRzR121Zx720BsTm6TwHvvYNznPXDDiTME928HBg79SpYUJ7seR0E8fDC3Dg=="}],"memo":""},"metadata":{"timestamp":"1765676076"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"317420ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"7fBUOLPOY228nHPrL+rqPZ0OZ5T2iIDszfIvHaFxAoeHiiRpA8o1dcT/8EBI1ROhfS0JHUggeIXUHuhJ0V26BA=="}],"memo":""},"metadata":{"timestamp":"1765762311"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"317420ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"3LTqX+g9ePIp5yFWx9TSOqFFOeLUZ6CZaA1QEh6Y0Uz5wgxGxWY0CpiJkOPugfJSFXb2JGG/becJ8pJi0FVGAQ=="}],"memo":""},"metadata":{"timestamp":"1765762316"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"fr9+7gHtZjYVQu8TqSvnKiBPp9Ox3TIpmxghWGAnvcys6S15g/VB9LW8PvGC8muUEVnjiSxVEdLwRoZAiFQlBQ=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ymYLbbgI0RKuwUpS0zXnFltFqCETjRmvLdnsBn8yJi0gbPe1k8+IPyN4ycZx5WNvDKG+Re4eWaYBh3f+QvM0CA=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"NO8ngGEiZyvb0WUcfGIcE+nodgepiXLqZEuoixzZh2BHp0h2DZYWXmCbLmhZzIoisuxhvixbOhbXThd/owt+AA=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"EMxf6fY9MLHf0FIZg1ctL/SbCjSIcwNkS77n3TUHUhSzSUHR0pWCf7hplDCDB4/BED1oLodUd1H+lLSP6pckDw=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Jwlj9sFbILJ9O+KPZ+eTa2JR4/ecHWz7J5xR8Olbah0r19UHGiKYRFJ1AY+sz75k9fMUtmbz036V+uAN+iSUBQ=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Ra4o48dRxmjYvAg+djautt7V76UScPjHbL+MB7nz187+7kynztji9KKN2JsTO5y16BudWJNGN2pR7OwmAvEiCg=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"R4CgXEK/0ktkj1XzYsxAcp+U/T9gcOWScX249/P29Yjfvf74n2E2yHxS2+yrAUSNgVWGHHT8P5dWaO3UaEQADg=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"t+GoN9+iFtd0Phgsk4g7yEDifqhkKVHqU/t8dleB3sXJOhPSYeaJjZ/BXrPnd/mhjMqzvUIzAmoe/N9BmZsYAA=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762321_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"yX7G7lFffzPPSN+M4E3LWTUyYzC75xAFrwbmtHUspeEgWiNcrxxkh+ya4j8lSuogvgt3eIRDlcixPW0S7NNIDA=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/p/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762321_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"package.gno","body":"package runtime\n\ntype Language string\n\nconst (\n\tFrench    Language = \"french\"\n\tItalian   Language = \"italian\"\n\tSpanish   Language = \"spanish\"\n\tHindi     Language = \"hindi\"\n\tBulgarian Language = \"bulgarian\"\n\tSerbian   Language = \"serbian\"\n)\n\n// GetGreeting generates a greeting in\n// the specified language\nfunc GetGreeting(language Language) string {\n\tswitch language {\n\tcase French:\n\t\treturn \"Bonjour\"\n\tcase Italian:\n\t\treturn \"Ciao\"\n\tcase Spanish:\n\t\treturn \"Hola\"\n\tcase Hindi:\n\t\treturn \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á\"\n\tcase Bulgarian:\n\t\treturn \"–ó–¥—Ä–∞–≤–µ–π—Ç–µ\"\n\tcase Serbian:\n\t\treturn \"–ó–¥—Ä–∞–≤–æ\"\n\tdefault:\n\t\treturn \"Hello\"\n\t}\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"480960","gas_fee":"481ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"uyhvXXAxd4LWi9ypuxFBU626d6ra7gSshjZEkqy0wD+it1DbyuNJD+DB/MwWiuGrA+DcgxxPA2yFgAm05WgBBQ=="}],"memo":""},"metadata":{"timestamp":"1765762321"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"2816845ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"I36crwgqEDA2fdXqUXAOlon2gWSjvDoeIouavRCjWtGRbLnns1/Y583bRNrjlDM2ELqrKPcYTzvbIYyMllkLBg=="}],"memo":""},"metadata":{"timestamp":"1765762411"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","amount":"2816845ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iDSUN3bQYTs03JJsoXU+0EXDn1wuRTFFLCSaQuy2I1L1hEIdeelQitj8hX327ovMIJ1vnMcDqr+IYWj1PsmxCg=="}],"memo":""},"metadata":{"timestamp":"1765762416"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_0","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_0\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"W7ciZEKYp7WNYHCKx/Ik69AhigoTJe0s5m3RvV+5kQHugAHbyktEV530U5tsjFbhx3dOgyFyTxrMGQCy1pFADA=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_1","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_1\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"NhPXTYLbOVDVrvP3EBLMRdkxmaYZHnEuaPxB5/Q/Z0r6NnRqkJFMDy5quTDshCvEqVZjtWAOhCYB+oUJP2m/AQ=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_2","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_2\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"d8FYiXMz2U/sNvcQj0O+trfX/OJ3OzsDhhybAU6oPsMffa3RZhZHTG3j2dRBkyLv7XgnM0l1OmlnrFZLxe7HCg=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_3","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_3\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"e2liRSL/XAIg5EdTUwFd8gbEvVMUQoGqwr28iVRkp15O7gG9J6B0pzHvbxKp5su13MV6P1ERj+yJSl6F9ObJAA=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_4","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_4\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"xuNSv0XLdm9kUmEFMHZwuvSiT3VFGpkJ4MCggRxfyTyvSF+bkn0laDxrgVITEWshyCeaZrnrBPaYuWx5VzOLDA=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_5","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_5\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"xSEEiY4e5cb+RVV3EE0YgahhPFBXSiNzUa+FXmEhFepbjaLM9l/9Xul5+4TkgFn19MAY+b6q1eZTWTqi5hTRAg=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_6","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_6\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"JKKmaMjom5DRa+icIJ+rkYuTvGsyasfqPFK7/VkKw+soLPysxtbO/OKMPtCFaem2+QdzfGVWuFJ98H8hCfNnDg=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_7","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_7\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"259WrXH7golRwYYp8r40fSA0yuAT+tUkBIf3urgS1jC5NRCHeF1fZJ2vN/hR58ewFPghLybRjOoPyAacKoELBQ=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"name":"runtime","path":"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_8","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f/stress_1765762421_8\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"8iYlWO6Q470HJrMl9G+nTVVNrHrN9GqbO+rNX0g5EUM5zlLbqxQ+XtSXxp8reKcOstwbiThtKO+dP8xKqmfqDw=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","package":{"name":"runtime","path":"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_9","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg/stress_1765762421_9\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"603504","gas_fee":"604ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"y0ju5R5KP8/MD56bzcd/eytsmcqRL8ZxU+qfCIdyIgkyElMD3HHKXmE0Jv8IdbKUWokzNvQfddBIapV3wnsCBw=="}],"memo":""},"metadata":{"timestamp":"1765762421"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"runtime","path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513\"\ngno = \"0.9\"\n\n[addpkg]\n  creator = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n"},{"name":"realm.gno","body":"package runtime\n\nvar greeting string\n\nfunc init() {\n\tgreeting = \"Hello\"\n}\n\n// SayHello says hello to the specified name, using\n// the saved greeting\nfunc SayHello(cur realm, name string) string {\n\treturn greeting + \" \" + name + \"!\"\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"598838","gas_fee":"599ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"e8hC94zGFFxStzkASYvQXOjz36JZr9R0JwB3bISxRbUPes0vSqZrDScGKVQz3A6tj9y9Y9R6cgJMz7zcq/MoAA=="}],"memo":""},"metadata":{"timestamp":"1765762512"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-0"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"W7VFuru0+baDyrKrwDb15BIrgOmI2470kSrhv2Y8c+FqX7ghyFDhhkZAsQ88qR/B7Hcm3WmMEYofgU8oGBYUBA=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-1"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"/1pvNsZmdTF5CIbiOTpTD/9Epv6WQI6h9Eu6l8iuBv211xkN1mgMOVrvV3v7u695olzn+QBQ5CCRnTLTNj2IBQ=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-2"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"qjLVdqIiNjF1MvOcAXEpo3vARezxehMYO4gXUlnRKX8dGsaaDxZPP8cnoZYkeUyl8Z/MmIsuu16djd8iD7VDAQ=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-3"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1Mou48GhFTkHrUscXKAGWZxdJryw89ZaBAbQF6S16y6w5oLXzBwydQAporqo+TvSDzka96q5TUYsMi7y6Rx+BA=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-4"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"ooZPImanMFnPeAb3K0hEwBAj1cFAVVYhPk+ZAfi6uRQfDrLSIH1udxfNF0QPj6V3Jb+PIYuPaAmjHjhF2fIuCA=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-5"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"VeaefPYxHT3jMA7f3u9uCC5Zg/5gafvfjKFijUCcU2b/KxahSBsthNTF1/7hM/sVr3AFvfGMMA3p2YWeKwjLCg=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-6"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"7S3DoUxf0FgsOX2hvJpPVp8M5IedrujJtJ+292UzQblKPh2VwMFY5hs2UpJj/gp2UwtGe4UavN6nSDfuLGxhDw=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-7"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"8YTu9C/mI5ZLcpKej/Rw90S+a3KP3p/bro+OzC8Pn7njAvH15k70LkucofhSAK7ET6sC0TziWZN+OK1dG+iuDw=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-8"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"PkVck5Uzs43xaZoiebfxKTFPqESVChh8Tfql8iGu+g/ZHsWFbKJa4LRBUabGFmzRp9iFycUH2uroR5ryhy8UAw=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d598tyfatprdstalqutk62cnzpm3thvyy9mypg","send":"","max_deposit":"","pkg_path":"gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/stress_1765762513","func":"SayHello","args":["Account-9"]}],"fee":{"gas_wanted":"167592","gas_fee":"168ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"E2lmbTz7T5JjAk1Bav4ktlfENxRR330SIcQvjxTUdgcFiUgUyTUtUC1qcT5uyt0m3UvcQEZ1YO27zLWqD2nIBg=="}],"memo":""},"metadata":{"timestamp":"1765762517"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1h4de3tdpy00vz7m0xqatnc50q2l98xgc4wmzxr","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"kIS/pxMWq/TxWe6KRbE5b//4c2QXrLLUQZE2thR0EpjbuNNghAYhdYMqMgORf1wbP6dJVBCehwL6yXPQZoxnCQ=="}],"memo":""},"metadata":{"timestamp":"1765774258"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1g4cttr7z65uvnsh08w4cw3gncy54tvupz24qh8","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"1000ugnot"}],"fee":{"gas_wanted":"45815","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"9oT1n21UUT7n+3MpiSbnO9G37asaF+nb90J3W+/4IyxPzRCkVZRLQrIeRgc10ZfJ8P+17oAjnToeWeHZNHG9Ag=="}],"memo":""},"metadata":{"timestamp":"1765783008"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1eg0lxpnulp2acxlhzfq2x9h3jp404nlmcf3qc9","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"1000ugnot"}],"fee":{"gas_wanted":"45815","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"QctY5fU+v8KFL8JdxnaiQMWGvvXUHCnbF7IjOMJA1CCKkLU89Lr8LTHMovqZS9o9HZ5Z1evgwF97BPfIX7ViAA=="}],"memo":""},"metadata":{"timestamp":"1765783018"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1pmjf4fgcd0k6pxrdzj2veggsj95zxqwk9rehwg","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"1000ugnot"}],"fee":{"gas_wanted":"45815","gas_fee":"46ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"iUiK2SFaGucy330ZBHmaj3TYGnK/Da8ap3wB+OApDz4xpgH6VWkuye4SIRn8HE0bAHQGnevWxS9RQ0JAfN66Ag=="}],"memo":""},"metadata":{"timestamp":"1765783028"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1g4cttr7z65uvnsh08w4cw3gncy54tvupz24qh8","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"4305440","gas_fee":"4306ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"bmqakx24yhul8h8dAeixfNIp+Rcg/96SSmBgRTM71nTooHBnbeoPSdGNm+/z6NNGJnCV49XANhDTXdjhQUhcDQ=="}],"memo":""},"metadata":{"timestamp":"1765785968"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1h4de3tdpy00vz7m0xqatnc50q2l98xgc4wmzxr","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"kIS/pxMWq/TxWe6KRbE5b//4c2QXrLLUQZE2thR0EpjbuNNghAYhdYMqMgORf1wbP6dJVBCehwL6yXPQZoxnCQ=="}],"memo":""},"metadata":{"timestamp":"1765789013"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1h4de3tdpy00vz7m0xqatnc50q2l98xgc4wmzxr","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","99"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"2IJ6agTYUPItmz3hlIb9WIDwn1zrCi7XOD0b1hQhGxurZpB2qcuYpfyqI91f7nfYl9MlH/8K/j94ZomAX5GvDw=="}],"memo":""},"metadata":{"timestamp":"1765789320"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g18r0t8dq2z0q7udery6l7cq7gxczm2c548cspu8","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"b82ep3SMC0hV6eaPrnEdr/3XjzsC6I0ue5eUIi5HTTufL0VFChc+p0UVq1Y/4IcZzIRSgFbaCol5GpyEJOM8Cw=="}],"memo":""},"metadata":{"timestamp":"1765790425"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1h4de3tdpy00vz7m0xqatnc50q2l98xgc4wmzxr","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","55"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"3VB0QV4za8yD4E3mAWAVcr3nhDKUWlXNhfyfbCRRClg3Qhtp6X9FfRWBxJhskvYeYXudyYNQD8biTuiSR/LVCg=="}],"memo":""},"metadata":{"timestamp":"1765795909"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1h4de3tdpy00vz7m0xqatnc50q2l98xgc4wmzxr","send":"","max_deposit":"","pkg_path":"gno.land/r/gnoland/wugnot","func":"Approve","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","45"]}],"fee":{"gas_wanted":"6112955","gas_fee":"6113ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"l8CUZyiZvqnKzNFkByJlN9f9S2Wog1zPyw35+4fDovzcgSO1Fu+0qcm+K8RFCMyxbf/3ls9bGIIWrak6rWFvDQ=="}],"memo":""},"metadata":{"timestamp":"1765797266"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1evV1HEwbpIPh2ASULKpDyn4WVZWNPQb8URKCnyJ/ngPQ4OF8mo540PQGoqVlvYSpDTBwLkgcIAUqboVzA7+AA=="}],"memo":""},"metadata":{"timestamp":"1765807142"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1evV1HEwbpIPh2ASULKpDyn4WVZWNPQb8URKCnyJ/ngPQ4OF8mo540PQGoqVlvYSpDTBwLkgcIAUqboVzA7+AA=="}],"memo":""},"metadata":{"timestamp":"1765807544"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"1evV1HEwbpIPh2ASULKpDyn4WVZWNPQb8URKCnyJ/ngPQ4OF8mo540PQGoqVlvYSpDTBwLkgcIAUqboVzA7+AA=="}],"memo":""},"metadata":{"timestamp":"1765808046"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"jv+ZnugF5dMpP2kyW904HCvtXhOw80upsGyVYr1IdHXEOBQLcMC9j9+FswQNFSwXqUeLW8gwNyZ9KpWu2BNRAg=="}],"memo":""},"metadata":{"timestamp":"1765808102"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Vc7+d5NGnFUpaU2YkX0aLMPGc8edBnL0eFd2PKPcQL9umJsQAZ+nsHFEbbODPlRd7RnvWzkAgvK5Bvg9FW7OCw=="}],"memo":""},"metadata":{"timestamp":"1765808117"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"5JgiBpt6jOTHWrDJ+pFD/9lBBxGNFJeGakj63ITBYfLJD7d9KHwmYgho5tSbv22ch/edznoWl47Og4WTHx2LDg=="}],"memo":""},"metadata":{"timestamp":"1765808132"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg","package":{"name":"test35","path":"gno.land/r/vik000/test35","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/vik000/test35\"\ngno = \"0.9\"\nprivate = true\n\n[addpkg]\n  creator = \"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg\"\n"},{"name":"home.gno","body":"package test35\n\nfunc Render(path string) string {\n\treturn \"hello35\"\n}\n\n\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"Dgai+Pu8YKIx1J433gucAYHrJNJfzNu93m5HA9rInKL73ZAZZzGETCjZfeOTEajX986F7LJrA9EVbymLrfhFAw=="}],"memo":""},"metadata":{"timestamp":"1765810127"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","max_deposit":"","pkg_path":"gno.land/r/boards000/v1rc1","func":"CreateBoard","args":["CommonDAO","true"]}],"fee":{"gas_wanted":"40000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"nrx8zqZmWUJmbymkAsy8iR8yohaiq5Eyo8vMX4M0p6yh2JznrSitYF1EL5H+frdLHUanaU016c0QL7gm+feCBg=="}],"memo":""},"metadata":{"timestamp":"1765810218"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"LCCkzTfaBLat1mP+w6X11uyByE7Y37pLpVpnyRsO4lZ2RpojBqftr5JNQXU2cxhkps1v4pzcC/RY9jHEiXetCQ=="}],"memo":""},"metadata":{"timestamp":"1765810298"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"LCCkzTfaBLat1mP+w6X11uyByE7Y37pLpVpnyRsO4lZ2RpojBqftr5JNQXU2cxhkps1v4pzcC/RY9jHEiXetCQ=="}],"memo":""},"metadata":{"timestamp":"1765810313"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg","package":{"name":"home","path":"gno.land/r/vik000/home","files":[{"name":"gnomod.toml","body":"module = \"gno.land/r/vik000/home\"\ngno = \"0.9\"\nprivate = true\n\n[addpkg]\n  creator = \"g13kytw9mpyutwmyg5eq7arqxqcszfl6uq4p89zg\"\n"},{"name":"home.gno","body":"package home\n\nfunc Render(path string) string {\n\treturn \"hello\"\n}\n\n\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"}},"send":"","max_deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"OMY69WIMPiaeCTy+I1SJC7AF88tHV/PW+zixPAXy70yo+xU1/u5HGr/23IbMR/MjaSZF/KXrsYzia2dBbTZ0Bg=="}],"memo":""},"metadata":{"timestamp":"1765810323"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","max_deposit":"","pkg_path":"gno.land/r/boards000/v1rc1","func":"CreateThread","args":["2","Write a DAO Realm - Part 1","## Overview\n\nThis two parts tutorial explores one way to create a non-token based DAO that allows the creation\nof general proposals, also known as text proposals, where the initial set of DAO members are\ndefined within the realm source code. The second part of this tutorial will explore how to add and\nremove members by using a different type of proposal.\n\nTutorial uses the pure [gno.land/p/nt/commondao] package to define the DAO and the different types\nor proposals. This package already define for us the types and features needed to create single or\ntree based DAOs.\n\nThe final DAO implementation aims to be as simple as possible to give you a example or starting\npoint to help you build your own DAO.\n\nWhile going though the tutorial try to find the places that you could improve or where you could\nextend the DAO functionality with features that would be useful for your use case.\n\n## What You'll Learn\n\n- How to create a simple DAO\n- How to create a general proposal\n- How to write minimal public functions to create general proposals and vote\n\n## What You'll Need\n\n- Understanding of [Gno language](https://docs.gno.land/)\n- Access and familiarity with [Gno Playground]\n- [Adena wallet](https://www.adena.app/) installed in your browser\n- **Three accounts** created in Adena wallet\n- Knowledge on how to deploy realms and packages using [Gno Playground] or [gnokey]\n- Knowledge on how to interact with realms using [Gno Connect] or [gnokey]\n\n## The DAO\n\nLets start by creating the DAO and its members. The number of DAO members is not fixed, one could\nuse any number of initial members depending on the implementation but for the tutorial we must add\nthree initial members to be able to tally votes on proposals by absolute majority, passing proposals\nwhere 51% or more members vote \"yes\".\n\nTo create the DAO open [Gno Playground] and create a new `dao.gno` file:\n\n```go\npackage mydao\n\nimport \"gno.land/p/nt/commondao\"\n\nvar myDAO = commondao.New(\n    commondao.WithSlug(\"mydao\"),\n    commondao.WithName(\"MyDAO\"),\n    // TODO: Replace these three addresses with you account addresses\n    commondao.WithMember(\"g1lyzcpa7duh69lk04nahxup484xrz4k6k2nqdun\"),\n    commondao.WithMember(\"g125t352u4pmdrr57emc4pe04y40sknr5ztng5mt\"),\n    commondao.WithMember(\"g1zzc479zj8taxd5e4g5mydg4rkpmujg7uflrj8p\"),\n)\n\n// mustGetProposal returns a proposal or panics if it doesn't exist\nfunc mustGetProposal(id uint64) *commondao.Proposal {\n    // Try to get it from the list of active proposals\n    p := myDAO.ActiveProposals().Get(id)\n    if p == nil {\n        panic(\"proposal not found\")\n    }\n\n    return p\n}\n\n// assertIsMember asserts that an address belongs to a DAO member\nfunc assertIsMember(addr address) {\n    if !myDAO.Members().Has(addr) {\n        panic(\"caller is not a DAO member\")\n    }\n}\n```\n\n\u003e Gno Playground always creates an example `package.gno` file. This file **must** be deleted\n\u003e after creating the `dao.gno` file.\n\n\u003e Also it's recommended that you save your code using Gno Playground's save as draft feature when\n\u003e files are created or modified to avoid loosing your changes.\n\nThe DAO is created with `mydao` as identifier and \"MyDAO\" as name.\n\nYou should change the member addresses in the example Gno code by the three initial account\naddresses that you defined in your Adena wallet, otherwise you won't be able to create proposals in\nyour DAO and vote on them.\n\n## Views\n\nGno.land realms optionally support rendering views by defining a public realm function called\n\"Render\". Using this feature we can render any number of different views. For the tutorial we\nare going to render two views, one to display DAO information and another to display information\nfor specific proposals.\n\nThe `Render(path string) string` function receives a single argument called `path` which is a\nstring containing a path that we will use to render Markdown for the DAO or a proposal.\n\nBy default when there is no path we will render the DAO, otherwise we will expect the path to be a\nnumber which will be used as proposal ID.\n\nDefine the `Render()` function by creating a `render.gno` file:\n\n```go\npackage mydao\n\nimport (\n    \"strconv\"\n    \"strings\"\n\n    \"gno.land/p/nt/commondao\"\n)\n\n// Render returns the Markdown for the corresponding view path.\nfunc Render(path string) string {\n    // When the path is empty render the DAO view\n    if path == \"\" {\n        return renderDAO()\n    }\n\n    // Otherwise the path must contain a number with a proposal ID\n    proposalID, err := strconv.ParseUint(path, 10, 64)\n    if err != nil {\n        panic(\"invalid proposal ID\")\n    }\n\n    return renderProposal(proposalID)\n}\n```\n\nTwo private render function are also defined to simplify the `Render()` function and make it easier\nto read. Each one of these two functions will focus either on the DAO view or the proposal view.\n\n### DAO View\n\nAs mentioned before, this is the function that is called by default when visiting your realm in the\n[gno.land] website.\n\nFor example if yout DAO realm is deployed under `gno.land/r/jeronimoalbi/examples/mydao` path,\ncalling `https://gno.land/r/jeronimoalbi/examples/mydao` would render the DAO view.\n\nTo implement the DAO view add the `renderDAO()` function at the end of the `render.gno` file:\n\n```go\nfunc renderDAO() string {\n    var output strings.Builder\n\n    // Use the DAO name as title\n    output.WriteString(\"# \" + myDAO.Name() + \"\\n\")\n\n    // Add the list of DAO member addresses\n    output.WriteString(\"## Members\\n\")\n    myDAO.Members().IterateByOffset(0, myDAO.Members().Size(), func(member address) bool {\n        output.WriteString(\"- \" + member.String() + \"\\n\")\n        return false\n    })\n\n    return output.String()\n}\n```\n\nThis and the `renderProposal()` functions use the `strings` package from the Gno standard library to\ngenerate the required Markdown for each of the views. Using the `strings.Builder` type we can write\nstrings multiple times and get the concatenation as output by calling the `String()` method on it.\n\n### Proposal View\n\nRendering this view requires a render path to be specified when visiting your realm in the\n[gno.land] website.\n\nFor example if your DAO realm is deployed under `gno.land/r/jeronimoalbi/examples/mydao` path,\ncalling `https://gno.land/r/jeronimoalbi/examples/mydao:1` would render the view for the proposal\nwith ID 1.\n\n\u003e Notice that the render path is written after the colon \":\" and for this tutorial it is expected to\n\u003e be a number which is used to find a proposal by ID.\n\nTo implement the proposal view add the `renderProposal()` function at the end of the `render.gno` file:\n\n```go\nfunc renderProposal(id uint64) string {\n    var (\n        output strings.Builder\n        p      = mustGetProposal(id)\n    )\n\n    // Use proposal's title and ID as title\n    output.WriteString(\"# Proposal #\" + strconv.FormatUint(p.ID(), 10) + \": \" + p.Definition().Title() + \"\\n\")\n\n    // Add important proposal values\n    output.WriteString(\"- Created: \" + p.CreatedAt().UTC().Format(\"2006-01-02 15:04 MST\") + \"\\n\")\n    output.WriteString(\"- Proposer: \" + p.Creator().String() + \"\\n\")\n    output.WriteString(\"- Status: \" + string(p.Status()) + \"\\n\")\n    output.WriteString(\"\\n\" + p.Definition().Body() + \"\\n\")\n\n    // Add the number of votes for each one of the voted choices\n    output.WriteString(\"\\n## Votes\\n\")\n    record := p.VotingRecord()\n    if record.Size() == 0 {\n        output.WriteString(\"Proposal has no votes\\n\")\n    } else {\n        record.IterateVotesCount(func(c commondao.VoteChoice, voteCount int) bool {\n            output.WriteString(\"- \" + string(c) + \": \" + strconv.Itoa(voteCount) + \"\\n\")\n            return false\n        })\n    }\n\n    return output.String()\n}\n```\n\nThis function is a bit more complex than the DAO one but it follows the same idea, it generates\nMarkdown containing the most important and minimal imformation for a proposal.\n\n## General Proposal Definition\n\nThe [gno.land/p/nt/commondao] package allows the definition of different proposal types though the\nimplementation of proposal definitions.\n\nThe following is the minimal interface that has to be implemented to create a new proposal type:\n\n```go\ntype ProposalDefinition interface {\n    // Title returns the proposal title.\n    Title() string\n\n    // Body returns proposal's body.\n    // It usually contains description or values that are specific to the proposal,\n    // like a description of the proposal's motivation or the list of values that\n    // would be applied when the proposal is approved.\n    Body() string\n\n    // VotingPeriod returns the period where votes are allowed after proposal creation.\n    // It is used to calculate the voting deadline from the proposal's creationd date.\n    VotingPeriod() time.Duration\n\n    // Tally counts the number of votes and verifies if proposal passes.\n    // It receives a voting context containing a readonly record with the votes\n    // that has been submitted for the proposal and also the list of DAO members.\n    Tally(VotingContext) (passes bool, _ error)\n}\n```\n\nThe `VotingContext` type contains the voting record where submitted votes are stored and the\nlist of DAO members. The voting context must be used to tally the votes, but it can also be\nused to check quorum for example.\n\nTo define a general proposal definition create a `proposal_general.gno` file:\n\n```go\npackage mydao\n\nimport (\n    \"time\"\n\n    \"gno.land/p/nt/commondao\"\n)\n\ntype generalDefinition struct {\n    title, description string\n}\n\nfunc (p generalDefinition) Title() string             { return p.title }\nfunc (p generalDefinition) Body() string              { return p.description }\nfunc (generalDefinition) VotingPeriod() time.Duration { return time.Hour }\n\nfunc (generalDefinition) Tally(ctx commondao.VotingContext) (bool, error) {\n    // Check if a quorum of 50% has been met\n    if !commondao.IsQuorumReached(commondao.QuorumHalf, ctx.VotingRecord, ctx.Members) {\n        return false, commondao.ErrNoQuorum\n    }\n\n    // Tally votes by absolute majority, which requires 51% votes\n    c, success := commondao.SelectChoiceByAbsoluteMajority(ctx.VotingRecord, ctx.Members.Size())\n    if success {\n        return c == commondao.ChoiceYes, nil\n    }\n    return false, nil\n}\n```\n\n\u003e It's important to mention that you might want to change the voting period to a smaller time frame\n\u003e if you intend to try or demo a general proposal.\n\nPay special attention to the `Tally()` method which is the one used by the proposals to count the\nvotes and decide on a winner choice. Votes can be counted using different rules. For the general\nproposal votes are counted by absolute majority which includes voting abstentions when calculating\nthe required percentage for a voting choice to win.\n\n\u003e Here you could implement a different way for tallying votes.\n\n## Public Realm Functions\n\nUntil now the only public realm function that was defined is the `Render()`, so the next step is to\ndefine the rest of the public function that the DAO realm must expose so users can create general\nproposal and vote on them.\n\n### Create General Proposal\n\nTo allow DAO members to create new general proposals define a `CreateGeneralProposal()` function by\ncreating a `public.gno` file:\n\n```go\npackage mydao\n\nimport (\n    \"chain/runtime\"\n    \"strings\"\n\n    \"gno.land/p/nt/commondao\"\n)\n\n// CreateGeneralProposal creates a general proposal.\n//\n// Arguments:\n// - title: A title for the proposal\n// - description: A description for the proposal\nfunc CreateGeneralProposal(_ realm, title, description string) uint64 {\n    // Proposal description and title are required\n    assertTitleIsNotEmpty(title)\n    assertDescriptionIsNotEmpty(description)\n\n    // Check that the original caller is a member of the DAO\n    caller := runtime.OriginCaller()\n    assertIsMember(caller)\n\n    // Create a new proposal that uses the general definition\n    p, err := myDAO.Propose(caller, generalDefinition{\n        title,\n        description,\n    })\n    if err != nil {\n        panic(err)\n    }\n\n    return uint64(p.ID())\n}\n```\n\n### Vote\n\nTo allow DAO members to vote on any type of proposal define a `Vote()` function at the end of the\n`public.gno` file:\n\n```go\n// Vote allows voting on proposals.\n//\n// Arguments:\n// - proposalID: ID of the proposal where the vote must be submitted\n// - vote: A string with choice to vote\nfunc Vote(_ realm, proposalID uint64, vote string) string {\n    // Check that the original caller is a member of the DAO\n    caller := runtime.OriginCaller()\n    assertIsMember(caller)\n    \n    p := mustGetProposal(proposalID)\n    choice := commondao.VoteChoice(vote)\n    \n    // When the voted choice is invalid use a custom error that display valid choices\n    if !p.IsVoteChoiceValid(choice) {\n        var choices []string\n        for _, c := range p.VoteChoices() {\n        \tchoices = append(choices, string(c))\n        }\n\n        panic(\"invalid vote choice, valid choices: \" + strings.Join(choices, \", \"))\n    }\n\n    err := myDAO.Vote(caller, p.ID(), choice, \"\")\n    if err != nil {\n        panic(err)\n    }\n\n    return \"Vote submitted sucessfully\"\n}\n```\n\n## What's Next\n\nNow you are ready to continue with the part 2 of the tutorial to learn how to define a new type of\nproposal to add and remove DAO members.\n\n[gno.land]: https://gno.land\n[gno.land/p/nt/commondao]: https://gno.land/p/nt/commondao/\n[Gno Playground]: https://play.gno.land/\n[Gno Connect]: https://gno.studio/connect/\n[gnokey]: https://docs.gno.land/users/interact-with-gnokey/"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"fjt22NKoMBuI2H0XKy9SC/breNnUxbYw4X2GWPMTVK6atiOZQq5/n1iPR3Ft2gjzhVOh5nR81XF3vmGp5FWAAg=="}],"memo":""},"metadata":{"timestamp":"1765812147"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","max_deposit":"","pkg_path":"gno.land/r/boards000/v1rc1","func":"CreateThread","args":["2","Write a DAO Realm - Part 2","## Overview\n\nThis second part of the \"Write a DAO Smart Contract\" tutorial will explore how to add and remove\nmembers by using a different type of proposal. It continues where the first part left off.\n\n## What You'll Learn\n\n- What an executable proposal is\n- How to create an executable proposal that updates DAO members\n- How to write a minimal public function to execute proposals\n\n## What You'll Need\n\n- To have read the [first part] of this tutorial\n- Understanding of [Gno language](https://docs.gno.land/)\n- Knowledge on how to deploy realms and packages using [Gno Playground] or [gnokey]\n- Knowledge on how to interact with realms using [Gno Connect] or [gnokey]\n\n## Executable Proposals\n\nIt's useful to be able to change the members of the DAO by adding new members or removing existing\nones. One way to support this is though the implementation of a new type of proposal that when\napproved would make the necessary changes to the DAO. This type of proposal is called executable.\n\nThe steps needed to change DAO members using this new proposal type start by creating a new\nproposal to modify the DAO members, then voting on it and waiting until the voting deadline is met.\nOnce that happens, the proposal could be executed at any time to effectively modify the members.\n\nThe [gno.land/p/nt/commondao] package allows defining executable proposal types by implementing\nthe following interface:\n\n```go\ntype Executable interface {\n    // Execute executes the proposal\n    Execute(realm) error\n}\n```\n\n### Executable Proposal Definition\n\nProposal definitions that implement the `Execute()` method are able to modify the state after the\nproposal is approved and executed when the voting deadline is met.\n\nLet's define a new proposal strategy that adds or removes DAO members after it's approval by creating\na `proposal_members.gno` file:\n\n```go\npackage mydao\n\nimport (\n    \"errors\"\n    \"strings\"\n    \"time\"\n\n    \"gno.land/p/nt/commondao\"\n)\n\ntype modifyMembersDefinition struct {\n    newMembers, removeMembers []address\n}\n\nfunc (p modifyMembersDefinition) Title() string             { return \"Modify Members\" }\nfunc (modifyMembersDefinition) VotingPeriod() time.Duration { return time.Hour }\n\nfunc (p modifyMembersDefinition) Body() string {\n    var b strings.Builder\n\n    // When there are new members add a section title and list the members to add\n    if len(p.newMembers) \u003e 0 {\n        b.WriteString(\"## New Members\\n\")\n    }\n\n    for _, m := range p.newMembers {\n        b.WriteString(\"- \" + m.String() + \"\\n\")\n    }\n\n    // When there are members to remove add a section title and list the members to remove\n    if len(p.removeMembers) \u003e 0 {\n        b.WriteString(\"## Remove Members\\n\")\n    }\n\n    for _, m := range p.removeMembers {\n        b.WriteString(\"- \" + m.String() + \"\\n\")\n    }\n\n    // Return the Markdown that renders the body of the proposal\n    return b.String()\n}\n\nfunc (modifyMembersDefinition) Tally(ctx commondao.VotingContext) (bool, error) {\n    // Check if a quorum of 2/3s has been met\n    if !commondao.IsQuorumReached(commondao.QuorumTwoThirds, ctx.VotingRecord, ctx.Members) {\n        return false, commondao.ErrNoQuorum\n    }\n\n    // Tally votes by a super majority of 2/3s\n    c, success := commondao.SelectChoiceBySuperMajority(ctx.VotingRecord, ctx.Members.Size())\n    if success {\n        return c == commondao.ChoiceYes, nil\n    }\n    return false, nil\n}\n\nfunc (p modifyMembersDefinition) Execute(realm) error {\n    // Add each one of the new members to the DAO\n    for _, m := range p.newMembers {\n        if !myDAO.Members().Add(m) {\n            return errors.New(\"address is already a member: \" + m.String())\n        }\n    }\n\n    // Remove each one of the members to remove from the DAO\n    for _, m := range p.removeMembers {\n        if !myDAO.Members().Remove(m) {\n            return errors.New(\"address not found: \" + m.String())\n        }\n    }\n    return nil\n}\n```\n\n\u003e It's important to mention that you might want to change the voting period to a smaller time frame\n\u003e if you intend to try or demo the proposal.\n\nPay special attention to the `Execute()` method, which will be called after the proposal passes.\nThe other proposal definition methods were already explained in the [first part] of the tutorial.\n\n## Public Realm Functions\n\nThe next step is to define a new public realm function to allow the creation of member modification\nproposals and a second public function to be able to execute proposals once the voting deadline\nis met.\n\n### Create Modify DAO Member Proposal\n\nFirts, a helper function to parse one or more addresses from a string into actual addresses is\nrequired to be able to call the function using simple data types, for example when calling it\nusing [Gno Connect].\n\nTo do so define a `mustParseStringToAddresses()` function at the end of the `public.gno` file:\n\n```go\n// mustParseStringToAddresses parses a mulitiline text of addresses into a list.\nfunc mustParseStringToAddresses(s string) []address {\n    if s == \"\" {\n        return nil\n    }\n\n    var members []address\n    for _, raw := range strings.Split(s, \"\\n\") {\n        // Remove empty leading and trailing spaces\n        raw = strings.TrimSpace(raw)\n        if raw == \"\" {\n\t    continue\n        }\n\n        // Cast the string into an address and make sure address has the right format\n        addr := address(raw)\n        if !addr.IsValid() {\n\t    panic(\"invalid address: \" + addr.String())\n        }\n\n\t// Add current address to the list of addresses\n        members = append(members, addr)\n    }\n    return members\n}\n```\n\nTo allow DAO members to create new _modify members_ proposals, define a\n`CreateModifyMembersProposal()` function at the end of the `public.gno` file:\n\n````go\n// CreateModifyMembersProposal creates a proposal to modify DAO members.\n//\n// Arguments:\n// - newMembers: List of member addresses to add to the DAO\n// - removeMembers: List of member addresses to remove from the DAO\n//\n// A list of members must be newline separated list of addresses,\n// where each line must contain an address, for example:\n// ```\n// g187982000zsc493znqt828s90cmp6hcp2erhu6m\n// g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\n// ```\nfunc CreateModifyMembersProposal(_ realm, newMembers, removeMembers string) uint64 {\n    // Check that the original caller is a member of the DAO\n    caller := runtime.OriginCaller()\n    assertIsMember(caller)\n\n    // Make sure that at least a member would be added or removed\n    membersAdd := mustParseStringToAddresses(newMembers)\n    membersRemove := mustParseStringToAddresses(removeMembers)\n    if len(membersAdd) == 0 \u0026\u0026 len(membersAdd) == 0 {\n        panic(\"members are required\")\n    }\n\n    // Create a new proposal that uses the general definition\n    p, err := myDAO.Propose(caller, modifyMembersDefinition{\n        membersAdd,\n        membersRemove,\n    })\n    if err != nil {\n        panic(err)\n    }\n\n    return uint64(p.ID())\n}\n````\n\nThis function receives one or more member addresses that should be added or removed from the DAO\nafter the proposal is approved, when proposal is executed.\n\n### Create a Public Realm Function to Execute Proposals\n\nTo allow executing proposals define an `Execute()` function at the end of the `public.gno` file:\n\n```go\n// Execute executes active proposals.\nfunc Execute(_ realm, proposalID uint64) string {\n    caller := runtime.OriginCaller()\n    assertIsMember(caller)\n\n    p := mustGetProposal(proposalID)\n    err := myDAO.Execute(p.ID())\n    if err != nil {\n        panic(err)\n    }\n\n    return \"Proposal executed successfully\"\n}\n```\n\nThe `Execute()` function should be called for any type of proposals, executable or non executable,\nto update the proposal state to reflect the outcome of the votes once the voting deadline is met.\n\n## What's Next\n\nNow you can add or remove DAO members by following these steps:\n\n- Deploy your DAO realm to **gno.land**\n- Create a new member modification proposal by calling `CreateModifyMembersProposal()`\n- Vote _YES_ on the new proposal using the current DAO member accounts\n- Once the voting deadline is met execute the proposal by calling `Execute()`\n- Check the list of DAO members in your DAO **gno.land** realm view\n\nFrom here, you can explore extending the tutorial examples with different use cases. For example,\nyou could improve validation. The [gno.land/p/nt/commondao] package has support for proposal\nvalidation by implementing the `Validator` interface in the proposal definitions.\n\nOther things to explore could be using different tallying methods to count the votes, or even\ncreating a tree based DAO, which is also supported by [gno.land/p/nt/commondao].\n\n[first part]: https://gno.land/r/jeronimoalbi/blog:posts/write-a-dao-smart-contract-part-1\n[gno.land/p/nt/commondao]: https://gno.land/p/nt/commondao/\n[Gno Connect]: https://gno.studio/connect/\n[Gno Playground]: https://play.gno.land/\n[gnokey]: https://docs.gno.land/users/interact-with-gnokey/"]}],"fee":{"gas_wanted":"50000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeyEd25519","value":"2g3CFZbu6aQJNamdPR9XqWG1J1AFY2FRH+fWxKTpX/U="},"signature":"a0iz8eEAv2una62PHCeBp7guHZkhd+Gm80RMFoDsUiQ9QtSe4Kx5hE3FCYLe09JOyieOXSkuC2Vt61y9hJGhDA=="}],"memo":""},"metadata":{"timestamp":"1765812198"}}
