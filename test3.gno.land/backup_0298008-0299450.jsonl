{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1n4w8sg02yp3fffr2c2f06fxrwxd3luhuvdqs6d","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"6Q6L2jks4Qo5rJQ4dEXjGMFrON/tv5CJmApl6MvHn4QAH6Rl/VjVLk0jqFohvTx+UwWcD/cu9VkoChuAhv3+nw=="}],"memo":""},"blockNum":"298433"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1n4w8sg02yp3fffr2c2f06fxrwxd3luhuvdqs6d","package":{"Name":"whitelist","Path":"gno.land/p/pengu/whitelist","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Avle4Xra+bPICCaKr1ivfDV83rWwiWdftYkvOxLrsmJI"},"signature":"MhY5Fyfi8DaPdN/zNf38icqjgGyxAKmTRCfGCSZ2xp1u1T99OAYrSIsLtgEf2us1PvejQosLxzAoXvs8N/DVkA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298435"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1n4w8sg02yp3fffr2c2f06fxrwxd3luhuvdqs6d","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"M5LHAhNfjnKwB4kA4j67D0hNXY2Zh1OfNAQQMtDPMEhYmt2bbwYgW0ojuQh7pwBTTL9upF/xm7hyMV7345iYng=="}],"memo":""},"blockNum":"298438"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1n4w8sg02yp3fffr2c2f06fxrwxd3luhuvdqs6d","package":{"Name":"whitelist","Path":"gno.land/r/pengu/whitelist","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/pengu/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\twhitelist \"REPLACE WITH YOUR PACKAGE PATH\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Avle4Xra+bPICCaKr1ivfDV83rWwiWdftYkvOxLrsmJI"},"signature":"Imzkq+z0kSpIUHorG19HNOQtihkCfjFuc+MzZD58U1tjLju5PvE5L1Jz3jwCKfdALbnU1Fh/5zunhMJ3uJjzJQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298440"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1n4w8sg02yp3fffr2c2f06fxrwxd3luhuvdqs6d","package":{"Name":"whitelist","Path":"gno.land/r/pengu/whitelist","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\twhitelist \"gno.land/p/pengu\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Avle4Xra+bPICCaKr1ivfDV83rWwiWdftYkvOxLrsmJI"},"signature":"StOFSor8Dpbb6A9gc4xYc+C+s+oiG0ZhZFoxJpaRJyR0JBx4h49h4YNDrx6ViTtexs+utP4Ai0h7LdMvL2Aqiw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298444"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1n4w8sg02yp3fffr2c2f06fxrwxd3luhuvdqs6d","package":{"Name":"whitelistfactory","Path":"gno.land/r/pengu/whitelistfactory","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\twhitelist \"gno.land/p/pengu\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Avle4Xra+bPICCaKr1ivfDV83rWwiWdftYkvOxLrsmJI"},"signature":"1zPhwKzwwe1t4Y051pSk9k7dm17zOF/G5QuAC9IUMTQwLgsj2hEXv3hNNQ8SGOjWRTROSeoGY28OWu65DqeRgA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298446"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1n4w8sg02yp3fffr2c2f06fxrwxd3luhuvdqs6d","package":{"Name":"whitelistfactory","Path":"gno.land/r/pengu/whitelistfactory","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/pengu/whitelist\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Avle4Xra+bPICCaKr1ivfDV83rWwiWdftYkvOxLrsmJI"},"signature":"ytmT0eKg53+JFfDFo+D1NTQiSdQFnCEEK9DAGhkGTqYWPrcPIdddPPS34E6YE5VCpqQBLEWP+xdJ8/+TdUBkBQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298448"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"ethtoken","Path":"gno.land/r/token/ethtoken","Files":[{"Name":"ethtoken.gno","Body":"package ethtoken\n\nimport (\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\t\"std\"\n)\n\nvar (\n\tethtoken *grc20.AdminToken\n\tadmin    std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n\tethtoken = grc20.NewAdminToken(\"Ethereum\", \"ETH\", 4)\n\tethtoken.Mint(admin, 1000000*1000000)\n}\n\n// Return total numbers tokens minted\nfunc TotalSupply() uint64 {\n\treturn ethtoken.TotalSupply()\n}\n\n// Return total balance account\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := ethtoken.BalanceOf(owner.Resolve())\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\n// Set an account as an allowed spender to serve on behalf of the owner\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := ethtoken.Allowance(owner.Resolve(), spender.Resolve())\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn allowance\n}\n\n// Transfer amount to another account\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := ethtoken.Transfer(caller, to.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Approve a calling account to spend a configurale amount of token on behalf of the token owner\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := ethtoken.Approve(caller, spender.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Transfer amount of token from an account that granted approval to another account\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := ethtoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Create a configurable number of token by the admin\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := ethtoken.Mint(address.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Destroy a configurable number of token by the amdin\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := ethtoken.Burn(address.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Return a user's balance as a formatted string\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn ethtoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := ethtoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Verify if address is admin\nfunc assertAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"i4XslW1SS6MED3XFWzT6udKB7kKurTB5eZ+v2uRfDX4WF2Gb/XB1lNdj0jMRJ1KVOwqqgTVUIcPLuq6VSDiO8w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298484"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"ethtoken","Path":"gno.land/r/token/ethtoken","Files":[{"Name":"ethtoken.gno","Body":"package ethtoken\n\nimport (\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\t\"std\"\n)\n\nvar (\n\tethtoken *grc20.AdminToken\n\tadmin    std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n\tethtoken = grc20.NewAdminToken(\"Ethereum\", \"ETH\", 4)\n\tethtoken.Mint(admin, 1000000*1000000)\n}\n\n// Return total numbers tokens minted\nfunc TotalSupply() uint64 {\n\treturn ethtoken.TotalSupply()\n}\n\n// Return total balance account\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := ethtoken.BalanceOf(owner.Resolve())\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\n// Set an account as an allowed spender to serve on behalf of the owner\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := ethtoken.Allowance(owner.Resolve(), spender.Resolve())\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn allowance\n}\n\n// Transfer amount to another account\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.Transfer(caller, to.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Approve a calling account to spend a configurale amount of token on behalf of the token owner\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.Approve(caller, spender.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Transfer amount of token from an account that granted approval to another account\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Create a configurable number of token by the admin\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := ethtoken.Mint(address.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Destroy a configurable number of token by the amdin\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := ethtoken.Burn(address.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Return a user's balance as a formatted string\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn ethtoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := ethtoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Verify if address is admin\nfunc assertAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"5K/Owuul4AX3Yjj+s8dJd9xh7WVMktJKnUxTdl1+ms8BLGebefnTlglDJW9e+jLDZvDEqHjBsXCFhEJLOO6RSQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298495"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"ethtoken","Path":"gno.land/r/token/ethtoken","Files":[{"Name":"ethtoken.gno","Body":"package ethtoken\n\nimport (\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\t\"std\"\n)\n\nvar (\n\tethtoken *grc20.AdminToken\n\tadmin    std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n\tethtoken = grc20.NewAdminToken(\"Ethereum\", \"ETH\", 4)\n\tethtoken.Mint(admin, 1000000*1000000)\n}\n\n// Return total numbers tokens minted\nfunc TotalSupply() uint64 {\n\treturn ethtoken.TotalSupply()\n}\n\n// Return total balance account\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := ethtoken.BalanceOf(owner.Resolve())\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\n// Set an account as an allowed spender to serve on behalf of the owner\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := ethtoken.Allowance(owner.Resolve(), spender.Resolve())\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn allowance\n}\n\n// Transfer amount to another account\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.Transfer(caller, to.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Approve a calling account to spend a configurale amount of token on behalf of the token owner\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.Approve(caller, spender.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Transfer amount of token from an account that granted approval to another account\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Create a configurable number of token by the admin\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := ethtoken.Mint(address.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Destroy a configurable number of token by the amdin\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := ethtoken.Burn(address.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Return a user's balance as a formatted string\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn ethtoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := ethtoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Verify if address is admin\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"9+c2RKjUGGmZDRMPGrvpmsoSTn6viP+aN9ZWpXS+YVgfW+t7lCvpDCEpNPIXm6jfwh8aEolprREiN5Lobepx/w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298497"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"ethtoken","Path":"gno.land/r/token/ethtoken","Files":[{"Name":"ethtoken.gno","Body":"package ethtoken\n\nimport (\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\t\"std\"\n    \"strings\"\n)\n\nvar (\n\tethtoken *grc20.AdminToken\n\tadmin    std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n\tethtoken = grc20.NewAdminToken(\"Ethereum\", \"ETH\", 4)\n\tethtoken.Mint(admin, 1000000*1000000)\n}\n\n// Return total numbers tokens minted\nfunc TotalSupply() uint64 {\n\treturn ethtoken.TotalSupply()\n}\n\n// Return total balance account\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := ethtoken.BalanceOf(owner.Resolve())\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\n// Set an account as an allowed spender to serve on behalf of the owner\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := ethtoken.Allowance(owner.Resolve(), spender.Resolve())\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn allowance\n}\n\n// Transfer amount to another account\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.Transfer(caller, to.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Approve a calling account to spend a configurale amount of token on behalf of the token owner\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.Approve(caller, spender.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Transfer amount of token from an account that granted approval to another account\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := ethtoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Create a configurable number of token by the admin\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := ethtoken.Mint(address.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Destroy a configurable number of token by the amdin\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := ethtoken.Burn(address.Resolve(), amount)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Return a user's balance as a formatted string\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn ethtoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := ethtoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Verify if address is admin\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"uR+L0i9jDYvUxmg3zSujwoQEiRyvr2k4Q9xkKAOpNkNjJMMhcj1Be+OYzD5nBoa3Y2iL0jOpTZJvfcux/Ct1lQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298501"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"bapenft","Path":"gno.land/r/nft/bapenft","Files":[{"Name":"bapenft.gno","Body":"package bapenft\n\nimport (\n    \"std\"\n\n    \"gno.land/p/demo/grc/grc721\"\n    \"gno.land/r/demo/users\"\n)\n\nvar (\n    admin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n    // provision the token's name and symbol\n    bapenft = grc721.NewBasicNFT(\"bapenft\", \"BAPENFT\")\n)\n\nfunc init() {\n    mintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := bapenft.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        bapenft.Mint(owner, tid)\n    }\n}\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := bapenft.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := bapenft.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return bapenft.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := bapenft.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := bapenft.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := bapenft.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := bapenft.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := bapenft.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := bapenft.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return bapenft.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"8Ii/KvuzT2MbL0jKwvQbBg+VK1Dvg7kpL3voPNRFCUkOGNpBQL1KMSSiDGG2J3KICm405ckBsVLDXOJSCpFxvQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298512"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"bapenft","Path":"gno.land/r/nft/bapenft","Files":[{"Name":"bapenft.gno","Body":"package bapenft\n\nimport (\n    \"std\"\n\n    \"gno.land/p/demo/grc/grc721\"\n    \"gno.land/r/demo/users\"\n)\n\nvar (\n    admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n    bapenft = grc721.NewBasicNFT(\"bapenft\", \"BAPENFT\")\n)\n\nfunc init() {\n    mintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := bapenft.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        bapenft.Mint(owner, tid)\n    }\n}\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := bapenft.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := bapenft.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return bapenft.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := bapenft.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := bapenft.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := bapenft.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := bapenft.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := bapenft.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := bapenft.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return bapenft.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"FY7iaWsp71Upeq3cT60DXr43N56lQILpALS0/S6xsZAf0gkvZtQG1fn2IjaTdq8gXp4rafmOLPcGvqpoEJ0y4A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298517"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"bapenft","Path":"gno.land/r/nft/bapenft","Files":[{"Name":"bapenft.gno","Body":"package bapenft\n\nimport (\n    \"std\"\n\n    \"gno.land/p/demo/grc/grc721\"\n    \"gno.land/r/demo/users\"\n)\n\nvar (\n    admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n    bapenft = grc721.NewBasicNFT(\"bapenft\", \"BNFT\")\n)\n\nfunc init() {\n    mintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := bapenft.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        bapenft.Mint(owner, tid)\n    }\n}\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := bapenft.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := bapenft.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return bapenft.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := bapenft.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := bapenft.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := bapenft.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := bapenft.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := bapenft.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := bapenft.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return bapenft.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"KmN9rOU77zgdOYZe236ffAG+HLxrTlLg3Vu2l6wFEyw3pAa3sbJZcqS+LHzi/0Ek42nFkXjrJfN0qU1MsVBWgA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298521"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15wmukt79xymnnu6c4de32trnufudqum60yrxu8","package":{"Name":"hello","Path":"gno.land/r/hello/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6QxDeE9T4utsKFysdC0JZTyVwnc4UgqQ7vhHJf5pp+p"},"signature":"gUCSbF82EVYS8XfjptgDvFSrYWsMQKEwSCzsb8qRUgpgiuiLhkz40mCth4Nj0j5zuo+9VXOLDQyOZ1yLaFHZMw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298739"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15wmukt79xymnnu6c4de32trnufudqum60yrxu8","package":{"Name":"AlexTest","Path":"gno.land/r/AlexTest/AlexTest","Files":[{"Name":"package.gno","Body":"package AlexTest\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6QxDeE9T4utsKFysdC0JZTyVwnc4UgqQ7vhHJf5pp+p"},"signature":"iSz6tqKUbPLIZpxyOSAWCSwy9QLenOT4eLmiDKVeGikMIOseoQnlrKL7nw69Mtua4RdydD+BnLZeH0C962KIOQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298741"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15wmukt79xymnnu6c4de32trnufudqum60yrxu8","package":{"Name":"alextest","Path":"gno.land/r/alextest/alextest","Files":[{"Name":"package.gno","Body":"package alextest\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6QxDeE9T4utsKFysdC0JZTyVwnc4UgqQ7vhHJf5pp+p"},"signature":"C2BoMJ93akG0wsuSFIvuriiKVXREmRoWSAt79SmQR+UvNARJKDBOiyZ/WIcELa+Q3szf3fak1dCEs6Rbmsj+Iw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"298743"}
