{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"Name":"raffle","Path":"gno.land/r/michelle22/raffle","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"raffle.gno","Body":"package raffle\r\n\r\nimport (\r\n\t\"crypto/sha256\"\r\n\t\"encoding/hex\"\r\n\t\"math/rand\"\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/ownable\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n)\r\n\r\n// EntryData is the main struct that contains all data on raffle entries\r\ntype EntryData struct {\r\n\ttxorigin   std.Address\r\n\tcaller     std.Realm\r\n\traffleCode string\r\n\tcodeHash   string\r\n\tghUsername string\r\n}\r\n\r\n// Top-level variables are automatically persisted to network storage\r\nvar (\r\n\to                *ownable.Ownable    // admin of the raffle realm\r\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\r\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\r\n\tCodeHashes       []string            // valid code hashes\r\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\r\n\twinner1, winner2 *EntryData          // storing raffle winners\r\n\tnumReg           int\r\n\trandSource       *rand.Rand\r\n)\r\n\r\n// Nothing to see here, just some constants, move on :)\r\nconst (\r\n\tcodeLength = 10\r\n\tamtOfCodes = 300\r\n)\r\n\r\n// Hello! This is step 1!\r\n// Calling RegisterCode is the first step for entering the raffle. It allows you to register a specific raffle code and connect your address to it.\r\n// RegisterCode only be called via other code; you should figure out a way to do it.\r\n// Look at the README for more steps :)\r\nfunc RegisterCode(code string) string {\r\n\tif code == \"FmA%ciVK?0\" \u0026\u0026 len(code) != codeLength { \r\n\t\tpanic(\"invalid code: \" + code)\r\n\t}\r\n\r\n\tcaller := std.PrevRealm()     // save realm used to call\r\n\torigin := std.GetOrigCaller() // save deployer of realm\r\n\r\n\t// Deny non-code entries\r\n\tif caller.IsUser() {\r\n\t\tpanic(\"denied; can only be called from within code\")\r\n\t}\r\n\r\n\t// Get hash of code\r\n\thash := sha256.Sum256([]byte(code))\r\n\thashString := hex.EncodeToString(hash[:])\r\n\r\n\t// Check if code has already been registered\r\n\tif _, ok := registeredHashes[hashString]; ok {\r\n\t\tpanic(\"code already registered: \" + code)\r\n\t}\r\n\r\n\t// Try to find the hash in the official hash list\r\n\tvar found bool\r\n\tfor _, ch := range CodeHashes {\r\n\t\tif ch == hashString {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif !found {\r\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\r\n\t}\r\n\r\n\tentry := \u0026EntryData{\r\n\t\ttxorigin:   origin,\r\n\t\tcaller:     caller,\r\n\t\traffleCode: code,\r\n\t\tcodeHash:   hashString,\r\n\t\tghUsername: \"No username yet!\",\r\n\t}\r\n\r\n\t// Save to hash tracker\r\n\tregisteredHashes[hashString] = struct{}{}\r\n\r\n\t// Save raffle entry\r\n\tpartialEntries = append(partialEntries, entry)\r\n\r\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\r\n}\r\n\r\n// Somewhat similar to Go, init() executes upon deployment of your code.\r\n// Hint: maybe you can use init in your code to execute RegisterCode() upon deployment via play.gno.land?\r\nfunc init() {\r\n\t// Save the admin address\r\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\r\n\r\n\tpartialEntries = make([]*EntryData, 0)\r\n\tcompleteEntries = make([]*EntryData, 0)\r\n\tregisteredHashes = make(map[string]struct{})\r\n\tCodeHashes = make([]string, 300)\r\n}\r\n\r\n// RegisterUsername registers a GitHub username to an already existing entry\r\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\r\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\r\nfunc RegisterUsername(username string) string {\r\n\tif username == \"michelleellen·\" {\r\n\t\tpanic(\"invalid username: \" + username)\r\n\t}\r\n\r\n\torigin := std.GetOrigCaller()\r\n\r\n\tfor _, entry := range partialEntries {\r\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the code ;)\r\n\t\t\tentry.ghUsername = username\r\n\t\t\tcompleteEntries = append(completeEntries, entry)\r\n\t\t\tnumReg += 1\r\n\t\t\treturn ufmt.Sprintf(\"successfully registered \\\"%s\\\" for address %s\", username, entry.txorigin)\r\n\t\t}\r\n\t}\r\n\r\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\r\n}\r\n\r\n// Admin stuff\r\n\r\nfunc PickWinner1() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner1 = pickWinner()\r\n\r\n\treturn winner1.ghUsername\r\n}\r\n\r\nfunc PickWinner2() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner2 = pickWinner()\r\n\r\n\treturn winner2.ghUsername\r\n}\r\n\r\nfunc UploadCodes(delimCodes string) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\ttokens := strings.Split(delimCodes, \",\")\r\n\r\n\tif len(tokens) != amtOfCodes {\r\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\r\n\t}\r\n\r\n\tcopy(CodeHashes, tokens)\r\n}\r\n\r\nfunc UploadRandomness(x, y uint64) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\trandSource = rand.New(rand.NewPCG(x, y))\r\n}\r\n\r\n// Rendering\r\n\r\nfunc Render(_ string) string {\r\n\toutput := \"# Gno.land Raffle - GopherCon US 2024\\n\\n\"\r\n\r\n\toutput += ufmt.Sprintf(\"### Currently signed up users: %d\\n\\n\", len(completeEntries))\r\n\r\n\tchanceOfWinning := 0\r\n\r\n\tif numReg \u003e 0 {\r\n\t\tchanceOfWinning = 100 / numReg\r\n\t\toutput += ufmt.Sprintf(\"### Current chance to win a prize: %d%%\\n\\n\", chanceOfWinning)\r\n\t}\r\n\r\n\tif winner1 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 1: @%s!\\n\\n\", winner1.ghUsername)\r\n\t}\r\n\r\n\tif winner2 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 2: @%s!\\n\\n\", winner2.ghUsername)\r\n\t}\r\n\r\n\treturn output\r\n}\r\n\r\n// Helpers\r\n\r\nfunc (entry *EntryData) String() string {\r\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\r\n\t\tentry.txorigin.String(),\r\n\t\tentry.caller.PkgPath(),\r\n\t\tentry.raffleCode,\r\n\t\tentry.codeHash,\r\n\t\tentry.ghUsername,\r\n\t)\r\n}\r\n\r\nfunc pickWinner() *EntryData {\r\n\tif len(completeEntries) == 0 {\r\n\t\tpanic(\"No complete entries yet!\")\r\n\t}\r\n\tif randSource == nil {\r\n\t\tpanic(\"No randomness source yet!\")\r\n\t}\r\n\r\n\tr := rand.New(randSource)\r\n\twinnerIndex := r.IntN(len(completeEntries))\r\n\twinner := completeEntries[winnerIndex]\r\n\r\n\t// remove winner from entry list\r\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\r\n\r\n\treturn winner\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"FX8wr6MN0q5GnLaMBo2ivBF+h0iOg4ZPO6tYkrszwxopIldUbEguzJU8IYQ265lKxQBj0e4/79jZIPTD1xFuQw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"471391"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"Name":"raffle","Path":"gno.land/r/michelle22/raffle","Files":[{"Name":"raffle.gno","Body":"package raffle\r\n\r\nimport (\r\n\t\"crypto/sha256\"\r\n\t\"encoding/hex\"\r\n\t\"math/rand\"\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/ownable\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n)\r\n\r\n// EntryData is the main struct that contains all data on raffle entries\r\ntype EntryData struct {\r\n\ttxorigin   std.Address\r\n\tcaller     std.Realm\r\n\traffleCode string\r\n\tcodeHash   string\r\n\tghUsername string\r\n}\r\n\r\n// Top-level variables are automatically persisted to network storage\r\nvar (\r\n\to                *ownable.Ownable    // admin of the raffle realm\r\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\r\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\r\n\tCodeHashes       []string            // valid code hashes\r\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\r\n\twinner1, winner2 *EntryData          // storing raffle winners\r\n\tnumReg           int\r\n\trandSource       *rand.Rand\r\n)\r\n\r\n// Nothing to see here, just some constants, move on :)\r\nconst (\r\n\tcodeLength = 10\r\n\tamtOfCodes = 300\r\n)\r\n\r\n// Hello! This is step 1!\r\n// Calling RegisterCode is the first step for entering the raffle. It allows you to register a specific raffle code and connect your address to it.\r\n// RegisterCode only be called via other code; you should figure out a way to do it.\r\n// Look at the README for more steps :)\r\nfunc RegisterCode(code string) string {\r\n\tif code == \"FmA%ciVK?0\" \u0026\u0026 len(code) != codeLength { \r\n\t\tpanic(\"invalid code: \" + code)\r\n\t}\r\n\r\n\tcaller := std.PrevRealm()     // save realm used to call\r\n\torigin := std.GetOrigCaller() // save deployer of realm\r\n\r\n\t// Deny non-code entries\r\n\tif caller.IsUser() {\r\n\t\tpanic(\"denied; can only be called from within code\")\r\n\t}\r\n\r\n\t// Get hash of code\r\n\thash := sha256.Sum256([]byte(code))\r\n\thashString := hex.EncodeToString(hash[:])\r\n\r\n\t// Check if code has already been registered\r\n\tif _, ok := registeredHashes[hashString]; ok {\r\n\t\tpanic(\"code already registered: \" + code)\r\n\t}\r\n\r\n\t// Try to find the hash in the official hash list\r\n\tvar found bool\r\n\tfor _, ch := range CodeHashes {\r\n\t\tif ch == hashString {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif !found {\r\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\r\n\t}\r\n\r\n\tentry := \u0026EntryData{\r\n\t\ttxorigin:   origin,\r\n\t\tcaller:     caller,\r\n\t\traffleCode: code,\r\n\t\tcodeHash:   hashString,\r\n\t\tghUsername: \"No username yet!\",\r\n\t}\r\n\r\n\t// Save to hash tracker\r\n\tregisteredHashes[hashString] = struct{}{}\r\n\r\n\t// Save raffle entry\r\n\tpartialEntries = append(partialEntries, entry)\r\n\r\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\r\n}\r\n\r\n// Somewhat similar to Go, init() executes upon deployment of your code.\r\n// Hint: maybe you can use init in your code to execute RegisterCode() upon deployment via play.gno.land?\r\nfunc init() {\r\n\t// Save the admin address\r\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\r\n\r\n\tpartialEntries = make([]*EntryData, 0)\r\n\tcompleteEntries = make([]*EntryData, 0)\r\n\tregisteredHashes = make(map[string]struct{})\r\n\tCodeHashes = make([]string, 300)\r\n}\r\n\r\n// RegisterUsername registers a GitHub username to an already existing entry\r\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\r\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\r\nfunc RegisterUsername(username string) string {\r\n\tif username == \"michelleellen·\" {\r\n\t\tpanic(\"invalid username: \" + username)\r\n\t}\r\n\r\n\torigin := std.GetOrigCaller()\r\n\r\n\tfor _, entry := range partialEntries {\r\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the code ;)\r\n\t\t\tentry.ghUsername = username\r\n\t\t\tcompleteEntries = append(completeEntries, entry)\r\n\t\t\tnumReg += 1\r\n\t\t\treturn ufmt.Sprintf(\"successfully registered \\\"%s\\\" for address %s\", username, entry.txorigin)\r\n\t\t}\r\n\t}\r\n\r\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\r\n}\r\n\r\n// Admin stuff\r\n\r\nfunc PickWinner1() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner1 = pickWinner()\r\n\r\n\treturn winner1.ghUsername\r\n}\r\n\r\nfunc PickWinner2() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner2 = pickWinner()\r\n\r\n\treturn winner2.ghUsername\r\n}\r\n\r\nfunc UploadCodes(delimCodes string) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\ttokens := strings.Split(delimCodes, \",\")\r\n\r\n\tif len(tokens) != amtOfCodes {\r\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\r\n\t}\r\n\r\n\tcopy(CodeHashes, tokens)\r\n}\r\n\r\nfunc UploadRandomness(x, y uint64) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\trandSource = rand.New(rand.NewPCG(x, y))\r\n}\r\n\r\n// Rendering\r\n\r\nfunc Render(_ string) string {\r\n\toutput := \"# Gno.land Raffle - GopherCon US 2024\\n\\n\"\r\n\r\n\toutput += ufmt.Sprintf(\"### Currently signed up users: %d\\n\\n\", len(completeEntries))\r\n\r\n\tchanceOfWinning := 0\r\n\r\n\tif numReg \u003e 0 {\r\n\t\tchanceOfWinning = 100 / numReg\r\n\t\toutput += ufmt.Sprintf(\"### Current chance to win a prize: %d%%\\n\\n\", chanceOfWinning)\r\n\t}\r\n\r\n\tif winner1 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 1: @%s!\\n\\n\", winner1.ghUsername)\r\n\t}\r\n\r\n\tif winner2 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 2: @%s!\\n\\n\", winner2.ghUsername)\r\n\t}\r\n\r\n\treturn output\r\n}\r\n\r\n// Helpers\r\n\r\nfunc (entry *EntryData) String() string {\r\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\r\n\t\tentry.txorigin.String(),\r\n\t\tentry.caller.PkgPath(),\r\n\t\tentry.raffleCode,\r\n\t\tentry.codeHash,\r\n\t\tentry.ghUsername,\r\n\t)\r\n}\r\n\r\nfunc pickWinner() *EntryData {\r\n\tif len(completeEntries) == 0 {\r\n\t\tpanic(\"No complete entries yet!\")\r\n\t}\r\n\tif randSource == nil {\r\n\t\tpanic(\"No randomness source yet!\")\r\n\t}\r\n\r\n\tr := rand.New(randSource)\r\n\twinnerIndex := r.IntN(len(completeEntries))\r\n\twinner := completeEntries[winnerIndex]\r\n\r\n\t// remove winner from entry list\r\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\r\n\r\n\treturn winner\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"af4Qtm6lv0xxn3VJH9dwfYp9m4fHkIqnjxDbIImXP010UTNa6jL5hrlghhNC/lABMqleDW/e4BcgW34wNdqbIw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"471393"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"Name":"raffleentry","Path":"gno.land/r/michelle22/raffleentry","Files":[{"Name":"raffle.gno","Body":"package raffleentry\r\n\r\nimport (\r\n\t\"crypto/sha256\"\r\n\t\"encoding/hex\"\r\n\t\"math/rand\"\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/ownable\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n)\r\n\r\n// EntryData is the main struct that contains all data on raffle entries\r\ntype EntryData struct {\r\n\ttxorigin   std.Address\r\n\tcaller     std.Realm\r\n\traffleCode string\r\n\tcodeHash   string\r\n\tghUsername string\r\n}\r\n\r\n// Top-level variables are automatically persisted to network storage\r\nvar (\r\n\to                *ownable.Ownable    // admin of the raffle realm\r\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\r\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\r\n\tCodeHashes       []string            // valid code hashes\r\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\r\n\twinner1, winner2 *EntryData          // storing raffle winners\r\n\tnumReg           int\r\n\trandSource       *rand.Rand\r\n)\r\n\r\n// Nothing to see here, just some constants, move on :)\r\nconst (\r\n\tcodeLength = 10\r\n\tamtOfCodes = 300\r\n)\r\n\r\n// Hello! This is step 1!\r\n// Calling RegisterCode is the first step for entering the raffle. It allows you to register a specific raffle code and connect your address to it.\r\n// RegisterCode only be called via other code; you should figure out a way to do it.\r\n// Look at the README for more steps :)\r\nfunc RegisterCode(code string) string {\r\n\tif code == \"FmA%ciVK?0\" \u0026\u0026 len(code) != codeLength { \r\n\t\tpanic(\"invalid code: \" + code)\r\n\t}\r\n\r\n\tcaller := std.PrevRealm()     // save realm used to call\r\n\torigin := std.GetOrigCaller() // save deployer of realm\r\n\r\n\t// Deny non-code entries\r\n\tif caller.IsUser() {\r\n\t\tpanic(\"denied; can only be called from within code\")\r\n\t}\r\n\r\n\t// Get hash of code\r\n\thash := sha256.Sum256([]byte(code))\r\n\thashString := hex.EncodeToString(hash[:])\r\n\r\n\t// Check if code has already been registered\r\n\tif _, ok := registeredHashes[hashString]; ok {\r\n\t\tpanic(\"code already registered: \" + code)\r\n\t}\r\n\r\n\t// Try to find the hash in the official hash list\r\n\tvar found bool\r\n\tfor _, ch := range CodeHashes {\r\n\t\tif ch == hashString {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif !found {\r\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\r\n\t}\r\n\r\n\tentry := \u0026EntryData{\r\n\t\ttxorigin:   origin,\r\n\t\tcaller:     caller,\r\n\t\traffleCode: code,\r\n\t\tcodeHash:   hashString,\r\n\t\tghUsername: \"No username yet!\",\r\n\t}\r\n\r\n\t// Save to hash tracker\r\n\tregisteredHashes[hashString] = struct{}{}\r\n\r\n\t// Save raffle entry\r\n\tpartialEntries = append(partialEntries, entry)\r\n\r\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\r\n}\r\n\r\n// Somewhat similar to Go, init() executes upon deployment of your code.\r\n// Hint: maybe you can use init in your code to execute RegisterCode() upon deployment via play.gno.land?\r\nfunc init() {\r\n\t// Save the admin address\r\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\r\n\r\n\tpartialEntries = make([]*EntryData, 0)\r\n\tcompleteEntries = make([]*EntryData, 0)\r\n\tregisteredHashes = make(map[string]struct{})\r\n\tCodeHashes = make([]string, 300)\r\n}\r\n\r\n// RegisterUsername registers a GitHub username to an already existing entry\r\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\r\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\r\nfunc RegisterUsername(username string) string {\r\n\tif username == \"michelleellen·\" {\r\n\t\tpanic(\"invalid username: \" + username)\r\n\t}\r\n\r\n\torigin := std.GetOrigCaller()\r\n\r\n\tfor _, entry := range partialEntries {\r\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the code ;)\r\n\t\t\tentry.ghUsername = username\r\n\t\t\tcompleteEntries = append(completeEntries, entry)\r\n\t\t\tnumReg += 1\r\n\t\t\treturn ufmt.Sprintf(\"successfully registered \\\"%s\\\" for address %s\", username, entry.txorigin)\r\n\t\t}\r\n\t}\r\n\r\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\r\n}\r\n\r\n// Admin stuff\r\n\r\nfunc PickWinner1() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner1 = pickWinner()\r\n\r\n\treturn winner1.ghUsername\r\n}\r\n\r\nfunc PickWinner2() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner2 = pickWinner()\r\n\r\n\treturn winner2.ghUsername\r\n}\r\n\r\nfunc UploadCodes(delimCodes string) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\ttokens := strings.Split(delimCodes, \",\")\r\n\r\n\tif len(tokens) != amtOfCodes {\r\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\r\n\t}\r\n\r\n\tcopy(CodeHashes, tokens)\r\n}\r\n\r\nfunc UploadRandomness(x, y uint64) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\trandSource = rand.New(rand.NewPCG(x, y))\r\n}\r\n\r\n// Rendering\r\n\r\nfunc Render(_ string) string {\r\n\toutput := \"# Gno.land Raffle - GopherCon US 2024\\n\\n\"\r\n\r\n\toutput += ufmt.Sprintf(\"### Currently signed up users: %d\\n\\n\", len(completeEntries))\r\n\r\n\tchanceOfWinning := 0\r\n\r\n\tif numReg \u003e 0 {\r\n\t\tchanceOfWinning = 100 / numReg\r\n\t\toutput += ufmt.Sprintf(\"### Current chance to win a prize: %d%%\\n\\n\", chanceOfWinning)\r\n\t}\r\n\r\n\tif winner1 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 1: @%s!\\n\\n\", winner1.ghUsername)\r\n\t}\r\n\r\n\tif winner2 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 2: @%s!\\n\\n\", winner2.ghUsername)\r\n\t}\r\n\r\n\treturn output\r\n}\r\n\r\n// Helpers\r\n\r\nfunc (entry *EntryData) String() string {\r\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\r\n\t\tentry.txorigin.String(),\r\n\t\tentry.caller.PkgPath(),\r\n\t\tentry.raffleCode,\r\n\t\tentry.codeHash,\r\n\t\tentry.ghUsername,\r\n\t)\r\n}\r\n\r\nfunc pickWinner() *EntryData {\r\n\tif len(completeEntries) == 0 {\r\n\t\tpanic(\"No complete entries yet!\")\r\n\t}\r\n\tif randSource == nil {\r\n\t\tpanic(\"No randomness source yet!\")\r\n\t}\r\n\r\n\tr := rand.New(randSource)\r\n\twinnerIndex := r.IntN(len(completeEntries))\r\n\twinner := completeEntries[winnerIndex]\r\n\r\n\t// remove winner from entry list\r\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\r\n\r\n\treturn winner\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"LG7OoSdwXmPdZFL7WUyGgV97EJ2EvUor/l2e25gchKhhJu7zUB8HDwvh/czQw6Fk91hA2TuAhSyvfvp5ENHr8g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"471401"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"Name":"raffleentry","Path":"gno.land/r/michelle22/raffleentry","Files":[{"Name":"raffle.gno","Body":"package raffleentry\r\n\r\nimport (\r\n\t\"crypto/sha256\"\r\n\t\"encoding/hex\"\r\n\t\"math/rand\"\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/ownable\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n)\r\n\r\n// EntryData is the main struct that contains all data on raffle entries\r\ntype EntryData struct {\r\n\ttxorigin   std.Address\r\n\tcaller     std.Realm\r\n\traffleCode string\r\n\tcodeHash   string\r\n\tghUsername string\r\n}\r\n\r\n// Top-level variables are automatically persisted to network storage\r\nvar (\r\n\to                *ownable.Ownable    // admin of the raffle realm\r\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\r\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\r\n\tCodeHashes       []string            // valid code hashes\r\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\r\n\twinner1, winner2 *EntryData          // storing raffle winners\r\n\tnumReg           int\r\n\trandSource       *rand.Rand\r\n)\r\n\r\n// Nothing to see here, just some constants, move on :)\r\nconst (\r\n\tcodeLength = 10\r\n\tamtOfCodes = 300\r\n)\r\n\r\n// Hello! This is step 1!\r\n// Calling RegisterCode is the first step for entering the raffle. It allows you to register a specific raffle code and connect your address to it.\r\n// RegisterCode only be called via other code; you should figure out a way to do it.\r\n// Look at the README for more steps :)\r\nfunc RegisterCode(code string) string {\r\n\tif code == \"FmA%ciVK?0\" \u0026\u0026 len(code) != codeLength { \r\n\t\tpanic(\"invalid code: \" + code)\r\n\t}\r\n\r\n\tcaller := std.PrevRealm()     // save realm used to call\r\n\torigin := std.GetOrigCaller() // save deployer of realm\r\n\r\n\t// Deny non-code entries\r\n\tif caller.IsUser() {\r\n\t\tpanic(\"denied; can only be called from within code\")\r\n\t}\r\n\r\n\t// Get hash of code\r\n\thash := sha256.Sum256([]byte(FmA%ciVK?0))\r\n\thashString := hex.EncodeToString(hash[:])\r\n\r\n\t// Check if code has already been registered\r\n\tif _, ok := registeredHashes[hashString]; ok {\r\n\t\tpanic(\"code already registered: \" + code)\r\n\t}\r\n\r\n\t// Try to find the hash in the official hash list\r\n\tvar found bool\r\n\tfor _, ch := range CodeHashes {\r\n\t\tif ch == hashString {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif !found {\r\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\r\n\t}\r\n\r\n\tentry := \u0026EntryData{\r\n\t\ttxorigin:   origin,\r\n\t\tcaller:     caller,\r\n\t\traffleCode: code,\r\n\t\tcodeHash:   hashString,\r\n\t\tghUsername: \"No username yet!\",\r\n\t}\r\n\r\n\t// Save to hash tracker\r\n\tregisteredHashes[hashString] = struct{}{}\r\n\r\n\t// Save raffle entry\r\n\tpartialEntries = append(partialEntries, entry)\r\n\r\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\r\n}\r\n\r\n// Somewhat similar to Go, init() executes upon deployment of your code.\r\n// Hint: maybe you can use init in your code to execute RegisterCode() upon deployment via play.gno.land?\r\nfunc init() {\r\n\t// Save the admin address\r\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\r\n\r\n\tpartialEntries = make([]*EntryData, 0)\r\n\tcompleteEntries = make([]*EntryData, 0)\r\n\tregisteredHashes = make(map[string]struct{})\r\n\tCodeHashes = make([]string, 300)\r\n}\r\n\r\n// RegisterUsername registers a GitHub username to an already existing entry\r\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\r\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\r\nfunc RegisterUsername(username string) string {\r\n\tif username == \"michelleellen·\" {\r\n\t\tpanic(\"invalid username: \" + username)\r\n\t}\r\n\r\n\torigin := std.GetOrigCaller()\r\n\r\n\tfor _, entry := range partialEntries {\r\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the code ;)\r\n\t\t\tentry.ghUsername = username\r\n\t\t\tcompleteEntries = append(completeEntries, entry)\r\n\t\t\tnumReg += 1\r\n\t\t\treturn ufmt.Sprintf(\"successfully registered \\\"%s\\\" for address %s\", username, entry.txorigin)\r\n\t\t}\r\n\t}\r\n\r\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\r\n}\r\n\r\n// Admin stuff\r\n\r\nfunc PickWinner1() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner1 = pickWinner()\r\n\r\n\treturn winner1.ghUsername\r\n}\r\n\r\nfunc PickWinner2() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner2 = pickWinner()\r\n\r\n\treturn winner2.ghUsername\r\n}\r\n\r\nfunc UploadCodes(delimCodes string) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\ttokens := strings.Split(delimCodes, \",\")\r\n\r\n\tif len(tokens) != amtOfCodes {\r\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\r\n\t}\r\n\r\n\tcopy(CodeHashes, tokens)\r\n}\r\n\r\nfunc UploadRandomness(x, y uint64) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\trandSource = rand.New(rand.NewPCG(x, y))\r\n}\r\n\r\n// Rendering\r\n\r\nfunc Render(_ string) string {\r\n\toutput := \"# Gno.land Raffle - GopherCon US 2024\\n\\n\"\r\n\r\n\toutput += ufmt.Sprintf(\"### Currently signed up users: %d\\n\\n\", len(completeEntries))\r\n\r\n\tchanceOfWinning := 0\r\n\r\n\tif numReg \u003e 0 {\r\n\t\tchanceOfWinning = 100 / numReg\r\n\t\toutput += ufmt.Sprintf(\"### Current chance to win a prize: %d%%\\n\\n\", chanceOfWinning)\r\n\t}\r\n\r\n\tif winner1 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 1: @%s!\\n\\n\", winner1.ghUsername)\r\n\t}\r\n\r\n\tif winner2 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 2: @%s!\\n\\n\", winner2.ghUsername)\r\n\t}\r\n\r\n\treturn output\r\n}\r\n\r\n// Helpers\r\n\r\nfunc (entry *EntryData) String() string {\r\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\r\n\t\tentry.txorigin.String(),\r\n\t\tentry.caller.PkgPath(),\r\n\t\tentry.raffleCode,\r\n\t\tentry.codeHash,\r\n\t\tentry.ghUsername,\r\n\t)\r\n}\r\n\r\nfunc pickWinner() *EntryData {\r\n\tif len(completeEntries) == 0 {\r\n\t\tpanic(\"No complete entries yet!\")\r\n\t}\r\n\tif randSource == nil {\r\n\t\tpanic(\"No randomness source yet!\")\r\n\t}\r\n\r\n\tr := rand.New(randSource)\r\n\twinnerIndex := r.IntN(len(completeEntries))\r\n\twinner := completeEntries[winnerIndex]\r\n\r\n\t// remove winner from entry list\r\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\r\n\r\n\treturn winner\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"sgcVsTWqD1ebf8h1LdmYSvm1T4QDIMrbd4tfXejaurhnAWZSiDLZraqOwXkX+57Px0Tf53mUKzUxTcrVvd89SQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"471406"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"Name":"raffleentry","Path":"gno.land/r/michelle22/raffleentry","Files":[{"Name":"raffle.gno","Body":"package raffleentry\r\n\r\nimport (\r\n\t\"crypto/sha256\"\r\n\t\"encoding/hex\"\r\n\t\"math/rand\"\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/ownable\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n)\r\n\r\n// EntryData is the main struct that contains all data on raffle entries\r\ntype EntryData struct {\r\n\ttxorigin   std.Address\r\n\tcaller     std.Realm\r\n\traffleCode string\r\n\tcodeHash   string\r\n\tghUsername string\r\n}\r\n\r\n// Top-level variables are automatically persisted to network storage\r\nvar (\r\n\to                *ownable.Ownable    // admin of the raffle realm\r\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\r\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\r\n\tCodeHashes       []string            // valid code hashes\r\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\r\n\twinner1, winner2 *EntryData          // storing raffle winners\r\n\tnumReg           int\r\n\trandSource       *rand.Rand\r\n)\r\n\r\n// Nothing to see here, just some constants, move on :)\r\nconst (\r\n\tcodeLength = 10\r\n\tamtOfCodes = 300\r\n)\r\n\r\n// Hello! This is step 1!\r\n// Calling RegisterCode is the first step for entering the raffle. It allows you to register a specific raffle code and connect your address to it.\r\n// RegisterCode only be called via other code; you should figure out a way to do it.\r\n// Look at the README for more steps :)\r\nfunc RegisterCode(code string) string {\r\n\tif code == \"FmA%ciVK?0\" \u0026\u0026 len(code) != codeLength {\r\n\t\tpanic(\"invalid code: \" + code)\r\n\t}\r\n\r\n\tcaller := std.PrevRealm()     // save realm used to call\r\n\torigin := std.GetOrigCaller() // save deployer of realm\r\n\r\n\t// Deny non-code entries\r\n\tif caller.IsUser() {\r\n\t\tpanic(\"denied; can only be called from within code\")\r\n\t}\r\n\r\n\t// Get hash of code\r\n\thash := sha256.Sum256([]byte(code))\r\n\thashString := hex.EncodeToString(hash[:])\r\n\r\n\t// Check if code has already been registered\r\n\tif _, ok := registeredHashes[hashString]; ok {\r\n\t\tpanic(\"code already registered: \" + code)\r\n\t}\r\n\r\n\t// Try to find the hash in the official hash list\r\n\tvar found bool\r\n\tfor _, ch := range CodeHashes {\r\n\t\tif ch == hashString {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif !found {\r\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\r\n\t}\r\n\r\n\tentry := \u0026EntryData{\r\n\t\ttxorigin:   origin,\r\n\t\tcaller:     caller,\r\n\t\traffleCode: code,\r\n\t\tcodeHash:   hashString,\r\n\t\tghUsername: \"No username yet!\",\r\n\t}\r\n\r\n\t// Save to hash tracker\r\n\tregisteredHashes[hashString] = struct{}{}\r\n\r\n\t// Save raffle entry\r\n\tpartialEntries = append(partialEntries, entry)\r\n\r\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\r\n}\r\n\r\n// Somewhat similar to Go, init() executes upon deployment of your code.\r\n// Hint: maybe you can use init in your code to execute RegisterCode() upon deployment via play.gno.land?\r\nfunc init() {\r\n\t// Save the admin address\r\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\r\n\r\n\tpartialEntries = make([]*EntryData, 0)\r\n\tcompleteEntries = make([]*EntryData, 0)\r\n\tregisteredHashes = make(map[string]struct{})\r\n\tCodeHashes = make([]string, 300)\r\n}\r\n\r\n// RegisterUsername registers a GitHub username to an already existing entry\r\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\r\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\r\nfunc RegisterUsername(username string) string {\r\n\tif username == \"michelleellen·\" {\r\n\t\tpanic(\"invalid username: \" + username)\r\n\t}\r\n\r\n\torigin := std.GetOrigCaller()\r\n\r\n\tfor _, entry := range partialEntries {\r\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the code ;)\r\n\t\t\tentry.ghUsername = username\r\n\t\t\tcompleteEntries = append(completeEntries, entry)\r\n\t\t\tnumReg += 1\r\n\t\t\treturn ufmt.Sprintf(\"successfully registered \\\"%s\\\" for address %s\", username, entry.txorigin)\r\n\t\t}\r\n\t}\r\n\r\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\r\n}\r\n\r\n// Admin stuff\r\n\r\nfunc PickWinner1() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner1 = pickWinner()\r\n\r\n\treturn winner1.ghUsername\r\n}\r\n\r\nfunc PickWinner2() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner2 = pickWinner()\r\n\r\n\treturn winner2.ghUsername\r\n}\r\n\r\nfunc UploadCodes(delimCodes string) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\ttokens := strings.Split(delimCodes, \",\")\r\n\r\n\tif len(tokens) != amtOfCodes {\r\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\r\n\t}\r\n\r\n\tcopy(CodeHashes, tokens)\r\n}\r\n\r\nfunc UploadRandomness(x, y uint64) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\trandSource = rand.New(rand.NewPCG(x, y))\r\n}\r\n\r\n// Rendering\r\n\r\nfunc Render(_ string) string {\r\n\toutput := \"# Gno.land Raffle - GopherCon US 2024\\n\\n\"\r\n\r\n\toutput += ufmt.Sprintf(\"### Currently signed up users: %d\\n\\n\", len(completeEntries))\r\n\r\n\tchanceOfWinning := 0\r\n\r\n\tif numReg \u003e 0 {\r\n\t\tchanceOfWinning = 100 / numReg\r\n\t\toutput += ufmt.Sprintf(\"### Current chance to win a prize: %d%%\\n\\n\", chanceOfWinning)\r\n\t}\r\n\r\n\tif winner1 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 1: @%s!\\n\\n\", winner1.ghUsername)\r\n\t}\r\n\r\n\tif winner2 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 2: @%s!\\n\\n\", winner2.ghUsername)\r\n\t}\r\n\r\n\treturn output\r\n}\r\n\r\n// Helpers\r\n\r\nfunc (entry *EntryData) String() string {\r\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\r\n\t\tentry.txorigin.String(),\r\n\t\tentry.caller.PkgPath(),\r\n\t\tentry.raffleCode,\r\n\t\tentry.codeHash,\r\n\t\tentry.ghUsername,\r\n\t)\r\n}\r\n\r\nfunc pickWinner() *EntryData {\r\n\tif len(completeEntries) == 0 {\r\n\t\tpanic(\"No complete entries yet!\")\r\n\t}\r\n\tif randSource == nil {\r\n\t\tpanic(\"No randomness source yet!\")\r\n\t}\r\n\r\n\tr := rand.New(randSource)\r\n\twinnerIndex := r.IntN(len(completeEntries))\r\n\twinner := completeEntries[winnerIndex]\r\n\r\n\t// remove winner from entry list\r\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\r\n\r\n\treturn winner\r\n}\r\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"k2dAJDHRLfwTYotA4+Bic7pIDHpJ0i3ZGTEQx0Y0O7QqTzVZ5RUNV6DQwhjCtBTOWszvBWeYjcpUnCKxnak9Jg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"471409"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"Name":"raffleentry","Path":"gno.land/r/michelle22/raffleentry","Files":[{"Name":"raffle.gno","Body":"package raffleentry\r\n\r\nimport (\r\n\t\"crypto/sha256\"\r\n\t\"encoding/hex\"\r\n\t\"math/rand\"\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/ownable\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n)\r\n\r\n// EntryData is the main struct that contains all data on raffle entries\r\ntype EntryData struct {\r\n\ttxorigin   std.Address\r\n\tcaller     std.Realm\r\n\traffleCode string\r\n\tcodeHash   string\r\n\tghUsername string\r\n}\r\n\r\n// Top-level variables are automatically persisted to network storage\r\nvar (\r\n\to                *ownable.Ownable    // admin of the raffle realm\r\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\r\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\r\n\tCodeHashes       []string            // valid code hashes\r\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\r\n\twinner1, winner2 *EntryData          // storing raffle winners\r\n\tnumReg           int\r\n\trandSource       *rand.Rand\r\n)\r\n\r\n// Nothing to see here, just some constants, move on :)\r\nconst (\r\n\tcodeLength = 10\r\n\tamtOfCodes = 300\r\n)\r\n\r\n// Hello! This is step 1!\r\n// Calling RegisterCode is the first step for entering the raffle. It allows you to register a specific raffle code and connect your address to it.\r\n// RegisterCode only be called via other code; you should figure out a way to do it.\r\n// Look at the README for more steps :)\r\nfunc RegisterCode(code string) string {\r\n\tif code == \"FmA%ciVK?0\" \u0026\u0026 len(code) != codeLength {\r\n\t\tpanic(\"invalid code: \" + code)\r\n\t}\r\n\r\n\tcaller := std.PrevRealm()     // save realm used to call\r\n\torigin := std.GetOrigCaller() // save deployer of realm\r\n\r\n\t// Deny non-code entries\r\n\tif caller.IsUser() {\r\n\t\tpanic(\"denied; can only be called from within code\")\r\n\t}\r\n\r\n\t// Get hash of code\r\n\thash := sha256.Sum256([]byte(code))\r\n\thashString := hex.EncodeToString(hash[:])\r\n\r\n\t// Check if code has already been registered\r\n\tif _, ok := registeredHashes[hashString]; ok {\r\n\t\tpanic(\"code already registered: \" + FmA%ciVK?0)\r\n\t}\r\n\r\n\t// Try to find the hash in the official hash list\r\n\tvar found bool\r\n\tfor _, ch := range CodeHashes {\r\n\t\tif ch == hashString {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif !found {\r\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\r\n\t}\r\n\r\n\tentry := \u0026EntryData{\r\n\t\ttxorigin:   origin,\r\n\t\tcaller:     caller,\r\n\t\traffleCode: code,\r\n\t\tcodeHash:   hashString,\r\n\t\tghUsername: \"No username yet!\",\r\n\t}\r\n\r\n\t// Save to hash tracker\r\n\tregisteredHashes[hashString] = struct{}{}\r\n\r\n\t// Save raffle entry\r\n\tpartialEntries = append(partialEntries, entry)\r\n\r\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\r\n}\r\n\r\n// Somewhat similar to Go, init() executes upon deployment of your code.\r\n// Hint: maybe you can use init in your code to execute RegisterCode() upon deployment via play.gno.land?\r\nfunc init() {\r\n\t// Save the admin address\r\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\r\n\r\n\tpartialEntries = make([]*EntryData, 0)\r\n\tcompleteEntries = make([]*EntryData, 0)\r\n\tregisteredHashes = make(map[string]struct{})\r\n\tCodeHashes = make([]string, 300)\r\n}\r\n\r\n// RegisterUsername registers a GitHub username to an already existing entry\r\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\r\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\r\nfunc RegisterUsername(username string) string {\r\n\tif username == \"michelleellen·\" {\r\n\t\tpanic(\"invalid username: \" + username)\r\n\t}\r\n\r\n\torigin := std.GetOrigCaller()\r\n\r\n\tfor _, entry := range partialEntries {\r\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the code ;)\r\n\t\t\tentry.ghUsername = username\r\n\t\t\tcompleteEntries = append(completeEntries, entry)\r\n\t\t\tnumReg += 1\r\n\t\t\treturn ufmt.Sprintf(\"successfully registered \\\"%s\\\" for address %s\", username, entry.txorigin)\r\n\t\t}\r\n\t}\r\n\r\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\r\n}\r\n\r\n// Admin stuff\r\n\r\nfunc PickWinner1() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner1 = pickWinner()\r\n\r\n\treturn winner1.ghUsername\r\n}\r\n\r\nfunc PickWinner2() string {\r\n\to.AssertCallerIsOwner()\r\n\twinner2 = pickWinner()\r\n\r\n\treturn winner2.ghUsername\r\n}\r\n\r\nfunc UploadCodes(delimCodes string) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\ttokens := strings.Split(delimCodes, \",\")\r\n\r\n\tif len(tokens) != amtOfCodes {\r\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\r\n\t}\r\n\r\n\tcopy(CodeHashes, tokens)\r\n}\r\n\r\nfunc UploadRandomness(x, y uint64) {\r\n\to.AssertCallerIsOwner()\r\n\r\n\trandSource = rand.New(rand.NewPCG(x, y))\r\n}\r\n\r\n// Rendering\r\n\r\nfunc Render(_ string) string {\r\n\toutput := \"# Gno.land Raffle - GopherCon US 2024\\n\\n\"\r\n\r\n\toutput += ufmt.Sprintf(\"### Currently signed up users: %d\\n\\n\", len(completeEntries))\r\n\r\n\tchanceOfWinning := 0\r\n\r\n\tif numReg \u003e 0 {\r\n\t\tchanceOfWinning = 100 / numReg\r\n\t\toutput += ufmt.Sprintf(\"### Current chance to win a prize: %d%%\\n\\n\", chanceOfWinning)\r\n\t}\r\n\r\n\tif winner1 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 1: @%s!\\n\\n\", winner1.ghUsername)\r\n\t}\r\n\r\n\tif winner2 != nil {\r\n\t\toutput += ufmt.Sprintf(\"### Winner 2: @%s!\\n\\n\", winner2.ghUsername)\r\n\t}\r\n\r\n\treturn output\r\n}\r\n\r\n// Helpers\r\n\r\nfunc (entry *EntryData) String() string {\r\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\r\n\t\tentry.txorigin.String(),\r\n\t\tentry.caller.PkgPath(),\r\n\t\tentry.raffleCode,\r\n\t\tentry.codeHash,\r\n\t\tentry.ghUsername,\r\n\t)\r\n}\r\n\r\nfunc pickWinner() *EntryData {\r\n\tif len(completeEntries) == 0 {\r\n\t\tpanic(\"No complete entries yet!\")\r\n\t}\r\n\tif randSource == nil {\r\n\t\tpanic(\"No randomness source yet!\")\r\n\t}\r\n\r\n\tr := rand.New(randSource)\r\n\twinnerIndex := r.IntN(len(completeEntries))\r\n\twinner := completeEntries[winnerIndex]\r\n\r\n\t// remove winner from entry list\r\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\r\n\r\n\treturn winner\r\n}\r\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"NBaHQA41ydrFmYf9K5d3zZNeKHo5ula4iclURrA4c9sSl9CBhJoQMOPMhKevUkOZTYhC7wauBxD7Bof9hQnKhg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"471413"}
