{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ffzxha57dh0qgv9ma5v393ur0zexfvp6lsjpae","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g122n67es9vzs0rmharsggfr4sdkd45aysnuzf7m","1"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A09whvkfsR4pCSEYMMt/do4mD9Zf76Dzs9/kOirITiy0"},"signature":"OGFfeH7uWhJl6yJ5qjDlVDY0O1oGC6EXTO5qnKjfZTYwr0+mmlTZsUlDO7zvFasP1Db1Xvo61BzUS1Pdurn0uA=="}],"memo":""},"blockNum":"309901"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"whitelist","Path":"gno.land/p/malek/whitelist","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"6udHiMHoLejhCu/RMlwrGWhS2gnfzT+o6/vUnQOljR1xqJisT5CnCpxyXFwbtYawhc0Y3vDqorlZUG5WMmMwbg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310048"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"whitelist","Path":"gno.land/r/malek/whitelist","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\twhitelist \"gno.land/p/malek/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n\n\treturn id, \"successfully created whitelist!\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t\treturn ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n\treturn \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Add whitelist owner\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"#### Whitelist owner : %s\\n\",\n\t\t\t\tw.GetWhitelistOwner(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"\\nMaximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"K01Xl4J9JqBYilFZpSRd9kcl40a1PJUDbKKIyf5YRnok5g6VhsOqqZwptsIovgm6UD3GylkyTtda9KNMsWpYfA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310054"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"whitelistfactory","Path":"gno.land/r/malek/whitelistfactory","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\twhitelist \"gno.land/p/malek/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n\n\treturn id, \"successfully created whitelist!\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t\treturn ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n\treturn \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Add whitelist owner\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"#### Whitelist owner : %s\\n\",\n\t\t\t\tw.GetWhitelistOwner(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"\\nMaximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"r9d5SXNxy/695ZbiitmDuSZ5iKBkgfQe3Kl/wj1EOEkFczVskIRIN9iV+YpmvnsYWf1Pz2Tv1dVYRfZLGYkrsg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310056"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/malek/whitelistfactory","func":"NewWhitelist","args":["First whitelist","10000","5"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"h4Z9E8eDlxku2zqWb0vrL24yQTFz7tBFK1m3onpodBwgI3D2Xwf6H75tJNTAIHxkZelq+/4VtV7tAf5x3dPu1w=="}],"memo":""},"blockNum":"310150"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/malek/whitelistfactory","func":"NewWhitelist","args":["First whitelist","310555","5"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"p0fq+UguIC503Sc4cGBfOgPlXcLFdmmbilhDKHJ0aUJpcfyM8ElIXA4GHeWVCZxbvsmibD9apaWjRx8S0DSL9g=="}],"memo":""},"blockNum":"310157"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","to_address":"g1tsvsa6x0xhekmp4yhvuh69x5fd7u7ar3cwzj9y","amount":"25000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"r/48etKuzjXP5DOJU62cp9jC16zy4SWke0Y8C3rf7c0mnTUfXrnn4K/Cb/P6wkw5qG3qvq/sl4KsjXrvaTuTRg=="}],"memo":""},"blockNum":"310172"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1tsvsa6x0xhekmp4yhvuh69x5fd7u7ar3cwzj9y","send":"","pkg_path":"gno.land/r/malek/whitelistfactory","func":"NewWhitelist","args":["First whitelist","310555","5"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj0lS9UneSMA2nQszu6Fa/57MuJZvy7p1jkcr8G5JG0t"},"signature":"tt6ONF6zh4/oMAJ+yCtTA6PQ25MruNHf2aFhc5LQNE8vMVFOqVhao6EBM0sMaA7e+MZNimRZX6tHpZUnzeimdw=="}],"memo":""},"blockNum":"310174"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"DIGIX666","Path":"gno.land/r/whitelist/DIGIX666","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"afg40peMwa0bWXcFDUbw+8DdqJ8zAk09T2+iisLXi819LIgIrJcaMyvNaKnSjKfwwqy/xfNH9XgL4GNayZoMmg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310216"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"digix666","Path":"gno.land/p/whitelist/digix666","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"n7i2wsdkNYYYHN6pxw79SE7CjCw74oKa97IG/tg1tX4z3Onnqt8t1AteGXjfhRA4JOwnB/m9xMlZTxCnLsrCOw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310219"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"digix666_test","Path":"gno.land/p/whitelist/digix666_test","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"fLG+I+40+KAGSsah9UIJv1UxLsG3sm4OkJwToyWZmA9aCN8ckE/ifLegFc5jL6HK20712aVuTYzf5GF1H+XqDw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310225"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"whitelist","Path":"gno.land/r/digxi666/whitelist","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"e6hTw9aA6Xff5V7TGp2nfrYvGnw6KCwL+T0dNGngZj0RRIFdEBXjZRN93IfXeZ6FHpa18b0NF0QbOQf5XMQcaA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310228"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"whitlist","Path":"gno.land/r/digix666/whitlist","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\twhitelist \"REPLACE WITH YOUR PACKAGE PATH\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"fzDJMHjJ6NdrSPMtEyDQQSMyCSMjvVA3EfdtCj+R1PhLSV2v0aKd1iLOZPzKZWN4hA7UldGJHqOWSkp6cvQcew=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310237"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"whitelist","Path":"gno.land/r/digix666/whitelist","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/digix666/whitelist\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"aXUJ6csKxteKHLbJpbDq8y8JeLpmJt/k7s71A+OFSbBcjrBkkt7cH3Co7LUtIMjlm1J6iLeafhztYDIXIqtvNg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310247"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"whitelistfactory","Path":"gno.land/r/digix666/whitelistfactory","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/digix666/whitelist\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"W+la5U0aOQA27hhPrXxVeZiFUwnaj1uxmcbyxqM6yHpSEs9KhIThf2MjT5drcIEXhEQa+Z2fFYhgtAi7z2HGJQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310249"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"whitelistfactory","Path":"gno.land/r/digix666/whitelistfactory","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/digxi666/whitelist\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"nkuvk7AZMn42PqxlGc6CpqcB0aEfb4FjJAw85CJVaw0vFrELaT7ryg1bAQHKc5VRuXEvsgEerm2m3kO+veKfaQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310282"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1yc0x2kj67mj564zsjyp27t5zya5eynnrdqkpqv","send":"","pkg_path":"gno.land/r/boom/boom","func":"TotalSupply","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoskAak9V7kkLOloTiqbXGzO9W6/+zCt+M5+uISHBEak"},"signature":"L1euoN9pcy6WcS1SPjOhTp6my+r7zOjyQl7O1WcvdVdl527WC1SQqPXTXlNrATfRAKDt7pzRErDNgn1qadiDXQ=="}],"memo":"Called through gno.studio"},"blockNum":"310405"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1yc0x2kj67mj564zsjyp27t5zya5eynnrdqkpqv","send":"","pkg_path":"gno.land/r/boom/boom","func":"Render","args":["\""]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoskAak9V7kkLOloTiqbXGzO9W6/+zCt+M5+uISHBEak"},"signature":"y+ZwG4JLU3Gt4/+E934iIJLlOlrbU5WGgaXgXEiCUeteVGaiTZGUSzK7JRVNhV0M4w8GrD3K7qcV7yqLdmhLug=="}],"memo":"Called through gno.studio"},"blockNum":"310407"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"ZGRlDf2V8Rb6CG+CLsBfjWowWAjMFmGW3w+Z7Pt5UgsfRkdaQH4+BcL2dmjbVVlZaOfUY02J/wTWAfqcDyW2Cw=="}],"memo":""},"blockNum":"310531"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"6yfKhC9CUlaTROeX5wLl9V//oTD0TiJ1lgZ+HqDX2wdSM+CX2iK6OkH4CX1fpU0K0jftMozytRf3/D3Nsr9bUQ=="}],"memo":""},"blockNum":"310533"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"b6YSODlwOcOJoWIArkDBlS4HY7LlvCDuIcejRAyfs6YBGqgLw/msjupwYMBngIuCOCPDxPYNxB4CKgTjVlfTGQ=="}],"memo":""},"blockNum":"310536"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"mytoken","Path":"gno.land/r/digix666/mytoken","Files":[{"Name":"digixtoken.gno","Body":"package mytoken\n\nimport (\n    \"std\"\n\t\"strings\"\n    \"gno.land/p/demo/ufmt\"\n    \"gno.land/r/demo/users\"\n    pusers \"gno.land/p/demo/users\"\n    \"gno.land/p/demo/grc/grc20\"\n)\n\nvar (\n    mytoken *grc20.AdminToken\n    admin   std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n    // provision the token's name, symbol and number of decimals\n    mytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n    // set the total supply\n    mytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n    return mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner pusers.AddressOrName) uint64 {\n    balance, err := mytoken.BalanceOf(users.Resolve(owner))\n    if err != nil {\n        panic(err)\n    }\n    return balance\n}\n\nfunc Allowance(owner, spender pusers.AddressOrName) uint64 {\n    allowance, err := mytoken.Allowance(users.Resolve(owner), users.Resolve(spender))\n    if err != nil {\n        panic(err)\n    }\n    return allowance\n}\n\nfunc Transfer(to pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.Transfer(caller, users.Resolve(to), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Approve(spender pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.Approve(caller, users.Resolve(spender), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.TransferFrom(caller, users.Resolve(from), users.Resolve(to), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Mint(address pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mytoken.Mint(users.Resolve(address), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(address pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mytoken.Burn(users.Resolve(address), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Render(path string) string {\n    parts := strings.Split(path, \"/\")\n    c := len(parts)\n\n    switch {\n    case path == \"\":\n        return mytoken.RenderHome()\n    case c == 2 \u0026\u0026 parts[0] == \"balance\":\n        owner := pusers.AddressOrName(parts[1])\n        balance, _ := mytoken.BalanceOf(users.Resolve(owner))\n        return ufmt.Sprintf(\"%d\\n\", balance)\n    default:\n        return \"404\\n\"\n    }\n}\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"bXC6Y57pq3kG+5gAfhV2YjPtEGylx6jsMlvPtmFx++Esxl6lqNk+CiAlozEBSHqqVbYBYTzhxSauKXg/ukWAaA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310564"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"mytoken","Path":"gno.land/r/digix666/mytoken","Files":[{"Name":"digixtoken.gno","Body":"package mytoken\n\nimport (\n    \"std\"\n\t\"strings\"\n    \"gno.land/p/demo/ufmt\"\n    \"gno.land/r/demo/users\"\n    \"gno.land/p/demo/users\"\n    \"gno.land/p/demo/grc/grc20\"\n)\n\nvar (\n    mytoken *grc20.AdminToken\n    admin   std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n    // provision the token's name, symbol and number of decimals\n    mytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n    // set the total supply\n    mytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n    return mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner pusers.AddressOrName) uint64 {\n    balance, err := mytoken.BalanceOf(users.Resolve(owner))\n    if err != nil {\n        panic(err)\n    }\n    return balance\n}\n\nfunc Allowance(owner, spender pusers.AddressOrName) uint64 {\n    allowance, err := mytoken.Allowance(users.Resolve(owner), users.Resolve(spender))\n    if err != nil {\n        panic(err)\n    }\n    return allowance\n}\n\nfunc Transfer(to pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.Transfer(caller, users.Resolve(to), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Approve(spender pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.Approve(caller, users.Resolve(spender), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.TransferFrom(caller, users.Resolve(from), users.Resolve(to), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Mint(address pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mytoken.Mint(users.Resolve(address), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(address pusers.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mytoken.Burn(users.Resolve(address), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Render(path string) string {\n    parts := strings.Split(path, \"/\")\n    c := len(parts)\n\n    switch {\n    case path == \"\":\n        return mytoken.RenderHome()\n    case c == 2 \u0026\u0026 parts[0] == \"balance\":\n        owner := pusers.AddressOrName(parts[1])\n        balance, _ := mytoken.BalanceOf(users.Resolve(owner))\n        return ufmt.Sprintf(\"%d\\n\", balance)\n    default:\n        return \"404\\n\"\n    }\n}\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"2CQJcGqb82eoyIj6SQcqU1HppArwFQ26FE29vJkvzpl5bXGc+Fk+ndc2n4/s7ab5Kd8dCFMPT+LNgoFOyDElqw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310566"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1yc0x2kj67mj564zsjyp27t5zya5eynnrdqkpqv","send":"","pkg_path":"gno.land/r/boom/boom","func":"TotalSupply","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoskAak9V7kkLOloTiqbXGzO9W6/+zCt+M5+uISHBEak"},"signature":"TsRhzuKozSbp8IElSpWVUQBZbEOBxAXKVmES2SL60gIm8kzfSHhPy02hmqrNUEkbMdsLOAgQ9WnkkFQ0KIYm8g=="}],"memo":"Called through gno.studio"},"blockNum":"310572"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"mytoken","Path":"gno.land/r/digix666/mytoken","Files":[{"Name":"digixtoken.gno","Body":"package mytoken\n\nimport (\n    \"std\"\n    \"gno.land/p/demo/grc/grc20\"\n    \"strings\"\n    \"gno.land/p/demo/ufmt\"\n    \"gno.land/r/demo/users\"\n)\n\nvar (\n    mytoken *grc20.AdminToken\n    admin   std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n    // provision the token's name, symbol and number of decimals\n    mytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n    // set the total supply\n    mytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n    return mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n    balance, err := mytoken.BalanceOf(users.Resolve(owner))\n    if err != nil {\n        panic(err)\n    }\n    return balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n    allowance, err := mytoken.Allowance(users.Resolve(owner), users.Resolve(spender))\n    if err != nil {\n        panic(err)\n    }\n    return allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.Transfer(caller, users.Resolve(to), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.Approve(caller, users.Resolve(spender), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.TransferFrom(caller, users.Resolve(from), users.Resolve(to), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mytoken.Mint(users.Resolve(address), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mytoken.Burn(users.Resolve(address), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Render(path string) string {\n    parts := strings.Split(path, \"/\")\n    c := len(parts)\n\n    switch {\n    case path == \"\":\n        return mytoken.RenderHome()\n    case c == 2 \u0026\u0026 parts[0] == \"balance\":\n        owner := users.AddressOrName(parts[1])\n        balance, _ := mytoken.BalanceOf(users.Resolve(owner))\n        return ufmt.Sprintf(\"%d\\n\", balance)\n    default:\n        return \"404\\n\"\n    }\n}\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"5QVD0ah2APfkAipDs6hZyvMbUl0fqTGEelMY4sJ3rT9QfUx/gm5A1Y2fGeGhgVQ3l4qPIle84iUl/WiiRQPo4g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310617"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"thox","Path":"gno.land/r/demo/thox","Files":[{"Name":"package.gno","Body":"package thox\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\ttokenbest *grc20.AdminToken\n\tadmin     std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n\ttokenbest = grc20.NewAdminToken(\"Thox\", \"TOHX\", 4)\n\n\ttokenbest.Mint(admin, 1000000*10000)\n}\n\nfunc TotalSupply() uint64 {\n\treturn tokenbest.TotalSupply()\n}\n\nfunc BalanceOf(owner pusers.AddressOrName) uint64 {\n\tbalance, err := tokenbest.BalanceOf(users.Resolve(owner))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender pusers.AddressOrName) uint64 {\n\tallowance, err := tokenbest.Allowance(users.Resolve(owner), users.Resolve(spender))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to pusers.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := tokenbest.Transfer(caller, users.Resolve(to), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender pusers.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := tokenbest.Approve(caller, users.Resolve(spender), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := tokenbest.TransferFrom(caller, users.Resolve(from), users.Resolve(to), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address pusers.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := tokenbest.Mint(users.Resolve(address), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address pusers.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := tokenbest.Burn(users.Resolve(address), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn tokenbest.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := pusers.AddressOrName(parts[1])\n\t\tbalance, _ := tokenbest.BalanceOf(users.Resolve(owner))\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"kO1zQloIOHFPt+dLqm1Z1mKATplga1bU8IPtAPVAoCMVub7ynstoR8W5pyIapkPdp8ALVCK8lDksHeHTQmFuiA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310626"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","package":{"Name":"mytoken","Path":"gno.land/r/digix666/mytoken","Files":[{"Name":"digixtoken.gno","Body":"package mytoken\n\nimport (\n    \"std\"\n    \"gno.land/p/demo/grc/grc20\"\n    \"strings\"\n    \"gno.land/p/demo/ufmt\"\n    \"gno.land/r/demo/users\"\n)\n\nvar (\n    mytoken *grc20.AdminToken\n    admin   std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n    // provision the token's name, symbol and number of decimals\n    mytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n    // set the total supply\n    mytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n    return mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n    balance, err := mytoken.BalanceOf(owner.Resolve())\n    if err != nil {\n        panic(err)\n    }\n    return balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n    allowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n    if err != nil {\n        panic(err)\n    }\n    return allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.Transfer(caller, to.Resolve(), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.Approve(caller, spender.Resolve(), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    err := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mytoken.Mint(address.Resolve(), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mytoken.Burn(address.Resolve(), amount)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Render(path string) string {\n    parts := strings.Split(path, \"/\")\n    c := len(parts)\n\n    switch {\n    case path == \"\":\n        return mytoken.RenderHome()\n    case c == 2 \u0026\u0026 parts[0] == \"balance\":\n        owner := users.AddressOrName(parts[1])\n        balance, _ := mytoken.BalanceOf(owner.Resolve())\n        return ufmt.Sprintf(\"%d\\n\", balance)\n    default:\n        return \"404\\n\"\n    }\n}\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7F3+SG0EvfD9EoMgxL8VSOFIb+XlP7eI0SIbyQYrAmF"},"signature":"D/70cb+WLY3Hit4IGXJXtbzw7Jde/QKCF3xv/teV43RLTU+uElZFXmHJEp/meZ1/VMuvYfLiMz6xOrpPycn6tg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"310628"}
