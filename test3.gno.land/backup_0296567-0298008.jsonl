{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whietlistv1","Path":"gno.land/p/leon/whietlistv1","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"oD+7aAn4XqDP3GhMmM37XsvzrEGdRP/kHYBP9f6hfVcRqtaW7eob0PpjgnIpk1SbMtSkXV6v2ClmfL4tsjCzDA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297414"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist","Path":"gno.land/p/fzth_gnoland/whitelist","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"VDWmGej0X+4bKBKPUBesbOb1GY4lIXdLivJRXQeCdDUuG4Daedsmw6fNgTPfz4RdC9jTRG8VcuY71phb6OlfcQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297496"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist1","Path":"gno.land/p/leon/whitelist1","Files":[{"Name":"whitelist.gno","Body":"package whitelist1\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int            // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024"},{"Name":"whitelist_test.gno","Body":"package whitelist1\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"lrkpLW6Co2R88vsTXbWLSaTkjP7PmSZgAWcP5D2v+/E7MLGGyLsRL65C6yKsVrfQh0vH3xPvC8nsr1jh6MLvLw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297516"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id)), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"qJ8lkIxxrIKK6hxoYRMAQHMU7DR1g3tQgf5V/2g62IdQb+8oL/ae+ZOqd0EjlQXqDWlLrfuBe4mnvu6aK2c8rA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297521"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"axfRvFXKj2LAZ+biTZ8/WpCkCYUylMq3yFsgMHvg/zdv34sajKv1gtLLD7ZioV+qq/d6X2ncNeej9MpjO+/SrQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297523"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory1\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"PovYXR6TTFhmthZP8Az8Hl74OsV8YN5XPudWpLbPBYA9+hKUTDKxe6NCDZHIAj17V/StLpRVt7xMktwHob24cA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297525"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"avl","Path":"gno.land/p/leon/avl","Files":[{"Name":"gno.mod","Body":"module gno.land/p/demo/avl\n"},{"Name":"node.gno","Body":"package avl\n\n//----------------------------------------\n// Node\n\ntype Node struct {\n\tkey       string\n\tvalue     interface{}\n\theight    int8\n\tsize      int\n\tleftNode  *Node\n\trightNode *Node\n}\n\nfunc NewNode(key string, value interface{}) *Node {\n\treturn \u0026Node{\n\t\tkey:    key,\n\t\tvalue:  value,\n\t\theight: 0,\n\t\tsize:   1,\n\t}\n}\n\nfunc (node *Node) Size() int {\n\tif node == nil {\n\t\treturn 0\n\t}\n\treturn node.size\n}\n\nfunc (node *Node) IsLeaf() bool {\n\treturn node.height == 0\n}\n\nfunc (node *Node) Key() string {\n\treturn node.key\n}\n\nfunc (node *Node) Value() interface{} {\n\treturn node.value\n}\n\nfunc (node *Node) _copy() *Node {\n\tif node.height == 0 {\n\t\tpanic(\"Why are you copying a value node?\")\n\t}\n\treturn \u0026Node{\n\t\tkey:       node.key,\n\t\theight:    node.height,\n\t\tsize:      node.size,\n\t\tleftNode:  node.leftNode,\n\t\trightNode: node.rightNode,\n\t}\n}\n\nfunc (node *Node) Has(key string) (has bool) {\n\tif node == nil {\n\t\treturn false\n\t}\n\tif node.key == key {\n\t\treturn true\n\t}\n\tif node.height == 0 {\n\t\treturn false\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\treturn node.getLeftNode().Has(key)\n\t\t} else {\n\t\t\treturn node.getRightNode().Has(key)\n\t\t}\n\t}\n}\n\nfunc (node *Node) Get(key string) (index int, value interface{}, exists bool) {\n\tif node == nil {\n\t\treturn 0, nil, false\n\t}\n\tif node.height == 0 {\n\t\tif node.key == key {\n\t\t\treturn 0, node.value, true\n\t\t} else if node.key \u003c key {\n\t\t\treturn 1, nil, false\n\t\t} else {\n\t\t\treturn 0, nil, false\n\t\t}\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\treturn node.getLeftNode().Get(key)\n\t\t} else {\n\t\t\trightNode := node.getRightNode()\n\t\t\tindex, value, exists = rightNode.Get(key)\n\t\t\tindex += node.size - rightNode.size\n\t\t\treturn index, value, exists\n\t\t}\n\t}\n}\n\nfunc (node *Node) GetByIndex(index int) (key string, value interface{}) {\n\tif node.height == 0 {\n\t\tif index == 0 {\n\t\t\treturn node.key, node.value\n\t\t} else {\n\t\t\tpanic(\"GetByIndex asked for invalid index\")\n\t\t\treturn \"\", nil\n\t\t}\n\t} else {\n\t\t// TODO: could improve this by storing the sizes\n\t\tleftNode := node.getLeftNode()\n\t\tif index \u003c leftNode.size {\n\t\t\treturn leftNode.GetByIndex(index)\n\t\t} else {\n\t\t\treturn node.getRightNode().GetByIndex(index - leftNode.size)\n\t\t}\n\t}\n}\n\n// XXX consider a better way to do this... perhaps split Node from Node.\nfunc (node *Node) Set(key string, value interface{}) (newSelf *Node, updated bool) {\n\tif node == nil {\n\t\treturn NewNode(key, value), false\n\t}\n\tif node.height == 0 {\n\t\tif key \u003c node.key {\n\t\t\treturn \u0026Node{\n\t\t\t\tkey:       node.key,\n\t\t\t\theight:    1,\n\t\t\t\tsize:      2,\n\t\t\t\tleftNode:  NewNode(key, value),\n\t\t\t\trightNode: node,\n\t\t\t}, false\n\t\t} else if key == node.key {\n\t\t\treturn NewNode(key, value), true\n\t\t} else {\n\t\t\treturn \u0026Node{\n\t\t\t\tkey:       key,\n\t\t\t\theight:    1,\n\t\t\t\tsize:      2,\n\t\t\t\tleftNode:  node,\n\t\t\t\trightNode: NewNode(key, value),\n\t\t\t}, false\n\t\t}\n\t} else {\n\t\tnode = node._copy()\n\t\tif key \u003c node.key {\n\t\t\tnode.leftNode, updated = node.getLeftNode().Set(key, value)\n\t\t} else {\n\t\t\tnode.rightNode, updated = node.getRightNode().Set(key, value)\n\t\t}\n\t\tif updated {\n\t\t\treturn node, updated\n\t\t} else {\n\t\t\tnode.calcHeightAndSize()\n\t\t\treturn node.balance(), updated\n\t\t}\n\t}\n}\n\n// newNode: The new node to replace node after remove.\n// newKey: new leftmost leaf key for node after successfully removing 'key' if changed.\n// value: removed value.\nfunc (node *Node) Remove(key string) (\n\tnewNode *Node, newKey string, value interface{}, removed bool,\n) {\n\tif node == nil {\n\t\treturn nil, \"\", nil, false\n\t}\n\tif node.height == 0 {\n\t\tif key == node.key {\n\t\t\treturn nil, \"\", node.value, true\n\t\t} else {\n\t\t\treturn node, \"\", nil, false\n\t\t}\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\tvar newLeftNode *Node\n\t\t\tnewLeftNode, newKey, value, removed = node.getLeftNode().Remove(key)\n\t\t\tif !removed {\n\t\t\t\treturn node, \"\", value, false\n\t\t\t} else if newLeftNode == nil { // left node held value, was removed\n\t\t\t\treturn node.rightNode, node.key, value, true\n\t\t\t}\n\t\t\tnode = node._copy()\n\t\t\tnode.leftNode = newLeftNode\n\t\t\tnode.calcHeightAndSize()\n\t\t\tnode = node.balance()\n\t\t\treturn node, newKey, value, true\n\t\t} else {\n\t\t\tvar newRightNode *Node\n\t\t\tnewRightNode, newKey, value, removed = node.getRightNode().Remove(key)\n\t\t\tif !removed {\n\t\t\t\treturn node, \"\", value, false\n\t\t\t} else if newRightNode == nil { // right node held value, was removed\n\t\t\t\treturn node.leftNode, \"\", value, true\n\t\t\t}\n\t\t\tnode = node._copy()\n\t\t\tnode.rightNode = newRightNode\n\t\t\tif newKey != \"\" {\n\t\t\t\tnode.key = newKey\n\t\t\t}\n\t\t\tnode.calcHeightAndSize()\n\t\t\tnode = node.balance()\n\t\t\treturn node, \"\", value, true\n\t\t}\n\t}\n}\n\nfunc (node *Node) getLeftNode() *Node {\n\treturn node.leftNode\n}\n\nfunc (node *Node) getRightNode() *Node {\n\treturn node.rightNode\n}\n\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateRight() *Node {\n\tnode = node._copy()\n\tl := node.getLeftNode()\n\t_l := l._copy()\n\n\t_lrCached := _l.rightNode\n\t_l.rightNode = node\n\tnode.leftNode = _lrCached\n\n\tnode.calcHeightAndSize()\n\t_l.calcHeightAndSize()\n\n\treturn _l\n}\n\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateLeft() *Node {\n\tnode = node._copy()\n\tr := node.getRightNode()\n\t_r := r._copy()\n\n\t_rlCached := _r.leftNode\n\t_r.leftNode = node\n\tnode.rightNode = _rlCached\n\n\tnode.calcHeightAndSize()\n\t_r.calcHeightAndSize()\n\n\treturn _r\n}\n\n// NOTE: mutates height and size\nfunc (node *Node) calcHeightAndSize() {\n\tnode.height = maxInt8(node.getLeftNode().height, node.getRightNode().height) + 1\n\tnode.size = node.getLeftNode().size + node.getRightNode().size\n}\n\nfunc (node *Node) calcBalance() int {\n\treturn int(node.getLeftNode().height) - int(node.getRightNode().height)\n}\n\n// NOTE: assumes that node can be modified\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) balance() (newSelf *Node) {\n\tbalance := node.calcBalance()\n\tif balance \u003e 1 {\n\t\tif node.getLeftNode().calcBalance() \u003e= 0 {\n\t\t\t// Left Left Case\n\t\t\treturn node.rotateRight()\n\t\t} else {\n\t\t\t// Left Right Case\n\t\t\t// node = node._copy()\n\t\t\tleft := node.getLeftNode()\n\t\t\tnode.leftNode = left.rotateLeft()\n\t\t\t// node.calcHeightAndSize()\n\t\t\treturn node.rotateRight()\n\t\t}\n\t}\n\tif balance \u003c -1 {\n\t\tif node.getRightNode().calcBalance() \u003c= 0 {\n\t\t\t// Right Right Case\n\t\t\treturn node.rotateLeft()\n\t\t} else {\n\t\t\t// Right Left Case\n\t\t\t// node = node._copy()\n\t\t\tright := node.getRightNode()\n\t\t\tnode.rightNode = right.rotateRight()\n\t\t\t// node.calcHeightAndSize()\n\t\t\treturn node.rotateLeft()\n\t\t}\n\t}\n\t// Nothing changed\n\treturn node\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) Iterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, true, true, cb)\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) ReverseIterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, false, true, cb)\n}\n\n// TraverseInRange traverses all nodes, including inner nodes.\n// Start is inclusive and end is exclusive when ascending,\n// Start and end are inclusive when descending.\n// Empty start and empty end denote no start and no end.\n// If leavesOnly is true, only visit leaf nodes.\n// NOTE: To simulate an exclusive reverse traversal,\n// just append 0x00 to start.\nfunc (node *Node) TraverseInRange(start, end string, ascending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\tafterStart := (start == \"\" || start \u003c node.key)\n\tstartOrAfter := (start == \"\" || start \u003c= node.key)\n\tbeforeEnd := false\n\tif ascending {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c end)\n\t} else {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c= end)\n\t}\n\n\t// Run callback per inner/leaf node.\n\tstop := false\n\tif (!node.IsLeaf() \u0026\u0026 !leavesOnly) ||\n\t\t(node.IsLeaf() \u0026\u0026 startOrAfter \u0026\u0026 beforeEnd) {\n\t\tstop = cb(node)\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t}\n\tif node.IsLeaf() {\n\t\treturn stop\n\t}\n\n\tif ascending {\n\t\t// check lower nodes, then higher\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t} else {\n\t\t// check the higher nodes first\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t}\n\n\treturn stop\n}\n\n// TraverseByOffset traverses all nodes, including inner nodes.\n// A limit of math.MaxInt means no limit.\nfunc (node *Node) TraverseByOffset(offset, limit int, descending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\n\t// fast paths. these happen only if TraverseByOffset is called directly on a leaf.\n\tif limit \u003c= 0 || offset \u003e= node.size {\n\t\treturn false\n\t}\n\tif node.IsLeaf() {\n\t\tif offset \u003e 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn cb(node)\n\t}\n\n\t// go to the actual recursive function.\n\treturn node.traverseByOffset(offset, limit, descending, leavesOnly, cb)\n}\n\nfunc (node *Node) traverseByOffset(offset, limit int, descending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\t// caller guarantees: offset \u003c node.size; limit \u003e 0.\n\n\tif !leavesOnly {\n\t\tif cb(node) {\n\t\t\treturn true\n\t\t}\n\t}\n\tfirst, second := node.getLeftNode(), node.getRightNode()\n\tif descending {\n\t\tfirst, second = second, first\n\t}\n\tif first.IsLeaf() {\n\t\t// either run or skip, based on offset\n\t\tif offset \u003e 0 {\n\t\t\toffset--\n\t\t} else {\n\t\t\tcb(first)\n\t\t\tlimit--\n\t\t\tif limit \u003c= 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// possible cases:\n\t\t// 1 the offset given skips the first node entirely\n\t\t// 2 the offset skips none or part of the first node, but the limit requires some of the second node.\n\t\t// 3 the offset skips none or part of the first node, and the limit stops our search on the first node.\n\t\tif offset \u003e= first.size {\n\t\t\toffset -= first.size // 1\n\t\t} else {\n\t\t\tif first.traverseByOffset(offset, limit, descending, leavesOnly, cb) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// number of leaves which could actually be called from inside\n\t\t\tdelta := first.size - offset\n\t\t\toffset = 0\n\t\t\tif delta \u003e= limit {\n\t\t\t\treturn true // 3\n\t\t\t}\n\t\t\tlimit -= delta // 2\n\t\t}\n\t}\n\n\t// because of the caller guarantees and the way we handle the first node,\n\t// at this point we know that limit \u003e 0 and there must be some values in\n\t// this second node that we include.\n\n\t// =\u003e if the second node is a leaf, it has to be included.\n\tif second.IsLeaf() {\n\t\treturn cb(second)\n\t}\n\t// =\u003e if it is not a leaf, it will still be enough to recursively call this\n\t// function with the updated offset and limit\n\treturn second.traverseByOffset(offset, limit, descending, leavesOnly, cb)\n}\n\n// Only used in testing...\nfunc (node *Node) lmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getLeftNode().lmd()\n}\n\n// Only used in testing...\nfunc (node *Node) rmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getRightNode().rmd()\n}\n\nfunc maxInt8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"},{"Name":"node_test.gno","Body":"package avl\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestTraverseByOffset(t *testing.T) {\n\tconst testStrings = `Alfa\nAlfred\nAlpha\nAlphabet\nBeta\nBeth\nBook\nBrowser`\n\ttt := []struct {\n\t\tname string\n\t\tdesc bool\n\t}{\n\t\t{\"ascending\", false},\n\t\t{\"descending\", true},\n\t}\n\n\tfor _, tc := range tt {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsl := strings.Split(testStrings, \"\\n\")\n\n\t\t\t// sort a first time in the order opposite to how we'll be traversing\n\t\t\t// the tree, to ensure that we are not just iterating through with\n\t\t\t// insertion order.\n\t\t\tsort.Sort(sort.StringSlice(sl))\n\t\t\tif !tc.desc {\n\t\t\t\treverseSlice(sl)\n\t\t\t}\n\n\t\t\tr := NewNode(sl[0], nil)\n\t\t\tfor _, v := range sl[1:] {\n\t\t\t\tr, _ = r.Set(v, nil)\n\t\t\t}\n\n\t\t\t// then sort sl in the order we'll be traversing it, so that we can\n\t\t\t// compare the result with sl.\n\t\t\treverseSlice(sl)\n\n\t\t\tvar result []string\n\t\t\tfor i := 0; i \u003c len(sl); i++ {\n\t\t\t\tr.TraverseByOffset(i, 1, tc.desc, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif !slicesEqual(sl, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", sl, result)\n\t\t\t}\n\n\t\t\tfor l := 2; l \u003c= len(sl); l++ {\n\t\t\t\t// \"slices\"\n\t\t\t\tfor i := 0; i \u003c= len(sl); i++ {\n\t\t\t\t\tmax := i + l\n\t\t\t\t\tif max \u003e len(sl) {\n\t\t\t\t\t\tmax = len(sl)\n\t\t\t\t\t}\n\t\t\t\t\texp := sl[i:max]\n\t\t\t\t\tactual := []string{}\n\n\t\t\t\t\tr.TraverseByOffset(i, l, tc.desc, true, func(tr *Node) bool {\n\t\t\t\t\t\tactual = append(actual, tr.Key())\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\t// t.Log(exp, actual)\n\t\t\t\t\tif !slicesEqual(exp, actual) {\n\t\t\t\t\t\tt.Errorf(\"want %v got %v\", exp, actual)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc slicesEqual(w1, w2 []string) bool {\n\tif len(w1) != len(w2) {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c len(w1); i++ {\n\t\tif w1[0] != w2[0] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc reverseSlice(ss []string) {\n\tfor i := 0; i \u003c len(ss)/2; i++ {\n\t\tj := len(ss) - 1 - i\n\t\tss[i], ss[j] = ss[j], ss[i]\n\t}\n}\n"},{"Name":"tree.gno","Body":"package avl\n\ntype IterCbFn func(key string, value interface{}) bool\n\n//----------------------------------------\n// Tree\n\n// The zero struct can be used as an empty tree.\ntype Tree struct {\n\tnode *Node\n}\n\nfunc NewTree() *Tree {\n\treturn \u0026Tree{\n\t\tnode: nil,\n\t}\n}\n\nfunc (tree *Tree) Size() int {\n\treturn tree.node.Size()\n}\n\nfunc (tree *Tree) Has(key string) (has bool) {\n\treturn tree.node.Has(key)\n}\n\nfunc (tree *Tree) Get(key string) (value interface{}, exists bool) {\n\t_, value, exists = tree.node.Get(key)\n\treturn\n}\n\nfunc (tree *Tree) GetByIndex(index int) (key string, value interface{}) {\n\treturn tree.node.GetByIndex(index)\n}\n\nfunc (tree *Tree) Set(key string, value interface{}) (updated bool) {\n\tnewnode, updated := tree.node.Set(key, value)\n\ttree.node = newnode\n\treturn updated\n}\n\nfunc (tree *Tree) Remove(key string) (value interface{}, removed bool) {\n\tnewnode, _, value, removed := tree.node.Remove(key)\n\ttree.node = newnode\n\treturn value, removed\n}\n\n// Shortcut for TraverseInRange.\nfunc (tree *Tree) Iterate(start, end string, cb IterCbFn) bool {\n\treturn tree.node.TraverseInRange(start, end, true, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// Shortcut for TraverseInRange.\nfunc (tree *Tree) ReverseIterate(start, end string, cb IterCbFn) bool {\n\treturn tree.node.TraverseInRange(start, end, false, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// Shortcut for TraverseByOffset.\nfunc (tree *Tree) IterateByOffset(offset int, count int, cb IterCbFn) bool {\n\treturn tree.node.TraverseByOffset(offset, count, true, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// Shortcut for TraverseByOffset.\nfunc (tree *Tree) ReverseIterateByOffset(offset int, count int, cb IterCbFn) bool {\n\treturn tree.node.TraverseByOffset(offset, count, false, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n"},{"Name":"z_0_filetest.gno","Body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\t// node, _ = node.Set(\"key0\", \"value0\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key1\", \"value1\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 2\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key0\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value0\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"ModTime\": \"5\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:6]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"091729e38bda8724bce4c314f9624b91af679459\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"0b5493aa4ea42087780bdfcaebab2c3eec351c15\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"4\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"Nonce\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.0\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"10\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"15\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"6c9948281d4c60b2d95233b76388d54d8b1a2fad\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\"\n//                     }\n//                 }\n//             }\n//         }\n//     ]\n// }\n"},{"Name":"z_1_filetest.gno","Body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\tnode, _ = node.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key2\", \"value2\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:9]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:8]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"7a8a63e17a567d7b0891ac89d5cd90072a73787d\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"ab5a297f4eb033d88bdf1677f4dc151ccb9fde9f\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:7]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"627e8e517e7ae5db0f3b753e2a32b607989198b6\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"fe8afd501233fb95375016199f0443b3c6ab1fbc\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"6\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"Nonce\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.0\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"10\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"15\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"c5eefc40ed065461b4a920c1349ed734ffdead8f\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//                     }\n//                 }\n//             }\n//         }\n//     ]\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]\n"},{"Name":"z_2_filetest.gno","Body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar tree avl.Tree\n\nfunc init() {\n\ttree.Set(\"key0\", \"value0\")\n\ttree.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tupdated = tree.Set(\"key2\", \"value2\")\n\tprintln(updated, tree.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:10]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:9]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"213baed7e3326f2403b5f30e5d4397510ba4f37d\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"be751422ef4c2bc068a456f9467d2daca27db8ca\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:8]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"af4d0b158681d85eb2a7f6888b39a05ca7b790ee\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"ef853d70e334fd2c807d6c2c751da1fcd1e5ad58\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"3a5af0895c2c45b8a5e894644bcd689f1fdc4785\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"ModTime\": \"7\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]\n"}]},"deposit":""}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"isFLtaHcbZsTyjQyKk01nT6EGwX5FrRYFIrG94hIvn8TvAu/ggjNSwWx4LhBAFRfqBRdyEp4EcJeWhvlXPTZ3Q=="}],"memo":""},"blockNum":"297531"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"avl","Path":"gno.land/p/leon/avl","Files":[{"Name":"gno.mod","Body":"module gno.land/p/demo/avl\n"},{"Name":"node.gno","Body":"package avl\n\n//----------------------------------------\n// Node\n\ntype Node struct {\n\tkey       string\n\tvalue     interface{}\n\theight    int8\n\tsize      int\n\tleftNode  *Node\n\trightNode *Node\n}\n\nfunc NewNode(key string, value interface{}) *Node {\n\treturn \u0026Node{\n\t\tkey:    key,\n\t\tvalue:  value,\n\t\theight: 0,\n\t\tsize:   1,\n\t}\n}\n\nfunc (node *Node) Size() int {\n\tif node == nil {\n\t\treturn 0\n\t}\n\treturn node.size\n}\n\nfunc (node *Node) IsLeaf() bool {\n\treturn node.height == 0\n}\n\nfunc (node *Node) Key() string {\n\treturn node.key\n}\n\nfunc (node *Node) Value() interface{} {\n\treturn node.value\n}\n\nfunc (node *Node) _copy() *Node {\n\tif node.height == 0 {\n\t\tpanic(\"Why are you copying a value node?\")\n\t}\n\treturn \u0026Node{\n\t\tkey:       node.key,\n\t\theight:    node.height,\n\t\tsize:      node.size,\n\t\tleftNode:  node.leftNode,\n\t\trightNode: node.rightNode,\n\t}\n}\n\nfunc (node *Node) Has(key string) (has bool) {\n\tif node == nil {\n\t\treturn false\n\t}\n\tif node.key == key {\n\t\treturn true\n\t}\n\tif node.height == 0 {\n\t\treturn false\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\treturn node.getLeftNode().Has(key)\n\t\t} else {\n\t\t\treturn node.getRightNode().Has(key)\n\t\t}\n\t}\n}\n\nfunc (node *Node) Get(key string) (index int, value interface{}, exists bool) {\n\tif node == nil {\n\t\treturn 0, nil, false\n\t}\n\tif node.height == 0 {\n\t\tif node.key == key {\n\t\t\treturn 0, node.value, true\n\t\t} else if node.key \u003c key {\n\t\t\treturn 1, nil, false\n\t\t} else {\n\t\t\treturn 0, nil, false\n\t\t}\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\treturn node.getLeftNode().Get(key)\n\t\t} else {\n\t\t\trightNode := node.getRightNode()\n\t\t\tindex, value, exists = rightNode.Get(key)\n\t\t\tindex += node.size - rightNode.size\n\t\t\treturn index, value, exists\n\t\t}\n\t}\n}\n\nfunc (node *Node) GetByIndex(index int) (key string, value interface{}) {\n\tif node.height == 0 {\n\t\tif index == 0 {\n\t\t\treturn node.key, node.value\n\t\t} else {\n\t\t\tpanic(\"GetByIndex asked for invalid index\")\n\t\t\treturn \"\", nil\n\t\t}\n\t} else {\n\t\t// TODO: could improve this by storing the sizes\n\t\tleftNode := node.getLeftNode()\n\t\tif index \u003c leftNode.size {\n\t\t\treturn leftNode.GetByIndex(index)\n\t\t} else {\n\t\t\treturn node.getRightNode().GetByIndex(index - leftNode.size)\n\t\t}\n\t}\n}\n\n// XXX consider a better way to do this... perhaps split Node from Node.\nfunc (node *Node) Set(key string, value interface{}) (newSelf *Node, updated bool) {\n\tif node == nil {\n\t\treturn NewNode(key, value), false\n\t}\n\tif node.height == 0 {\n\t\tif key \u003c node.key {\n\t\t\treturn \u0026Node{\n\t\t\t\tkey:       node.key,\n\t\t\t\theight:    1,\n\t\t\t\tsize:      2,\n\t\t\t\tleftNode:  NewNode(key, value),\n\t\t\t\trightNode: node,\n\t\t\t}, false\n\t\t} else if key == node.key {\n\t\t\treturn NewNode(key, value), true\n\t\t} else {\n\t\t\treturn \u0026Node{\n\t\t\t\tkey:       key,\n\t\t\t\theight:    1,\n\t\t\t\tsize:      2,\n\t\t\t\tleftNode:  node,\n\t\t\t\trightNode: NewNode(key, value),\n\t\t\t}, false\n\t\t}\n\t} else {\n\t\tnode = node._copy()\n\t\tif key \u003c node.key {\n\t\t\tnode.leftNode, updated = node.getLeftNode().Set(key, value)\n\t\t} else {\n\t\t\tnode.rightNode, updated = node.getRightNode().Set(key, value)\n\t\t}\n\t\tif updated {\n\t\t\treturn node, updated\n\t\t} else {\n\t\t\tnode.calcHeightAndSize()\n\t\t\treturn node.balance(), updated\n\t\t}\n\t}\n}\n\n// newNode: The new node to replace node after remove.\n// newKey: new leftmost leaf key for node after successfully removing 'key' if changed.\n// value: removed value.\nfunc (node *Node) Remove(key string) (\n\tnewNode *Node, newKey string, value interface{}, removed bool,\n) {\n\tif node == nil {\n\t\treturn nil, \"\", nil, false\n\t}\n\tif node.height == 0 {\n\t\tif key == node.key {\n\t\t\treturn nil, \"\", node.value, true\n\t\t} else {\n\t\t\treturn node, \"\", nil, false\n\t\t}\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\tvar newLeftNode *Node\n\t\t\tnewLeftNode, newKey, value, removed = node.getLeftNode().Remove(key)\n\t\t\tif !removed {\n\t\t\t\treturn node, \"\", value, false\n\t\t\t} else if newLeftNode == nil { // left node held value, was removed\n\t\t\t\treturn node.rightNode, node.key, value, true\n\t\t\t}\n\t\t\tnode = node._copy()\n\t\t\tnode.leftNode = newLeftNode\n\t\t\tnode.calcHeightAndSize()\n\t\t\tnode = node.balance()\n\t\t\treturn node, newKey, value, true\n\t\t} else {\n\t\t\tvar newRightNode *Node\n\t\t\tnewRightNode, newKey, value, removed = node.getRightNode().Remove(key)\n\t\t\tif !removed {\n\t\t\t\treturn node, \"\", value, false\n\t\t\t} else if newRightNode == nil { // right node held value, was removed\n\t\t\t\treturn node.leftNode, \"\", value, true\n\t\t\t}\n\t\t\tnode = node._copy()\n\t\t\tnode.rightNode = newRightNode\n\t\t\tif newKey != \"\" {\n\t\t\t\tnode.key = newKey\n\t\t\t}\n\t\t\tnode.calcHeightAndSize()\n\t\t\tnode = node.balance()\n\t\t\treturn node, \"\", value, true\n\t\t}\n\t}\n}\n\nfunc (node *Node) getLeftNode() *Node {\n\treturn node.leftNode\n}\n\nfunc (node *Node) getRightNode() *Node {\n\treturn node.rightNode\n}\n\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateRight() *Node {\n\tnode = node._copy()\n\tl := node.getLeftNode()\n\t_l := l._copy()\n\n\t_lrCached := _l.rightNode\n\t_l.rightNode = node\n\tnode.leftNode = _lrCached\n\n\tnode.calcHeightAndSize()\n\t_l.calcHeightAndSize()\n\n\treturn _l\n}\n\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateLeft() *Node {\n\tnode = node._copy()\n\tr := node.getRightNode()\n\t_r := r._copy()\n\n\t_rlCached := _r.leftNode\n\t_r.leftNode = node\n\tnode.rightNode = _rlCached\n\n\tnode.calcHeightAndSize()\n\t_r.calcHeightAndSize()\n\n\treturn _r\n}\n\n// NOTE: mutates height and size\nfunc (node *Node) calcHeightAndSize() {\n\tnode.height = maxInt8(node.getLeftNode().height, node.getRightNode().height) + 1\n\tnode.size = node.getLeftNode().size + node.getRightNode().size\n}\n\nfunc (node *Node) calcBalance() int {\n\treturn int(node.getLeftNode().height) - int(node.getRightNode().height)\n}\n\n// NOTE: assumes that node can be modified\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) balance() (newSelf *Node) {\n\tbalance := node.calcBalance()\n\tif balance \u003e 1 {\n\t\tif node.getLeftNode().calcBalance() \u003e= 0 {\n\t\t\t// Left Left Case\n\t\t\treturn node.rotateRight()\n\t\t} else {\n\t\t\t// Left Right Case\n\t\t\t// node = node._copy()\n\t\t\tleft := node.getLeftNode()\n\t\t\tnode.leftNode = left.rotateLeft()\n\t\t\t// node.calcHeightAndSize()\n\t\t\treturn node.rotateRight()\n\t\t}\n\t}\n\tif balance \u003c -1 {\n\t\tif node.getRightNode().calcBalance() \u003c= 0 {\n\t\t\t// Right Right Case\n\t\t\treturn node.rotateLeft()\n\t\t} else {\n\t\t\t// Right Left Case\n\t\t\t// node = node._copy()\n\t\t\tright := node.getRightNode()\n\t\t\tnode.rightNode = right.rotateRight()\n\t\t\t// node.calcHeightAndSize()\n\t\t\treturn node.rotateLeft()\n\t\t}\n\t}\n\t// Nothing changed\n\treturn node\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) Iterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, true, true, cb)\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) ReverseIterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, false, true, cb)\n}\n\n// TraverseInRange traverses all nodes, including inner nodes.\n// Start is inclusive and end is exclusive when ascending,\n// Start and end are inclusive when descending.\n// Empty start and empty end denote no start and no end.\n// If leavesOnly is true, only visit leaf nodes.\n// NOTE: To simulate an exclusive reverse traversal,\n// just append 0x00 to start.\nfunc (node *Node) TraverseInRange(start, end string, ascending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\tafterStart := (start == \"\" || start \u003c node.key)\n\tstartOrAfter := (start == \"\" || start \u003c= node.key)\n\tbeforeEnd := false\n\tif ascending {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c end)\n\t} else {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c= end)\n\t}\n\n\t// Run callback per inner/leaf node.\n\tstop := false\n\tif (!node.IsLeaf() \u0026\u0026 !leavesOnly) ||\n\t\t(node.IsLeaf() \u0026\u0026 startOrAfter \u0026\u0026 beforeEnd) {\n\t\tstop = cb(node)\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t}\n\tif node.IsLeaf() {\n\t\treturn stop\n\t}\n\n\tif ascending {\n\t\t// check lower nodes, then higher\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t} else {\n\t\t// check the higher nodes first\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t}\n\n\treturn stop\n}\n\n// TraverseByOffset traverses all nodes, including inner nodes.\n// A limit of math.MaxInt means no limit.\nfunc (node *Node) TraverseByOffset(offset, limit int, descending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\n\t// fast paths. these happen only if TraverseByOffset is called directly on a leaf.\n\tif limit \u003c= 0 || offset \u003e= node.size {\n\t\treturn false\n\t}\n\tif node.IsLeaf() {\n\t\tif offset \u003e 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn cb(node)\n\t}\n\n\t// go to the actual recursive function.\n\treturn node.traverseByOffset(offset, limit, descending, leavesOnly, cb)\n}\n\nfunc (node *Node) traverseByOffset(offset, limit int, descending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\t// caller guarantees: offset \u003c node.size; limit \u003e 0.\n\n\tif !leavesOnly {\n\t\tif cb(node) {\n\t\t\treturn true\n\t\t}\n\t}\n\tfirst, second := node.getLeftNode(), node.getRightNode()\n\tif descending {\n\t\tfirst, second = second, first\n\t}\n\tif first.IsLeaf() {\n\t\t// either run or skip, based on offset\n\t\tif offset \u003e 0 {\n\t\t\toffset--\n\t\t} else {\n\t\t\tcb(first)\n\t\t\tlimit--\n\t\t\tif limit \u003c= 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// possible cases:\n\t\t// 1 the offset given skips the first node entirely\n\t\t// 2 the offset skips none or part of the first node, but the limit requires some of the second node.\n\t\t// 3 the offset skips none or part of the first node, and the limit stops our search on the first node.\n\t\tif offset \u003e= first.size {\n\t\t\toffset -= first.size // 1\n\t\t} else {\n\t\t\tif first.traverseByOffset(offset, limit, descending, leavesOnly, cb) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// number of leaves which could actually be called from inside\n\t\t\tdelta := first.size - offset\n\t\t\toffset = 0\n\t\t\tif delta \u003e= limit {\n\t\t\t\treturn true // 3\n\t\t\t}\n\t\t\tlimit -= delta // 2\n\t\t}\n\t}\n\n\t// because of the caller guarantees and the way we handle the first node,\n\t// at this point we know that limit \u003e 0 and there must be some values in\n\t// this second node that we include.\n\n\t// =\u003e if the second node is a leaf, it has to be included.\n\tif second.IsLeaf() {\n\t\treturn cb(second)\n\t}\n\t// =\u003e if it is not a leaf, it will still be enough to recursively call this\n\t// function with the updated offset and limit\n\treturn second.traverseByOffset(offset, limit, descending, leavesOnly, cb)\n}\n\n// Only used in testing...\nfunc (node *Node) lmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getLeftNode().lmd()\n}\n\n// Only used in testing...\nfunc (node *Node) rmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getRightNode().rmd()\n}\n\nfunc maxInt8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"},{"Name":"node_test.gno","Body":"package avl\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestTraverseByOffset(t *testing.T) {\n\tconst testStrings = `Alfa\nAlfred\nAlpha\nAlphabet\nBeta\nBeth\nBook\nBrowser`\n\ttt := []struct {\n\t\tname string\n\t\tdesc bool\n\t}{\n\t\t{\"ascending\", false},\n\t\t{\"descending\", true},\n\t}\n\n\tfor _, tc := range tt {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsl := strings.Split(testStrings, \"\\n\")\n\n\t\t\t// sort a first time in the order opposite to how we'll be traversing\n\t\t\t// the tree, to ensure that we are not just iterating through with\n\t\t\t// insertion order.\n\t\t\tsort.Sort(sort.StringSlice(sl))\n\t\t\tif !tc.desc {\n\t\t\t\treverseSlice(sl)\n\t\t\t}\n\n\t\t\tr := NewNode(sl[0], nil)\n\t\t\tfor _, v := range sl[1:] {\n\t\t\t\tr, _ = r.Set(v, nil)\n\t\t\t}\n\n\t\t\t// then sort sl in the order we'll be traversing it, so that we can\n\t\t\t// compare the result with sl.\n\t\t\treverseSlice(sl)\n\n\t\t\tvar result []string\n\t\t\tfor i := 0; i \u003c len(sl); i++ {\n\t\t\t\tr.TraverseByOffset(i, 1, tc.desc, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif !slicesEqual(sl, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", sl, result)\n\t\t\t}\n\n\t\t\tfor l := 2; l \u003c= len(sl); l++ {\n\t\t\t\t// \"slices\"\n\t\t\t\tfor i := 0; i \u003c= len(sl); i++ {\n\t\t\t\t\tmax := i + l\n\t\t\t\t\tif max \u003e len(sl) {\n\t\t\t\t\t\tmax = len(sl)\n\t\t\t\t\t}\n\t\t\t\t\texp := sl[i:max]\n\t\t\t\t\tactual := []string{}\n\n\t\t\t\t\tr.TraverseByOffset(i, l, tc.desc, true, func(tr *Node) bool {\n\t\t\t\t\t\tactual = append(actual, tr.Key())\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\t// t.Log(exp, actual)\n\t\t\t\t\tif !slicesEqual(exp, actual) {\n\t\t\t\t\t\tt.Errorf(\"want %v got %v\", exp, actual)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc slicesEqual(w1, w2 []string) bool {\n\tif len(w1) != len(w2) {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c len(w1); i++ {\n\t\tif w1[0] != w2[0] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc reverseSlice(ss []string) {\n\tfor i := 0; i \u003c len(ss)/2; i++ {\n\t\tj := len(ss) - 1 - i\n\t\tss[i], ss[j] = ss[j], ss[i]\n\t}\n}\n"},{"Name":"tree.gno","Body":"package avl\n\ntype IterCbFn func(key string, value interface{}) bool\n\n//----------------------------------------\n// Tree\n\n// The zero struct can be used as an empty tree.\ntype Tree struct {\n\tnode *Node\n}\n\nfunc NewTree() *Tree {\n\treturn \u0026Tree{\n\t\tnode: nil,\n\t}\n}\n\nfunc (tree *Tree) Size() int {\n\treturn tree.node.Size()\n}\n\nfunc (tree *Tree) Has(key string) (has bool) {\n\treturn tree.node.Has(key)\n}\n\nfunc (tree *Tree) Get(key string) (value interface{}, exists bool) {\n\t_, value, exists = tree.node.Get(key)\n\treturn\n}\n\nfunc (tree *Tree) GetByIndex(index int) (key string, value interface{}) {\n\treturn tree.node.GetByIndex(index)\n}\n\nfunc (tree *Tree) Set(key string, value interface{}) (updated bool) {\n\tnewnode, updated := tree.node.Set(key, value)\n\ttree.node = newnode\n\treturn updated\n}\n\nfunc (tree *Tree) Remove(key string) (value interface{}, removed bool) {\n\tnewnode, _, value, removed := tree.node.Remove(key)\n\ttree.node = newnode\n\treturn value, removed\n}\n\n// Shortcut for TraverseInRange.\nfunc (tree *Tree) Iterate(start, end string, cb IterCbFn) bool {\n\treturn tree.node.TraverseInRange(start, end, true, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// Shortcut for TraverseInRange.\nfunc (tree *Tree) ReverseIterate(start, end string, cb IterCbFn) bool {\n\treturn tree.node.TraverseInRange(start, end, false, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// Shortcut for TraverseByOffset.\nfunc (tree *Tree) IterateByOffset(offset int, count int, cb IterCbFn) bool {\n\treturn tree.node.TraverseByOffset(offset, count, true, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// Shortcut for TraverseByOffset.\nfunc (tree *Tree) ReverseIterateByOffset(offset int, count int, cb IterCbFn) bool {\n\treturn tree.node.TraverseByOffset(offset, count, false, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n"},{"Name":"z_0_filetest.gno","Body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\t// node, _ = node.Set(\"key0\", \"value0\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key1\", \"value1\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 2\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key0\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value0\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"ModTime\": \"5\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:6]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"091729e38bda8724bce4c314f9624b91af679459\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"0b5493aa4ea42087780bdfcaebab2c3eec351c15\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"4\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"Nonce\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.0\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"10\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"15\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"6c9948281d4c60b2d95233b76388d54d8b1a2fad\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\"\n//                     }\n//                 }\n//             }\n//         }\n//     ]\n// }\n"},{"Name":"z_1_filetest.gno","Body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\tnode, _ = node.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key2\", \"value2\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:9]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:8]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"7a8a63e17a567d7b0891ac89d5cd90072a73787d\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"ab5a297f4eb033d88bdf1677f4dc151ccb9fde9f\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:7]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"627e8e517e7ae5db0f3b753e2a32b607989198b6\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"fe8afd501233fb95375016199f0443b3c6ab1fbc\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"6\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"Nonce\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.0\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"10\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"15\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"c5eefc40ed065461b4a920c1349ed734ffdead8f\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//                     }\n//                 }\n//             }\n//         }\n//     ]\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]\n"},{"Name":"z_2_filetest.gno","Body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar tree avl.Tree\n\nfunc init() {\n\ttree.Set(\"key0\", \"value0\")\n\ttree.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tupdated = tree.Set(\"key2\", \"value2\")\n\tprintln(updated, tree.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:10]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:9]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"213baed7e3326f2403b5f30e5d4397510ba4f37d\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"be751422ef4c2bc068a456f9467d2daca27db8ca\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:8]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"af4d0b158681d85eb2a7f6888b39a05ca7b790ee\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"ef853d70e334fd2c807d6c2c751da1fcd1e5ad58\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"3a5af0895c2c45b8a5e894644bcd689f1fdc4785\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"ModTime\": \"7\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"y6MN6cVVRIKpDC3NEJJY+43sRaxA4yJEbQbpziydvFxQUatS/U5OBINXp4AETzu1UMvKmapvALcNvov+noUP2Q=="}],"memo":""},"blockNum":"297533"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory1\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"2R5md8RSkA7JxYM3ODfkTxdeb2TnGW4SxKenSlT6biFzXPdFDxAU72ZdIPpl4iQsECrwvIOfLKJSeJdsG2Mhtg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297537"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory1\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"rnJjawGTsmAiVcSi7SRYAAiQaW15F7rTtqCVkdruRBkMh45UHBl+xmfVOGJpSpsDM71elpVwAeDps20jzeGq3Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297540"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory1\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"ghgvh2Rb/XjR61jcrlZqvDiJF4cXxq+1VPP45IiuC0kYvIfHtAVDMMhz9ncOYKOI1CE3BhOeq0l+u6XRZJNJ4g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297542"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory1\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"R+O/BJ+F/vNUMFPfZYmN+girkYevdnmDnquZHM5H155TaUEXA62I0gFq+mLit6QVWouSetf1dDrjAIE/CltSqQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297544"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory1\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"c257qgwdMXnKJDAX3NjFgSRMjxO4gPx8+5dpsmRUus5xgNCTHYzJ/flZahE8CC/UqhMQzEnDIRkKrLDtOtS6sQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297546"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory1\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist1.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"sVgExCRtEG2OOVkQy7WVArdmNmevlhxqzHFcneyDYRcpqOU8uXrycSUqweb2rtPVYHmjuN3gCWyDDcQ5FvSDsg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297548"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory1","Path":"gno.land/r/leon/whitelistfactory1","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory1\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/leon/whitelist1\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist1.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist1.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist1.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"XrJ1+LW2GEgxWdJ2rpg+7J4VH8APTyh1wUrnd6JJjR8+LyFyn7gG8rEczjcXkfG1VLPfBwiwlgXwVWWHlhtC3A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297550"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist_wpackagename","Path":"gno.land/r/leon/whitelist_wpackagename","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\twhitelist \"gno.land/p/leon/whitelist\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"2K/cRqnAD6bpfBNbjyxuCp3+fgRiGTUxBfj+t9o3aEsi7JSTWTv/4qhGC8tEGn88SfI9r7n578vRNSBdLH0AXA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297553"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist_wpackagename","Path":"gno.land/r/leon/whitelist_wpackagename","Files":[{"Name":"whitelistfactory.gno","Body":"package whitelist_wpackagename\n\nimport (\n\t\"bytes\"\n\t\"std\"\n    \"strconv\"\n\n    // Test3 AVL package is outdated. On this path you can find the newest version of the package.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\twhitelist \"gno.land/p/leon/whitelist\" // Change to your deployed whitelist package path\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int, maxUsers int) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= int(std.GetHeight()) {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Itoa(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= int(std.GetHeight()) {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e int(std.GetHeight()) {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n\n// Tutorial: From Zero to Gno.land Hero - Updated 10th of March 2024\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"VVvhCjN70I77R6y21BHyL0H+aqJuIq01hopqpVMHqcFt8QJk8mTO3Gg/ceLT+axseOGeiojx7ZQiq5vQpysooQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"297555"}
