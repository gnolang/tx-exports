{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","send":"","pkg_path":"gno.land/r/boom/boom","func":"TotalSupply","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"/LeOnYsvZd7X2kuvOmGvh2v6LBQu3aHollvt0qD57tQEmLwNsQhDqF46Vepyuk09ZoYc0BGlM9Tq76cjo+cNvQ=="}],"memo":"Called through gno.studio"},"blockNum":"294258"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","send":"","pkg_path":"gno.land/r/boom/boom","func":"TotalSupply","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"bVrV2TUPA50hZvJ9hSL3z2/GrBhJjpiUrdq48yKtyQ56+dRLRTfwfLKMpNwbev2ybxEl1nuDGRDXqdQaHj0o4g=="}],"memo":"Called through gno.studio"},"blockNum":"294260"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazaitoken","Path":"gno.land/r/demo/kazaitoken","Files":[{"Name":"package.gno","Body":"package kazaitoken\n\nimport (\n  \"std\"\n  \"strings\"\n\n  \"gno.land/p/demo/users\"\n  \"gno.land/p/demo/ufmt\"\n  \"gno.land/p/demo/grc/grc20\"\n)\n\nvar (\n  kazaitoken *grc20.AdminToken\n  admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n  kazaitoken = grc20.NewAdminToken(\"kazaiToken\", \"KAZ\", 6)\n  kazaitoken.Mint(admin, 100000000)\n}\n\nfunc TotalSupply() uint64 {\n  return kazaitoken.TotalSupply()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"gSs3GhXxSWSpsQxRx3lZ/b649EH+CZ3tcmXEgF60NvQlCQ4qsuvG8qCpx9CJphlIDRBm7URMj2zRTjkRHNKO5Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294341"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazaitoken","Path":"gno.land/r/demo/kazaitoken","Files":[{"Name":"package.gno","Body":"package kazaitoken\n\nimport (\n  \"std\"\n  \"strings\"\n\n  \"gno.land/r/demo/users\"\n  \"gno.land/p/demo/ufmt\"\n  \"gno.land/p/demo/grc/grc20\"\n)\n\nvar (\n  kazaitoken *grc20.AdminToken\n  admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n  kazaitoken = grc20.NewAdminToken(\"kazaiToken\", \"KAZ\", 6)\n  kazaitoken.Mint(admin, 100000000)\n}\n\nfunc TotalSupply() uint64 {\n  return kazaitoken.TotalSupply()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"g0Mvd44l4wyVWAnJ04SaxRqn6GhVjv0hvdVu5KxIOv4I2a3LNW57iQS/7a+ZbUsLORKbEAmWt7CcVpkG6dstWA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294344"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazaitoken","Path":"gno.land/r/demo/kazaitoken","Files":[{"Name":"package.gno","Body":"package kazaitoken\n\nimport (\n  \"std\"\n  \"strings\"\n\n  \"gno.land/r/demo/users\"\n  \"gno.land/p/demo/ufmt\"\n  \"gno.land/p/demo/grc/grc20\"\n)\n\nvar (\n  kazaitoken *grc20.AdminToken\n  admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n  kazaitoken = grc20.NewAdminToken(\"kazaiToken\", \"KAZ\", 6)\n  kazaitoken.Mint(admin, 100000000)\n}\n\nfunc TotalSupply() uint64 {\n  return kazaitoken.TotalSupply()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"8CWaqccww1YzAOOXfP0Q495tSLi1oKQLOGKyYpFGQq9/Jd6k2IucvDo7+pqg4BSh6uj8C/bvDtxRT6T0549xDw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294349"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazai","Path":"gno.land/r/demo/kazai","Files":[{"Name":"package.gno","Body":"package kazai\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tkazai  *grc20.AdminToken\n\tadmin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n\tkazai = grc20.NewAdminToken(\"KazaiToken\", \"KAZ\", 6)\n\tkazai.Mint(admin, 1000000000) // @administrator\n}\n\n// method proxies as public functions.\n//\n\n// getters.\n\nfunc TotalSupply() uint64 {\n\treturn foo.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := foo.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := foo.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\n// setters.\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.Transfer(caller, to.Resolve(), amount)\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.Approve(caller, spender.Resolve(), amount)\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n}\n\n// administration.\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tfoo.Mint(address.Resolve(), amount)\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tfoo.Burn(address.Resolve(), amount)\n}\n\n// render.\n//\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn foo.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := foo.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"ktC3wvHrMUbX0h1fwWamjOZeW+pXce3ZrjPxCxp/sBYgFKjdwB3KE6hr8pCaVnzezLxBUKT+D35AHSFusfXshg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294354"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazai","Path":"gno.land/r/demo/kazai","Files":[{"Name":"package.gno","Body":"package kazai\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tkazai  *grc20.AdminToken\n\tadmin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n\tkazai = grc20.NewAdminToken(\"KazaiToken\", \"KAZ\", 6)\n\tkazai.Mint(admin, 1000000000) // @administrator\n}\n\n// method proxies as public functions.\n//\n\n// getters.\n\nfunc TotalSupply() uint64 {\n\treturn kazai.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := foo.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := foo.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\n// setters.\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.Transfer(caller, to.Resolve(), amount)\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.Approve(caller, spender.Resolve(), amount)\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n}\n\n// administration.\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tfoo.Mint(address.Resolve(), amount)\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tfoo.Burn(address.Resolve(), amount)\n}\n\n// render.\n//\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn foo.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := foo.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"UDNGVch5VZf59ZPjXXgtyj6RgEKvdkTQiGtT+b/2gkoK7i0X3hijO3TAP1qLIKJ7rd454JZEoddxlZ1lKFpvYg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294356"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazai","Path":"gno.land/r/demo/kazai","Files":[{"Name":"package.gno","Body":"package kazai\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tkazai  *grc20.AdminToken\n\tadmin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n)\n\nfunc init() {\n\tkazai = grc20.NewAdminToken(\"KazaiToken\", \"KAZ\", 6)\n\tkazai.Mint(admin, 1000000000) // @administrator\n}\n\n// method proxies as public functions.\n//\n\n// getters.\n\nfunc TotalSupply() uint64 {\n\treturn kazai.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := kazai.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := kazai.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\n// setters.\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n  kazai.Transfer(caller, to.Resolve(), amount)\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tkazai.Approve(caller, spender.Resolve(), amount)\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tkazai.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n}\n\n// administration.\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tkazai.Mint(address.Resolve(), amount)\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tkazai.Burn(address.Resolve(), amount)\n}\n\n// render.\n//\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn kazai.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := kazai.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"wH+WM2o1dC9jM1Bz+8z+5bxrZyCF16/0x6B8rnCAzUxVwUAg/xg1VmdS/+x+w/ajUjHLLJUdetpla6s7+5LBdw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294359"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","send":"","pkg_path":"gno.land/r/demo/kazai","func":"Transfer","args":["g1ayxdpq5jzqrkedjp57xvdhvf9g6jjwhxt5wn2f","1000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"sPTEeTeOTWVRF02lg9WOJSN4povwxEwIRSq35k/HNfJgz2HLwfXaRCxnXB/vTGphHOVhrQvYbLL4E4O/FoFA1g=="}],"memo":""},"blockNum":"294391"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","send":"","pkg_path":"gno.land/r/test11/poll","func":"Vote","args":["Blue"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"J9yBuCPfB7cxPkaXNopJ2QOdVlQ0HfK3u8HrWRne8s5I+NhqgJAIBiSt+UJWJP3YJoI/CxCztw5RwpOAUgqsBA=="}],"memo":"Called through gno.studio"},"blockNum":"294404"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","to_address":"g1ayxdpq5jzqrkedjp57xvdhvf9g6jjwhxt5wn2f","amount":"5990000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"IgqnfoB3MNK10+9UIUJOhINcazUbfR5uCr4NVZ2gLaYhxqo/UzHzMpvbmhKrySJl7EhrP+5TOsNMH6UdALxQJQ=="}],"memo":""},"blockNum":"294417"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1ayxdpq5jzqrkedjp57xvdhvf9g6jjwhxt5wn2f","package":{"Name":"hello","Path":"gno.land/r/demo/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ApG+L9WvD3TJKSYknSaEL7uGAX77yqJWoa71BK9cRGwa"},"signature":"NSFt9snpdQ9wtDDjA3Wcm+1OzC29Ndv0r3pCC+WZqNotsDaRBsxwPvqLsHZrICog8AQhNxPyWm5sQMpnlXSyBg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294506"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1ayxdpq5jzqrkedjp57xvdhvf9g6jjwhxt5wn2f","package":{"Name":"hello1","Path":"gno.land/r/demo/hello1","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ApG+L9WvD3TJKSYknSaEL7uGAX77yqJWoa71BK9cRGwa"},"signature":"QVQWaJYUitOlTaTT6AqcuZpsCG9xmVjds/OcV4gGRAEriaMWbSkOiXPzfiEK5mq0xlTvzCGdODJhMQkyoZfF9A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294508"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazainft","Path":"gno.land/r/demo/kazainft","Files":[{"Name":"package.gno","Body":"package kazainft\n\nimport (\n  \"std\"\n\n  \"gno.land/p/demo/grc/grc721\"\n)\n\nadmin (\n  admin std.Address(\"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\")\n  kazainft = grc721.NewBasicNFT(\"kazaiNFT\", \"KNFT\")\n)\n\nfunc init() {\n  MintNNFT = (admin, 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := my.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        mynonfungibletoken.Mint(owner, tid)\n    }\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := mynonfungibletoken.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := mynonfungibletoken.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := mynonfungibletoken.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mynonfungibletoken.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mynonfungibletoken.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Render\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return mynonfungibletoken.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"t5ejg8m3EmqS/N1x+XHJUUDjZzbkekio+kLzkDfH6mE/y/7fTDRyE7bSdcbNU8fxEVdNYjdzm6cWtgQ7jbiaAg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294524"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazainft","Path":"gno.land/r/demo/kazainft","Files":[{"Name":"package.gno","Body":"package kazainft\n\nimport (\n  \"std\"\n\n  \"gno.land/p/demo/grc/grc721\"\n)\n\nvar (\n  admin std.Address(\"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\")\n  kazainft = grc721.NewBasicNFT(\"kazaiNFT\", \"KNFT\")\n)\n\nfunc init() {\n  MintNNFT = (admin, 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := my.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        mynonfungibletoken.Mint(owner, tid)\n    }\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := mynonfungibletoken.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := mynonfungibletoken.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := mynonfungibletoken.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mynonfungibletoken.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := mynonfungibletoken.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Render\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return mynonfungibletoken.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"bmK6crRJgIXoFVBSwTkVSvY9bVVtrXIeWt3y6Y5uCpR5zOcVQ6a3SFQJRXRIi4nDjSWw9zp21euHqcQOILhfrw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294526"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazainft","Path":"gno.land/r/demo/kazainft","Files":[{"Name":"package.gno","Body":"package kazainft\n\nimport (\n  \"std\"\n\n  \"gno.land/p/demo/grc/grc721\"\n)\n\nvar (\n    admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\" // set admin account\n    // provision the token's name and symbol\n    kazainft = grc721.NewBasicNFT(\"KazaiNFT\", \"KNFT\")\n)\n\nfunc init() {\n  MintNNFT(admin, 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := my.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        kazainft.Mint(owner, tid)\n    }\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := kazainft.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := kazainft.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return kazainft.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := kazainft.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := kazainft.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Render\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return kazainft.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"ZzVPXrSPXihcRHymcfC5hs1DfFPqpRZALqix3+i0x7U5FbM7cSDR/63I9UQ+fdaHBpcg0qO1Jx8h4NefAj06sg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294530"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazainft","Path":"gno.land/r/demo/kazainft","Files":[{"Name":"package.gno","Body":"package kazainft\n\nimport (\n  \"std\"\n\n  \"gno.land/p/demo/grc/grc721\"\n  \"gno.land/r/demo/users\"\n)\n\nvar (\n    admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\" // set admin account\n    // provision the token's name and symbol\n    kazainft = grc721.NewBasicNFT(\"KazaiNFT\", \"KNFT\")\n)\n\nfunc init() {\n  MintNNFT(admin, 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := my.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        kazainft.Mint(owner, tid)\n    }\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := kazainft.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := kazainft.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return kazainft.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := kazainft.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := kazainft.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Render\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return kazainft.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"7RVWSIr3R6i84RS9YuatJB48G+hTMcYhemufxYRb7ipOlqgxPUy9qy7m3V8ezOV6M60sLfpuB5nJ7TxuW7FHvw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294532"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazainft","Path":"gno.land/r/demo/kazainft","Files":[{"Name":"package.gno","Body":"package kazainft\n\nimport (\n  \"std\"\n\n  \"gno.land/p/demo/grc/grc721\"\n  \"gno.land/r/demo/users\"\n)\n\nvar (\n    admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\" // set admin account\n    // provision the token's name and symbol\n    kazainft = *grc721.NewBasicNFT(\"KazaiNFT\", \"KNFT\")\n)\n\nfunc init() {\n  MintNNFT(admin, 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := my.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        kazainft.Mint(owner, tid)\n    }\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := kazainft.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := kazainft.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return kazainft.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := kazainft.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := kazainft.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Render\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return kazainft.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"g4UtaQGVNuk72Am33m5J9XmZGtruGmyhshBMVW4ssdwrhkMOipZvx/RYoww9aPSMIz7QwJpXyGeUkPoK7deS/w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294538"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazainft","Path":"gno.land/r/demo/kazainft","Files":[{"Name":"package.gno","Body":"package kazainft\n\nimport (\n  \"std\"\n\n  \"gno.land/p/demo/grc/grc721\"\n  \"gno.land/r/demo/users\"\n)\n\nvar (\n    admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\" // set admin account\n    // provision the token's name and symbol\n    kazainft = grc721.NewBasicNFT(\"KazaiNFT\", \"KNFT\")\n)\n\nfunc init() {\n  MintNNFT(admin, 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := my.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        kazainft.Mint(owner, tid)\n    }\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := kazainft.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := kazainft.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return kazainft.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := kazainft.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := kazainft.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\n// Render\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return kazainft.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"EEz/0nB5GH84YjkYXTMBypI9doHZ7wU0bdjYmfEGuIgdLAcjfR5NLcOadYh699uQm5lq4GZUwSCuBB7s1Ub4og=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294541"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist","Path":"gno.land/p/demo/whitelist","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int64          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int64, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int64 {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, deadline, maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"},{"Name":"whitelistFactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int64, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id)), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"U6zAghwLAX/93VJ1Esghj4z7vitqTSeR2riC7M8444MJ55LJGtmH09iL/JHdVk3+9EgXjcvqdZyeURjxu/9hMw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294916"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist","Path":"gno.land/p/demo/whitelist","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int64          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int64, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int64 {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, deadline, maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"EzwhL9hcLa7ZFqfsq8p836+MeZuwMIvvvexP0hjv6B8fc97hSqgso+qhAVlrCFxI5OWia2e9tPv4onAcowRxWA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294918"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1l9aypkr8xfvs82zeux486ddzec88ty69lue9de","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"1cEl//lIp8G/YIysFk4v6ynVmxxsw6Z9JZ0qNPd+fshwP4GzAjkV0+HjKJTjzpUgwZBXdRTs7KHlv/PEvohRJg=="}],"memo":""},"blockNum":"294924"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l9aypkr8xfvs82zeux486ddzec88ty69lue9de","package":{"Name":"whitelist1","Path":"gno.land/p/demo/whitelist1","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int64          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int64, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int64 {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, deadline, maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A8cOu+SP23y9viXAaK+QAChcbUHxn8txLdj5f3E7x520"},"signature":"kd9fDFSXtkbTKxPvFvGLlqFpfEO6ukxLQ4nr15TdD+N8BKUSRsqhZfNUEquvx0XXygVdr++3BS0f0+rHDTX5PQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294926"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistFactory","Path":"gno.land/r/demo/whitelistFactory","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int64          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int64, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int64 {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, deadline, maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"},{"Name":"whitelistFactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int64, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id)), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"c5X+2ci5cxWlnl3WWp5XLVqSNm9GiC5S4Dy8ioOUbixoK1Wn3EVxWq2H+gAZfVPkXwELrmOQ+qKcV0s5YFniYw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294934"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistFactory","Path":"gno.land/r/demo/whitelistFactory","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int64          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int64, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int64 {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, deadline, maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"},{"Name":"whitelistFactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int64, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id)), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"9eWi0Y6qga91epC9CED78WGvPu408PTo3F1jb7FJUlwZkCNDBrEGTKse6unUAFB+TdMSPbCEg9EmvyQ4+1KYSQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294936"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory","Path":"gno.land/r/demo/whitelistfactory","Files":[{"Name":"whitelist.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int64          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int64, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int64 {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}\n"},{"Name":"whitelist_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, deadline, maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}"},{"Name":"whitelistFactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int64, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id)), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"z6twed/6mImDHCZAhp/3bFirl9NAaWEWaNq2mNJf8Ks6ouB0YJ8ouWYskxMh18zqIEGHcQb2HXlHjZCbh3Bfzw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294938"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory","Path":"gno.land/r/demo/whitelistfactory","Files":[{"Name":"whitelistFactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int64, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id)), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"kMHWHsUNirlFs+aGp6RXhJJrh7rwY5bpp/E8oTbx3Hg2PuC6VwGxsoA9rsps7Qw0jU7bg0cAX36gQqrB0FjLvQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294941"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory","Path":"gno.land/r/demo/whitelistfactory","Files":[{"Name":"whitelistFactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\n// Constructor\nfunc init() {\n\twhitelistTree = avl.NewTree()\n}\n\nfunc NewWhitelist(name string, deadline int64, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"m+y8IVwpXGEa/qmWwITWULln03E2SkXGFPOMaYanpZ8YoPXHGN6eJ//urol/B8JcgiubWggVskUEpNV4VvAE1Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294943"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory","Path":"gno.land/r/demo/whitelistfactory","Files":[{"Name":"whitelistFactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\nfunc NewWhitelist(name string, deadline int64, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"keSjzl9tUHnWwcXPhq+w9le0JvItf8LT/gg+ZW7PbIkViFU1ZBTuFr4CS3KpGJeYR9clRMoMcBFxoWKjcXzwog=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294947"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelistfactory","Path":"gno.land/r/demo/whitelistfactory","Files":[{"Name":"whitelistFactory.gno","Body":"package whitelistfactory\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/whitelist\"\n)\n\n// State variables\nvar (\n\twhitelistTree *avl.Tree\n)\n\nfunc NewWhitelist(name string, deadline int, maxUsers int64) (int, string) {\n\n\t// Check if deadline is in the past\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn -1, \"deadline cannot be in the past\"\n\t}\n\n\t// Get user who sent the transaction\n\ttxSender := std.GetOrigCaller()\n\n\t// We will use the current size of the tree for the ID\n\tid := whitelistTree.Size()\n\n\tif maxUsers \u003c= 0 {\n\t\treturn -1, \"Maximum number of users cannot be less than 1\"\n\t}\n\n\t// Create new whitelist instance\n\tw := whitelist.NewWhitelist(name, deadline, maxUsers, txSender)\n\n\t// Update AVL tree with new state\n\tsuccess := whitelistTree.Set(strconv.Itoa(id), w)\n    if success {\n\t    return id, \"successfully created whitelist!\"\n    }\n    return -1, \"could not create new whitelist\"\n}\n\nfunc SignUpToWhitelist(whitelistID int) string {\n\t// Get ID and convert to string\n\tid := strconv.Atoi(whitelistID)\n\t\n\t// Get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// Try to get specific whitelist from AVL tree\n\t// Note: AVL tree keys are of the string type\n\twhiteListRaw, exists := whitelistTree.Get(id)\n\n\tif !exists {\n\t\treturn \"whitelist does not exist\"\n\t}\n\n\t// Cast raw Tree data into \"Whitelist\" type\n\tw, _ := whiteListRaw.(*whitelist.Whitelist)\n\n\tddl := w.GetWhitelistDeadline()\n\n\t// error handling\n\tif w.IsOnWhitelist(txSender) {\n\t\treturn \"user already in whitelist\"\n\t}\n\n\t// If deadline has passed\n\tif ddl \u003c= std.GetHeight() {\n\t\treturn \"whitelist already closed\"\n\t}\n\n\t// If whitelist is full\n\tif w.GetMaxUsers() \u003c= len(w.GetWhitelistedUsers()) {\n\t\treturn \"whitelist full\"\n\t}\n\n\t// Add txSender to user list\n\tw.AddUserToList(txSender)\n\n\t// Update the AVL tree with new state\n\tsuccess := whitelistTree.Set(id, w)\n\tif success {\n\t    return ufmt.Sprintf(\"successfully added user to whitelist %d\", whitelistID)\n\t}\n    return \"failed to sign up\"\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHomepage()\n\t}\n\n\treturn \"unknown page\"\n}\n\nfunc renderHomepage() string {\n\n\t// Define empty buffer\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Sign up to a Whitelist\\n\\n\")\n\n\t// If no whitelists have been created\n\tif whitelistTree.Size() == 0 {\n\t\tb.WriteString(\"### No whitelists available currently!\")\n\t\treturn b.String()\n\t}\n\n\t// Iterate through AVL tree\n\twhitelistTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Whitelist struct\n\t\tw := value.(*whitelist.Whitelist)\n\t\tddl := w.GetWhitelistDeadline()\n\n\t\t// Add whitelist name\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Whitelist #%s: %s\\n\",\n\t\t\t\tkey, // whitelist ID\n\t\t\t\tw.GetWhitelistName(),\n\t\t\t),\n\t\t)\n\n\t\t// Check if whitelist deadline is past due\n\t\tif ddl \u003e std.GetHeight() {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups close at block %d\\n\",\n\t\t\t\t\tw.GetWhitelistDeadline(),\n\t\t\t\t),\n\t\t\t)\n\t\t} else {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\n\t\t\t\t\t\"Whitelist sign-ups closed!\\n\\n\",\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\t// List max number of users in waitlist\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"Maximum number of users in whitelist: %d\\n\\n\",\n\t\t\t\tw.GetMaxUsers(),\n\t\t\t),\n\t\t)\n\n\t\t// List all users that are currently whitelisted\n\t\tif users := w.GetWhitelistedUsers(); len(users) \u003e 0 {\n\t\t\tb.WriteString(\n\t\t\t\tufmt.Sprintf(\"Currently whitelisted users: %d\\n\\n\", len(users)),\n\t\t\t)\n\n\t\t\tfor index, user := range users {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"#%d - %s  \\n\", index, user),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tb.WriteString(\"No addresses are whitelisted currently\\n\")\n\t\t}\n\n\t\tb.WriteString(\"\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"Xa7/jLLTkwZJlokzg+vzHLGTuKKJLINnUzupmaTugfBrJ5VD/NvhM5HnjBdXMkpi6UbR0QRGOCJGzJSeEW6ZWA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294949"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist","Path":"gno.land/p/demo/whitelist","Files":[{"Name":"asd.gno","Body":"import (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int64          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int64 {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}"},{"Name":"asdsad_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, deadline, maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}\n\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"hemOUwraNrHXOWMEL0+dtMsttNltycPvYTxwdTD3nVIc24rkJyKoE7ApXoq3gIC9lGR4N5QwdvvEdSGzk8E86w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294955"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist","Path":"gno.land/p/demo/whitelist","Files":[{"Name":"asd.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int64          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int64 {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}"},{"Name":"asdsad_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, deadline, maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}\n\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"3uCwU1y/I+RBBtKvZmIkrgk6QOOQ5uM1nIAaj832hhkY3SmHnX+UkY4yPC2xa7Vb1+J/Q1+c8c7Pc7xjTRLIIQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294957"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist","Path":"gno.land/p/demo/whitelist","Files":[{"Name":"asd.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}"},{"Name":"asdsad_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}\n\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"SwVsfDna8eB+RFAdBzaz95LBfiLHCrd/m7rP/WQ/hZomTkXPDvnnQhiob/HbiUUCHEzVqRkaa58TgRhRhRgRfA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294961"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist","Path":"gno.land/p/leon/whitelist","Files":[{"Name":"asd.gno","Body":"package whitelistnew\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}"},{"Name":"asdsad_test.gno","Body":"package whitelistnew\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}\n\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"BuRPJ/U9V24ebu7semZSggGRD1haE6XGRDAMKWd4KI86yN3/k82MxD8qw8R+7pBT9W0V3SL2Yqqo+7Tu8U56fg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294963"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"whitelist","Path":"gno.land/p/leon/whitelist","Files":[{"Name":"asd.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n)\n\ntype Whitelist struct {\n\tname     string         // Name of whitelist\n\towner    std.Address    // Owner of whitelist\n\tdeadline int          // Whitelist deadline in block height\n\tmaxUsers int            // Max number of users in whitelist\n\tuserList []std.Address  // Currently signed-up users\n}\n\n// Create a new Whitelist instance from arguments\nfunc NewWhitelist(name string, deadline int, maxUsers int, owner std.Address) *Whitelist {\n\treturn \u0026Whitelist{\n\t\tname:     name,\n\t\towner:    owner,\n\t\tdeadline: deadline,\n\t\tmaxUsers: maxUsers,\n\t\tuserList: make([]std.Address, 0),\n\t}\n}\n\nfunc (w *Whitelist) GetWhitelistName() string {\n\treturn w.name\n}\n\nfunc (w *Whitelist) GetWhitelistOwner() std.Address {\n\treturn w.owner\n}\n\nfunc (w *Whitelist) GetWhitelistDeadline() int {\n\treturn w.deadline\n}\n\nfunc (w *Whitelist) GetMaxUsers() int {\n\treturn w.maxUsers\n}\n\nfunc (w *Whitelist) GetWhitelistedUsers() []std.Address {\n\treturn w.userList\n}\n\nfunc (w *Whitelist) AddUserToList(userToAdd std.Address) bool {\n\tw.userList = append(w.userList, userToAdd)\n\treturn true\n}\n\n// Check if userToCheck is on whitelist w\nfunc (w *Whitelist) IsOnWhitelist(userToCheck std.Address) bool {\n\tfor _, user := range w.GetWhitelistedUsers() {\n\t\tif user.String() == userToCheck.String() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if txSender is owner of w\nfunc (w *Whitelist) IsOwnerOfWhitelist(txSender std.Address) bool {\n\treturn txSender == w.GetWhitelistOwner()\n}"},{"Name":"asdsad_test.gno","Body":"package whitelist\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestWhitelist_Setup(t *testing.T) {\n\tvar (\n\t\tname     = \"First whitelist!\"\n\t\tdeadline = std.GetHeight() + 100 // get future height\n\t\tmaxUsers = 100\n\t)\n\n    // generate mock address\n\talice := testutils.TestAddress(\"alice\")\n\n    // use mock address to execute test transaction\n\tstd.TestSetOrigCaller(alice)\n\n\tw := NewWhitelist(name, int(deadline), maxUsers, alice)\n\n\tif w.GetWhitelistOwner() != alice {\n\t\tt.Fatal(\"invalid whitelist owner\")\n\t}\n\n\tif w.GetMaxUsers() != maxUsers {\n\t\tt.Fatal(\"invalid max user number\")\n\t}\n\n\tif w.GetWhitelistDeadline() != deadline {\n\t\tt.Fatal(\"invalid deadline\")\n\t}\n\n\tif len(w.GetWhitelistedUsers()) != 0 {\n\t\tt.Fatal(\"invalid whitelisted user list\")\n\t}\n}\n\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"e9INpz07WCf0JDBH/ZQyYrBub81NduVEiX5aN7TtyQNbQ7fXacWKp/lADciuC6Om274hBZUOg2A/WWbI5ztg3Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"294965"}
