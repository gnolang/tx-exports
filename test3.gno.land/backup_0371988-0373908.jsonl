{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1qlpyq66qyhnmt4qnmcz3eefn50z8nhvuh9yuts","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"ml8pjiXQgfCUTMI47Wy4VQAwspB+KOWzh9mfBtBPBIQ3clX33iDI94PhbEGN+Jt3Xq3g4xcvqanjD6qKCFoWxA=="}],"memo":""},"blockNum":"372091"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1yghm3zzf6u3gqrqecx0rhqrslhtfsgf5h9kggy","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"zv8c9x0EqvmKpCam1rOOvnR7N/Qad0OHAUjWVdWEzEtgVy1YYDgfWovFbyES8r1aVhvZUsIKROq0VauXWONVHg=="}],"memo":""},"blockNum":"372123"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1la2lme833a80jx9x4veg02gc9xkcnxrqrs0qpf","package":{"Name":"TriskelBZH","Path":"gno.land/r/demo2/TriskelBZH","Files":[{"Name":"package.gno","Body":"package TriskelBZH\n\nfunc Render(path string) string {\n  return \"TriskelBZH !\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ay+iQ/9uyFNqmkxdpMH+WGh1JPQoQgxlVmCbx4XVpWWh"},"signature":"NNbccjxAUcuQmITEf6PfSfPL59DUqBQYGgCnPEhpuzdVFNrl4sIJ3D8dXcdQbS+mGNVWqLByNfGngPq0DELhWQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372355"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1la2lme833a80jx9x4veg02gc9xkcnxrqrs0qpf","package":{"Name":"TriskelBZH","Path":"gno.land/r/demo2/TriskelBZH","Files":[{"Name":"package.gno","Body":"package TriskelBZH\n\nfunc Render(path string) string {\n  return \"TriskelBZH !\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ay+iQ/9uyFNqmkxdpMH+WGh1JPQoQgxlVmCbx4XVpWWh"},"signature":"u9x4Gm71bUv96EzR1frR5KK++t3/Nenn7EL9/Q72Qdwm7Gqb9lR6zHYr9ubRhIBVEy61xy+TAhoXSxZ8qXBtPg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372357"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1la2lme833a80jx9x4veg02gc9xkcnxrqrs0qpf","package":{"Name":"TriskelBZH","Path":"gno.land/r/demo2/TriskelBZH","Files":[{"Name":"package.gno","Body":"package TriskelBZH\n\nfunc Render(path string) string {\n  return \"TriskelBZH !\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ay+iQ/9uyFNqmkxdpMH+WGh1JPQoQgxlVmCbx4XVpWWh"},"signature":"RtTUc9bOo4MBewPQiSvR866lDb9K9N5RlqA+ytBRvbdVWNmrTBAKzCQIbI+N0a5/u2WYvlGCk++UmSfcn9qWWQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372360"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1la2lme833a80jx9x4veg02gc9xkcnxrqrs0qpf","package":{"Name":"TriskelBZH","Path":"gno.land/r/demo2/TriskelBZH","Files":[{"Name":"package.gno","Body":"package TriskelBZH\n\nfunc Render(path string) string {\n\treturn \"TriskelBZH !\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ay+iQ/9uyFNqmkxdpMH+WGh1JPQoQgxlVmCbx4XVpWWh"},"signature":"9hUt61AGCUS3PaxfNYmNssd3lI25AtjBLaPTljqKsrACsV46TrpJwfwrZ9EP/KkyZuDQaLM17XsLsvtVKMIdUA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372363"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"N44giGLCGd/emzE72jltytqHsbZ8IvOPZjJ5PIP9t5kxxzwRYEpGz5rkJpugRrhFI/6R6Ixy/YFGXNAtWuxHlg=="}],"memo":""},"blockNum":"372367"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1la2lme833a80jx9x4veg02gc9xkcnxrqrs0qpf","package":{"Name":"TriskelBZH","Path":"gno.land/r/demo2/TriskelBZH","Files":[{"Name":"package.gno","Body":"package triskelbzh\n\nfunc Render(path string) string {\n\treturn \"TriskelBZH !\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ay+iQ/9uyFNqmkxdpMH+WGh1JPQoQgxlVmCbx4XVpWWh"},"signature":"yb+ShcWi2ffZXZYJxXmOU+UMq+yR58dpKMA1x0K1Lp8omf5xI9gM+SJKI/gLHpYYdIT0Ejem3t480Y9cqMtXzQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372369"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1la2lme833a80jx9x4veg02gc9xkcnxrqrs0qpf","package":{"Name":"triskelbzh","Path":"gno.land/r/demo2/triskelbzh","Files":[{"Name":"package.gno","Body":"package triskelbzh\n\nfunc Render(path string) string {\n\treturn \"triskelbzh\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ay+iQ/9uyFNqmkxdpMH+WGh1JPQoQgxlVmCbx4XVpWWh"},"signature":"EKu3VIPLT132wOA31YU7ivae6VaGrYHyMTwGopEQY3ZpGJAxm2n6yuxTyjaYKGPL5oawFVkhafeNluJPrnNgsw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372371"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"9H7jp7v5uPuEUdmDdS2Dfa0YlWPlgyXlMjtpMyHthExp5Ew2kKqpwVjDqThxc1BFIzhf6bnMPit3CP5mOxNQ1g=="}],"memo":""},"blockNum":"372391"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1zd3aykct4yr4steu6f6n9t9z9emwhrkc0wgzef","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"6Rl3bPoLmynJCvxzpO8xYB85inSuaXcRJ54h5qpk0nlKQ7qKIzwBsszbLqFOAUjDu+bPzvW4PS2tvgK/QfU34w=="}],"memo":""},"blockNum":"372498"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1zd3aykct4yr4steu6f6n9t9z9emwhrkc0wgzef","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"nvT4pj0d211UziNwm6TdUqrBV2OpDe8WCoEkF2rQ+5gwrxki5hI8V6zUG/TljcE4Ga2RNQ8zF/gdR5r/UVO9mA=="}],"memo":""},"blockNum":"372503"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1zd3aykct4yr4steu6f6n9t9z9emwhrkc0wgzef","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"iI31pmyLyYn6wHO4nHnLewqktbsNprbS//C+wEp81zsvkTnHd57hSBdIAlP+oj4Zhh7UJTmjx3hsfl/jXI5nmQ=="}],"memo":""},"blockNum":"372507"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1zd3aykct4yr4steu6f6n9t9z9emwhrkc0wgzef","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"IYPWvyw5446E/gCDr2Ks6pojbzDr1g/XOmU9jN4TOCZ+VE4DE+G5+RNPvmK5EOfJok7lrzN/lRB9fM/2c8KKqg=="}],"memo":""},"blockNum":"372509"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1zd3aykct4yr4steu6f6n9t9z9emwhrkc0wgzef","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"26y7F0NyK2q19BgnLxViWCwO2oOO1zQNbA65JjLkURsaSbImR7wdxklFntWCPJlmJ5ivq0TUxCq51ELJmbuK1w=="}],"memo":""},"blockNum":"372511"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1zd3aykct4yr4steu6f6n9t9z9emwhrkc0wgzef","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"gF6kN3X1yDR92OkY3ZV/iwcpCA86cVDCgDN8J8uATB4fpNMgUPDmxtW5+RzLhgbGMaKRLdBejtfkukguOWDY2g=="}],"memo":""},"blockNum":"372514"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1rjvp8rxukfel3c22chcnw9yu4zqz7n4nypdjeq","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"5mucPu1VQAcwTzZAkL3LTdoQbAB0b3J59ltls1crKzgzikpgOqZkaYjf5liKLzz1xzp3pinPK5sL7/EcoGxcwQ=="}],"memo":""},"blockNum":"372539"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1rjvp8rxukfel3c22chcnw9yu4zqz7n4nypdjeq","package":{"Name":"banditia","Path":"gno.land/r/pirates/banditia","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A823EdOmNQwSmpdC87v/iiurQPnSyFdjZtW2EYsXfYtA"},"signature":"d15p+oGWTkNKLjCrgCa2rCwSYjrj1jwSJcA8yqFk0Pk0P8gPFPJ2xsxQOri3oSuQp2RFTXm425fFEK3cBNThfQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372541"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1rjvp8rxukfel3c22chcnw9yu4zqz7n4nypdjeq","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"gNfqtqsuH+4Ezqhqd1WuxK5PVHcoj3v59FyHqwb+VoYNI7CgnRI0fQJW1RqgBPQ6jYDl9svgcB1oCP+T1ad9kQ=="}],"memo":""},"blockNum":"372543"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1rjvp8rxukfel3c22chcnw9yu4zqz7n4nypdjeq","package":{"Name":"banditia","Path":"gno.land/r/pirates/banditia","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A823EdOmNQwSmpdC87v/iiurQPnSyFdjZtW2EYsXfYtA"},"signature":"kIKXGpTHFcfiLZ2s5bZSt0GeTvlVz3lHUm9zI1xNfFAb/LWqFTLCn1ECCyFS4dAT/vKfisuPuTiVyvL3DOCtSQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372545"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1rjvp8rxukfel3c22chcnw9yu4zqz7n4nypdjeq","package":{"Name":"banditia","Path":"gno.land/r/pirates/banditia","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A823EdOmNQwSmpdC87v/iiurQPnSyFdjZtW2EYsXfYtA"},"signature":"/OXbNowyAFfqQmoEhpSqQL3LPro9OMxKKtctdDf+9xR8UBE1XyNc/I9Z6PBx8dwlNI/aXDi3DMGB/nPw5K0AIA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372547"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1rjvp8rxukfel3c22chcnw9yu4zqz7n4nypdjeq","package":{"Name":"banditia","Path":"gno.land/r/pirates/banditia","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A823EdOmNQwSmpdC87v/iiurQPnSyFdjZtW2EYsXfYtA"},"signature":"3V/NsKYKSB7f2sazAOZ+mNaRWOnpFhzVJWqCQMkuwAMsSN9KhGp+RKUtE4U2yuWmV3U3eUXMix0BB7/EMLjoMQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372552"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1rjvp8rxukfel3c22chcnw9yu4zqz7n4nypdjeq","package":{"Name":"banditia","Path":"gno.land/r/pirates/banditia","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A823EdOmNQwSmpdC87v/iiurQPnSyFdjZtW2EYsXfYtA"},"signature":"mVMhN9jMC2LeKdzduxv1dOIKqCoJdfL4nhWs0woVSYVAsiJhaqB25pb5jMkURvx7Gb086cRaL2yV6JMTdCfGJw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372555"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1rjvp8rxukfel3c22chcnw9yu4zqz7n4nypdjeq","package":{"Name":"bandit","Path":"gno.land/r/banditia/bandit","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A823EdOmNQwSmpdC87v/iiurQPnSyFdjZtW2EYsXfYtA"},"signature":"VCGQxeX2JhNgt+yF7ebinYGClsQLhSF4CjhNYQlhi3sEXD4WCijlLEBmSDW/RzQ6JQ6W0ofi81ZYzXsrJt7iag=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372560"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1dvfhkhjp0qgrrm4tr065aqz6ntjs0qr7rtmxuu","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"EQPaf5ZVh8bbHcIZci9dVfeEv97g4gm7Hyc26N5omMIjMO/LHBNSU1J9lIlYeGZG52T4pd8JnzXV6rtNRUsaoA=="}],"memo":""},"blockNum":"372565"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1uf8u5jf2m9l80g0zsfq7tufl3qufqc4393jtkl","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"33000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AitYIWT3az4Jx3hGzTapJ6hyalJ6EYgqQCpYoe7Gx2Sw"},"signature":"RYIBFbYTVAFbWFO0YmZHprWccMp0Rlf4zKvF+Fk9avIQkGZDjC0SD/jfqO/20UdDbEvfIfUyT8ONrdYySCsseQ=="}],"memo":""},"blockNum":"372591"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"10000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"gcGoORwiZdLcRTCpuMVIuo9jdyKgtlX9yxXRCgoiVBEM1S4pNdmCt5zcIRcuxBzzMiAd5xrcwqX7lLkHzvuHdg=="}],"memo":""},"blockNum":"372593"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"8QiznC99MSF45Wlv6kVHgjKMekJ0dBjJa4XoufzRh4NsenKVRpW1qA7v4pyI7Te5qR7YeIxjaeHdcaeNTXfzbA=="}],"memo":""},"blockNum":"372595"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8","package":{"Name":"closure","Path":"gno.land/r/demo2/closure","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"close.gno","Body":"package y\n\nfunc Foo(cb func(value uint64)) {\n  // ... cryptopunkstar\n  cb(12345)\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsfGYP4d45M3jSq3Cs02mX9XC3pIVzEkSG91ZXpsKZ2s"},"signature":"XMXo3EMN/zmepjvAmSjcHzvTIGWrO2ARd3IO3liZGRBuvX/h0w11l0PooLxClbaNBr24IDsa4jAT1AMJr1QZ4Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372598"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"v1pre1","Path":"gno.land/p/demo/gnome/dao/v1pre1","Files":[{"Name":"record_test.gno","Body":"package gnome\n\nimport (\n\t\"testing\"\n\n\tgnome \"gno.land/p/demo/gnome/dao/v1pre1\"\n)\n\nfunc TestVotingRecord(t *testing.T) {\n\t// Act\n\trecord := NewVotingRecord()\n\n\t// Assert\n\tif got := record.Votes(); got != nil {\n\t\tt.Fatalf(\"expected no votes, got: %d\", len(got))\n\t}\n\n\tif got := record.VoteCount(); got != 0 {\n\t\tt.Fatalf(\"expected no vote count: 0, got: %d\", got)\n\t}\n}\n\nfunc TestVotingRecordAdd(t *testing.T) {\n\t// Arrange\n\trecord := NewVotingRecord()\n\tvote := gnome.Vote{Choice: gnome.ChoiceYes}\n\n\t// Act\n\trecord.Add(vote)\n\n\t// Assert\n\tvotes := record.Votes()\n\tif c := len(votes); c != 1 {\n\t\tt.Fatalf(\"expected one votes, got: %d\", c)\n\t}\n\n\tif got := votes[0]; got != vote {\n\t\tt.Fatalf(\"expected vote: %v, got: %v\", vote, got)\n\t}\n\n\tif got := record.VoteCount(); got != 1 {\n\t\tt.Fatalf(\"expected vote count: %d, got: %d\", 1, got)\n\t}\n\n\tif got := record.Get(vote.Choice); got != 1 {\n\t\tt.Fatalf(\"expected record to get one '%v' count, got: %d\", gnome.ChoiceYes, got)\n\t}\n\n\trecord.Iterate(func(v gnome.VoteChoice, count uint) bool {\n\t\tif v != gnome.ChoiceYes {\n\t\t\tt.Fatalf(\"expected iterate choice: %v, got: %v\", gnome.ChoiceYes, v)\n\t\t}\n\n\t\tif count != 1 {\n\t\t\tt.Fatalf(\"expected iterate vote count: %d, got: %d\", 1, count)\n\t\t}\n\n\t\treturn false\n\t})\n}\n\nfunc TestVotingRecordRemove(t *testing.T) {\n\tt.Skip(\"TODO: Write unit test for VotingRecord.Remove()\")\n}\n\nfunc TestSelectChoiceByMajority(t *testing.T) {\n\tt.Skip(\"TODO: Write unit test for SelectChoiceByMajority\")\n}\n\nfunc TestSelectChoiceBySuperMajority(t *testing.T) {\n\tt.Skip(\"TODO: Write unit test for SelectChoiceBySuperMajority\")\n}\n"},{"Name":"proposal_test.gno","Body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/testutils\"\n\n\tgnome \"gno.land/p/demo/gnome/dao/v1pre1\"\n)\n\nvar (\n\tfutureTime = time.Now().Add(time.Hour)\n\tzeroTime   = time.Time{}\n)\n\n// TODO: Improve proposal unit test using test cases and adding missing methods\nfunc TestProposalWithStandardStrategy(t *testing.T) {\n\tcases := []struct {\n\t\tname, title, description string\n\t\tdao                      *gnome.DAO\n\t\terr                      error\n\t}{\n\t\t{\n\t\t\tname:        \"ok\",\n\t\t\tdao:         gnome.MustNew(\"test\", \"Test\", \"Test DAO\"),\n\t\t\ttitle:       \"Proposal\",\n\t\t\tdescription: \"Test proposal\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty DAO\",\n\t\t\terr:  errors.New(\"proposal DAO is required\"),\n\t\t},\n\t\t{\n\t\t\tname: \"empty title\",\n\t\t\tdao:  gnome.MustNew(\"test\", \"Test\", \"Test DAO\"),\n\t\t\terr:  errors.New(\"proposal title is required\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"empty description\",\n\t\t\tdao:   gnome.MustNew(\"test\", \"Test\", \"Test DAO\"),\n\t\t\ttitle: \"Proposal\",\n\t\t\terr:   errors.New(\"proposal description is required\"),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tid := gnome.ID(1)\n\t\t\tproposer := testutils.TestAddress(\"proposer\")\n\t\t\tstrategy := testStrategy{}\n\t\t\tstatus := gnome.StatusActive\n\n\t\t\t// Act\n\t\t\tproposal, err := gnome.NewProposal(id, strategy, proposer, tc.dao, tc.title, tc.description)\n\n\t\t\t// Assert\n\t\t\tassertError(t, tc.err, err)\n\t\t\tif tc.err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got := proposal.ID(); got != id {\n\t\t\t\tt.Fatalf(\"expected ID: %d, got: %d\", id, got)\n\t\t\t}\n\n\t\t\tif got := proposal.DAO(); got.Name() != tc.dao.Name() {\n\t\t\t\tt.Fatalf(\"expected DAO: '%s', got: '%s'\", tc.dao.Name(), got.Name())\n\t\t\t}\n\n\t\t\tif got := proposal.Title(); got != tc.title {\n\t\t\t\tt.Fatalf(\"expected title: '%s', got: '%s'\", tc.title, got)\n\t\t\t}\n\n\t\t\tif got := proposal.Description(); got != tc.description {\n\t\t\t\tt.Fatalf(\"expected description: '%s', got: '%s'\", tc.description, got)\n\t\t\t}\n\n\t\t\tif got := proposal.Proposer(); got != proposer {\n\t\t\t\tt.Fatalf(\"expected proposer: '%s', got: '%s'\", proposer, got)\n\t\t\t}\n\n\t\t\tif got := proposal.CreatedAt(); got.IsZero() {\n\t\t\t\tt.Fatalf(\"expected a valid creation time, got: '%s'\", got.String())\n\t\t\t}\n\n\t\t\tif got := proposal.VotingDeadline(); got.IsZero() {\n\t\t\t\tt.Fatalf(\"expected a valid deadline time, got: '%s'\", got.String())\n\t\t\t}\n\n\t\t\tnow := time.Now()\n\t\t\tif got := proposal.VotingDeadline(); got.Before(now) { // TODO: Using after makes assertion fail (?)\n\t\t\t\tt.Fatalf(\"expected deadline to happen after: '%s', got: '%s'\", now.String(), got.String())\n\t\t\t}\n\n\t\t\tif got := proposal.Status(); got != status {\n\t\t\t\tt.Fatalf(\"expected status: %d, got: %d\", status, got)\n\t\t\t}\n\n\t\t\tif got := proposal.Strategy().Name(); got != strategy.Name() {\n\t\t\t\tt.Fatalf(\"expected strategy: '%s', got: '%s'\", strategy.Name(), got)\n\t\t\t}\n\n\t\t\tif got := proposal.Strategy().Name(); got != strategy.Name() {\n\t\t\t\tt.Fatalf(\"expected strategy: '%s', got: '%s'\", strategy.Name(), got)\n\t\t\t}\n\n\t\t\tif c := len(proposal.Votes()); c != 0 {\n\t\t\t\tt.Fatalf(\"expected no votes, got: %d votes\", c)\n\t\t\t}\n\n\t\t\tif c := proposal.VotingRecord().VoteCount(); c != 0 {\n\t\t\t\tt.Fatalf(\"expected an empty votes record, got: %d records\", c)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProposalWithdraw(t *testing.T) {\n\t// TODO: Test success cases where proposal status is review\n\twantErr := gnome.ErrReviewStatusRequired\n\twantStatus := gnome.StatusWithdrawed\n\tproposal := mustCreateProposal(t, testStrategy{}, gnome.WithReviewDeadline(futureTime))\n\n\tif err := proposal.Withdraw(); err != nil {\n\t\tt.Fatalf(\"expected no error, got: '%s'\", err.Error())\n\t}\n\n\tif err := proposal.Withdraw(); err != wantErr {\n\t\tt.Fatalf(\"expected error: '%s', got: '%s'\", wantErr.Error(), err.Error())\n\t}\n\n\tif got := proposal.Status(); got != wantStatus {\n\t\tt.Fatalf(\"expected status: %d, got: %d\", wantStatus, got)\n\t}\n}\n\nfunc TestProposalVote(t *testing.T) {\n\tmemberAddr := testutils.TestAddress(\"member\")\n\tsetupDAOMember := func(p *gnome.Proposal) {\n\t\tp.DAO().AddMember(memberAddr)\n\t}\n\n\tcases := []struct {\n\t\tname, reason string\n\t\taddress      std.Address\n\t\tchoice       gnome.VoteChoice\n\t\tvoteCount    int\n\t\toptions      []gnome.ProposalOption\n\t\tsetup        func(*gnome.Proposal)\n\t\terr          error\n\t}{\n\t\t{\n\t\t\tname:      \"ok\",\n\t\t\taddress:   memberAddr,\n\t\t\tchoice:    gnome.ChoiceYes,\n\t\t\tvoteCount: 1,\n\t\t\tsetup:     setupDAOMember,\n\t\t},\n\t\t{\n\t\t\tname:    \"proposal not active\",\n\t\t\taddress: memberAddr,\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\toptions: []gnome.ProposalOption{\n\t\t\t\tgnome.WithReviewDeadline(futureTime),\n\t\t\t},\n\t\t\terr: gnome.ErrProposalNotActive,\n\t\t\tsetup: func(p *gnome.Proposal) {\n\t\t\t\tsetupDAOMember(p)\n\t\t\t\tp.Withdraw()\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"vote with invalid reason\",\n\t\t\taddress: memberAddr,\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\treason:  \"1234\",\n\t\t\terr:     gnome.ErrInvalidReason,\n\t\t\tsetup:   setupDAOMember,\n\t\t},\n\t\t{\n\t\t\tname:      \"already voted\",\n\t\t\taddress:   memberAddr,\n\t\t\tchoice:    gnome.ChoiceYes,\n\t\t\tvoteCount: 1,\n\t\t\toptions: []gnome.ProposalOption{\n\t\t\t\tgnome.WithVoteChangeDuration(-1),\n\t\t\t},\n\t\t\terr: gnome.ErrAlreadyVoted,\n\t\t\tsetup: func(p *gnome.Proposal) {\n\t\t\t\tsetupDAOMember(p)\n\t\t\t\tp.Vote(memberAddr, gnome.ChoiceYes, \"\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"vote after proposal deadline\",\n\t\t\taddress: memberAddr,\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\toptions: []gnome.ProposalOption{\n\t\t\t\tgnome.WithVotingDeadline(zeroTime),\n\t\t\t},\n\t\t\terr:   gnome.ErrProposalVotingDeadlineMet,\n\t\t\tsetup: setupDAOMember,\n\t\t},\n\t\t{\n\t\t\tname:    \"non member vote not allowed\",\n\t\t\taddress: memberAddr,\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\terr:     gnome.ErrMemberVoteNotAllowed,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tproposal := mustCreateProposal(t, testStrategy{}, tc.options...)\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(proposal)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\terr := proposal.Vote(tc.address, tc.choice, tc.reason)\n\n\t\t\t// Assert\n\t\t\tassertError(t, tc.err, err)\n\n\t\t\tvotes := proposal.Votes()\n\t\t\tvoteCount := len(votes)\n\t\t\tif voteCount != tc.voteCount {\n\t\t\t\tt.Fatalf(\"expected %d vote(s), got: %d\", tc.voteCount, voteCount)\n\t\t\t}\n\n\t\t\tif voteCount \u003e 0 {\n\t\t\t\tif got := votes[0].Address; got != tc.address {\n\t\t\t\t\tt.Fatalf(\"expected vote address: '%s', got: '%s'\", tc.address, got)\n\t\t\t\t}\n\n\t\t\t\tif got := votes[0].Choice; got != tc.choice {\n\t\t\t\t\tt.Fatalf(\"expected vote choice: '%s', got: '%s'\", tc.choice, got)\n\t\t\t\t}\n\n\t\t\t\tif got := votes[0].Reason; got != tc.reason {\n\t\t\t\t\tt.Fatalf(\"expected vote reason: '%s', got: '%s'\", tc.reason, got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProposalTally(t *testing.T) {\n\taddresses := [3]std.Address{\n\t\ttestutils.TestAddress(\"member1\"),\n\t\ttestutils.TestAddress(\"member2\"),\n\t\ttestutils.TestAddress(\"member3\"),\n\t}\n\tsetupDAOMembers := func(p *gnome.Proposal) {\n\t\tdao := p.DAO()\n\t\tfor _, addr := range addresses {\n\t\t\tdao.AddMember(addr)\n\t\t}\n\t}\n\n\t// TODO: Test tally with upper level DAO votes\n\tcases := []struct {\n\t\tname                 string\n\t\tvotes                []gnome.Vote\n\t\tchoice               gnome.VoteChoice\n\t\tstrategy             gnome.ProposalStrategy\n\t\tstatus               gnome.ProposalStatus\n\t\tvotingDeadlinePassed bool\n\t\toptions              []gnome.ProposalOption\n\t\tsetup                func(*gnome.Proposal)\n\t\terr                  error\n\t}{\n\t\t{\n\t\t\tname: \"proposal pass\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Address: addresses[0], Choice: gnome.ChoiceYes},\n\t\t\t\t{Address: addresses[1], Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice:   gnome.ChoiceYes,\n\t\t\tstrategy: testStrategy{gnome.ChoiceYes},\n\t\t\tstatus:   gnome.StatusPassed,\n\t\t\toptions:  []gnome.ProposalOption{gnome.WithVotingDeadline(zeroTime)},\n\t\t\tsetup:    setupDAOMembers,\n\t\t},\n\t\t{\n\t\t\tname: \"proposal rejected\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Address: addresses[0], Choice: gnome.ChoiceYes},\n\t\t\t\t{Address: addresses[1], Choice: gnome.ChoiceNo},\n\t\t\t\t{Address: addresses[2], Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tstrategy: testStrategy{gnome.ChoiceNo},\n\t\t\tstatus:   gnome.StatusRejected,\n\t\t\toptions:  []gnome.ProposalOption{gnome.WithVotingDeadline(zeroTime)},\n\t\t\tsetup:    setupDAOMembers,\n\t\t},\n\t\t{\n\t\t\tname: \"proposal incomplete\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Address: addresses[0], Choice: gnome.ChoiceYes},\n\t\t\t\t{Address: addresses[1], Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tstrategy: testStrategy{},\n\t\t\tstatus:   gnome.StatusLowParticipation,\n\t\t\toptions:  []gnome.ProposalOption{gnome.WithVotingDeadline(zeroTime)},\n\t\t\tsetup:    setupDAOMembers,\n\t\t},\n\t\t{\n\t\t\tname: \"no quorum\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Address: addresses[0], Choice: gnome.ChoiceYes},\n\t\t\t\t{Address: addresses[1], Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tstrategy: testStrategy{},\n\t\t\tstatus:   gnome.StatusLowParticipation,\n\t\t\toptions:  []gnome.ProposalOption{gnome.WithVotingDeadline(zeroTime)},\n\t\t\tsetup:    setupDAOMembers,\n\t\t},\n\t\t{\n\t\t\tname:     \"proposal not active\",\n\t\t\tstatus:   gnome.StatusWithdrawed,\n\t\t\toptions:  []gnome.ProposalOption{gnome.WithReviewDeadline(futureTime)},\n\t\t\tstrategy: testStrategy{},\n\t\t\tsetup: func(p *gnome.Proposal) {\n\t\t\t\tp.Withdraw()\n\t\t\t},\n\t\t\terr: gnome.ErrProposalNotActive,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tproposal := mustCreateProposal(t, tc.strategy, tc.options...)\n\n\t\t\tfor _, v := range tc.votes {\n\t\t\t\t// Add votes directly to the record because deadline might be expired for some test cases\n\t\t\t\tproposal.votingRecord.Add(v)\n\t\t\t}\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(proposal)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\terr := proposal.Tally()\n\n\t\t\t// Assert\n\t\t\tassertError(t, tc.err, err)\n\n\t\t\tif got := proposal.Status(); got != tc.status {\n\t\t\t\tt.Fatalf(\"expected status: %d, got: %d\", tc.status, got)\n\t\t\t}\n\n\t\t\tif got := proposal.Choice(); got != tc.choice {\n\t\t\t\tt.Fatalf(\"expected winner choice: %d, got: %d\", tc.choice, got)\n\t\t\t}\n\n\t\t\t// TODO: Test proposal execution when a strategy implements Executer\n\t\t})\n\t}\n}\n\nfunc mustCreateProposal(t *testing.T, s gnome.ProposalStrategy, options ...gnome.ProposalOption) *gnome.Proposal {\n\tt.Helper()\n\n\tdao := gnome.MustNew(\"test\", \"Test\", \"Test DAO\")\n\taddr := testutils.TestAddress(\"proposer\")\n\tproposal, err := gnome.NewProposal(1, s, addr, dao, \"Title\", \"Description\", options...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn proposal\n}\n\nfunc assertError(t *testing.T, expected, actual error) {\n\tt.Helper()\n\n\tif expected != nil {\n\t\tif actual == nil {\n\t\t\tt.Fatalf(\"expected error: '%s', got no error\", expected.Error())\n\t\t}\n\n\t\tif expected.Error() != actual.Error() {\n\t\t\tt.Fatalf(\"expected error: '%s', got: '%s'\", expected.Error(), actual.Error())\n\t\t}\n\t} else if actual != nil {\n\t\tt.Fatalf(\"expected no error, got: '%s'\", actual.Error())\n\t}\n}\n\ntype testStrategy struct {\n\tChoice gnome.VoteChoice\n}\n\nfunc (testStrategy) Name() string                                            { return \"test\" }\nfunc (testStrategy) Quorum() float64                                         { return 0.51 }\nfunc (testStrategy) VotingPeriod() time.Duration                             { return 0 }\nfunc (testStrategy) VoteChoices() []gnome.VoteChoice                         { return []gnome.VoteChoice{gnome.ChoiceYes} }\nfunc (s testStrategy) Tally(*gnome.DAO, gnome.VotingRecord) gnome.VoteChoice { return s.Choice }\n"},{"Name":"paginator_test.gno","Body":"package gnome\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\tgnome \"gno.land/p/demo/gnome/dao/v1pre1\"\n)\n\nfunc TestPaginator(t *testing.T) {\n\titems := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tcases := []struct {\n\t\tname, uri, prevPath, nextPath    string\n\t\toffset, pageSize, page, lastPage int\n\t\tpageItems                        string\n\t\tstopped, enabled, isLastPage     bool\n\t}{\n\t\t{\n\t\t\tname:      \"page 1\",\n\t\t\turi:       \"gno.land/r/gnome:foo/bar/page=1/baz\",\n\t\t\tenabled:   true,\n\t\t\tnextPath:  \"/r/gnome:foo/bar/page=2/baz\",\n\t\t\toffset:    0,\n\t\t\tpageSize:  5,\n\t\t\tpage:      1,\n\t\t\tlastPage:  2,\n\t\t\tpageItems: \"[1 2 3 4 5]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"page 2\",\n\t\t\turi:        \"gno.land/r/gnome:foo/bar/page=2/baz\",\n\t\t\tenabled:    true,\n\t\t\tprevPath:   \"/r/gnome:foo/bar/page=1/baz\",\n\t\t\tnextPath:   \"\",\n\t\t\toffset:     5,\n\t\t\tpageSize:   5,\n\t\t\tpage:       2,\n\t\t\tlastPage:   2,\n\t\t\tpageItems:  \"[6 7 8 9 10]\",\n\t\t\tisLastPage: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"missing page\",\n\t\t\turi:       \"gno.land/r/gnome:foo/bar/page=3/baz\",\n\t\t\tenabled:   true,\n\t\t\tprevPath:  \"/r/gnome:foo/bar/page=2/baz\",\n\t\t\tnextPath:  \"/r/gnome:foo/bar/page=4/baz\",\n\t\t\toffset:    10,\n\t\t\tpageSize:  5,\n\t\t\tpage:      3,\n\t\t\tlastPage:  2,\n\t\t\tpageItems: \"[]\",\n\t\t\tstopped:   true,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid page number\",\n\t\t\turi:       \"gno.land/r/gnome:foo/bar/page=0/baz\",\n\t\t\tenabled:   false,\n\t\t\tprevPath:  \"\",\n\t\t\tnextPath:  \"\",\n\t\t\toffset:    0,\n\t\t\tpageSize:  4,\n\t\t\tpage:      0,\n\t\t\tlastPage:  3,\n\t\t\tpageItems: \"[]\",\n\t\t\tstopped:   true,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid page value\",\n\t\t\turi:       \"gno.land/r/gnome:foo/bar/page=foo/baz\",\n\t\t\tenabled:   false,\n\t\t\tprevPath:  \"\",\n\t\t\tnextPath:  \"\",\n\t\t\toffset:    0,\n\t\t\tpageSize:  2,\n\t\t\tpage:      0,\n\t\t\tlastPage:  5,\n\t\t\tpageItems: \"[]\",\n\t\t\tstopped:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tvar pageItems []int\n\n\t\t\t// Act\n\t\t\tp := gnome.NewPaginator(tc.uri, gnome.WithPageSize(tc.pageSize), gnome.WithItemCount(len(items)))\n\n\t\t\t// Assert\n\t\t\tif got := p.Page(); got != tc.page {\n\t\t\t\tt.Fatalf(\"expected page: %d, got: %d\", tc.page, got)\n\t\t\t}\n\n\t\t\tif got := p.LastPage(); got != tc.lastPage {\n\t\t\t\tt.Fatalf(\"expected last page: %d, got: %d\", tc.lastPage, got)\n\t\t\t}\n\n\t\t\tif got := p.PrevPageURI(); got != tc.prevPath {\n\t\t\t\tt.Fatalf(\"expected prev page path: '%s', got: '%s'\", tc.prevPath, got)\n\t\t\t}\n\n\t\t\tif got := p.NextPageURI(); got != tc.nextPath {\n\t\t\t\tt.Fatalf(\"expected next page path: '%s', got: '%s'\", tc.nextPath, got)\n\t\t\t}\n\n\t\t\tif got := p.Offset(); got != tc.offset {\n\t\t\t\tt.Fatalf(\"expected offset: %d, got: %d\", tc.offset, got)\n\t\t\t}\n\n\t\t\tif got := p.PageSize(); got != tc.pageSize {\n\t\t\t\tt.Fatalf(\"expected page size: %d, got: %d\", tc.pageSize, got)\n\t\t\t}\n\n\t\t\tif got := p.IsEnabled(); got != tc.enabled {\n\t\t\t\tt.Fatalf(\"expected enabled: %v, got: %v\", tc.enabled, got)\n\t\t\t}\n\n\t\t\tif got := p.IsLastPage(); got != tc.isLastPage {\n\t\t\t\tt.Fatalf(\"expected is last page to be: %v, got: %v\", tc.isLastPage, got)\n\t\t\t}\n\n\t\t\tstopped := p.Iterate(func(i int) bool {\n\t\t\t\tif i \u003e= len(items) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\n\t\t\t\tpageItems = append(pageItems, items[i])\n\t\t\t\treturn false\n\t\t\t})\n\t\t\tif stopped != tc.stopped {\n\t\t\t\tt.Fatalf(\"expected iteration result: %v, got: %v\", tc.stopped, stopped)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", pageItems); got != tc.pageItems {\n\t\t\t\tt.Fatalf(\"expected page items: %s, got: %s\", tc.pageItems, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"Name":"gno.mod","Body":"module gno.land/p/demo/gnome/dao/v1pre1pre1\n\nrequire (\n\tgno.land/p/demo/avl v0.0.0-latest\n\tgno.land/p/demo/json v0.0.0-latest\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"},{"Name":"uri.gno","Body":"package gnome\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar reSlug = regexp.MustCompile(\"^[a-zA-Z]+[a-zA-Z0-9-_]*$\")\n\n// IsSlug checks if a string is a valid slug.\nfunc IsSlug(s string) bool {\n\treturn reSlug.MatchString(s)\n}\n\n// SplitRealmURI splits a Gnoland URI into Realm URI and render path.\nfunc SplitRealmURI(uri string) (realmURI, renderPath string) {\n\tif uri == \"\" {\n\t\treturn\n\t}\n\n\tparts := strings.SplitN(uri, \":\", 2)\n\trealmURI = parts[0]\n\tif len(parts) \u003e 1 {\n\t\trenderPath = parts[1]\n\t}\n\treturn\n}\n\n// JoinRealmURI joins a Realm URI to render paths.\n// It is assumed that the first argument is the Realm URI\n// and the rest of the arguments are render path elements.\nfunc JoinRealmURI(paths ...string) string {\n\tcount := len(paths)\n\tif count == 0 {\n\t\treturn \"\"\n\t}\n\n\trealmURI := paths[0]\n\tif count == 1 {\n\t\treturn realmURI\n\t}\n\treturn realmURI + \":\" + strings.Join(paths[1:], \"/\")\n}\n\n// CutRealmDomain cuts out the Gnoland domain prefix from a URI.\nfunc CutRealmDomain(uri string) string {\n\trealmPath, _ := strings.CutPrefix(uri, \"gno.land\")\n\treturn realmPath\n}\n"},{"Name":"proposal.gno","Body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nconst (\n\tStatusReview ProposalStatus = iota\n\tStatusActive\n\tStatusPassed\n\tStatusRejected\n\tStatusLowParticipation\n\tStatusWithdrawed\n)\n\nconst (\n\t// TODO: Add more choices which also should be configurable (use a different type?)\n\tChoiceNone VoteChoice = \"\"\n\tChoiceYes  VoteChoice = \"yes\"\n\tChoiceNo   VoteChoice = \"no\"\n)\n\nconst (\n\tdefaultVoteChangeDuration = time.Hour\n\texecutionErrorMsg         = \"proposal execution error\"\n)\n\nvar (\n\tErrAlreadyVoted              = errors.New(\"member already voted on this proposal\")\n\tErrInvalidReason             = errors.New(\"reason must have at least 5 characters\")\n\tErrInvalidVoteChoice         = errors.New(\"invalid vote choice\")\n\tErrMemberVoteNotAllowed      = errors.New(\"you must be a DAO or parent DAO member to vote\")\n\tErrProposalVotingDeadlineMet = errors.New(\"proposal voting deadline already met\")\n\tErrProposalNotActive         = errors.New(\"proposal is not active\")\n\tErrProposalNotPassed         = errors.New(`proposal status must be \"passed\"`)\n\tErrReviewStatusRequired      = errors.New(`proposal status must be \"review\"`)\n)\n\ntype (\n\t// ExecutionError indicates that proposal execution failed.\n\tExecutionError struct {\n\t\t// Reason contains the error or error message with the reason of the error.\n\t\tReason interface{}\n\t}\n\n\t// ProposalIterFn defines the a callback to iterate proposals.\n\tProposalIterFn func(*Proposal) bool\n\n\t// ProposalOption configures proposals.\n\tProposalOption func(*Proposal)\n\n\t// ProposalStatus defines the type for proposal states.\n\tProposalStatus uint8\n\n\t// VoteChoice defines the type for proposal vote choices.\n\tVoteChoice string\n\n\t// Vote contains the information for a member vote.\n\tVote struct {\n\t\t// Address is the DAO member address.\n\t\tAddress std.Address\n\n\t\t// Choice is the proposal choice being voted.\n\t\tChoice VoteChoice\n\n\t\t// Reason contains the reason for the vote.\n\t\tReason string\n\n\t\t// DAO contains the DAO that the proposal being voted belongs to.\n\t\tDAO *DAO\n\n\t\t// CreatedAt contains the time when the vote was submitted.\n\t\tCreatedAt time.Time\n\t}\n)\n\n// Error returns the execution error message.\nfunc (e ExecutionError) Error() string {\n\tswitch v := e.Reason.(type) {\n\tcase string:\n\t\treturn executionErrorMsg + \": \" + v\n\tcase error:\n\t\treturn executionErrorMsg + \": \" + v.Error()\n\tdefault:\n\t\treturn executionErrorMsg\n\t}\n}\n\n// String returns the proposal status name.\nfunc (s ProposalStatus) String() string {\n\tswitch s {\n\tcase StatusReview:\n\t\treturn \"review\"\n\tcase StatusActive:\n\t\treturn \"active\"\n\tcase StatusPassed:\n\t\treturn \"passed\"\n\tcase StatusRejected:\n\t\treturn \"rejected\"\n\tcase StatusLowParticipation:\n\t\treturn \"low participation\"\n\tcase StatusWithdrawed:\n\t\treturn \"withdrawed\"\n\tdefault:\n\t\treturn \"invalid\"\n\t}\n}\n\n// IsExecutionError checks if an error is an ExecutionError.\nfunc IsExecutionError(err error) bool {\n\tswitch err.(type) {\n\tcase ExecutionError:\n\t\treturn true\n\tcase *ExecutionError:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// WithVotingDeadline assigns a voting deadline to the proposal.\nfunc WithVotingDeadline(t time.Time) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.votingDeadline = t\n\t}\n}\n\n// WithReviewDeadline assigns a review deadline to the proposal.\n// Review status allows proposal withdraw within a time frame after the proposal is created.\n// Proposals must be activated when a review deadline is assigned.\nfunc WithReviewDeadline(t time.Time) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.reviewDeadline = t\n\t}\n}\n\n// WithVoteChangeDuration change the default grace period to change a submitted vote choice.\nfunc WithVoteChangeDuration(d time.Duration) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.voteChangeDuration = d\n\t}\n}\n\n// NewProposal creates a new proposal.\n// By default proposals use the standard strategy with a deadline of seven days.\nfunc NewProposal(\n\tid ID,\n\tstrategy ProposalStrategy,\n\tproposer std.Address,\n\tdao *DAO,\n\ttitle, description string,\n\toptions ...ProposalOption,\n) (*Proposal, error) {\n\tif dao == nil {\n\t\treturn nil, errors.New(\"proposal DAO is required\")\n\t}\n\n\tif strings.TrimSpace(title) == \"\" {\n\t\treturn nil, errors.New(\"proposal title is required\")\n\t}\n\n\tif strings.TrimSpace(description) == \"\" {\n\t\treturn nil, errors.New(\"proposal description is required\")\n\t}\n\n\tnow := time.Now()\n\tp := \u0026Proposal{\n\t\tid:                 id,\n\t\tproposer:           proposer,\n\t\tdao:                dao,\n\t\ttitle:              title,\n\t\tdescription:        description,\n\t\tvotingDeadline:     now.Add(strategy.VotingPeriod()),\n\t\tvoteChangeDuration: defaultVoteChangeDuration,\n\t\tstrategy:           strategy,\n\t\tvotingRecord:       NewVotingRecord(),\n\t\tcreatedAt:          now,\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(p)\n\t}\n\n\t// Create the proposal as active when a review deadline is not assigned\n\tif p.reviewDeadline.IsZero() {\n\t\tp.status = StatusActive\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn p, nil\n}\n\n// Proposal defines a DAO proposal.\ntype Proposal struct {\n\tid                 ID\n\tdao                *DAO\n\ttitle              string\n\tdescription        string\n\tproposer           std.Address\n\tcreatedAt          time.Time\n\tvotingDeadline     time.Time\n\treviewDeadline     time.Time\n\tvoteChangeDuration time.Duration\n\tstatus             ProposalStatus\n\tstrategy           ProposalStrategy\n\tvotingRecord       *VotingRecord\n\tchoice             VoteChoice\n}\n\n// ID returns the proposal ID.\nfunc (p Proposal) ID() ID {\n\treturn p.id\n}\n\n// DAO returns the DAO that the proposal belongs to.\nfunc (p Proposal) DAO() *DAO {\n\treturn p.dao\n}\n\n// Strategy returns the strategy of the proposal.\nfunc (p Proposal) Strategy() ProposalStrategy {\n\treturn p.strategy\n}\n\n// Title returns the title of the proposal.\nfunc (p Proposal) Title() string {\n\treturn p.title\n}\n\n// Description returns the description of the proposal.\nfunc (p Proposal) Description() string {\n\treturn p.description\n}\n\n// Proposer returns the address of the member that created the proposal.\nfunc (p Proposal) Proposer() std.Address {\n\treturn p.proposer\n}\n\n// Choice returns the winner choice.\nfunc (p Proposal) Choice() VoteChoice {\n\treturn p.choice\n}\n\n// CreatedAt returns the creation time of the proposal.\nfunc (p Proposal) CreatedAt() time.Time {\n\treturn p.createdAt\n}\n\n// VotingDeadline returns the voting deadline for the proposal.\n// No more votes are allowed after this deadline.\nfunc (p Proposal) VotingDeadline() time.Time {\n\treturn p.votingDeadline\n}\n\n// ReviewDeadline returns the deadline for proposal review.\nfunc (p Proposal) ReviewDeadline() time.Time {\n\treturn p.reviewDeadline\n}\n\n// VoteChangeDuration returns the duration after voting where users can change the voted choice.\nfunc (p Proposal) VoteChangeDuration() time.Duration {\n\treturn p.voteChangeDuration\n}\n\n// Status returns the status of the proposal.\nfunc (p Proposal) Status() ProposalStatus {\n\treturn p.status\n}\n\n// Votes returns the proposal votes.\nfunc (p Proposal) Votes() []Vote {\n\treturn p.votingRecord.Votes()\n}\n\n// VotingRecord returns the voting record of the proposal.\n// The record contains the number of votes for each voting choice.\nfunc (p Proposal) VotingRecord() *VotingRecord {\n\treturn p.votingRecord\n}\n\n// IsExecutable checks if the proposal is executable.\nfunc (p Proposal) IsExecutable() bool {\n\t_, ok := p.strategy.(Executer)\n\treturn ok\n}\n\n// IsChoiceAllowed checks if a vote choice is valid for the proposal.\nfunc (p Proposal) IsChoiceAllowed(choice VoteChoice) bool {\n\tfor _, c := range p.strategy.VoteChoices() {\n\t\tif c == choice {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// HasVotingDeadlinePassed checks if the voting deadline for the proposal has passed.\nfunc (p Proposal) HasVotingDeadlinePassed() bool {\n\treturn time.Now().After(p.votingDeadline)\n}\n\n// HasReviewDeadlinePassed checks if the deadline for proposal review has passed.\nfunc (p Proposal) HasReviewDeadlinePassed() bool {\n\treturn time.Now().After(p.reviewDeadline)\n}\n\n// Withdraw changes the status of the proposal to withdrawed.\n// Proposal must have status \"review\" to be withdrawed.\nfunc (p *Proposal) Withdraw() error {\n\tif p.status != StatusReview {\n\t\treturn ErrReviewStatusRequired\n\t}\n\n\tp.status = StatusWithdrawed\n\treturn nil\n}\n\n// Activate changes the status of the proposal to active.\n// Proposal must have status \"review\" to be activated.\nfunc (p *Proposal) Activate() error {\n\t// TODO: Add test cases for proposal Activate() method\n\tif p.status != StatusReview {\n\t\treturn ErrReviewStatusRequired\n\t}\n\n\tp.status = StatusActive\n\treturn nil\n}\n\n// Vote submits a vote for the proposal.\nfunc (p *Proposal) Vote(addr std.Address, choice VoteChoice, reason string) error {\n\tif p.status != StatusActive {\n\t\treturn ErrProposalNotActive\n\t}\n\n\tnow := time.Now()\n\tif p.votingDeadline.Before(now) {\n\t\treturn ErrProposalVotingDeadlineMet\n\t}\n\n\tif !p.IsChoiceAllowed(choice) {\n\t\treturn ErrInvalidVoteChoice\n\t}\n\n\tif reason != \"\" \u0026\u0026 len(reason) \u003c 5 {\n\t\treturn ErrInvalidReason\n\t}\n\n\t// When there is a vote for the account check if it's voting within the\n\t// grace period that allows changing the voted choice. This allows to\n\t// correct mistakes made when seding the vote TX within a small time frame.\n\t// TODO: Add a unit test case to check vote change\n\tfor _, v := range p.votingRecord.Votes() {\n\t\tif v.Address == addr {\n\t\t\tif v.CreatedAt.Add(p.voteChangeDuration).Before(now) {\n\t\t\t\treturn ErrAlreadyVoted\n\t\t\t}\n\n\t\t\tp.votingRecord.Remove(addr)\n\t\t}\n\t}\n\n\t// Check the vote being submitted if vote check is required\n\tif c, ok := p.strategy.(VoteChecker); ok {\n\t\tif err := c.CheckVote(addr, choice, reason); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Account must be a member of the proposal's DAO or any of its parents to be allowed to vote\n\tvar dao *DAO\n\tif p.dao.HasMember(addr) {\n\t\t// When the account is member of the proposal's DAO its vote is accounted\n\t\t// as a vote from this DAO even if its also member of a parent DAO.\n\t\tdao = p.dao\n\t} else {\n\t\t// Try to find the higher order DAO that the account is member of\n\t\tdao = findBelongingDAO(addr, p.dao.parent)\n\t}\n\n\tif dao == nil {\n\t\treturn ErrMemberVoteNotAllowed\n\t}\n\n\tp.votingRecord.Add(Vote{\n\t\tAddress:   addr,\n\t\tChoice:    choice,\n\t\tReason:    reason,\n\t\tDAO:       dao,\n\t\tCreatedAt: time.Now(),\n\t})\n\n\treturn nil\n}\n\n// Tally counts the number of votes and updates the proposal status accordingly.\n// The outcome of counting the votes depends on the proposal strategy.\n// This function does NOT check the voting deadline, it's responsibility of the caller to do so.\nfunc (p *Proposal) Tally() error {\n\tif p.status != StatusActive {\n\t\treturn ErrProposalNotActive\n\t}\n\n\t// Split votes from DAO members and members of parent DAOs\n\tvar memberVotes, parentVotes []Vote\n\tfor _, v := range p.Votes() {\n\t\tif p.dao.HasMember(v.Address) {\n\t\t\tmemberVotes = append(memberVotes, v)\n\t\t} else {\n\t\t\tparentVotes = append(parentVotes, v)\n\t\t}\n\t}\n\n\t// Votes from parent DAOs dismisses all votes from members of the current DAO\n\tif len(parentVotes) \u003e 0 {\n\t\tp.tallyParentVotes(parentVotes)\n\t} else {\n\t\tp.tallyMemberVotes(memberVotes)\n\t}\n\treturn nil\n}\n\nfunc (p Proposal) Validate() error {\n\tif v, ok := p.strategy.(Validator); ok {\n\t\tif err := v.Validate(p.dao); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Execute executes the proposal.\nfunc (p *Proposal) Execute() error {\n\tif p.status != StatusPassed {\n\t\treturn ErrProposalNotPassed\n\t}\n\n\tif e, ok := p.strategy.(Executer); ok {\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn ExecutionError{err}\n\t\t}\n\n\t\tif err := e.Execute(p.dao); err != nil {\n\t\t\treturn ExecutionError{err}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Proposal) tallyParentVotes(votes []Vote) {\n\t// TODO: Implement parent votes tally\n\t// TODO: Save member votes tally results? Or use a proposal status to show votes were dismissed?\n}\n\nfunc (p *Proposal) tallyMemberVotes(votes []Vote) {\n\t// TODO: Deal with the case where a member that voted in active proposals is removed.\n\t//       Index/Keep track of the DAOs each member belongs to? For easy access to proposals.\n\n\t// Check if the required quorum is met\n\tpercentage := float64(len(votes)) / float64(len(p.dao.Members()))\n\tif percentage \u003c p.strategy.Quorum() {\n\t\tp.status = StatusLowParticipation\n\t\treturn\n\t}\n\n\t// Tally votes and update proposal with the outcome\n\tchoice := p.strategy.Tally(p.dao, *p.votingRecord)\n\n\tswitch choice {\n\tcase ChoiceYes:\n\t\tp.choice = ChoiceYes\n\t\tp.status = StatusPassed\n\tcase ChoiceNo:\n\t\tp.status = StatusRejected\n\tdefault:\n\t\tp.status = StatusLowParticipation\n\t}\n}\n\n// Proposals helps managing multiple proposals.\n// Its also a factory for proposals that assigns incremental IDs to each new proposal.\ntype Proposals struct {\n\tlastID    ID\n\tproposals avl.Tree // ID -\u003e *Proposal\n\tgroups    avl.Tree // DAO name -\u003e []*Proposal\n}\n\n// New creates a new proposal.\nfunc (ps *Proposals) New(\n\tstrategy ProposalStrategy,\n\tproposer std.Address,\n\tdao *DAO,\n\ttitle, description string,\n\toptions ...ProposalOption,\n) (*Proposal, error) {\n\tp, err := NewProposal(ps.genID(), strategy, proposer, dao, title, description, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tps.indexProposal(p)\n\n\treturn p, nil\n}\n\n// Exists checks if a proposal exists.\nfunc (ps Proposals) Exists(id ID) bool {\n\treturn ps.proposals.Has(id.Key())\n}\n\n// Get gets a proposal.\nfunc (ps Proposals) Get(id ID) *Proposal {\n\tif v, exists := ps.proposals.Get(id.Key()); exists {\n\t\treturn v.(*Proposal)\n\t}\n\treturn nil\n}\n\n// GetByDAO gets all proposals of a DAO.\nfunc (ps Proposals) GetByDAO(daoName string) []*Proposal {\n\tif v, exists := ps.groups.Get(daoName); exists {\n\t\treturn v.([]*Proposal)\n\t}\n\treturn nil\n}\n\n// Iterate iterates all proposals starting from the oldest one.\nfunc (ps Proposals) Iterate(fn ProposalIterFn) bool {\n\treturn ps.proposals.Iterate(\"\", \"\", func(_ string, value interface{}) bool {\n\t\treturn fn(value.(*Proposal))\n\t})\n}\n\n// ReverseIterate iterates all proposals starting from the latest one.\nfunc (ps Proposals) ReverseIterate(fn ProposalIterFn) bool {\n\treturn ps.proposals.ReverseIterate(\"\", \"\", func(_ string, value interface{}) bool {\n\t\treturn fn(value.(*Proposal))\n\t})\n}\n\nfunc (ps *Proposals) genID() ID {\n\tps.lastID += 1\n\treturn ps.lastID\n}\n\nfunc (ps *Proposals) indexProposal(p *Proposal) {\n\tdaoName := p.DAO().Name()\n\tproposals := ps.GetByDAO(daoName)\n\tps.groups.Set(daoName, append([]*Proposal{p}, proposals...)) // reverse append\n\tps.proposals.Set(p.ID().Key(), p)\n}\n\nfunc findBelongingDAO(addr std.Address, node *DAO) *DAO {\n\tif node == nil {\n\t\treturn nil\n\t}\n\n\t// Before checking the current DAO try to find\n\t// if address is a member of a higher order DAO\n\tdao := findBelongingDAO(addr, node.parent)\n\tif dao == nil \u0026\u0026 node.HasMember(addr) {\n\t\treturn node\n\t}\n\treturn nil\n}\n"},{"Name":"id.gno","Body":"package gnome\n\nimport (\n\t\"encoding/binary\"\n\t\"strconv\"\n)\n\n// ID defines a generic ID type.\ntype ID uint64\n\n// String returns the value of the ID as a string.\nfunc (id ID) String() string {\n\treturn strconv.Itoa(int(id))\n}\n\n// Key returns the binary representation of the ID to be used as key for AVL trees.\nfunc (id ID) Key() string {\n\tbuf := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(buf, uint64(id))\n\treturn string(buf)\n}\n\n// ConvertKeyToID converts a key to an ID.\n// Key is a binary representation of an ID.\nfunc ConvertKeyToID(key string) (ID, bool) {\n\tif len(key) != 8 {\n\t\treturn 0, false\n\t}\n\treturn ID(binary.BigEndian.Uint64([]byte(key))), true\n}\n"},{"Name":"strategy.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\t\"time\"\n)\n\ntype (\n\t// VoteChoiceRecord contains the number of counted votes for a single voting choice.\n\tVoteChoiceRecord struct {\n\t\tChoice VoteChoice\n\t\tCount  uint\n\t}\n\n\t// ProposalStrategy defines the interface for the different proposal types.\n\tProposalStrategy interface {\n\t\t// Name returns the name of the strategy.\n\t\tName() string\n\n\t\t// Quorum returns the minimum required percentage of DAO member votes\n\t\t// required for a proposal to pass.\n\t\tQuorum() float64\n\n\t\t// VotingPeriod returns the period that a proposal should allow voting.\n\t\tVotingPeriod() time.Duration\n\n\t\t// VoteChoices returns the valid voting choices for the strategy.\n\t\tVoteChoices() []VoteChoice\n\n\t\t// Tally counts the votes and returns the winner voting choice.\n\t\tTally(*DAO, VotingRecord) VoteChoice\n\t}\n)\n\n// VoteChecker defines an interface for proposal vote validation.\n// Proposal strategies that require checking votes when they are submitted should implement it.\ntype VoteChecker interface {\n\t// CheckVote checks that a vote is valid for the strategy.\n\tCheckVote(member std.Address, choice VoteChoice, reason string) error\n}\n\n// Executer defines an interface for executable proposals.\n// Proposals strategies that implement the interface can modify the DAO state when proposal passes.\ntype Executer interface {\n\t// Execute executes the proposal.\n\t// TODO: Execute should return some feedback on success\n\tExecute(*DAO) error\n}\n\n// Validator defines an interface for proposal validation.\n// Proposal strategies that implement the interface can validate that a proposal is valid for the current DAO state.\ntype Validator interface {\n\t// Validate validates if a proposal is valid for the current DAO state.\n\tValidate(*DAO) error\n}\n"},{"Name":"paginator.gno","Body":"package gnome\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst paginatorStyle = `\u003cstyle\u003e\n.paginator { text-align: center; }\n.paginator a { text-decoration: none; }\n.paginator a:hover { text-decoration: underline; }\n.paginator .left { padding-right: 4px; }\n.paginator .right { padding-left: 4px; }\n\u003c/style\u003e`\n\nvar (\n\tdefaultPageSize = 50\n\tminPageSize     = 1\n\tpagePrefix      = \"page=\"\n)\n\ntype (\n\t// PaginatorIterFn defines a callback to iterate page items.\n\tPaginatorIterFn func(index int) (stop bool)\n\n\t// PaginatorOption configures the paginator.\n\tPaginatorOption func(*Paginator)\n)\n\n// WithPageSize assigns a page size to a paginator.\n// The minimum page size is 5.\nfunc WithPageSize(size int) PaginatorOption {\n\treturn func(p *Paginator) {\n\t\tif size \u003c minPageSize {\n\t\t\tp.pageSize = minPageSize\n\t\t} else {\n\t\t\tp.pageSize = size\n\t\t}\n\t}\n}\n\n// WithItemCount assigns the total number of items that can be paginated.\n// Assigning the total item count allows the paginator to determine the last page number.\nfunc WithItemCount(count int) PaginatorOption {\n\treturn func(p *Paginator) {\n\t\tp.itemCount = count\n\t}\n}\n\n// NewPaginator creates a new paginator.\n// URI path must contain the page number for the paginator to iterate items.\n// Page number is specified in the URI path using \"page=N\" where N is the page\n// number which must start from 1. For example: gno.land/p/gnome:a/b/page=2.\n// Paginator is disabled when the URI path doesn't have a page specified or\n// when the specified page is not valid.\nfunc NewPaginator(uri string, options ...PaginatorOption) Paginator {\n\trealmURI, renderPath := SplitRealmURI(uri)\n\tp := Paginator{\n\t\trealmPath: CutRealmDomain(realmURI),\n\t\tpageSize:  defaultPageSize,\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(\u0026p)\n\t}\n\n\tp.lastPage = int(math.Ceil(float64(p.itemCount) / float64(p.pageSize)))\n\n\t// Iterate path items until paginator arguments are found.\n\t// Path prefix and suffix are kept to be able to generate\n\t// page URLs keeping the render path format.\n\titems := strings.Split(renderPath, \"/\")\n\tfor i, item := range items {\n\t\tif strings.HasPrefix(item, pagePrefix) {\n\t\t\tp.pathSuffix = items[i+1:]\n\t\t\tp.page, _ = strconv.Atoi(item[len(pagePrefix):])\n\t\t\tbreak\n\t\t}\n\n\t\tp.pathPrefix = append(p.pathPrefix, item)\n\t}\n\treturn p\n}\n\n// Paginator allows paging items.\ntype Paginator struct {\n\trealmPath                           string\n\tpathPrefix, pathSuffix              []string\n\tpageSize, page, lastPage, itemCount int\n}\n\n// Offset returns the index for the first page item.\nfunc (p Paginator) Offset() int {\n\tif !p.IsEnabled() {\n\t\treturn 0\n\t}\n\treturn (p.page - 1) * p.pageSize\n}\n\n// PageSize returns the size of each page.\nfunc (p Paginator) PageSize() int {\n\treturn p.pageSize\n}\n\n// Page returns the current page number.\n// Zero is returned when the paginator is disabled.\nfunc (p Paginator) Page() int {\n\treturn p.page\n}\n\n// LastPage returns the number of the last page.\n// Zero is returned when paginator is initialized without the total item count.\nfunc (p Paginator) LastPage() int {\n\treturn p.lastPage\n}\n\n// IsEnabled checks if paginator is enabled.\nfunc (p Paginator) IsEnabled() bool {\n\treturn p.page \u003e 0\n}\n\n// IsLastPage checks if the current page is the last one.\nfunc (p Paginator) IsLastPage() bool {\n\treturn p.page == p.lastPage\n}\n\n// GetPageURI returns the URI for a page.\n// An empty string is returned when page is \u003c 1.\nfunc (p Paginator) GetPageURI(page int) string {\n\tif !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\n\trenderPath := append(p.pathPrefix, pagePrefix+strconv.Itoa(page))\n\trenderPath = append(renderPath, p.pathSuffix...)\n\treturn p.realmPath + \":\" + strings.Join(renderPath, \"/\")\n}\n\n// PrevPageURI returns the URI path to the previous page.\n// An empty string is returned when current page is the first page.\nfunc (p Paginator) PrevPageURI() string {\n\tif p.page == 1 || !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\treturn p.GetPageURI(p.page - 1)\n}\n\n// NextPageURI returns the URI path to the next page.\nfunc (p Paginator) NextPageURI() string {\n\tif p.IsLastPage() {\n\t\treturn \"\"\n\t}\n\treturn p.GetPageURI(p.page + 1)\n}\n\n// Iterate allows iterating page items.\nfunc (p Paginator) Iterate(fn PaginatorIterFn) bool {\n\tif !p.IsEnabled() {\n\t\treturn true\n\t}\n\n\tstart := p.Offset()\n\tfor i := start; i \u003c start+p.PageSize(); i++ {\n\t\tif fn(i) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p Paginator) Render() string {\n\tif !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\n\tvar markdown string\n\tif s := p.PrevPageURI(); s != \"\" {\n\t\tmarkdown = ufmt.Sprintf(`\u003ca href=\"%s\" class=\"left\"\u003e\u0026lt;-\u003c/a\u003e`, s)\n\t} else {\n\t\tmarkdown += `\u003cspan class=\"left\"\u003e--\u003c/span\u003e`\n\t}\n\n\t// TODO: Add display links to other page numbers?\n\tmarkdown += ufmt.Sprintf(\"page %d\", p.page)\n\n\tif s := p.NextPageURI(); s != \"\" {\n\t\tmarkdown += ufmt.Sprintf(`\u003ca href=\"%s\" class=\"right\"\u003e-\u0026gt;\u003c/a\u003e`, s)\n\t} else {\n\t\tmarkdown += `\u003cspan class=\"right\"\u003e--\u003c/span\u003e`\n\t}\n\n\treturn paginatorStyle + `\u003cp class=\"paginator\"\u003e` + markdown + `\u003c/p\u003e`\n}\n"},{"Name":"marshal.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/json\"\n)\n\ntype PreMarshaler interface {\n\tPreMarshal() *json.Node\n}\n\nfunc PreMarshalDAO(dao *DAO) *json.Node {\n\treturn preMarshalDAO(\"dao\", dao)\n}\n\nfunc PreMarshalProposals(p Proposals) *json.Node {\n\tnode := json.ObjectNode(\"proposals\", nil)\n\tnode.AppendObject(\"lastID\", json.StringNode(\"lastID\", p.lastID.String()))\n\tnode.AppendObject(\"proposals\", preMarshalProposals(\"proposals\", p.proposals))\n\tnode.AppendObject(\"groups\", preMarshalProposalGroups(\"groups\", p.groups))\n\treturn node\n}\n\nfunc preMarshalDAO(key string, dao *DAO) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\tnode.AppendObject(\"name\", json.StringNode(\"name\", dao.name))\n\tnode.AppendObject(\"title\", json.StringNode(\"title\", dao.title))\n\tnode.AppendObject(\"manifest\", json.StringNode(\"manifest\", dao.manifest))\n\tnode.AppendObject(\"isSuperCouncil\", json.BoolNode(\"isSuperCouncil\", dao.isSuperCouncil))\n\tnode.AppendObject(\"children\", preMarshalChildren(dao.children))\n\tnode.AppendObject(\"members\", preMarshalAddresses(\"members\", dao.members))\n\tnode.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", dao.createdAt))\n\n\tif dao.parent != nil {\n\t\tnode.AppendObject(\"parentName\", json.StringNode(\"parentName\", dao.parent.name))\n\t} else {\n\t\tnode.AppendObject(\"parentName\", json.NullNode(\"parentName\"))\n\t}\n\n\treturn node\n}\n\nfunc preMarshalChildren(children []*DAO) *json.Node {\n\tif children == nil {\n\t\treturn json.NullNode(\"children\")\n\t}\n\n\tnodes := make([]*json.Node, len(children))\n\tfor i, c := range children {\n\t\tnodes[i] = preMarshalDAO(\"\", c)\n\t}\n\treturn json.ArrayNode(\"children\", nodes)\n}\n\nfunc preMarshalTime(key string, t time.Time) *json.Node {\n\tif t.IsZero() {\n\t\treturn json.NullNode(key)\n\t}\n\treturn json.StringNode(key, t.Format(time.RFC3339))\n}\n\nfunc preMarshalDuration(key string, d time.Duration) *json.Node {\n\treturn json.StringNode(key, strconv.FormatInt(int64(d), 10))\n}\n\nfunc preMarshalAddresses(key string, addresses []std.Address) *json.Node {\n\tif addresses == nil {\n\t\treturn json.NullNode(key)\n\t}\n\n\tnodes := make([]*json.Node, len(addresses))\n\tfor i, a := range addresses {\n\t\tnodes[i] = json.StringNode(\"\", a.String())\n\t}\n\treturn json.ArrayNode(key, nodes)\n}\n\nfunc preMarshalProposals(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(k string, value interface{}) bool {\n\t\tproposalID, _ := ConvertKeyToID(k) // TODO: Error should not happen, handle it anyways\n\t\tnode.AppendObject(proposalID.String(), preMarshalProposal(value.(*Proposal)))\n\t\treturn false\n\t})\n\treturn node\n}\n\nfunc preMarshalProposal(p *Proposal) *json.Node {\n\tnode := json.ObjectNode(\"\", nil)\n\tnode.AppendObject(\"id\", json.StringNode(\"id\", p.id.String()))\n\tnode.AppendObject(\"title\", json.StringNode(\"title\", p.title))\n\tnode.AppendObject(\"description\", json.StringNode(\"description\", p.description))\n\tnode.AppendObject(\"proposer\", json.StringNode(\"proposer\", p.proposer.String()))\n\tnode.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", p.createdAt))\n\tnode.AppendObject(\"votingDeadline\", preMarshalTime(\"votingDeadline\", p.votingDeadline))\n\tnode.AppendObject(\"reviewDeadline\", preMarshalTime(\"reviewDeadline\", p.reviewDeadline))\n\tnode.AppendObject(\"voteChangeDuration\", preMarshalDuration(\"voteChangeDuration\", p.voteChangeDuration))\n\tnode.AppendObject(\"status\", json.StringNode(\"status\", strconv.Itoa(int(p.status))))\n\tnode.AppendObject(\"strategy\", preMarshalStrategy(\"strategy\", p.strategy))\n\tnode.AppendObject(\"choice\", json.StringNode(\"choice\", string(p.choice)))\n\n\tif p.dao != nil {\n\t\tnode.AppendObject(\"daoName\", json.StringNode(\"daoName\", p.dao.name))\n\t} else {\n\t\tnode.AppendObject(\"daoName\", json.NullNode(\"daoName\"))\n\t}\n\n\tif p.votingRecord != nil {\n\t\tnode.AppendObject(\"votingRecord\", preMarshalVotingRecord(\"votingRecord\", p.votingRecord))\n\t} else {\n\t\tnode.AppendObject(\"votingRecord\", json.NullNode(\"votingRecord\"))\n\t}\n\n\treturn node\n}\n\nfunc preMarshalProposalGroups(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(k string, value interface{}) bool {\n\t\t// Save proposal IDs instead of the pre marshalled proposal which is saved inside \"proposals\"\n\t\tvar proposals []*json.Node\n\t\tfor _, p := range value.([]*Proposal) {\n\t\t\tproposals = append(proposals, json.StringNode(\"\", p.id.String()))\n\t\t}\n\n\t\tdaoID, _ := ConvertKeyToID(k) // TODO: Error should not happen, handle it anyways\n\t\tnode.AppendObject(daoID.String(), json.ArrayNode(\"\", proposals))\n\t\treturn false\n\t})\n\treturn node\n}\n\nfunc preMarshalStrategy(key string, s ProposalStrategy) *json.Node {\n\tif m, ok := s.(PreMarshaler); ok {\n\t\treturn m.PreMarshal()\n\t}\n\treturn json.NullNode(key)\n}\n\nfunc preMarshalVotingRecord(key string, r *VotingRecord) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\tnode.AppendObject(\"votes\", preMarshalVotes(\"votes\", r.votes))\n\tnode.AppendObject(\"counter\", preMarshalVoteCounter(\"counter\", r.counter))\n\treturn node\n}\n\nfunc preMarshalVotes(key string, votes []Vote) *json.Node {\n\tnodes := make([]*json.Node, len(votes))\n\tfor i, v := range votes {\n\t\tn := json.ObjectNode(\"\", nil)\n\t\tn.AppendObject(\"address\", json.StringNode(\"address\", v.Address.String()))\n\t\tn.AppendObject(\"choice\", json.StringNode(\"choice\", string(v.Choice)))\n\t\tn.AppendObject(\"reason\", json.StringNode(\"reason\", v.Reason))\n\t\tn.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", v.CreatedAt))\n\n\t\tif v.DAO != nil {\n\t\t\tn.AppendObject(\"daoName\", json.StringNode(\"daoName\", v.DAO.name))\n\t\t} else {\n\t\t\tn.AppendObject(\"daoName\", json.NullNode(\"daoName\"))\n\t\t}\n\n\t\tnodes[i] = n\n\t}\n\treturn json.ArrayNode(key, nodes)\n}\n\nfunc preMarshalVoteCounter(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(choice string, value interface{}) bool {\n\t\tnode.AppendObject(choice, json.NumberNode(\"\", float64(value.(uint))))\n\t\treturn false\n\t})\n\treturn node\n}\n"},{"Name":"dao_test.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\n\tgnome \"gno.land/p/demo/gnome/dao/v1pre1\"\n)\n\n// TODO: Add test cases to check different DAO options\nfunc TestDAO(t *testing.T) {\n\t// Arrange\n\tname := \"test\"\n\ttitle := \"Test DAO\"\n\tmanifest := \"This is a test\"\n\taddresses := []std.Address{\n\t\ttestutils.TestAddress(\"member1\"),\n\t\ttestutils.TestAddress(\"member2\"),\n\t}\n\n\t// Act\n\tdao := gnome.MustNew(name, title, manifest, gnome.WithMembers(addresses...))\n\n\t// Assert\n\tif got := dao.Name(); got != name {\n\t\tt.Fatalf(\"expected name: %d, got: %d\", name, got)\n\t}\n\n\tif got := dao.CreatedAt(); got.IsZero() {\n\t\tt.Fatalf(\"expected a valid creation time, got: '%s'\", got.String())\n\t}\n\n\tif got := dao.Title(); got != title {\n\t\tt.Fatalf(\"expected title: '%s', got: '%s'\", title, got)\n\t}\n\n\tif got := dao.Manifest(); got != manifest {\n\t\tt.Fatalf(\"expected manifest: '%s', got: '%s'\", manifest, got)\n\t}\n\n\tif got := dao.Parent(); got != nil {\n\t\tt.Fatalf(\"expected no parent DAO, got: '%s'\", got.Name())\n\t}\n\n\tif c := len(dao.SubDAOs()); c != 0 {\n\t\tt.Fatalf(\"expected no sub DAO nodes, got %d node(s)\", c)\n\t}\n\n\tif dao.IsSuperCouncil() {\n\t\tt.Fatal(\"expected DAO not to be a super council\")\n\t}\n\n\tmembers := dao.Members()\n\tif c := len(members); c != len(addresses) {\n\t\tt.Fatalf(\"expected %d DAO members, got %d\", len(addresses), c)\n\t}\n\n\tfor i, got := range members {\n\t\tif got != addresses[i] {\n\t\t\tt.Fatalf(\"expected member %d to have address %s, got: %s\", i, addresses[i], got)\n\t\t}\n\t}\n\n\tfor _, addr := range addresses {\n\t\tif !dao.HasMember(addr) {\n\t\t\tt.Fatalf(\"expected member %s to be a member of DAO\", addr)\n\t\t}\n\n\t\tm, found := dao.GetMember(addr)\n\t\tif !found {\n\t\t\tt.Fatalf(\"expected member %s to be found\", addr)\n\t\t}\n\n\t\tif m != addr {\n\t\t\tt.Fatalf(\"expected member to have address %s, got: %s\", addr, m)\n\t\t}\n\t}\n}\n\nfunc TestDAOAddMember(t *testing.T) {\n\tcases := []struct {\n\t\tname         string\n\t\taddress      std.Address\n\t\tmembersCount int\n\t\tshouldExist  bool\n\t\tsetup        func(*gnome.DAO)\n\t}{\n\t\t{\n\t\t\tname:         \"ok\",\n\t\t\taddress:      testutils.TestAddress(\"member\"),\n\t\t\tmembersCount: 1,\n\t\t\tshouldExist:  true,\n\t\t},\n\t\t{\n\t\t\tname:         \"existing\",\n\t\t\taddress:      testutils.TestAddress(\"member\"),\n\t\t\tmembersCount: 2,\n\t\t\tshouldExist:  true,\n\t\t\tsetup: func(dao *gnome.DAO) {\n\t\t\t\tdao.AddMember(testutils.TestAddress(\"member2\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:         \"duplicate\",\n\t\t\taddress:      testutils.TestAddress(\"member\"),\n\t\t\tmembersCount: 2,\n\t\t\tshouldExist:  true,\n\t\t\tsetup: func(dao *gnome.DAO) {\n\t\t\t\tdao.AddMember(testutils.TestAddress(\"member\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tdao := gnome.MustNew(\"test\", \"Test\", \"Test DAO\")\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(dao)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\tdao.AddMember(tc.address)\n\n\t\t\t// Assert\n\t\t\tif got := dao.HasMember(tc.address); got != tc.shouldExist {\n\t\t\t\tt.Fatalf(\"expected has member call to return %v, got: %v\", tc.shouldExist, got)\n\t\t\t}\n\n\t\t\tm, found := dao.GetMember(tc.address)\n\t\t\tif found != tc.shouldExist {\n\t\t\t\tt.Fatalf(\"expected member getter to return %v, got: %v\", tc.shouldExist, found)\n\t\t\t}\n\n\t\t\tif tc.shouldExist \u0026\u0026 m != tc.address {\n\t\t\t\tt.Fatalf(\"expected added member to have adderss %s, got: %s\", tc.address, m)\n\t\t\t}\n\n\t\t\tmembers := dao.Members()\n\t\t\tif c := len(members); c != tc.membersCount {\n\t\t\t\tt.Fatalf(\"expected %d member(s), got: %d\", tc.membersCount, c)\n\t\t\t}\n\n\t\t\tif len(members) \u003e 0 {\n\t\t\t\tm = members[len(members)-1]\n\t\t\t\tif m != tc.address {\n\t\t\t\t\tt.Fatalf(\"expected last added member address: %s, got: %s\", tc.address, m)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDAORemoveMember(t *testing.T) {\n\tcases := []struct {\n\t\tname    string\n\t\taddress std.Address\n\t\tsetup   func(*gnome.DAO)\n\t\tresult  bool\n\t}{\n\t\t{\n\t\t\tname:    \"ok\",\n\t\t\taddress: testutils.TestAddress(\"member\"),\n\t\t\tresult:  true,\n\t\t\tsetup: func(dao *gnome.DAO) {\n\t\t\t\tdao.AddMember(testutils.TestAddress(\"member\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"missing\",\n\t\t\taddress: testutils.TestAddress(\"member\"),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tdao := gnome.MustNew(\"test\", \"Test\", \"Test DAO\")\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(dao)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\tresult := dao.RemoveMember(tc.address)\n\n\t\t\t// Assert\n\t\t\tif result != tc.result {\n\t\t\t\tt.Fatalf(\"expected result to be %v, got: %v\", tc.result, result)\n\t\t\t}\n\n\t\t\tif dao.HasMember(tc.address) {\n\t\t\t\tt.Fatal(\"member shouldn't exist\")\n\t\t\t}\n\n\t\t\tif _, found := dao.GetMember(tc.address); found {\n\t\t\t\tt.Fatal(\"expected member getter to return false\")\n\t\t\t}\n\n\t\t\tif c := len(dao.Members()); c != 0 {\n\t\t\t\tt.Fatalf(\"expected no DAO members, got: %d\", c)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDAOAddSubDAO(t *testing.T) {\n\tcases := []struct {\n\t\tname, path  string\n\t\tchildren    int\n\t\tdao, subDAO *gnome.DAO\n\t\tresult      bool\n\t\tsetup       func(*gnome.DAO)\n\t}{\n\t\t{\n\t\t\tname:     \"ok\",\n\t\t\tdao:      gnome.MustNew(\"main\", \"Main\", \"-\"),\n\t\t\tsubDAO:   gnome.MustNew(\"foo\", \"Foo\", \"-\"),\n\t\t\tchildren: 1,\n\t\t\tpath:     \"main/foo\",\n\t\t\tresult:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"with children\",\n\t\t\tdao: gnome.MustNew(\n\t\t\t\t\"main\",\n\t\t\t\t\"Main\",\n\t\t\t\t\"-\",\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"bar\", \"Bar\", \"-\")),\n\t\t\t),\n\t\t\tsubDAO:   gnome.MustNew(\"foo\", \"Foo\", \"-\"),\n\t\t\tchildren: 2,\n\t\t\tpath:     \"main/foo\",\n\t\t\tresult:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate\",\n\t\t\tdao: gnome.MustNew(\n\t\t\t\t\"main\",\n\t\t\t\t\"Main\",\n\t\t\t\t\"-\",\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"foo\", \"Foo\", \"-\")),\n\t\t\t),\n\t\t\tsubDAO: gnome.MustNew(\"foo\", \"Foo\", \"-\"),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tresult := tc.dao.AddSubDAO(tc.subDAO)\n\n\t\t\t// Assert\n\t\t\tif result != tc.result {\n\t\t\t\tt.Fatalf(\"expected result to be %v, got: %v\", tc.result, result)\n\t\t\t}\n\n\t\t\tif result {\n\t\t\t\tif got := tc.subDAO.Path(); got != tc.path {\n\t\t\t\t\tt.Fatalf(\"expected path to be '%s', got: '%s'\", tc.path, got)\n\t\t\t\t}\n\n\t\t\t\tif c := len(tc.dao.SubDAOs()); c != tc.children {\n\t\t\t\t\tt.Fatalf(\"expected %d sub DAO node(s), got %d node(s)\", tc.children, c)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDAORemoveSubDAO(t *testing.T) {\n\tcases := []struct {\n\t\tname, subName string\n\t\tchildren      int\n\t\tsubDAO        *gnome.DAO\n\t\tresult        bool\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\tsubDAO: gnome.MustNew(\n\t\t\t\t\"main\",\n\t\t\t\t\"Main\",\n\t\t\t\t\"-\",\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"foo\", \"Foo\", \"-\")),\n\t\t\t),\n\t\t\tsubName: \"foo\",\n\t\t\tresult:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"with children\",\n\t\t\tsubDAO: gnome.MustNew(\n\t\t\t\t\"main\",\n\t\t\t\t\"Main\",\n\t\t\t\t\"-\",\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"foo\", \"Foo\", \"-\")),\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"bar\", \"Bar\", \"-\")),\n\t\t\t),\n\t\t\tsubName:  \"foo\",\n\t\t\tchildren: 1,\n\t\t\tresult:   true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing\",\n\t\t\tsubName: \"foo\",\n\t\t\tsubDAO:  gnome.MustNew(\"main\", \"Main\", \"-\"),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tresult := tc.subDAO.RemoveSubDAO(tc.subName)\n\n\t\t\t// Assert\n\t\t\tif result != tc.result {\n\t\t\t\tt.Fatalf(\"expected result to be %v, got: %v\", tc.result, result)\n\t\t\t}\n\n\t\t\tif result {\n\t\t\t\tif c := len(tc.subDAO.SubDAOs()); c != tc.children {\n\t\t\t\t\tt.Fatalf(\"expected %d sub DAO node(s), got %d node(s)\", tc.children, c)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDAOTree(t *testing.T) {\n\tdaoA1 := gnome.MustNew(\"a1\", \"A1\", \"-\")\n\tdaoA2 := gnome.MustNew(\"a2\", \"A2\", \"-\")\n\tdaoA := gnome.MustNew(\"a\", \"A\", \"-\", gnome.WithSubDAO(daoA1), gnome.WithSubDAO(daoA2))\n\tdaoB1 := gnome.MustNew(\"b1\", \"B1\", \"-\")\n\tdaoB := gnome.MustNew(\"b\", \"B\", \"-\", gnome.WithSubDAO(daoB1))\n\tdao := gnome.MustNew(\"main\", \"Main\", \"-\", gnome.WithSubDAO(daoA), gnome.WithSubDAO(daoB))\n\n\tcases := []struct {\n\t\tname, path string\n\t\tdao        *gnome.DAO\n\t}{\n\t\t{\n\t\t\tname: \"root\",\n\t\t\tpath: \"main\",\n\t\t\tdao:  dao,\n\t\t},\n\t\t{\n\t\t\tname: \"path a\",\n\t\t\tpath: \"main/a\",\n\t\t\tdao:  daoA,\n\t\t},\n\t\t{\n\t\t\tname: \"path a1\",\n\t\t\tpath: \"main/a/a1\",\n\t\t\tdao:  daoA1,\n\t\t},\n\t\t{\n\t\t\tname: \"path a2\",\n\t\t\tpath: \"main/a/a2\",\n\t\t\tdao:  daoA2,\n\t\t},\n\t\t{\n\t\t\tname: \"path b\",\n\t\t\tpath: \"main/b\",\n\t\t\tdao:  daoB,\n\t\t},\n\t\t{\n\t\t\tname: \"path b1\",\n\t\t\tpath: \"main/b/b1\",\n\t\t\tdao:  daoB1,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid\",\n\t\t\tpath: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid sub path\",\n\t\t\tpath: \"foo/bar\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tsubDAO := dao.GetDAO(tc.path)\n\n\t\t\t// Assert\n\t\t\tif subDAO != tc.dao {\n\t\t\t\tif subDAO == nil {\n\t\t\t\t\tt.Fatalf(\"DAO for path '%s' not found\", tc.path)\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"unexpected DAO for path '%s': '%s'\", tc.path, subDAO.Name())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif subDAO != nil \u0026\u0026 subDAO.Path() != tc.path {\n\t\t\t\tt.Fatalf(\"expected DAO to return path '%s': got '%s'\", tc.path, subDAO.Path())\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"Name":"record.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// VotingRecordIterFn defines the a callback to iterate voting choices.\ntype VotingRecordIterFn func(_ VoteChoice, voteCount uint) bool\n\n// NewVotingRecord creates a new voting record.\nfunc NewVotingRecord() *VotingRecord {\n\treturn \u0026VotingRecord{}\n}\n\n// VotingRecord mamages votes and vote count.\ntype VotingRecord struct {\n\tvotes   []Vote\n\tcounter avl.Tree // VoteChoice -\u003e count (uint)\n}\n\n// Votes return the list of votes.\nfunc (r VotingRecord) Votes() []Vote {\n\treturn r.votes\n}\n\n// VoteCount returns the number of votes.\nfunc (r VotingRecord) VoteCount() int {\n\treturn len(r.votes)\n}\n\n// Get returns the number of votes for vote choice.\nfunc (r VotingRecord) Get(c VoteChoice) uint {\n\tkey := string(c)\n\tif v, ok := r.counter.Get(key); ok {\n\t\treturn v.(uint)\n\t}\n\treturn 0\n}\n\n// Add adds a vote to the record.\nfunc (r *VotingRecord) Add(v Vote) {\n\tr.votes = append(r.votes, v)\n\tkey := string(v.Choice)\n\tr.counter.Set(key, r.Get(v.Choice)+1)\n}\n\n// Remove removes a vote from the record.\nfunc (r *VotingRecord) Remove(addr std.Address) bool {\n\tfor i, v := range r.votes {\n\t\tif v.Address == addr {\n\t\t\tr.votes = append(r.votes[:i], r.votes[i+1:]...)\n\t\t\tkey := string(v.Choice)\n\t\t\tr.counter.Set(key, r.Get(v.Choice)-1)\n\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Iterate iterates all vote choices.\nfunc (r VotingRecord) Iterate(fn VotingRecordIterFn) bool {\n\treturn r.counter.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tchoice := VoteChoice(key)\n\t\treturn fn(choice, value.(uint))\n\t})\n}\n\n// SelectChoiceByMajority select the vote choice by majority.\n// Vote choice is a majority when chosen by more than half of the votes.\n// Majority type is defined by the caller depending on the vote records and abstentions, it would be\n// absolute majority if abstentions are considered, otherwise it would potentially be simple majority.\nfunc SelectChoiceByMajority(r VotingRecord, abstentions int) (VoteChoice, bool) {\n\tvotesCount := r.VoteCount() + abstentions\n\tchoice := getMajorityChoice(r)\n\tisMajority := r.Get(choice) \u003e uint(votesCount/2)\n\treturn choice, isMajority\n}\n\n// SelectChoiceBySuperMajority select the vote choice by super majority using a 2/3s threshold.\n// Abstentions are not considered when calculating the super majority choice.\nfunc SelectChoiceBySuperMajority(r VotingRecord) (VoteChoice, bool) {\n\tchoice := getMajorityChoice(r)\n\tisMajority := r.Get(choice) \u003e uint((2*r.VoteCount())/3) // TODO: Allow threshold customization\n\treturn choice, isMajority\n}\n\n// getMajorityChoice returns the choice voted by the majority.\n// The result is only valid when there is a majority.\n// Caller must validate that the returned choice represents a majority.\nfunc getMajorityChoice(r VotingRecord) VoteChoice {\n\tvar (\n\t\tchoice       VoteChoice\n\t\tcurrentCount uint\n\t)\n\n\tr.Iterate(func(c VoteChoice, count uint) bool {\n\t\tif currentCount \u003c count {\n\t\t\tchoice = c\n\t\t\tcurrentCount = count\n\t\t}\n\t\treturn false\n\t})\n\n\treturn choice\n}\n"},{"Name":"dao.gno","Body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst daoPathSep = \"/\"\n\n// Option configures DAO.\ntype Option func(*DAO)\n\n// AssignAsSuperCouncil makes the DAO a super council.\nfunc AssignAsSuperCouncil() Option {\n\treturn func(dao *DAO) {\n\t\tdao.isSuperCouncil = true\n\t}\n}\n\n// WithSubDAO assigns sub DAO to a DAO.\nfunc WithSubDAO(sub *DAO) Option {\n\treturn func(dao *DAO) {\n\t\tsub.parent = dao\n\t\tdao.children = append(dao.children, sub)\n\t}\n}\n\n// WithMembers assigns members to a DAO.\nfunc WithMembers(addreses ...std.Address) Option {\n\treturn func(dao *DAO) {\n\t\tdao.members = addreses\n\t}\n}\n\n// New creates a new DAO.\nfunc New(name, title, manifest string, options ...Option) (*DAO, error) {\n\tname = strings.TrimSpace(name)\n\tif name == \"\" {\n\t\treturn nil, errors.New(\"DAO name is required\")\n\t}\n\n\tif !IsSlug(name) {\n\t\treturn nil, errors.New(`DAO name is not valid, only letters from \"a\" to \"z\", numbers, \"-\" and \"_\" are allowed`)\n\t}\n\n\ttitle = strings.TrimSpace(title)\n\tif title == \"\" {\n\t\treturn nil, errors.New(\"DAO title is required\")\n\t}\n\n\tmanifest = strings.TrimSpace(manifest)\n\tif manifest == \"\" {\n\t\treturn nil, errors.New(\"DAO manifest is required\")\n\t}\n\n\tdao := \u0026DAO{\n\t\tname:      name,\n\t\ttitle:     title,\n\t\tmanifest:  manifest,\n\t\tcreatedAt: time.Now(),\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(dao)\n\t}\n\n\treturn dao, nil\n}\n\n// MustNew creates a new DAO.\n// The function panics if any of the arguments is not valid.\nfunc MustNew(name, title, manifest string, options ...Option) *DAO {\n\tdao, err := New(name, title, manifest, options...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn dao\n}\n\n// DAO is a decentralized autonomous organization.\ntype DAO struct {\n\tname           string\n\ttitle          string\n\tmanifest       string // TODO: Rename to \"purpose\"?\n\tisSuperCouncil bool\n\tparent         *DAO\n\tchildren       []*DAO\n\tmembers        []std.Address\n\tcreatedAt      time.Time\n}\n\n// Name returns the name of the DAO.\nfunc (dao DAO) Name() string {\n\treturn dao.name\n}\n\n// Title returns the title of the DAO.\nfunc (dao DAO) Title() string {\n\treturn dao.title\n}\n\n// Manifest returns the manifest of the DAO.\nfunc (dao DAO) Manifest() string {\n\treturn dao.manifest\n}\n\n// SetManifest sets the manifest of the DAO.\nfunc (dao *DAO) SetManifest(s string) {\n\tdao.manifest = s\n}\n\n// CreatedAt returns the creation time of the DAO.\nfunc (dao DAO) CreatedAt() time.Time {\n\treturn dao.createdAt\n}\n\n// Parent returns the parent DAO of the sub DAO.\n// For the main DAO the result is nil.\nfunc (dao DAO) Parent() *DAO {\n\treturn dao.parent\n}\n\n// Path returns the path of the DAO.\nfunc (dao DAO) Path() string {\n\tif dao.parent == nil {\n\t\treturn dao.name\n\t}\n\treturn MakePath(dao.parent.Path(), dao.name)\n}\n\n// SubDAOs returns the sub DAOs.\nfunc (dao DAO) SubDAOs() []*DAO {\n\treturn dao.children\n}\n\n// GetFirstSubDAO returns the first sub DAO.\nfunc (dao DAO) GetFirstSubDAO() *DAO {\n\tif len(dao.children) == 0 {\n\t\treturn nil\n\t}\n\treturn dao.children[0]\n}\n\n// Members returns the members of the DAOs.\nfunc (dao DAO) Members() []std.Address {\n\treturn dao.members\n}\n\n// IsSuperCouncil checks if the DAO is a super council.\nfunc (dao DAO) IsSuperCouncil() bool {\n\treturn dao.isSuperCouncil\n}\n\n// HasMember checks if a member is part of the DAO.\nfunc (dao DAO) HasMember(addr std.Address) bool {\n\tfor _, m := range dao.members {\n\t\tif m == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AddMember adds a member to the DAO.\n// Caller must check the member before adding to avoid duplications.\nfunc (dao *DAO) AddMember(addr std.Address) {\n\tdao.members = append(dao.members, addr)\n}\n\n// GetMember gets a member of the DAO.\nfunc (dao DAO) GetMember(addr std.Address) (std.Address, bool) {\n\tfor _, m := range dao.members {\n\t\tif m == addr {\n\t\t\treturn m, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// RemoveMember removes a member of the DAO.\nfunc (dao *DAO) RemoveMember(addr std.Address) bool {\n\tfor i, m := range dao.members {\n\t\tif m == addr {\n\t\t\tdao.members = append(dao.members[:i], dao.members[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AddSubDAO adds a sub DAO to the DAO.\nfunc (dao *DAO) AddSubDAO(sub *DAO) bool {\n\tfor _, n := range dao.children {\n\t\tif n.name == sub.name {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tsub.parent = dao\n\tdao.children = append(dao.children, sub)\n\treturn true\n}\n\n// GetDAO get a DAO by path.\nfunc (dao *DAO) GetDAO(path string) *DAO {\n\tif path == \"\" {\n\t\treturn nil\n\t}\n\n\tif path == dao.name {\n\t\treturn dao\n\t}\n\n\t// Make sure that current node is not present at the beginning of the path\n\tpath = strings.TrimPrefix(path, dao.name+daoPathSep)\n\n\t// Split DAO path in child name and relative sub path\n\tparts := strings.SplitN(path, daoPathSep, 2)\n\tchildName := parts[0]\n\n\tfor _, sub := range dao.children {\n\t\tif sub.name != childName {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(parts) \u003e 1 {\n\t\t\t// Traverse node children when a sub node path is available\n\t\t\treturn sub.GetDAO(parts[1])\n\t\t}\n\t\treturn sub\n\t}\n\n\treturn nil\n}\n\n// RemoveSubDAO removes a sub DAO.\n// The sub DAO must be a first level children of the DAO.\nfunc (dao *DAO) RemoveSubDAO(name string) bool {\n\tfor i, sub := range dao.children {\n\t\tif sub.name == name {\n\t\t\tdao.children = append(dao.children[:i], dao.children[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsRoot checks if the DAO is the main DAO.\n// The main DAO is the root of the DAO tree.\nfunc (dao DAO) IsRoot() bool {\n\treturn dao.parent == nil\n}\n\n// MakePath creates a new DAO path.\nfunc MakePath(items ...string) string {\n\treturn strings.Join(items, daoPathSep)\n}\n"},{"Name":"uri_test.gno","Body":"package gnome\n\nimport (\n\t\"testing\"\n\n\tgnome \"gno.land/p/demo/gnome/dao/v1pre1\"\n)\n\nfunc TestSplitRealmURI(t *testing.T) {\n\tcases := []struct {\n\t\tname, uri, realmURI, renderPath string\n\t}{\n\t\t{\n\t\t\tname:     \"realm URI\",\n\t\t\turi:      \"gno.land/r/gnome\",\n\t\t\trealmURI: \"gno.land/r/gnome\",\n\t\t},\n\t\t{\n\t\t\tname:       \"realm URI with render path\",\n\t\t\turi:        \"gno.land/r/gnome:foo/bar\",\n\t\t\trealmURI:   \"gno.land/r/gnome\",\n\t\t\trenderPath: \"foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname:       \"realm URI with render path\",\n\t\t\turi:        \"gno.land/r/gnome:foo/bar\",\n\t\t\trealmURI:   \"gno.land/r/gnome\",\n\t\t\trenderPath: \"foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty URI\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\trealmURI, renderPath := gnome.SplitRealmURI(tc.uri)\n\n\t\t\t// Assert\n\t\t\tif realmURI != tc.realmURI {\n\t\t\t\tt.Fatalf(\"expected realm URI: '%s', got: '%s'\", tc.realmURI, realmURI)\n\t\t\t}\n\n\t\t\tif renderPath != tc.renderPath {\n\t\t\t\tt.Fatalf(\"expected render path: '%s', got: '%s'\", tc.renderPath, renderPath)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestJoinRealmURI(t *testing.T) {\n\tcases := []struct {\n\t\tname, uri string\n\t\tpaths     []string\n\t}{\n\t\t{\n\t\t\tname:  \"realm URI\",\n\t\t\turi:   \"gno.land/r/gnome\",\n\t\t\tpaths: []string{\"gno.land/r/gnome\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"realm URI with render path\",\n\t\t\turi:   \"gno.land/r/gnome:foo/bar\",\n\t\t\tpaths: []string{\"gno.land/r/gnome\", \"foo/bar\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"realm URI with multiple render paths\",\n\t\t\turi:   \"gno.land/r/gnome:foo/bar/baz\",\n\t\t\tpaths: []string{\"gno.land/r/gnome\", \"foo/bar\", \"baz\"},\n\t\t},\n\t\t{\n\t\t\tname: \"empty paths\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\turi := gnome.JoinRealmURI(tc.paths...)\n\n\t\t\t// Assert\n\t\t\tif uri != tc.uri {\n\t\t\t\tt.Fatalf(\"expected realm URI: '%s', got: '%s'\", tc.uri, uri)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCutRealmDomain(t *testing.T) {\n\tcases := []struct {\n\t\tname, uri, path string\n\t}{\n\t\t{\n\t\t\tname: \"with domain\",\n\t\t\turi:  \"gno.land/r/gnome\",\n\t\t\tpath: \"/r/gnome\",\n\t\t},\n\t\t{\n\t\t\tname: \"without domain\",\n\t\t\turi:  \"/r/gnome\",\n\t\t\tpath: \"/r/gnome\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tpath := gnome.CutRealmDomain(tc.uri)\n\n\t\t\t// Assert\n\t\t\tif path != tc.path {\n\t\t\t\tt.Fatalf(\"expected path: '%s', got: '%s'\", tc.path, path)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"V4XTcoYfeFtPtTbblniD1SSXrnuBGFpVSRFnDKWLAoR4trzZIh5OzbMs9Jp7HKdrnX/Am6k6aeEznEw5GZiBeg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372609"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"gnome","Path":"gno.land/r/demo/gnome/dao/v1pre1/gnome","Files":[{"Name":"uri.gno","Body":"package gnome\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar reSlug = regexp.MustCompile(\"^[a-zA-Z]+[a-zA-Z0-9-_]*$\")\n\n// IsSlug checks if a string is a valid slug.\nfunc IsSlug(s string) bool {\n\treturn reSlug.MatchString(s)\n}\n\n// SplitRealmURI splits a Gnoland URI into Realm URI and render path.\nfunc SplitRealmURI(uri string) (realmURI, renderPath string) {\n\tif uri == \"\" {\n\t\treturn\n\t}\n\n\tparts := strings.SplitN(uri, \":\", 2)\n\trealmURI = parts[0]\n\tif len(parts) \u003e 1 {\n\t\trenderPath = parts[1]\n\t}\n\treturn\n}\n\n// JoinRealmURI joins a Realm URI to render paths.\n// It is assumed that the first argument is the Realm URI\n// and the rest of the arguments are render path elements.\nfunc JoinRealmURI(paths ...string) string {\n\tcount := len(paths)\n\tif count == 0 {\n\t\treturn \"\"\n\t}\n\n\trealmURI := paths[0]\n\tif count == 1 {\n\t\treturn realmURI\n\t}\n\treturn realmURI + \":\" + strings.Join(paths[1:], \"/\")\n}\n\n// CutRealmDomain cuts out the Gnoland domain prefix from a URI.\nfunc CutRealmDomain(uri string) string {\n\trealmPath, _ := strings.CutPrefix(uri, \"gno.land\")\n\treturn realmPath\n}\n"},{"Name":"proposal.gno","Body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nconst (\n\tStatusReview ProposalStatus = iota\n\tStatusActive\n\tStatusPassed\n\tStatusRejected\n\tStatusLowParticipation\n\tStatusWithdrawed\n)\n\nconst (\n\t// TODO: Add more choices which also should be configurable (use a different type?)\n\tChoiceNone VoteChoice = \"\"\n\tChoiceYes  VoteChoice = \"yes\"\n\tChoiceNo   VoteChoice = \"no\"\n)\n\nconst (\n\tdefaultVoteChangeDuration = time.Hour\n\texecutionErrorMsg         = \"proposal execution error\"\n)\n\nvar (\n\tErrAlreadyVoted              = errors.New(\"member already voted on this proposal\")\n\tErrInvalidReason             = errors.New(\"reason must have at least 5 characters\")\n\tErrInvalidVoteChoice         = errors.New(\"invalid vote choice\")\n\tErrMemberVoteNotAllowed      = errors.New(\"you must be a DAO or parent DAO member to vote\")\n\tErrProposalVotingDeadlineMet = errors.New(\"proposal voting deadline already met\")\n\tErrProposalNotActive         = errors.New(\"proposal is not active\")\n\tErrProposalNotPassed         = errors.New(`proposal status must be \"passed\"`)\n\tErrReviewStatusRequired      = errors.New(`proposal status must be \"review\"`)\n)\n\ntype (\n\t// ExecutionError indicates that proposal execution failed.\n\tExecutionError struct {\n\t\t// Reason contains the error or error message with the reason of the error.\n\t\tReason interface{}\n\t}\n\n\t// ProposalIterFn defines the a callback to iterate proposals.\n\tProposalIterFn func(*Proposal) bool\n\n\t// ProposalOption configures proposals.\n\tProposalOption func(*Proposal)\n\n\t// ProposalStatus defines the type for proposal states.\n\tProposalStatus uint8\n\n\t// VoteChoice defines the type for proposal vote choices.\n\tVoteChoice string\n\n\t// Vote contains the information for a member vote.\n\tVote struct {\n\t\t// Address is the DAO member address.\n\t\tAddress std.Address\n\n\t\t// Choice is the proposal choice being voted.\n\t\tChoice VoteChoice\n\n\t\t// Reason contains the reason for the vote.\n\t\tReason string\n\n\t\t// DAO contains the DAO that the proposal being voted belongs to.\n\t\tDAO *DAO\n\n\t\t// CreatedAt contains the time when the vote was submitted.\n\t\tCreatedAt time.Time\n\t}\n)\n\n// Error returns the execution error message.\nfunc (e ExecutionError) Error() string {\n\tswitch v := e.Reason.(type) {\n\tcase string:\n\t\treturn executionErrorMsg + \": \" + v\n\tcase error:\n\t\treturn executionErrorMsg + \": \" + v.Error()\n\tdefault:\n\t\treturn executionErrorMsg\n\t}\n}\n\n// String returns the proposal status name.\nfunc (s ProposalStatus) String() string {\n\tswitch s {\n\tcase StatusReview:\n\t\treturn \"review\"\n\tcase StatusActive:\n\t\treturn \"active\"\n\tcase StatusPassed:\n\t\treturn \"passed\"\n\tcase StatusRejected:\n\t\treturn \"rejected\"\n\tcase StatusLowParticipation:\n\t\treturn \"low participation\"\n\tcase StatusWithdrawed:\n\t\treturn \"withdrawed\"\n\tdefault:\n\t\treturn \"invalid\"\n\t}\n}\n\n// IsExecutionError checks if an error is an ExecutionError.\nfunc IsExecutionError(err error) bool {\n\tswitch err.(type) {\n\tcase ExecutionError:\n\t\treturn true\n\tcase *ExecutionError:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// WithVotingDeadline assigns a voting deadline to the proposal.\nfunc WithVotingDeadline(t time.Time) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.votingDeadline = t\n\t}\n}\n\n// WithReviewDeadline assigns a review deadline to the proposal.\n// Review status allows proposal withdraw within a time frame after the proposal is created.\n// Proposals must be activated when a review deadline is assigned.\nfunc WithReviewDeadline(t time.Time) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.reviewDeadline = t\n\t}\n}\n\n// WithVoteChangeDuration change the default grace period to change a submitted vote choice.\nfunc WithVoteChangeDuration(d time.Duration) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.voteChangeDuration = d\n\t}\n}\n\n// NewProposal creates a new proposal.\n// By default proposals use the standard strategy with a deadline of seven days.\nfunc NewProposal(\n\tid ID,\n\tstrategy ProposalStrategy,\n\tproposer std.Address,\n\tdao *DAO,\n\ttitle, description string,\n\toptions ...ProposalOption,\n) (*Proposal, error) {\n\tif dao == nil {\n\t\treturn nil, errors.New(\"proposal DAO is required\")\n\t}\n\n\tif strings.TrimSpace(title) == \"\" {\n\t\treturn nil, errors.New(\"proposal title is required\")\n\t}\n\n\tif strings.TrimSpace(description) == \"\" {\n\t\treturn nil, errors.New(\"proposal description is required\")\n\t}\n\n\tnow := time.Now()\n\tp := \u0026Proposal{\n\t\tid:                 id,\n\t\tproposer:           proposer,\n\t\tdao:                dao,\n\t\ttitle:              title,\n\t\tdescription:        description,\n\t\tvotingDeadline:     now.Add(strategy.VotingPeriod()),\n\t\tvoteChangeDuration: defaultVoteChangeDuration,\n\t\tstrategy:           strategy,\n\t\tvotingRecord:       NewVotingRecord(),\n\t\tcreatedAt:          now,\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(p)\n\t}\n\n\t// Create the proposal as active when a review deadline is not assigned\n\tif p.reviewDeadline.IsZero() {\n\t\tp.status = StatusActive\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn p, nil\n}\n\n// Proposal defines a DAO proposal.\ntype Proposal struct {\n\tid                 ID\n\tdao                *DAO\n\ttitle              string\n\tdescription        string\n\tproposer           std.Address\n\tcreatedAt          time.Time\n\tvotingDeadline     time.Time\n\treviewDeadline     time.Time\n\tvoteChangeDuration time.Duration\n\tstatus             ProposalStatus\n\tstrategy           ProposalStrategy\n\tvotingRecord       *VotingRecord\n\tchoice             VoteChoice\n}\n\n// ID returns the proposal ID.\nfunc (p Proposal) ID() ID {\n\treturn p.id\n}\n\n// DAO returns the DAO that the proposal belongs to.\nfunc (p Proposal) DAO() *DAO {\n\treturn p.dao\n}\n\n// Strategy returns the strategy of the proposal.\nfunc (p Proposal) Strategy() ProposalStrategy {\n\treturn p.strategy\n}\n\n// Title returns the title of the proposal.\nfunc (p Proposal) Title() string {\n\treturn p.title\n}\n\n// Description returns the description of the proposal.\nfunc (p Proposal) Description() string {\n\treturn p.description\n}\n\n// Proposer returns the address of the member that created the proposal.\nfunc (p Proposal) Proposer() std.Address {\n\treturn p.proposer\n}\n\n// Choice returns the winner choice.\nfunc (p Proposal) Choice() VoteChoice {\n\treturn p.choice\n}\n\n// CreatedAt returns the creation time of the proposal.\nfunc (p Proposal) CreatedAt() time.Time {\n\treturn p.createdAt\n}\n\n// VotingDeadline returns the voting deadline for the proposal.\n// No more votes are allowed after this deadline.\nfunc (p Proposal) VotingDeadline() time.Time {\n\treturn p.votingDeadline\n}\n\n// ReviewDeadline returns the deadline for proposal review.\nfunc (p Proposal) ReviewDeadline() time.Time {\n\treturn p.reviewDeadline\n}\n\n// VoteChangeDuration returns the duration after voting where users can change the voted choice.\nfunc (p Proposal) VoteChangeDuration() time.Duration {\n\treturn p.voteChangeDuration\n}\n\n// Status returns the status of the proposal.\nfunc (p Proposal) Status() ProposalStatus {\n\treturn p.status\n}\n\n// Votes returns the proposal votes.\nfunc (p Proposal) Votes() []Vote {\n\treturn p.votingRecord.Votes()\n}\n\n// VotingRecord returns the voting record of the proposal.\n// The record contains the number of votes for each voting choice.\nfunc (p Proposal) VotingRecord() *VotingRecord {\n\treturn p.votingRecord\n}\n\n// IsExecutable checks if the proposal is executable.\nfunc (p Proposal) IsExecutable() bool {\n\t_, ok := p.strategy.(Executer)\n\treturn ok\n}\n\n// IsChoiceAllowed checks if a vote choice is valid for the proposal.\nfunc (p Proposal) IsChoiceAllowed(choice VoteChoice) bool {\n\tfor _, c := range p.strategy.VoteChoices() {\n\t\tif c == choice {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// HasVotingDeadlinePassed checks if the voting deadline for the proposal has passed.\nfunc (p Proposal) HasVotingDeadlinePassed() bool {\n\treturn time.Now().After(p.votingDeadline)\n}\n\n// HasReviewDeadlinePassed checks if the deadline for proposal review has passed.\nfunc (p Proposal) HasReviewDeadlinePassed() bool {\n\treturn time.Now().After(p.reviewDeadline)\n}\n\n// Withdraw changes the status of the proposal to withdrawed.\n// Proposal must have status \"review\" to be withdrawed.\nfunc (p *Proposal) Withdraw() error {\n\tif p.status != StatusReview {\n\t\treturn ErrReviewStatusRequired\n\t}\n\n\tp.status = StatusWithdrawed\n\treturn nil\n}\n\n// Activate changes the status of the proposal to active.\n// Proposal must have status \"review\" to be activated.\nfunc (p *Proposal) Activate() error {\n\t// TODO: Add test cases for proposal Activate() method\n\tif p.status != StatusReview {\n\t\treturn ErrReviewStatusRequired\n\t}\n\n\tp.status = StatusActive\n\treturn nil\n}\n\n// Vote submits a vote for the proposal.\nfunc (p *Proposal) Vote(addr std.Address, choice VoteChoice, reason string) error {\n\tif p.status != StatusActive {\n\t\treturn ErrProposalNotActive\n\t}\n\n\tnow := time.Now()\n\tif p.votingDeadline.Before(now) {\n\t\treturn ErrProposalVotingDeadlineMet\n\t}\n\n\tif !p.IsChoiceAllowed(choice) {\n\t\treturn ErrInvalidVoteChoice\n\t}\n\n\tif reason != \"\" \u0026\u0026 len(reason) \u003c 5 {\n\t\treturn ErrInvalidReason\n\t}\n\n\t// When there is a vote for the account check if it's voting within the\n\t// grace period that allows changing the voted choice. This allows to\n\t// correct mistakes made when seding the vote TX within a small time frame.\n\t// TODO: Add a unit test case to check vote change\n\tfor _, v := range p.votingRecord.Votes() {\n\t\tif v.Address == addr {\n\t\t\tif v.CreatedAt.Add(p.voteChangeDuration).Before(now) {\n\t\t\t\treturn ErrAlreadyVoted\n\t\t\t}\n\n\t\t\tp.votingRecord.Remove(addr)\n\t\t}\n\t}\n\n\t// Check the vote being submitted if vote check is required\n\tif c, ok := p.strategy.(VoteChecker); ok {\n\t\tif err := c.CheckVote(addr, choice, reason); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Account must be a member of the proposal's DAO or any of its parents to be allowed to vote\n\tvar dao *DAO\n\tif p.dao.HasMember(addr) {\n\t\t// When the account is member of the proposal's DAO its vote is accounted\n\t\t// as a vote from this DAO even if its also member of a parent DAO.\n\t\tdao = p.dao\n\t} else {\n\t\t// Try to find the higher order DAO that the account is member of\n\t\tdao = findBelongingDAO(addr, p.dao.parent)\n\t}\n\n\tif dao == nil {\n\t\treturn ErrMemberVoteNotAllowed\n\t}\n\n\tp.votingRecord.Add(Vote{\n\t\tAddress:   addr,\n\t\tChoice:    choice,\n\t\tReason:    reason,\n\t\tDAO:       dao,\n\t\tCreatedAt: time.Now(),\n\t})\n\n\treturn nil\n}\n\n// Tally counts the number of votes and updates the proposal status accordingly.\n// The outcome of counting the votes depends on the proposal strategy.\n// This function does NOT check the voting deadline, it's responsibility of the caller to do so.\nfunc (p *Proposal) Tally() error {\n\tif p.status != StatusActive {\n\t\treturn ErrProposalNotActive\n\t}\n\n\t// Split votes from DAO members and members of parent DAOs\n\tvar memberVotes, parentVotes []Vote\n\tfor _, v := range p.Votes() {\n\t\tif p.dao.HasMember(v.Address) {\n\t\t\tmemberVotes = append(memberVotes, v)\n\t\t} else {\n\t\t\tparentVotes = append(parentVotes, v)\n\t\t}\n\t}\n\n\t// Votes from parent DAOs dismisses all votes from members of the current DAO\n\tif len(parentVotes) \u003e 0 {\n\t\tp.tallyParentVotes(parentVotes)\n\t} else {\n\t\tp.tallyMemberVotes(memberVotes)\n\t}\n\treturn nil\n}\n\nfunc (p Proposal) Validate() error {\n\tif v, ok := p.strategy.(Validator); ok {\n\t\tif err := v.Validate(p.dao); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Execute executes the proposal.\nfunc (p *Proposal) Execute() error {\n\tif p.status != StatusPassed {\n\t\treturn ErrProposalNotPassed\n\t}\n\n\tif e, ok := p.strategy.(Executer); ok {\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn ExecutionError{err}\n\t\t}\n\n\t\tif err := e.Execute(p.dao); err != nil {\n\t\t\treturn ExecutionError{err}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Proposal) tallyParentVotes(votes []Vote) {\n\t// TODO: Implement parent votes tally\n\t// TODO: Save member votes tally results? Or use a proposal status to show votes were dismissed?\n}\n\nfunc (p *Proposal) tallyMemberVotes(votes []Vote) {\n\t// TODO: Deal with the case where a member that voted in active proposals is removed.\n\t//       Index/Keep track of the DAOs each member belongs to? For easy access to proposals.\n\n\t// Check if the required quorum is met\n\tpercentage := float64(len(votes)) / float64(len(p.dao.Members()))\n\tif percentage \u003c p.strategy.Quorum() {\n\t\tp.status = StatusLowParticipation\n\t\treturn\n\t}\n\n\t// Tally votes and update proposal with the outcome\n\tchoice := p.strategy.Tally(p.dao, *p.votingRecord)\n\n\tswitch choice {\n\tcase ChoiceYes:\n\t\tp.choice = ChoiceYes\n\t\tp.status = StatusPassed\n\tcase ChoiceNo:\n\t\tp.status = StatusRejected\n\tdefault:\n\t\tp.status = StatusLowParticipation\n\t}\n}\n\n// Proposals helps managing multiple proposals.\n// Its also a factory for proposals that assigns incremental IDs to each new proposal.\ntype Proposals struct {\n\tlastID    ID\n\tproposals avl.Tree // ID -\u003e *Proposal\n\tgroups    avl.Tree // DAO name -\u003e []*Proposal\n}\n\n// New creates a new proposal.\nfunc (ps *Proposals) New(\n\tstrategy ProposalStrategy,\n\tproposer std.Address,\n\tdao *DAO,\n\ttitle, description string,\n\toptions ...ProposalOption,\n) (*Proposal, error) {\n\tp, err := NewProposal(ps.genID(), strategy, proposer, dao, title, description, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tps.indexProposal(p)\n\n\treturn p, nil\n}\n\n// Exists checks if a proposal exists.\nfunc (ps Proposals) Exists(id ID) bool {\n\treturn ps.proposals.Has(id.Key())\n}\n\n// Get gets a proposal.\nfunc (ps Proposals) Get(id ID) *Proposal {\n\tif v, exists := ps.proposals.Get(id.Key()); exists {\n\t\treturn v.(*Proposal)\n\t}\n\treturn nil\n}\n\n// GetByDAO gets all proposals of a DAO.\nfunc (ps Proposals) GetByDAO(daoName string) []*Proposal {\n\tif v, exists := ps.groups.Get(daoName); exists {\n\t\treturn v.([]*Proposal)\n\t}\n\treturn nil\n}\n\n// Iterate iterates all proposals starting from the oldest one.\nfunc (ps Proposals) Iterate(fn ProposalIterFn) bool {\n\treturn ps.proposals.Iterate(\"\", \"\", func(_ string, value interface{}) bool {\n\t\treturn fn(value.(*Proposal))\n\t})\n}\n\n// ReverseIterate iterates all proposals starting from the latest one.\nfunc (ps Proposals) ReverseIterate(fn ProposalIterFn) bool {\n\treturn ps.proposals.ReverseIterate(\"\", \"\", func(_ string, value interface{}) bool {\n\t\treturn fn(value.(*Proposal))\n\t})\n}\n\nfunc (ps *Proposals) genID() ID {\n\tps.lastID += 1\n\treturn ps.lastID\n}\n\nfunc (ps *Proposals) indexProposal(p *Proposal) {\n\tdaoName := p.DAO().Name()\n\tproposals := ps.GetByDAO(daoName)\n\tps.groups.Set(daoName, append([]*Proposal{p}, proposals...)) // reverse append\n\tps.proposals.Set(p.ID().Key(), p)\n}\n\nfunc findBelongingDAO(addr std.Address, node *DAO) *DAO {\n\tif node == nil {\n\t\treturn nil\n\t}\n\n\t// Before checking the current DAO try to find\n\t// if address is a member of a higher order DAO\n\tdao := findBelongingDAO(addr, node.parent)\n\tif dao == nil \u0026\u0026 node.HasMember(addr) {\n\t\treturn node\n\t}\n\treturn nil\n}\n"},{"Name":"id.gno","Body":"package gnome\n\nimport (\n\t\"encoding/binary\"\n\t\"strconv\"\n)\n\n// ID defines a generic ID type.\ntype ID uint64\n\n// String returns the value of the ID as a string.\nfunc (id ID) String() string {\n\treturn strconv.Itoa(int(id))\n}\n\n// Key returns the binary representation of the ID to be used as key for AVL trees.\nfunc (id ID) Key() string {\n\tbuf := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(buf, uint64(id))\n\treturn string(buf)\n}\n\n// ConvertKeyToID converts a key to an ID.\n// Key is a binary representation of an ID.\nfunc ConvertKeyToID(key string) (ID, bool) {\n\tif len(key) != 8 {\n\t\treturn 0, false\n\t}\n\treturn ID(binary.BigEndian.Uint64([]byte(key))), true\n}\n"},{"Name":"strategy.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\t\"time\"\n)\n\ntype (\n\t// VoteChoiceRecord contains the number of counted votes for a single voting choice.\n\tVoteChoiceRecord struct {\n\t\tChoice VoteChoice\n\t\tCount  uint\n\t}\n\n\t// ProposalStrategy defines the interface for the different proposal types.\n\tProposalStrategy interface {\n\t\t// Name returns the name of the strategy.\n\t\tName() string\n\n\t\t// Quorum returns the minimum required percentage of DAO member votes\n\t\t// required for a proposal to pass.\n\t\tQuorum() float64\n\n\t\t// VotingPeriod returns the period that a proposal should allow voting.\n\t\tVotingPeriod() time.Duration\n\n\t\t// VoteChoices returns the valid voting choices for the strategy.\n\t\tVoteChoices() []VoteChoice\n\n\t\t// Tally counts the votes and returns the winner voting choice.\n\t\tTally(*DAO, VotingRecord) VoteChoice\n\t}\n)\n\n// VoteChecker defines an interface for proposal vote validation.\n// Proposal strategies that require checking votes when they are submitted should implement it.\ntype VoteChecker interface {\n\t// CheckVote checks that a vote is valid for the strategy.\n\tCheckVote(member std.Address, choice VoteChoice, reason string) error\n}\n\n// Executer defines an interface for executable proposals.\n// Proposals strategies that implement the interface can modify the DAO state when proposal passes.\ntype Executer interface {\n\t// Execute executes the proposal.\n\t// TODO: Execute should return some feedback on success\n\tExecute(*DAO) error\n}\n\n// Validator defines an interface for proposal validation.\n// Proposal strategies that implement the interface can validate that a proposal is valid for the current DAO state.\ntype Validator interface {\n\t// Validate validates if a proposal is valid for the current DAO state.\n\tValidate(*DAO) error\n}\n"},{"Name":"paginator.gno","Body":"package gnome\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst paginatorStyle = `\u003cstyle\u003e\n.paginator { text-align: center; }\n.paginator a { text-decoration: none; }\n.paginator a:hover { text-decoration: underline; }\n.paginator .left { padding-right: 4px; }\n.paginator .right { padding-left: 4px; }\n\u003c/style\u003e`\n\nvar (\n\tdefaultPageSize = 50\n\tminPageSize     = 1\n\tpagePrefix      = \"page=\"\n)\n\ntype (\n\t// PaginatorIterFn defines a callback to iterate page items.\n\tPaginatorIterFn func(index int) (stop bool)\n\n\t// PaginatorOption configures the paginator.\n\tPaginatorOption func(*Paginator)\n)\n\n// WithPageSize assigns a page size to a paginator.\n// The minimum page size is 5.\nfunc WithPageSize(size int) PaginatorOption {\n\treturn func(p *Paginator) {\n\t\tif size \u003c minPageSize {\n\t\t\tp.pageSize = minPageSize\n\t\t} else {\n\t\t\tp.pageSize = size\n\t\t}\n\t}\n}\n\n// WithItemCount assigns the total number of items that can be paginated.\n// Assigning the total item count allows the paginator to determine the last page number.\nfunc WithItemCount(count int) PaginatorOption {\n\treturn func(p *Paginator) {\n\t\tp.itemCount = count\n\t}\n}\n\n// NewPaginator creates a new paginator.\n// URI path must contain the page number for the paginator to iterate items.\n// Page number is specified in the URI path using \"page=N\" where N is the page\n// number which must start from 1. For example: gno.land/p/gnome:a/b/page=2.\n// Paginator is disabled when the URI path doesn't have a page specified or\n// when the specified page is not valid.\nfunc NewPaginator(uri string, options ...PaginatorOption) Paginator {\n\trealmURI, renderPath := SplitRealmURI(uri)\n\tp := Paginator{\n\t\trealmPath: CutRealmDomain(realmURI),\n\t\tpageSize:  defaultPageSize,\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(\u0026p)\n\t}\n\n\tp.lastPage = int(math.Ceil(float64(p.itemCount) / float64(p.pageSize)))\n\n\t// Iterate path items until paginator arguments are found.\n\t// Path prefix and suffix are kept to be able to generate\n\t// page URLs keeping the render path format.\n\titems := strings.Split(renderPath, \"/\")\n\tfor i, item := range items {\n\t\tif strings.HasPrefix(item, pagePrefix) {\n\t\t\tp.pathSuffix = items[i+1:]\n\t\t\tp.page, _ = strconv.Atoi(item[len(pagePrefix):])\n\t\t\tbreak\n\t\t}\n\n\t\tp.pathPrefix = append(p.pathPrefix, item)\n\t}\n\treturn p\n}\n\n// Paginator allows paging items.\ntype Paginator struct {\n\trealmPath                           string\n\tpathPrefix, pathSuffix              []string\n\tpageSize, page, lastPage, itemCount int\n}\n\n// Offset returns the index for the first page item.\nfunc (p Paginator) Offset() int {\n\tif !p.IsEnabled() {\n\t\treturn 0\n\t}\n\treturn (p.page - 1) * p.pageSize\n}\n\n// PageSize returns the size of each page.\nfunc (p Paginator) PageSize() int {\n\treturn p.pageSize\n}\n\n// Page returns the current page number.\n// Zero is returned when the paginator is disabled.\nfunc (p Paginator) Page() int {\n\treturn p.page\n}\n\n// LastPage returns the number of the last page.\n// Zero is returned when paginator is initialized without the total item count.\nfunc (p Paginator) LastPage() int {\n\treturn p.lastPage\n}\n\n// IsEnabled checks if paginator is enabled.\nfunc (p Paginator) IsEnabled() bool {\n\treturn p.page \u003e 0\n}\n\n// IsLastPage checks if the current page is the last one.\nfunc (p Paginator) IsLastPage() bool {\n\treturn p.page == p.lastPage\n}\n\n// GetPageURI returns the URI for a page.\n// An empty string is returned when page is \u003c 1.\nfunc (p Paginator) GetPageURI(page int) string {\n\tif !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\n\trenderPath := append(p.pathPrefix, pagePrefix+strconv.Itoa(page))\n\trenderPath = append(renderPath, p.pathSuffix...)\n\treturn p.realmPath + \":\" + strings.Join(renderPath, \"/\")\n}\n\n// PrevPageURI returns the URI path to the previous page.\n// An empty string is returned when current page is the first page.\nfunc (p Paginator) PrevPageURI() string {\n\tif p.page == 1 || !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\treturn p.GetPageURI(p.page - 1)\n}\n\n// NextPageURI returns the URI path to the next page.\nfunc (p Paginator) NextPageURI() string {\n\tif p.IsLastPage() {\n\t\treturn \"\"\n\t}\n\treturn p.GetPageURI(p.page + 1)\n}\n\n// Iterate allows iterating page items.\nfunc (p Paginator) Iterate(fn PaginatorIterFn) bool {\n\tif !p.IsEnabled() {\n\t\treturn true\n\t}\n\n\tstart := p.Offset()\n\tfor i := start; i \u003c start+p.PageSize(); i++ {\n\t\tif fn(i) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p Paginator) Render() string {\n\tif !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\n\tvar markdown string\n\tif s := p.PrevPageURI(); s != \"\" {\n\t\tmarkdown = ufmt.Sprintf(`\u003ca href=\"%s\" class=\"left\"\u003e\u0026lt;-\u003c/a\u003e`, s)\n\t} else {\n\t\tmarkdown += `\u003cspan class=\"left\"\u003e--\u003c/span\u003e`\n\t}\n\n\t// TODO: Add display links to other page numbers?\n\tmarkdown += ufmt.Sprintf(\"page %d\", p.page)\n\n\tif s := p.NextPageURI(); s != \"\" {\n\t\tmarkdown += ufmt.Sprintf(`\u003ca href=\"%s\" class=\"right\"\u003e-\u0026gt;\u003c/a\u003e`, s)\n\t} else {\n\t\tmarkdown += `\u003cspan class=\"right\"\u003e--\u003c/span\u003e`\n\t}\n\n\treturn paginatorStyle + `\u003cp class=\"paginator\"\u003e` + markdown + `\u003c/p\u003e`\n}\n"},{"Name":"marshal.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/json\"\n)\n\ntype PreMarshaler interface {\n\tPreMarshal() *json.Node\n}\n\nfunc PreMarshalDAO(dao *DAO) *json.Node {\n\treturn preMarshalDAO(\"dao\", dao)\n}\n\nfunc PreMarshalProposals(p Proposals) *json.Node {\n\tnode := json.ObjectNode(\"proposals\", nil)\n\tnode.AppendObject(\"lastID\", json.StringNode(\"lastID\", p.lastID.String()))\n\tnode.AppendObject(\"proposals\", preMarshalProposals(\"proposals\", p.proposals))\n\tnode.AppendObject(\"groups\", preMarshalProposalGroups(\"groups\", p.groups))\n\treturn node\n}\n\nfunc preMarshalDAO(key string, dao *DAO) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\tnode.AppendObject(\"name\", json.StringNode(\"name\", dao.name))\n\tnode.AppendObject(\"title\", json.StringNode(\"title\", dao.title))\n\tnode.AppendObject(\"manifest\", json.StringNode(\"manifest\", dao.manifest))\n\tnode.AppendObject(\"isSuperCouncil\", json.BoolNode(\"isSuperCouncil\", dao.isSuperCouncil))\n\tnode.AppendObject(\"children\", preMarshalChildren(dao.children))\n\tnode.AppendObject(\"members\", preMarshalAddresses(\"members\", dao.members))\n\tnode.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", dao.createdAt))\n\n\tif dao.parent != nil {\n\t\tnode.AppendObject(\"parentName\", json.StringNode(\"parentName\", dao.parent.name))\n\t} else {\n\t\tnode.AppendObject(\"parentName\", json.NullNode(\"parentName\"))\n\t}\n\n\treturn node\n}\n\nfunc preMarshalChildren(children []*DAO) *json.Node {\n\tif children == nil {\n\t\treturn json.NullNode(\"children\")\n\t}\n\n\tnodes := make([]*json.Node, len(children))\n\tfor i, c := range children {\n\t\tnodes[i] = preMarshalDAO(\"\", c)\n\t}\n\treturn json.ArrayNode(\"children\", nodes)\n}\n\nfunc preMarshalTime(key string, t time.Time) *json.Node {\n\tif t.IsZero() {\n\t\treturn json.NullNode(key)\n\t}\n\treturn json.StringNode(key, t.Format(time.RFC3339))\n}\n\nfunc preMarshalDuration(key string, d time.Duration) *json.Node {\n\treturn json.StringNode(key, strconv.FormatInt(int64(d), 10))\n}\n\nfunc preMarshalAddresses(key string, addresses []std.Address) *json.Node {\n\tif addresses == nil {\n\t\treturn json.NullNode(key)\n\t}\n\n\tnodes := make([]*json.Node, len(addresses))\n\tfor i, a := range addresses {\n\t\tnodes[i] = json.StringNode(\"\", a.String())\n\t}\n\treturn json.ArrayNode(key, nodes)\n}\n\nfunc preMarshalProposals(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(k string, value interface{}) bool {\n\t\tproposalID, _ := ConvertKeyToID(k) // TODO: Error should not happen, handle it anyways\n\t\tnode.AppendObject(proposalID.String(), preMarshalProposal(value.(*Proposal)))\n\t\treturn false\n\t})\n\treturn node\n}\n\nfunc preMarshalProposal(p *Proposal) *json.Node {\n\tnode := json.ObjectNode(\"\", nil)\n\tnode.AppendObject(\"id\", json.StringNode(\"id\", p.id.String()))\n\tnode.AppendObject(\"title\", json.StringNode(\"title\", p.title))\n\tnode.AppendObject(\"description\", json.StringNode(\"description\", p.description))\n\tnode.AppendObject(\"proposer\", json.StringNode(\"proposer\", p.proposer.String()))\n\tnode.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", p.createdAt))\n\tnode.AppendObject(\"votingDeadline\", preMarshalTime(\"votingDeadline\", p.votingDeadline))\n\tnode.AppendObject(\"reviewDeadline\", preMarshalTime(\"reviewDeadline\", p.reviewDeadline))\n\tnode.AppendObject(\"voteChangeDuration\", preMarshalDuration(\"voteChangeDuration\", p.voteChangeDuration))\n\tnode.AppendObject(\"status\", json.StringNode(\"status\", strconv.Itoa(int(p.status))))\n\tnode.AppendObject(\"strategy\", preMarshalStrategy(\"strategy\", p.strategy))\n\tnode.AppendObject(\"choice\", json.StringNode(\"choice\", string(p.choice)))\n\n\tif p.dao != nil {\n\t\tnode.AppendObject(\"daoName\", json.StringNode(\"daoName\", p.dao.name))\n\t} else {\n\t\tnode.AppendObject(\"daoName\", json.NullNode(\"daoName\"))\n\t}\n\n\tif p.votingRecord != nil {\n\t\tnode.AppendObject(\"votingRecord\", preMarshalVotingRecord(\"votingRecord\", p.votingRecord))\n\t} else {\n\t\tnode.AppendObject(\"votingRecord\", json.NullNode(\"votingRecord\"))\n\t}\n\n\treturn node\n}\n\nfunc preMarshalProposalGroups(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(k string, value interface{}) bool {\n\t\t// Save proposal IDs instead of the pre marshalled proposal which is saved inside \"proposals\"\n\t\tvar proposals []*json.Node\n\t\tfor _, p := range value.([]*Proposal) {\n\t\t\tproposals = append(proposals, json.StringNode(\"\", p.id.String()))\n\t\t}\n\n\t\tdaoID, _ := ConvertKeyToID(k) // TODO: Error should not happen, handle it anyways\n\t\tnode.AppendObject(daoID.String(), json.ArrayNode(\"\", proposals))\n\t\treturn false\n\t})\n\treturn node\n}\n\nfunc preMarshalStrategy(key string, s ProposalStrategy) *json.Node {\n\tif m, ok := s.(PreMarshaler); ok {\n\t\treturn m.PreMarshal()\n\t}\n\treturn json.NullNode(key)\n}\n\nfunc preMarshalVotingRecord(key string, r *VotingRecord) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\tnode.AppendObject(\"votes\", preMarshalVotes(\"votes\", r.votes))\n\tnode.AppendObject(\"counter\", preMarshalVoteCounter(\"counter\", r.counter))\n\treturn node\n}\n\nfunc preMarshalVotes(key string, votes []Vote) *json.Node {\n\tnodes := make([]*json.Node, len(votes))\n\tfor i, v := range votes {\n\t\tn := json.ObjectNode(\"\", nil)\n\t\tn.AppendObject(\"address\", json.StringNode(\"address\", v.Address.String()))\n\t\tn.AppendObject(\"choice\", json.StringNode(\"choice\", string(v.Choice)))\n\t\tn.AppendObject(\"reason\", json.StringNode(\"reason\", v.Reason))\n\t\tn.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", v.CreatedAt))\n\n\t\tif v.DAO != nil {\n\t\t\tn.AppendObject(\"daoName\", json.StringNode(\"daoName\", v.DAO.name))\n\t\t} else {\n\t\t\tn.AppendObject(\"daoName\", json.NullNode(\"daoName\"))\n\t\t}\n\n\t\tnodes[i] = n\n\t}\n\treturn json.ArrayNode(key, nodes)\n}\n\nfunc preMarshalVoteCounter(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(choice string, value interface{}) bool {\n\t\tnode.AppendObject(choice, json.NumberNode(\"\", float64(value.(uint))))\n\t\treturn false\n\t})\n\treturn node\n}\n"},{"Name":"record.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// VotingRecordIterFn defines the a callback to iterate voting choices.\ntype VotingRecordIterFn func(_ VoteChoice, voteCount uint) bool\n\n// NewVotingRecord creates a new voting record.\nfunc NewVotingRecord() *VotingRecord {\n\treturn \u0026VotingRecord{}\n}\n\n// VotingRecord mamages votes and vote count.\ntype VotingRecord struct {\n\tvotes   []Vote\n\tcounter avl.Tree // VoteChoice -\u003e count (uint)\n}\n\n// Votes return the list of votes.\nfunc (r VotingRecord) Votes() []Vote {\n\treturn r.votes\n}\n\n// VoteCount returns the number of votes.\nfunc (r VotingRecord) VoteCount() int {\n\treturn len(r.votes)\n}\n\n// Get returns the number of votes for vote choice.\nfunc (r VotingRecord) Get(c VoteChoice) uint {\n\tkey := string(c)\n\tif v, ok := r.counter.Get(key); ok {\n\t\treturn v.(uint)\n\t}\n\treturn 0\n}\n\n// Add adds a vote to the record.\nfunc (r *VotingRecord) Add(v Vote) {\n\tr.votes = append(r.votes, v)\n\tkey := string(v.Choice)\n\tr.counter.Set(key, r.Get(v.Choice)+1)\n}\n\n// Remove removes a vote from the record.\nfunc (r *VotingRecord) Remove(addr std.Address) bool {\n\tfor i, v := range r.votes {\n\t\tif v.Address == addr {\n\t\t\tr.votes = append(r.votes[:i], r.votes[i+1:]...)\n\t\t\tkey := string(v.Choice)\n\t\t\tr.counter.Set(key, r.Get(v.Choice)-1)\n\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Iterate iterates all vote choices.\nfunc (r VotingRecord) Iterate(fn VotingRecordIterFn) bool {\n\treturn r.counter.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tchoice := VoteChoice(key)\n\t\treturn fn(choice, value.(uint))\n\t})\n}\n\n// SelectChoiceByMajority select the vote choice by majority.\n// Vote choice is a majority when chosen by more than half of the votes.\n// Majority type is defined by the caller depending on the vote records and abstentions, it would be\n// absolute majority if abstentions are considered, otherwise it would potentially be simple majority.\nfunc SelectChoiceByMajority(r VotingRecord, abstentions int) (VoteChoice, bool) {\n\tvotesCount := r.VoteCount() + abstentions\n\tchoice := getMajorityChoice(r)\n\tisMajority := r.Get(choice) \u003e uint(votesCount/2)\n\treturn choice, isMajority\n}\n\n// SelectChoiceBySuperMajority select the vote choice by super majority using a 2/3s threshold.\n// Abstentions are not considered when calculating the super majority choice.\nfunc SelectChoiceBySuperMajority(r VotingRecord) (VoteChoice, bool) {\n\tchoice := getMajorityChoice(r)\n\tisMajority := r.Get(choice) \u003e uint((2*r.VoteCount())/3) // TODO: Allow threshold customization\n\treturn choice, isMajority\n}\n\n// getMajorityChoice returns the choice voted by the majority.\n// The result is only valid when there is a majority.\n// Caller must validate that the returned choice represents a majority.\nfunc getMajorityChoice(r VotingRecord) VoteChoice {\n\tvar (\n\t\tchoice       VoteChoice\n\t\tcurrentCount uint\n\t)\n\n\tr.Iterate(func(c VoteChoice, count uint) bool {\n\t\tif currentCount \u003c count {\n\t\t\tchoice = c\n\t\t\tcurrentCount = count\n\t\t}\n\t\treturn false\n\t})\n\n\treturn choice\n}\n"},{"Name":"dao.gno","Body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst daoPathSep = \"/\"\n\n// Option configures DAO.\ntype Option func(*DAO)\n\n// AssignAsSuperCouncil makes the DAO a super council.\nfunc AssignAsSuperCouncil() Option {\n\treturn func(dao *DAO) {\n\t\tdao.isSuperCouncil = true\n\t}\n}\n\n// WithSubDAO assigns sub DAO to a DAO.\nfunc WithSubDAO(sub *DAO) Option {\n\treturn func(dao *DAO) {\n\t\tsub.parent = dao\n\t\tdao.children = append(dao.children, sub)\n\t}\n}\n\n// WithMembers assigns members to a DAO.\nfunc WithMembers(addreses ...std.Address) Option {\n\treturn func(dao *DAO) {\n\t\tdao.members = addreses\n\t}\n}\n\n// New creates a new DAO.\nfunc New(name, title, manifest string, options ...Option) (*DAO, error) {\n\tname = strings.TrimSpace(name)\n\tif name == \"\" {\n\t\treturn nil, errors.New(\"DAO name is required\")\n\t}\n\n\tif !IsSlug(name) {\n\t\treturn nil, errors.New(`DAO name is not valid, only letters from \"a\" to \"z\", numbers, \"-\" and \"_\" are allowed`)\n\t}\n\n\ttitle = strings.TrimSpace(title)\n\tif title == \"\" {\n\t\treturn nil, errors.New(\"DAO title is required\")\n\t}\n\n\tmanifest = strings.TrimSpace(manifest)\n\tif manifest == \"\" {\n\t\treturn nil, errors.New(\"DAO manifest is required\")\n\t}\n\n\tdao := \u0026DAO{\n\t\tname:      name,\n\t\ttitle:     title,\n\t\tmanifest:  manifest,\n\t\tcreatedAt: time.Now(),\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(dao)\n\t}\n\n\treturn dao, nil\n}\n\n// MustNew creates a new DAO.\n// The function panics if any of the arguments is not valid.\nfunc MustNew(name, title, manifest string, options ...Option) *DAO {\n\tdao, err := New(name, title, manifest, options...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn dao\n}\n\n// DAO is a decentralized autonomous organization.\ntype DAO struct {\n\tname           string\n\ttitle          string\n\tmanifest       string // TODO: Rename to \"purpose\"?\n\tisSuperCouncil bool\n\tparent         *DAO\n\tchildren       []*DAO\n\tmembers        []std.Address\n\tcreatedAt      time.Time\n}\n\n// Name returns the name of the DAO.\nfunc (dao DAO) Name() string {\n\treturn dao.name\n}\n\n// Title returns the title of the DAO.\nfunc (dao DAO) Title() string {\n\treturn dao.title\n}\n\n// Manifest returns the manifest of the DAO.\nfunc (dao DAO) Manifest() string {\n\treturn dao.manifest\n}\n\n// SetManifest sets the manifest of the DAO.\nfunc (dao *DAO) SetManifest(s string) {\n\tdao.manifest = s\n}\n\n// CreatedAt returns the creation time of the DAO.\nfunc (dao DAO) CreatedAt() time.Time {\n\treturn dao.createdAt\n}\n\n// Parent returns the parent DAO of the sub DAO.\n// For the main DAO the result is nil.\nfunc (dao DAO) Parent() *DAO {\n\treturn dao.parent\n}\n\n// Path returns the path of the DAO.\nfunc (dao DAO) Path() string {\n\tif dao.parent == nil {\n\t\treturn dao.name\n\t}\n\treturn MakePath(dao.parent.Path(), dao.name)\n}\n\n// SubDAOs returns the sub DAOs.\nfunc (dao DAO) SubDAOs() []*DAO {\n\treturn dao.children\n}\n\n// GetFirstSubDAO returns the first sub DAO.\nfunc (dao DAO) GetFirstSubDAO() *DAO {\n\tif len(dao.children) == 0 {\n\t\treturn nil\n\t}\n\treturn dao.children[0]\n}\n\n// Members returns the members of the DAOs.\nfunc (dao DAO) Members() []std.Address {\n\treturn dao.members\n}\n\n// IsSuperCouncil checks if the DAO is a super council.\nfunc (dao DAO) IsSuperCouncil() bool {\n\treturn dao.isSuperCouncil\n}\n\n// HasMember checks if a member is part of the DAO.\nfunc (dao DAO) HasMember(addr std.Address) bool {\n\tfor _, m := range dao.members {\n\t\tif m == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AddMember adds a member to the DAO.\n// Caller must check the member before adding to avoid duplications.\nfunc (dao *DAO) AddMember(addr std.Address) {\n\tdao.members = append(dao.members, addr)\n}\n\n// GetMember gets a member of the DAO.\nfunc (dao DAO) GetMember(addr std.Address) (std.Address, bool) {\n\tfor _, m := range dao.members {\n\t\tif m == addr {\n\t\t\treturn m, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// RemoveMember removes a member of the DAO.\nfunc (dao *DAO) RemoveMember(addr std.Address) bool {\n\tfor i, m := range dao.members {\n\t\tif m == addr {\n\t\t\tdao.members = append(dao.members[:i], dao.members[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AddSubDAO adds a sub DAO to the DAO.\nfunc (dao *DAO) AddSubDAO(sub *DAO) bool {\n\tfor _, n := range dao.children {\n\t\tif n.name == sub.name {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tsub.parent = dao\n\tdao.children = append(dao.children, sub)\n\treturn true\n}\n\n// GetDAO get a DAO by path.\nfunc (dao *DAO) GetDAO(path string) *DAO {\n\tif path == \"\" {\n\t\treturn nil\n\t}\n\n\tif path == dao.name {\n\t\treturn dao\n\t}\n\n\t// Make sure that current node is not present at the beginning of the path\n\tpath = strings.TrimPrefix(path, dao.name+daoPathSep)\n\n\t// Split DAO path in child name and relative sub path\n\tparts := strings.SplitN(path, daoPathSep, 2)\n\tchildName := parts[0]\n\n\tfor _, sub := range dao.children {\n\t\tif sub.name != childName {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(parts) \u003e 1 {\n\t\t\t// Traverse node children when a sub node path is available\n\t\t\treturn sub.GetDAO(parts[1])\n\t\t}\n\t\treturn sub\n\t}\n\n\treturn nil\n}\n\n// RemoveSubDAO removes a sub DAO.\n// The sub DAO must be a first level children of the DAO.\nfunc (dao *DAO) RemoveSubDAO(name string) bool {\n\tfor i, sub := range dao.children {\n\t\tif sub.name == name {\n\t\t\tdao.children = append(dao.children[:i], dao.children[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsRoot checks if the DAO is the main DAO.\n// The main DAO is the root of the DAO tree.\nfunc (dao DAO) IsRoot() bool {\n\treturn dao.parent == nil\n}\n\n// MakePath creates a new DAO path.\nfunc MakePath(items ...string) string {\n\treturn strings.Join(items, daoPathSep)\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"qQRXi5ZaB7CEuXSCm+9QygZGivJqf7MHF3I767RhoM4tJlMszjMIRfvhloBlzYa09DJMYR1AHP9Te7yUA61NdQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372614"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8","package":{"Name":"closure","Path":"gno.land/r/demo2/closure","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"close.gno","Body":"package y\n\nfunc Foo(cb func(value uint64)) {\n  // ... cryptopunkstar\n  cb(12345)\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsfGYP4d45M3jSq3Cs02mX9XC3pIVzEkSG91ZXpsKZ2s"},"signature":"VKtiK/Z+dRTuQ2fgXbwGPHAmPoyZUXfOQxBL4K/QYFV5+o3r244Moq5p1gxlyamXRooE5mAJSB3qXCZGvMcPgg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372619"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"gnome","Path":"gno.land/r/demo/gnome/dao/v1pre1/gnome","Files":[{"Name":"uri.gno","Body":"package gnome\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar reSlug = regexp.MustCompile(\"^[a-zA-Z]+[a-zA-Z0-9-_]*$\")\n\n// IsSlug checks if a string is a valid slug.\nfunc IsSlug(s string) bool {\n\treturn reSlug.MatchString(s)\n}\n\n// SplitRealmURI splits a Gnoland URI into Realm URI and render path.\nfunc SplitRealmURI(uri string) (realmURI, renderPath string) {\n\tif uri == \"\" {\n\t\treturn\n\t}\n\n\tparts := strings.SplitN(uri, \":\", 2)\n\trealmURI = parts[0]\n\tif len(parts) \u003e 1 {\n\t\trenderPath = parts[1]\n\t}\n\treturn\n}\n\n// JoinRealmURI joins a Realm URI to render paths.\n// It is assumed that the first argument is the Realm URI\n// and the rest of the arguments are render path elements.\nfunc JoinRealmURI(paths ...string) string {\n\tcount := len(paths)\n\tif count == 0 {\n\t\treturn \"\"\n\t}\n\n\trealmURI := paths[0]\n\tif count == 1 {\n\t\treturn realmURI\n\t}\n\treturn realmURI + \":\" + strings.Join(paths[1:], \"/\")\n}\n\n// CutRealmDomain cuts out the Gnoland domain prefix from a URI.\nfunc CutRealmDomain(uri string) string {\n\trealmPath, _ := strings.CutPrefix(uri, \"gno.land\")\n\treturn realmPath\n}\n"},{"Name":"proposal.gno","Body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nconst (\n\tStatusReview ProposalStatus = iota\n\tStatusActive\n\tStatusPassed\n\tStatusRejected\n\tStatusLowParticipation\n\tStatusWithdrawed\n)\n\nconst (\n\t// TODO: Add more choices which also should be configurable (use a different type?)\n\tChoiceNone VoteChoice = \"\"\n\tChoiceYes  VoteChoice = \"yes\"\n\tChoiceNo   VoteChoice = \"no\"\n)\n\nconst (\n\tdefaultVoteChangeDuration = time.Hour\n\texecutionErrorMsg         = \"proposal execution error\"\n)\n\nvar (\n\tErrAlreadyVoted              = errors.New(\"member already voted on this proposal\")\n\tErrInvalidReason             = errors.New(\"reason must have at least 5 characters\")\n\tErrInvalidVoteChoice         = errors.New(\"invalid vote choice\")\n\tErrMemberVoteNotAllowed      = errors.New(\"you must be a DAO or parent DAO member to vote\")\n\tErrProposalVotingDeadlineMet = errors.New(\"proposal voting deadline already met\")\n\tErrProposalNotActive         = errors.New(\"proposal is not active\")\n\tErrProposalNotPassed         = errors.New(`proposal status must be \"passed\"`)\n\tErrReviewStatusRequired      = errors.New(`proposal status must be \"review\"`)\n)\n\ntype (\n\t// ExecutionError indicates that proposal execution failed.\n\tExecutionError struct {\n\t\t// Reason contains the error or error message with the reason of the error.\n\t\tReason interface{}\n\t}\n\n\t// ProposalIterFn defines the a callback to iterate proposals.\n\tProposalIterFn func(*Proposal) bool\n\n\t// ProposalOption configures proposals.\n\tProposalOption func(*Proposal)\n\n\t// ProposalStatus defines the type for proposal states.\n\tProposalStatus uint8\n\n\t// VoteChoice defines the type for proposal vote choices.\n\tVoteChoice string\n\n\t// Vote contains the information for a member vote.\n\tVote struct {\n\t\t// Address is the DAO member address.\n\t\tAddress std.Address\n\n\t\t// Choice is the proposal choice being voted.\n\t\tChoice VoteChoice\n\n\t\t// Reason contains the reason for the vote.\n\t\tReason string\n\n\t\t// DAO contains the DAO that the proposal being voted belongs to.\n\t\tDAO *DAO\n\n\t\t// CreatedAt contains the time when the vote was submitted.\n\t\tCreatedAt time.Time\n\t}\n)\n\n// Error returns the execution error message.\nfunc (e ExecutionError) Error() string {\n\tswitch v := e.Reason.(type) {\n\tcase string:\n\t\treturn executionErrorMsg + \": \" + v\n\tcase error:\n\t\treturn executionErrorMsg + \": \" + v.Error()\n\tdefault:\n\t\treturn executionErrorMsg\n\t}\n}\n\n// String returns the proposal status name.\nfunc (s ProposalStatus) String() string {\n\tswitch s {\n\tcase StatusReview:\n\t\treturn \"review\"\n\tcase StatusActive:\n\t\treturn \"active\"\n\tcase StatusPassed:\n\t\treturn \"passed\"\n\tcase StatusRejected:\n\t\treturn \"rejected\"\n\tcase StatusLowParticipation:\n\t\treturn \"low participation\"\n\tcase StatusWithdrawed:\n\t\treturn \"withdrawed\"\n\tdefault:\n\t\treturn \"invalid\"\n\t}\n}\n\n// IsExecutionError checks if an error is an ExecutionError.\nfunc IsExecutionError(err error) bool {\n\tswitch err.(type) {\n\tcase ExecutionError:\n\t\treturn true\n\tcase *ExecutionError:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// WithVotingDeadline assigns a voting deadline to the proposal.\nfunc WithVotingDeadline(t time.Time) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.votingDeadline = t\n\t}\n}\n\n// WithReviewDeadline assigns a review deadline to the proposal.\n// Review status allows proposal withdraw within a time frame after the proposal is created.\n// Proposals must be activated when a review deadline is assigned.\nfunc WithReviewDeadline(t time.Time) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.reviewDeadline = t\n\t}\n}\n\n// WithVoteChangeDuration change the default grace period to change a submitted vote choice.\nfunc WithVoteChangeDuration(d time.Duration) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.voteChangeDuration = d\n\t}\n}\n\n// NewProposal creates a new proposal.\n// By default proposals use the standard strategy with a deadline of seven days.\nfunc NewProposal(\n\tid ID,\n\tstrategy ProposalStrategy,\n\tproposer std.Address,\n\tdao *DAO,\n\ttitle, description string,\n\toptions ...ProposalOption,\n) (*Proposal, error) {\n\tif dao == nil {\n\t\treturn nil, errors.New(\"proposal DAO is required\")\n\t}\n\n\tif strings.TrimSpace(title) == \"\" {\n\t\treturn nil, errors.New(\"proposal title is required\")\n\t}\n\n\tif strings.TrimSpace(description) == \"\" {\n\t\treturn nil, errors.New(\"proposal description is required\")\n\t}\n\n\tnow := time.Now()\n\tp := \u0026Proposal{\n\t\tid:                 id,\n\t\tproposer:           proposer,\n\t\tdao:                dao,\n\t\ttitle:              title,\n\t\tdescription:        description,\n\t\tvotingDeadline:     now.Add(strategy.VotingPeriod()),\n\t\tvoteChangeDuration: defaultVoteChangeDuration,\n\t\tstrategy:           strategy,\n\t\tvotingRecord:       NewVotingRecord(),\n\t\tcreatedAt:          now,\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(p)\n\t}\n\n\t// Create the proposal as active when a review deadline is not assigned\n\tif p.reviewDeadline.IsZero() {\n\t\tp.status = StatusActive\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn p, nil\n}\n\n// Proposal defines a DAO proposal.\ntype Proposal struct {\n\tid                 ID\n\tdao                *DAO\n\ttitle              string\n\tdescription        string\n\tproposer           std.Address\n\tcreatedAt          time.Time\n\tvotingDeadline     time.Time\n\treviewDeadline     time.Time\n\tvoteChangeDuration time.Duration\n\tstatus             ProposalStatus\n\tstrategy           ProposalStrategy\n\tvotingRecord       *VotingRecord\n\tchoice             VoteChoice\n}\n\n// ID returns the proposal ID.\nfunc (p Proposal) ID() ID {\n\treturn p.id\n}\n\n// DAO returns the DAO that the proposal belongs to.\nfunc (p Proposal) DAO() *DAO {\n\treturn p.dao\n}\n\n// Strategy returns the strategy of the proposal.\nfunc (p Proposal) Strategy() ProposalStrategy {\n\treturn p.strategy\n}\n\n// Title returns the title of the proposal.\nfunc (p Proposal) Title() string {\n\treturn p.title\n}\n\n// Description returns the description of the proposal.\nfunc (p Proposal) Description() string {\n\treturn p.description\n}\n\n// Proposer returns the address of the member that created the proposal.\nfunc (p Proposal) Proposer() std.Address {\n\treturn p.proposer\n}\n\n// Choice returns the winner choice.\nfunc (p Proposal) Choice() VoteChoice {\n\treturn p.choice\n}\n\n// CreatedAt returns the creation time of the proposal.\nfunc (p Proposal) CreatedAt() time.Time {\n\treturn p.createdAt\n}\n\n// VotingDeadline returns the voting deadline for the proposal.\n// No more votes are allowed after this deadline.\nfunc (p Proposal) VotingDeadline() time.Time {\n\treturn p.votingDeadline\n}\n\n// ReviewDeadline returns the deadline for proposal review.\nfunc (p Proposal) ReviewDeadline() time.Time {\n\treturn p.reviewDeadline\n}\n\n// VoteChangeDuration returns the duration after voting where users can change the voted choice.\nfunc (p Proposal) VoteChangeDuration() time.Duration {\n\treturn p.voteChangeDuration\n}\n\n// Status returns the status of the proposal.\nfunc (p Proposal) Status() ProposalStatus {\n\treturn p.status\n}\n\n// Votes returns the proposal votes.\nfunc (p Proposal) Votes() []Vote {\n\treturn p.votingRecord.Votes()\n}\n\n// VotingRecord returns the voting record of the proposal.\n// The record contains the number of votes for each voting choice.\nfunc (p Proposal) VotingRecord() *VotingRecord {\n\treturn p.votingRecord\n}\n\n// IsExecutable checks if the proposal is executable.\nfunc (p Proposal) IsExecutable() bool {\n\t_, ok := p.strategy.(Executer)\n\treturn ok\n}\n\n// IsChoiceAllowed checks if a vote choice is valid for the proposal.\nfunc (p Proposal) IsChoiceAllowed(choice VoteChoice) bool {\n\tfor _, c := range p.strategy.VoteChoices() {\n\t\tif c == choice {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// HasVotingDeadlinePassed checks if the voting deadline for the proposal has passed.\nfunc (p Proposal) HasVotingDeadlinePassed() bool {\n\treturn time.Now().After(p.votingDeadline)\n}\n\n// HasReviewDeadlinePassed checks if the deadline for proposal review has passed.\nfunc (p Proposal) HasReviewDeadlinePassed() bool {\n\treturn time.Now().After(p.reviewDeadline)\n}\n\n// Withdraw changes the status of the proposal to withdrawed.\n// Proposal must have status \"review\" to be withdrawed.\nfunc (p *Proposal) Withdraw() error {\n\tif p.status != StatusReview {\n\t\treturn ErrReviewStatusRequired\n\t}\n\n\tp.status = StatusWithdrawed\n\treturn nil\n}\n\n// Activate changes the status of the proposal to active.\n// Proposal must have status \"review\" to be activated.\nfunc (p *Proposal) Activate() error {\n\t// TODO: Add test cases for proposal Activate() method\n\tif p.status != StatusReview {\n\t\treturn ErrReviewStatusRequired\n\t}\n\n\tp.status = StatusActive\n\treturn nil\n}\n\n// Vote submits a vote for the proposal.\nfunc (p *Proposal) Vote(addr std.Address, choice VoteChoice, reason string) error {\n\tif p.status != StatusActive {\n\t\treturn ErrProposalNotActive\n\t}\n\n\tnow := time.Now()\n\tif p.votingDeadline.Before(now) {\n\t\treturn ErrProposalVotingDeadlineMet\n\t}\n\n\tif !p.IsChoiceAllowed(choice) {\n\t\treturn ErrInvalidVoteChoice\n\t}\n\n\tif reason != \"\" \u0026\u0026 len(reason) \u003c 5 {\n\t\treturn ErrInvalidReason\n\t}\n\n\t// When there is a vote for the account check if it's voting within the\n\t// grace period that allows changing the voted choice. This allows to\n\t// correct mistakes made when seding the vote TX within a small time frame.\n\t// TODO: Add a unit test case to check vote change\n\tfor _, v := range p.votingRecord.Votes() {\n\t\tif v.Address == addr {\n\t\t\tif v.CreatedAt.Add(p.voteChangeDuration).Before(now) {\n\t\t\t\treturn ErrAlreadyVoted\n\t\t\t}\n\n\t\t\tp.votingRecord.Remove(addr)\n\t\t}\n\t}\n\n\t// Check the vote being submitted if vote check is required\n\tif c, ok := p.strategy.(VoteChecker); ok {\n\t\tif err := c.CheckVote(addr, choice, reason); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Account must be a member of the proposal's DAO or any of its parents to be allowed to vote\n\tvar dao *DAO\n\tif p.dao.HasMember(addr) {\n\t\t// When the account is member of the proposal's DAO its vote is accounted\n\t\t// as a vote from this DAO even if its also member of a parent DAO.\n\t\tdao = p.dao\n\t} else {\n\t\t// Try to find the higher order DAO that the account is member of\n\t\tdao = findBelongingDAO(addr, p.dao.parent)\n\t}\n\n\tif dao == nil {\n\t\treturn ErrMemberVoteNotAllowed\n\t}\n\n\tp.votingRecord.Add(Vote{\n\t\tAddress:   addr,\n\t\tChoice:    choice,\n\t\tReason:    reason,\n\t\tDAO:       dao,\n\t\tCreatedAt: time.Now(),\n\t})\n\n\treturn nil\n}\n\n// Tally counts the number of votes and updates the proposal status accordingly.\n// The outcome of counting the votes depends on the proposal strategy.\n// This function does NOT check the voting deadline, it's responsibility of the caller to do so.\nfunc (p *Proposal) Tally() error {\n\tif p.status != StatusActive {\n\t\treturn ErrProposalNotActive\n\t}\n\n\t// Split votes from DAO members and members of parent DAOs\n\tvar memberVotes, parentVotes []Vote\n\tfor _, v := range p.Votes() {\n\t\tif p.dao.HasMember(v.Address) {\n\t\t\tmemberVotes = append(memberVotes, v)\n\t\t} else {\n\t\t\tparentVotes = append(parentVotes, v)\n\t\t}\n\t}\n\n\t// Votes from parent DAOs dismisses all votes from members of the current DAO\n\tif len(parentVotes) \u003e 0 {\n\t\tp.tallyParentVotes(parentVotes)\n\t} else {\n\t\tp.tallyMemberVotes(memberVotes)\n\t}\n\treturn nil\n}\n\nfunc (p Proposal) Validate() error {\n\tif v, ok := p.strategy.(Validator); ok {\n\t\tif err := v.Validate(p.dao); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Execute executes the proposal.\nfunc (p *Proposal) Execute() error {\n\tif p.status != StatusPassed {\n\t\treturn ErrProposalNotPassed\n\t}\n\n\tif e, ok := p.strategy.(Executer); ok {\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn ExecutionError{err}\n\t\t}\n\n\t\tif err := e.Execute(p.dao); err != nil {\n\t\t\treturn ExecutionError{err}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Proposal) tallyParentVotes(votes []Vote) {\n\t// TODO: Implement parent votes tally\n\t// TODO: Save member votes tally results? Or use a proposal status to show votes were dismissed?\n}\n\nfunc (p *Proposal) tallyMemberVotes(votes []Vote) {\n\t// TODO: Deal with the case where a member that voted in active proposals is removed.\n\t//       Index/Keep track of the DAOs each member belongs to? For easy access to proposals.\n\n\t// Check if the required quorum is met\n\tpercentage := float64(len(votes)) / float64(len(p.dao.Members()))\n\tif percentage \u003c p.strategy.Quorum() {\n\t\tp.status = StatusLowParticipation\n\t\treturn\n\t}\n\n\t// Tally votes and update proposal with the outcome\n\tchoice := p.strategy.Tally(p.dao, *p.votingRecord)\n\n\tswitch choice {\n\tcase ChoiceYes:\n\t\tp.choice = ChoiceYes\n\t\tp.status = StatusPassed\n\tcase ChoiceNo:\n\t\tp.status = StatusRejected\n\tdefault:\n\t\tp.status = StatusLowParticipation\n\t}\n}\n\n// Proposals helps managing multiple proposals.\n// Its also a factory for proposals that assigns incremental IDs to each new proposal.\ntype Proposals struct {\n\tlastID    ID\n\tproposals avl.Tree // ID -\u003e *Proposal\n\tgroups    avl.Tree // DAO name -\u003e []*Proposal\n}\n\n// New creates a new proposal.\nfunc (ps *Proposals) New(\n\tstrategy ProposalStrategy,\n\tproposer std.Address,\n\tdao *DAO,\n\ttitle, description string,\n\toptions ...ProposalOption,\n) (*Proposal, error) {\n\tp, err := NewProposal(ps.genID(), strategy, proposer, dao, title, description, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tps.indexProposal(p)\n\n\treturn p, nil\n}\n\n// Exists checks if a proposal exists.\nfunc (ps Proposals) Exists(id ID) bool {\n\treturn ps.proposals.Has(id.Key())\n}\n\n// Get gets a proposal.\nfunc (ps Proposals) Get(id ID) *Proposal {\n\tif v, exists := ps.proposals.Get(id.Key()); exists {\n\t\treturn v.(*Proposal)\n\t}\n\treturn nil\n}\n\n// GetByDAO gets all proposals of a DAO.\nfunc (ps Proposals) GetByDAO(daoName string) []*Proposal {\n\tif v, exists := ps.groups.Get(daoName); exists {\n\t\treturn v.([]*Proposal)\n\t}\n\treturn nil\n}\n\n// Iterate iterates all proposals starting from the oldest one.\nfunc (ps Proposals) Iterate(fn ProposalIterFn) bool {\n\treturn ps.proposals.Iterate(\"\", \"\", func(_ string, value interface{}) bool {\n\t\treturn fn(value.(*Proposal))\n\t})\n}\n\n// ReverseIterate iterates all proposals starting from the latest one.\nfunc (ps Proposals) ReverseIterate(fn ProposalIterFn) bool {\n\treturn ps.proposals.ReverseIterate(\"\", \"\", func(_ string, value interface{}) bool {\n\t\treturn fn(value.(*Proposal))\n\t})\n}\n\nfunc (ps *Proposals) genID() ID {\n\tps.lastID += 1\n\treturn ps.lastID\n}\n\nfunc (ps *Proposals) indexProposal(p *Proposal) {\n\tdaoName := p.DAO().Name()\n\tproposals := ps.GetByDAO(daoName)\n\tps.groups.Set(daoName, append([]*Proposal{p}, proposals...)) // reverse append\n\tps.proposals.Set(p.ID().Key(), p)\n}\n\nfunc findBelongingDAO(addr std.Address, node *DAO) *DAO {\n\tif node == nil {\n\t\treturn nil\n\t}\n\n\t// Before checking the current DAO try to find\n\t// if address is a member of a higher order DAO\n\tdao := findBelongingDAO(addr, node.parent)\n\tif dao == nil \u0026\u0026 node.HasMember(addr) {\n\t\treturn node\n\t}\n\treturn nil\n}\n"},{"Name":"id.gno","Body":"package gnome\n\nimport (\n\t\"strconv\"\n)\n\n// ID defines a generic ID type.\ntype ID uint64\n\n// String returns the value of the ID as a string.\nfunc (id ID) String() string {\n\treturn strconv.Itoa(int(id))\n}\n\n// Key returns the binary representation of the ID to be used as key for AVL trees.\nfunc (id ID) Key() string {\n\treturn strconv.Itoa(int(id))\n}"},{"Name":"strategy.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\t\"time\"\n)\n\ntype (\n\t// VoteChoiceRecord contains the number of counted votes for a single voting choice.\n\tVoteChoiceRecord struct {\n\t\tChoice VoteChoice\n\t\tCount  uint\n\t}\n\n\t// ProposalStrategy defines the interface for the different proposal types.\n\tProposalStrategy interface {\n\t\t// Name returns the name of the strategy.\n\t\tName() string\n\n\t\t// Quorum returns the minimum required percentage of DAO member votes\n\t\t// required for a proposal to pass.\n\t\tQuorum() float64\n\n\t\t// VotingPeriod returns the period that a proposal should allow voting.\n\t\tVotingPeriod() time.Duration\n\n\t\t// VoteChoices returns the valid voting choices for the strategy.\n\t\tVoteChoices() []VoteChoice\n\n\t\t// Tally counts the votes and returns the winner voting choice.\n\t\tTally(*DAO, VotingRecord) VoteChoice\n\t}\n)\n\n// VoteChecker defines an interface for proposal vote validation.\n// Proposal strategies that require checking votes when they are submitted should implement it.\ntype VoteChecker interface {\n\t// CheckVote checks that a vote is valid for the strategy.\n\tCheckVote(member std.Address, choice VoteChoice, reason string) error\n}\n\n// Executer defines an interface for executable proposals.\n// Proposals strategies that implement the interface can modify the DAO state when proposal passes.\ntype Executer interface {\n\t// Execute executes the proposal.\n\t// TODO: Execute should return some feedback on success\n\tExecute(*DAO) error\n}\n\n// Validator defines an interface for proposal validation.\n// Proposal strategies that implement the interface can validate that a proposal is valid for the current DAO state.\ntype Validator interface {\n\t// Validate validates if a proposal is valid for the current DAO state.\n\tValidate(*DAO) error\n}\n"},{"Name":"paginator.gno","Body":"package gnome\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst paginatorStyle = `\u003cstyle\u003e\n.paginator { text-align: center; }\n.paginator a { text-decoration: none; }\n.paginator a:hover { text-decoration: underline; }\n.paginator .left { padding-right: 4px; }\n.paginator .right { padding-left: 4px; }\n\u003c/style\u003e`\n\nvar (\n\tdefaultPageSize = 50\n\tminPageSize     = 1\n\tpagePrefix      = \"page=\"\n)\n\ntype (\n\t// PaginatorIterFn defines a callback to iterate page items.\n\tPaginatorIterFn func(index int) (stop bool)\n\n\t// PaginatorOption configures the paginator.\n\tPaginatorOption func(*Paginator)\n)\n\n// WithPageSize assigns a page size to a paginator.\n// The minimum page size is 5.\nfunc WithPageSize(size int) PaginatorOption {\n\treturn func(p *Paginator) {\n\t\tif size \u003c minPageSize {\n\t\t\tp.pageSize = minPageSize\n\t\t} else {\n\t\t\tp.pageSize = size\n\t\t}\n\t}\n}\n\n// WithItemCount assigns the total number of items that can be paginated.\n// Assigning the total item count allows the paginator to determine the last page number.\nfunc WithItemCount(count int) PaginatorOption {\n\treturn func(p *Paginator) {\n\t\tp.itemCount = count\n\t}\n}\n\n// NewPaginator creates a new paginator.\n// URI path must contain the page number for the paginator to iterate items.\n// Page number is specified in the URI path using \"page=N\" where N is the page\n// number which must start from 1. For example: gno.land/p/gnome:a/b/page=2.\n// Paginator is disabled when the URI path doesn't have a page specified or\n// when the specified page is not valid.\nfunc NewPaginator(uri string, options ...PaginatorOption) Paginator {\n\trealmURI, renderPath := SplitRealmURI(uri)\n\tp := Paginator{\n\t\trealmPath: CutRealmDomain(realmURI),\n\t\tpageSize:  defaultPageSize,\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(\u0026p)\n\t}\n\n\tp.lastPage = int(math.Ceil(float64(p.itemCount) / float64(p.pageSize)))\n\n\t// Iterate path items until paginator arguments are found.\n\t// Path prefix and suffix are kept to be able to generate\n\t// page URLs keeping the render path format.\n\titems := strings.Split(renderPath, \"/\")\n\tfor i, item := range items {\n\t\tif strings.HasPrefix(item, pagePrefix) {\n\t\t\tp.pathSuffix = items[i+1:]\n\t\t\tp.page, _ = strconv.Atoi(item[len(pagePrefix):])\n\t\t\tbreak\n\t\t}\n\n\t\tp.pathPrefix = append(p.pathPrefix, item)\n\t}\n\treturn p\n}\n\n// Paginator allows paging items.\ntype Paginator struct {\n\trealmPath                           string\n\tpathPrefix, pathSuffix              []string\n\tpageSize, page, lastPage, itemCount int\n}\n\n// Offset returns the index for the first page item.\nfunc (p Paginator) Offset() int {\n\tif !p.IsEnabled() {\n\t\treturn 0\n\t}\n\treturn (p.page - 1) * p.pageSize\n}\n\n// PageSize returns the size of each page.\nfunc (p Paginator) PageSize() int {\n\treturn p.pageSize\n}\n\n// Page returns the current page number.\n// Zero is returned when the paginator is disabled.\nfunc (p Paginator) Page() int {\n\treturn p.page\n}\n\n// LastPage returns the number of the last page.\n// Zero is returned when paginator is initialized without the total item count.\nfunc (p Paginator) LastPage() int {\n\treturn p.lastPage\n}\n\n// IsEnabled checks if paginator is enabled.\nfunc (p Paginator) IsEnabled() bool {\n\treturn p.page \u003e 0\n}\n\n// IsLastPage checks if the current page is the last one.\nfunc (p Paginator) IsLastPage() bool {\n\treturn p.page == p.lastPage\n}\n\n// GetPageURI returns the URI for a page.\n// An empty string is returned when page is \u003c 1.\nfunc (p Paginator) GetPageURI(page int) string {\n\tif !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\n\trenderPath := append(p.pathPrefix, pagePrefix+strconv.Itoa(page))\n\trenderPath = append(renderPath, p.pathSuffix...)\n\treturn p.realmPath + \":\" + strings.Join(renderPath, \"/\")\n}\n\n// PrevPageURI returns the URI path to the previous page.\n// An empty string is returned when current page is the first page.\nfunc (p Paginator) PrevPageURI() string {\n\tif p.page == 1 || !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\treturn p.GetPageURI(p.page - 1)\n}\n\n// NextPageURI returns the URI path to the next page.\nfunc (p Paginator) NextPageURI() string {\n\tif p.IsLastPage() {\n\t\treturn \"\"\n\t}\n\treturn p.GetPageURI(p.page + 1)\n}\n\n// Iterate allows iterating page items.\nfunc (p Paginator) Iterate(fn PaginatorIterFn) bool {\n\tif !p.IsEnabled() {\n\t\treturn true\n\t}\n\n\tstart := p.Offset()\n\tfor i := start; i \u003c start+p.PageSize(); i++ {\n\t\tif fn(i) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p Paginator) Render() string {\n\tif !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\n\tvar markdown string\n\tif s := p.PrevPageURI(); s != \"\" {\n\t\tmarkdown = ufmt.Sprintf(`\u003ca href=\"%s\" class=\"left\"\u003e\u0026lt;-\u003c/a\u003e`, s)\n\t} else {\n\t\tmarkdown += `\u003cspan class=\"left\"\u003e--\u003c/span\u003e`\n\t}\n\n\t// TODO: Add display links to other page numbers?\n\tmarkdown += ufmt.Sprintf(\"page %d\", p.page)\n\n\tif s := p.NextPageURI(); s != \"\" {\n\t\tmarkdown += ufmt.Sprintf(`\u003ca href=\"%s\" class=\"right\"\u003e-\u0026gt;\u003c/a\u003e`, s)\n\t} else {\n\t\tmarkdown += `\u003cspan class=\"right\"\u003e--\u003c/span\u003e`\n\t}\n\n\treturn paginatorStyle + `\u003cp class=\"paginator\"\u003e` + markdown + `\u003c/p\u003e`\n}\n"},{"Name":"marshal.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/json\"\n)\n\ntype PreMarshaler interface {\n\tPreMarshal() *json.Node\n}\n\nfunc PreMarshalDAO(dao *DAO) *json.Node {\n\treturn preMarshalDAO(\"dao\", dao)\n}\n\nfunc PreMarshalProposals(p Proposals) *json.Node {\n\tnode := json.ObjectNode(\"proposals\", nil)\n\tnode.AppendObject(\"lastID\", json.StringNode(\"lastID\", p.lastID.String()))\n\tnode.AppendObject(\"proposals\", preMarshalProposals(\"proposals\", p.proposals))\n\tnode.AppendObject(\"groups\", preMarshalProposalGroups(\"groups\", p.groups))\n\treturn node\n}\n\nfunc preMarshalDAO(key string, dao *DAO) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\tnode.AppendObject(\"name\", json.StringNode(\"name\", dao.name))\n\tnode.AppendObject(\"title\", json.StringNode(\"title\", dao.title))\n\tnode.AppendObject(\"manifest\", json.StringNode(\"manifest\", dao.manifest))\n\tnode.AppendObject(\"isSuperCouncil\", json.BoolNode(\"isSuperCouncil\", dao.isSuperCouncil))\n\tnode.AppendObject(\"children\", preMarshalChildren(dao.children))\n\tnode.AppendObject(\"members\", preMarshalAddresses(\"members\", dao.members))\n\tnode.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", dao.createdAt))\n\n\tif dao.parent != nil {\n\t\tnode.AppendObject(\"parentName\", json.StringNode(\"parentName\", dao.parent.name))\n\t} else {\n\t\tnode.AppendObject(\"parentName\", json.NullNode(\"parentName\"))\n\t}\n\n\treturn node\n}\n\nfunc preMarshalChildren(children []*DAO) *json.Node {\n\tif children == nil {\n\t\treturn json.NullNode(\"children\")\n\t}\n\n\tnodes := make([]*json.Node, len(children))\n\tfor i, c := range children {\n\t\tnodes[i] = preMarshalDAO(\"\", c)\n\t}\n\treturn json.ArrayNode(\"children\", nodes)\n}\n\nfunc preMarshalTime(key string, t time.Time) *json.Node {\n\tif t.IsZero() {\n\t\treturn json.NullNode(key)\n\t}\n\treturn json.StringNode(key, t.Format(time.RFC3339))\n}\n\nfunc preMarshalDuration(key string, d time.Duration) *json.Node {\n\treturn json.StringNode(key, strconv.FormatInt(int64(d), 10))\n}\n\nfunc preMarshalAddresses(key string, addresses []std.Address) *json.Node {\n\tif addresses == nil {\n\t\treturn json.NullNode(key)\n\t}\n\n\tnodes := make([]*json.Node, len(addresses))\n\tfor i, a := range addresses {\n\t\tnodes[i] = json.StringNode(\"\", a.String())\n\t}\n\treturn json.ArrayNode(key, nodes)\n}\n\nfunc preMarshalProposals(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(k string, value interface{}) bool {\n\t\tproposalID, _ := ConvertKeyToID(k) // TODO: Error should not happen, handle it anyways\n\t\tnode.AppendObject(proposalID.String(), preMarshalProposal(value.(*Proposal)))\n\t\treturn false\n\t})\n\treturn node\n}\n\nfunc preMarshalProposal(p *Proposal) *json.Node {\n\tnode := json.ObjectNode(\"\", nil)\n\tnode.AppendObject(\"id\", json.StringNode(\"id\", p.id.String()))\n\tnode.AppendObject(\"title\", json.StringNode(\"title\", p.title))\n\tnode.AppendObject(\"description\", json.StringNode(\"description\", p.description))\n\tnode.AppendObject(\"proposer\", json.StringNode(\"proposer\", p.proposer.String()))\n\tnode.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", p.createdAt))\n\tnode.AppendObject(\"votingDeadline\", preMarshalTime(\"votingDeadline\", p.votingDeadline))\n\tnode.AppendObject(\"reviewDeadline\", preMarshalTime(\"reviewDeadline\", p.reviewDeadline))\n\tnode.AppendObject(\"voteChangeDuration\", preMarshalDuration(\"voteChangeDuration\", p.voteChangeDuration))\n\tnode.AppendObject(\"status\", json.StringNode(\"status\", strconv.Itoa(int(p.status))))\n\tnode.AppendObject(\"strategy\", preMarshalStrategy(\"strategy\", p.strategy))\n\tnode.AppendObject(\"choice\", json.StringNode(\"choice\", string(p.choice)))\n\n\tif p.dao != nil {\n\t\tnode.AppendObject(\"daoName\", json.StringNode(\"daoName\", p.dao.name))\n\t} else {\n\t\tnode.AppendObject(\"daoName\", json.NullNode(\"daoName\"))\n\t}\n\n\tif p.votingRecord != nil {\n\t\tnode.AppendObject(\"votingRecord\", preMarshalVotingRecord(\"votingRecord\", p.votingRecord))\n\t} else {\n\t\tnode.AppendObject(\"votingRecord\", json.NullNode(\"votingRecord\"))\n\t}\n\n\treturn node\n}\n\nfunc preMarshalProposalGroups(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(k string, value interface{}) bool {\n\t\t// Save proposal IDs instead of the pre marshalled proposal which is saved inside \"proposals\"\n\t\tvar proposals []*json.Node\n\t\tfor _, p := range value.([]*Proposal) {\n\t\t\tproposals = append(proposals, json.StringNode(\"\", p.id.String()))\n\t\t}\n\n\t\tdaoID, _ := ConvertKeyToID(k) // TODO: Error should not happen, handle it anyways\n\t\tnode.AppendObject(daoID.String(), json.ArrayNode(\"\", proposals))\n\t\treturn false\n\t})\n\treturn node\n}\n\nfunc preMarshalStrategy(key string, s ProposalStrategy) *json.Node {\n\tif m, ok := s.(PreMarshaler); ok {\n\t\treturn m.PreMarshal()\n\t}\n\treturn json.NullNode(key)\n}\n\nfunc preMarshalVotingRecord(key string, r *VotingRecord) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\tnode.AppendObject(\"votes\", preMarshalVotes(\"votes\", r.votes))\n\tnode.AppendObject(\"counter\", preMarshalVoteCounter(\"counter\", r.counter))\n\treturn node\n}\n\nfunc preMarshalVotes(key string, votes []Vote) *json.Node {\n\tnodes := make([]*json.Node, len(votes))\n\tfor i, v := range votes {\n\t\tn := json.ObjectNode(\"\", nil)\n\t\tn.AppendObject(\"address\", json.StringNode(\"address\", v.Address.String()))\n\t\tn.AppendObject(\"choice\", json.StringNode(\"choice\", string(v.Choice)))\n\t\tn.AppendObject(\"reason\", json.StringNode(\"reason\", v.Reason))\n\t\tn.AppendObject(\"createdAt\", preMarshalTime(\"createdAt\", v.CreatedAt))\n\n\t\tif v.DAO != nil {\n\t\t\tn.AppendObject(\"daoName\", json.StringNode(\"daoName\", v.DAO.name))\n\t\t} else {\n\t\t\tn.AppendObject(\"daoName\", json.NullNode(\"daoName\"))\n\t\t}\n\n\t\tnodes[i] = n\n\t}\n\treturn json.ArrayNode(key, nodes)\n}\n\nfunc preMarshalVoteCounter(key string, tree avl.Tree) *json.Node {\n\tnode := json.ObjectNode(key, nil)\n\ttree.Iterate(\"\", \"\", func(choice string, value interface{}) bool {\n\t\tnode.AppendObject(choice, json.NumberNode(\"\", float64(value.(uint))))\n\t\treturn false\n\t})\n\treturn node\n}\n"},{"Name":"record.gno","Body":"package gnome\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// VotingRecordIterFn defines the a callback to iterate voting choices.\ntype VotingRecordIterFn func(_ VoteChoice, voteCount uint) bool\n\n// NewVotingRecord creates a new voting record.\nfunc NewVotingRecord() *VotingRecord {\n\treturn \u0026VotingRecord{}\n}\n\n// VotingRecord mamages votes and vote count.\ntype VotingRecord struct {\n\tvotes   []Vote\n\tcounter avl.Tree // VoteChoice -\u003e count (uint)\n}\n\n// Votes return the list of votes.\nfunc (r VotingRecord) Votes() []Vote {\n\treturn r.votes\n}\n\n// VoteCount returns the number of votes.\nfunc (r VotingRecord) VoteCount() int {\n\treturn len(r.votes)\n}\n\n// Get returns the number of votes for vote choice.\nfunc (r VotingRecord) Get(c VoteChoice) uint {\n\tkey := string(c)\n\tif v, ok := r.counter.Get(key); ok {\n\t\treturn v.(uint)\n\t}\n\treturn 0\n}\n\n// Add adds a vote to the record.\nfunc (r *VotingRecord) Add(v Vote) {\n\tr.votes = append(r.votes, v)\n\tkey := string(v.Choice)\n\tr.counter.Set(key, r.Get(v.Choice)+1)\n}\n\n// Remove removes a vote from the record.\nfunc (r *VotingRecord) Remove(addr std.Address) bool {\n\tfor i, v := range r.votes {\n\t\tif v.Address == addr {\n\t\t\tr.votes = append(r.votes[:i], r.votes[i+1:]...)\n\t\t\tkey := string(v.Choice)\n\t\t\tr.counter.Set(key, r.Get(v.Choice)-1)\n\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Iterate iterates all vote choices.\nfunc (r VotingRecord) Iterate(fn VotingRecordIterFn) bool {\n\treturn r.counter.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tchoice := VoteChoice(key)\n\t\treturn fn(choice, value.(uint))\n\t})\n}\n\n// SelectChoiceByMajority select the vote choice by majority.\n// Vote choice is a majority when chosen by more than half of the votes.\n// Majority type is defined by the caller depending on the vote records and abstentions, it would be\n// absolute majority if abstentions are considered, otherwise it would potentially be simple majority.\nfunc SelectChoiceByMajority(r VotingRecord, abstentions int) (VoteChoice, bool) {\n\tvotesCount := r.VoteCount() + abstentions\n\tchoice := getMajorityChoice(r)\n\tisMajority := r.Get(choice) \u003e uint(votesCount/2)\n\treturn choice, isMajority\n}\n\n// SelectChoiceBySuperMajority select the vote choice by super majority using a 2/3s threshold.\n// Abstentions are not considered when calculating the super majority choice.\nfunc SelectChoiceBySuperMajority(r VotingRecord) (VoteChoice, bool) {\n\tchoice := getMajorityChoice(r)\n\tisMajority := r.Get(choice) \u003e uint((2*r.VoteCount())/3) // TODO: Allow threshold customization\n\treturn choice, isMajority\n}\n\n// getMajorityChoice returns the choice voted by the majority.\n// The result is only valid when there is a majority.\n// Caller must validate that the returned choice represents a majority.\nfunc getMajorityChoice(r VotingRecord) VoteChoice {\n\tvar (\n\t\tchoice       VoteChoice\n\t\tcurrentCount uint\n\t)\n\n\tr.Iterate(func(c VoteChoice, count uint) bool {\n\t\tif currentCount \u003c count {\n\t\t\tchoice = c\n\t\t\tcurrentCount = count\n\t\t}\n\t\treturn false\n\t})\n\n\treturn choice\n}\n"},{"Name":"dao.gno","Body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst daoPathSep = \"/\"\n\n// Option configures DAO.\ntype Option func(*DAO)\n\n// AssignAsSuperCouncil makes the DAO a super council.\nfunc AssignAsSuperCouncil() Option {\n\treturn func(dao *DAO) {\n\t\tdao.isSuperCouncil = true\n\t}\n}\n\n// WithSubDAO assigns sub DAO to a DAO.\nfunc WithSubDAO(sub *DAO) Option {\n\treturn func(dao *DAO) {\n\t\tsub.parent = dao\n\t\tdao.children = append(dao.children, sub)\n\t}\n}\n\n// WithMembers assigns members to a DAO.\nfunc WithMembers(addreses ...std.Address) Option {\n\treturn func(dao *DAO) {\n\t\tdao.members = addreses\n\t}\n}\n\n// New creates a new DAO.\nfunc New(name, title, manifest string, options ...Option) (*DAO, error) {\n\tname = strings.TrimSpace(name)\n\tif name == \"\" {\n\t\treturn nil, errors.New(\"DAO name is required\")\n\t}\n\n\tif !IsSlug(name) {\n\t\treturn nil, errors.New(`DAO name is not valid, only letters from \"a\" to \"z\", numbers, \"-\" and \"_\" are allowed`)\n\t}\n\n\ttitle = strings.TrimSpace(title)\n\tif title == \"\" {\n\t\treturn nil, errors.New(\"DAO title is required\")\n\t}\n\n\tmanifest = strings.TrimSpace(manifest)\n\tif manifest == \"\" {\n\t\treturn nil, errors.New(\"DAO manifest is required\")\n\t}\n\n\tdao := \u0026DAO{\n\t\tname:      name,\n\t\ttitle:     title,\n\t\tmanifest:  manifest,\n\t\tcreatedAt: time.Now(),\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(dao)\n\t}\n\n\treturn dao, nil\n}\n\n// MustNew creates a new DAO.\n// The function panics if any of the arguments is not valid.\nfunc MustNew(name, title, manifest string, options ...Option) *DAO {\n\tdao, err := New(name, title, manifest, options...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn dao\n}\n\n// DAO is a decentralized autonomous organization.\ntype DAO struct {\n\tname           string\n\ttitle          string\n\tmanifest       string // TODO: Rename to \"purpose\"?\n\tisSuperCouncil bool\n\tparent         *DAO\n\tchildren       []*DAO\n\tmembers        []std.Address\n\tcreatedAt      time.Time\n}\n\n// Name returns the name of the DAO.\nfunc (dao DAO) Name() string {\n\treturn dao.name\n}\n\n// Title returns the title of the DAO.\nfunc (dao DAO) Title() string {\n\treturn dao.title\n}\n\n// Manifest returns the manifest of the DAO.\nfunc (dao DAO) Manifest() string {\n\treturn dao.manifest\n}\n\n// SetManifest sets the manifest of the DAO.\nfunc (dao *DAO) SetManifest(s string) {\n\tdao.manifest = s\n}\n\n// CreatedAt returns the creation time of the DAO.\nfunc (dao DAO) CreatedAt() time.Time {\n\treturn dao.createdAt\n}\n\n// Parent returns the parent DAO of the sub DAO.\n// For the main DAO the result is nil.\nfunc (dao DAO) Parent() *DAO {\n\treturn dao.parent\n}\n\n// Path returns the path of the DAO.\nfunc (dao DAO) Path() string {\n\tif dao.parent == nil {\n\t\treturn dao.name\n\t}\n\treturn MakePath(dao.parent.Path(), dao.name)\n}\n\n// SubDAOs returns the sub DAOs.\nfunc (dao DAO) SubDAOs() []*DAO {\n\treturn dao.children\n}\n\n// GetFirstSubDAO returns the first sub DAO.\nfunc (dao DAO) GetFirstSubDAO() *DAO {\n\tif len(dao.children) == 0 {\n\t\treturn nil\n\t}\n\treturn dao.children[0]\n}\n\n// Members returns the members of the DAOs.\nfunc (dao DAO) Members() []std.Address {\n\treturn dao.members\n}\n\n// IsSuperCouncil checks if the DAO is a super council.\nfunc (dao DAO) IsSuperCouncil() bool {\n\treturn dao.isSuperCouncil\n}\n\n// HasMember checks if a member is part of the DAO.\nfunc (dao DAO) HasMember(addr std.Address) bool {\n\tfor _, m := range dao.members {\n\t\tif m == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AddMember adds a member to the DAO.\n// Caller must check the member before adding to avoid duplications.\nfunc (dao *DAO) AddMember(addr std.Address) {\n\tdao.members = append(dao.members, addr)\n}\n\n// GetMember gets a member of the DAO.\nfunc (dao DAO) GetMember(addr std.Address) (std.Address, bool) {\n\tfor _, m := range dao.members {\n\t\tif m == addr {\n\t\t\treturn m, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// RemoveMember removes a member of the DAO.\nfunc (dao *DAO) RemoveMember(addr std.Address) bool {\n\tfor i, m := range dao.members {\n\t\tif m == addr {\n\t\t\tdao.members = append(dao.members[:i], dao.members[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AddSubDAO adds a sub DAO to the DAO.\nfunc (dao *DAO) AddSubDAO(sub *DAO) bool {\n\tfor _, n := range dao.children {\n\t\tif n.name == sub.name {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tsub.parent = dao\n\tdao.children = append(dao.children, sub)\n\treturn true\n}\n\n// GetDAO get a DAO by path.\nfunc (dao *DAO) GetDAO(path string) *DAO {\n\tif path == \"\" {\n\t\treturn nil\n\t}\n\n\tif path == dao.name {\n\t\treturn dao\n\t}\n\n\t// Make sure that current node is not present at the beginning of the path\n\tpath = strings.TrimPrefix(path, dao.name+daoPathSep)\n\n\t// Split DAO path in child name and relative sub path\n\tparts := strings.SplitN(path, daoPathSep, 2)\n\tchildName := parts[0]\n\n\tfor _, sub := range dao.children {\n\t\tif sub.name != childName {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(parts) \u003e 1 {\n\t\t\t// Traverse node children when a sub node path is available\n\t\t\treturn sub.GetDAO(parts[1])\n\t\t}\n\t\treturn sub\n\t}\n\n\treturn nil\n}\n\n// RemoveSubDAO removes a sub DAO.\n// The sub DAO must be a first level children of the DAO.\nfunc (dao *DAO) RemoveSubDAO(name string) bool {\n\tfor i, sub := range dao.children {\n\t\tif sub.name == name {\n\t\t\tdao.children = append(dao.children[:i], dao.children[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsRoot checks if the DAO is the main DAO.\n// The main DAO is the root of the DAO tree.\nfunc (dao DAO) IsRoot() bool {\n\treturn dao.parent == nil\n}\n\n// MakePath creates a new DAO path.\nfunc MakePath(items ...string) string {\n\treturn strings.Join(items, daoPathSep)\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"rZW4m0nOw4tUd/j9XspyRYny445pqN1jzVMXYT/IKmF1MJOqK8oaNtrfUf6zx62cn3yhpm8wLTi4wFSeagdfwA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372621"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8","package":{"Name":"hello","Path":"gno.land/r/demo2/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsfGYP4d45M3jSq3Cs02mX9XC3pIVzEkSG91ZXpsKZ2s"},"signature":"YHSPrcBzmTxoGSWpEqnCV2h2oWmw0y3kGifoJBkRTNpCTSL9N+yxPHSju4Lk7MN0VR04juOvsHJAq9Ab+fsZRQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372623"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"json","Path":"gno.land/p/demo/json","Files":[{"Name":"escape.gno","Body":"package json\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"unicode/utf8\"\n)\n\nconst (\n\tsupplementalPlanesOffset     = 0x10000\n\thighSurrogateOffset          = 0xD800\n\tlowSurrogateOffset           = 0xDC00\n\tsurrogateEnd                 = 0xDFFF\n\tbasicMultilingualPlaneOffset = 0xFFFF\n\tbadHex                       = -1\n)\n\nvar hexLookupTable = [256]int{\n\t'0': 0x0, '1': 0x1, '2': 0x2, '3': 0x3, '4': 0x4,\n\t'5': 0x5, '6': 0x6, '7': 0x7, '8': 0x8, '9': 0x9,\n\t'A': 0xA, 'B': 0xB, 'C': 0xC, 'D': 0xD, 'E': 0xE, 'F': 0xF,\n\t'a': 0xA, 'b': 0xB, 'c': 0xC, 'd': 0xD, 'e': 0xE, 'f': 0xF,\n\t// Fill unspecified index-value pairs with key and value of -1\n\t'G': -1, 'H': -1, 'I': -1, 'J': -1,\n\t'K': -1, 'L': -1, 'M': -1, 'N': -1,\n\t'O': -1, 'P': -1, 'Q': -1, 'R': -1,\n\t'S': -1, 'T': -1, 'U': -1, 'V': -1,\n\t'W': -1, 'X': -1, 'Y': -1, 'Z': -1,\n\t'g': -1, 'h': -1, 'i': -1, 'j': -1,\n\t'k': -1, 'l': -1, 'm': -1, 'n': -1,\n\t'o': -1, 'p': -1, 'q': -1, 'r': -1,\n\t's': -1, 't': -1, 'u': -1, 'v': -1,\n\t'w': -1, 'x': -1, 'y': -1, 'z': -1,\n}\n\nfunc h2i(c byte) int {\n\treturn hexLookupTable[c]\n}\n\n// Unescape takes an input byte slice, processes it to Unescape certain characters,\n// and writes the result into an output byte slice.\n//\n// it returns the processed slice and any error encountered during the Unescape operation.\nfunc Unescape(input, output []byte) ([]byte, error) {\n\t// find the index of the first backslash in the input slice.\n\tfirstBackslash := bytes.IndexByte(input, backSlash)\n\tif firstBackslash == -1 {\n\t\treturn input, nil\n\t}\n\n\t// ensure the output slice has enough capacity to hold the result.\n\tinputLen := len(input)\n\tif cap(output) \u003c inputLen {\n\t\toutput = make([]byte, inputLen)\n\t}\n\n\toutput = output[:inputLen]\n\tcopy(output, input[:firstBackslash])\n\n\tinput = input[firstBackslash:]\n\tbuf := output[firstBackslash:]\n\n\tfor len(input) \u003e 0 {\n\t\tinLen, bufLen, err := processEscapedUTF8(input, buf)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput = input[inLen:] // the number of bytes consumed in the input\n\t\tbuf = buf[bufLen:]    // the number of bytes written to buf\n\n\t\t// find the next backslash in the remaining input\n\t\tnextBackslash := bytes.IndexByte(input, backSlash)\n\t\tif nextBackslash == -1 {\n\t\t\tcopy(buf, input)\n\t\t\tbuf = buf[len(input):]\n\t\t\tbreak\n\t\t}\n\n\t\tcopy(buf, input[:nextBackslash])\n\n\t\tinput = input[nextBackslash:]\n\t\tbuf = buf[nextBackslash:]\n\t}\n\n\treturn output[:len(output)-len(buf)], nil\n}\n\n// isSurrogatePair returns true if the rune is a surrogate pair.\n//\n// A surrogate pairs are used in UTF-16 encoding to encode characters\n// outside the Basic Multilingual Plane (BMP).\nfunc isSurrogatePair(r rune) bool {\n\treturn highSurrogateOffset \u003c= r \u0026\u0026 r \u003c= surrogateEnd\n}\n\n// combineSurrogates reconstruct the original unicode code points in the\n// supplemental plane by combinin the high and low surrogate.\n//\n// The hight surrogate in the range from U+D800 to U+DBFF,\n// and the low surrogate in the range from U+DC00 to U+DFFF.\n//\n// The formula to combine the surrogates is:\n// (high - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000\nfunc combineSurrogates(high, low rune) rune {\n\treturn ((high - highSurrogateOffset) \u003c\u003c 10) + (low - lowSurrogateOffset) + supplementalPlanesOffset\n}\n\n// deocdeSingleUnicodeEscape decodes a unicode escape sequence (e.g., \\uXXXX) into a rune.\nfunc decodeSingleUnicodeEscape(b []byte) (rune, bool) {\n\tif len(b) \u003c 6 {\n\t\treturn utf8.RuneError, false\n\t}\n\n\t// convert hex to decimal\n\th1, h2, h3, h4 := h2i(b[2]), h2i(b[3]), h2i(b[4]), h2i(b[5])\n\tif h1 == badHex || h2 == badHex || h3 == badHex || h4 == badHex {\n\t\treturn utf8.RuneError, false\n\t}\n\n\treturn rune(h1\u003c\u003c12 + h2\u003c\u003c8 + h3\u003c\u003c4 + h4), true\n}\n\n// decodeUnicodeEscape decodes a Unicode escape sequence from a byte slice.\nfunc decodeUnicodeEscape(b []byte) (rune, int) {\n\tr, ok := decodeSingleUnicodeEscape(b)\n\tif !ok {\n\t\treturn utf8.RuneError, -1\n\t}\n\n\t// determine valid unicode escapes within the BMP\n\tif r \u003c= basicMultilingualPlaneOffset \u0026\u0026 !isSurrogatePair(r) {\n\t\treturn r, 6\n\t}\n\n\t// Decode the following escape sequence to verify a UTF-16 susergate pair.\n\tr2, ok := decodeSingleUnicodeEscape(b[6:])\n\tif !ok {\n\t\treturn utf8.RuneError, -1\n\t}\n\n\tif r2 \u003c lowSurrogateOffset {\n\t\treturn utf8.RuneError, -1\n\t}\n\n\treturn combineSurrogates(r, r2), 12\n}\n\nvar escapeByteSet = [256]byte{\n\t'\"':  doubleQuote,\n\t'\\\\': backSlash,\n\t'/':  slash,\n\t'b':  backSpace,\n\t'f':  formFeed,\n\t'n':  newLine,\n\t'r':  carriageReturn,\n\t't':  tab,\n}\n\n// Unquote takes a byte slice and unquotes it by removing\n// the surrounding quotes and unescaping the contents.\nfunc Unquote(s []byte, border byte) (string, bool) {\n\ts, ok := unquoteBytes(s, border)\n\treturn string(s), ok\n}\n\n// unquoteBytes takes a byte slice and unquotes it by removing\n// TODO: consider to move this function to the strconv package.\nfunc unquoteBytes(s []byte, border byte) ([]byte, bool) {\n\tif len(s) \u003c 2 || s[0] != border || s[len(s)-1] != border {\n\t\treturn nil, false\n\t}\n\n\ts = s[1 : len(s)-1]\n\n\tr := 0\n\tfor r \u003c len(s) {\n\t\tc := s[r]\n\n\t\tif c == backSlash || c == border || c \u003c 0x20 {\n\t\t\tbreak\n\t\t}\n\n\t\tif c \u003c utf8.RuneSelf {\n\t\t\tr++\n\t\t\tcontinue\n\t\t}\n\n\t\trr, size := utf8.DecodeRune(s[r:])\n\t\tif rr == utf8.RuneError \u0026\u0026 size == 1 {\n\t\t\tbreak\n\t\t}\n\n\t\tr += size\n\t}\n\n\tif r == len(s) {\n\t\treturn s, true\n\t}\n\n\tutfDoubleMax := utf8.UTFMax * 2\n\tb := make([]byte, len(s)+utfDoubleMax)\n\tw := copy(b, s[0:r])\n\n\tfor r \u003c len(s) {\n\t\tif w \u003e= len(b)-utf8.UTFMax {\n\t\t\tnb := make([]byte, utfDoubleMax+(2*len(b)))\n\t\t\tcopy(nb, b)\n\t\t\tb = nb\n\t\t}\n\n\t\tc := s[r]\n\t\tif c == backSlash {\n\t\t\tr++\n\t\t\tif r \u003e= len(s) {\n\t\t\t\treturn nil, false\n\t\t\t}\n\n\t\t\tif s[r] == 'u' {\n\t\t\t\trr, res := decodeUnicodeEscape(s[r-1:])\n\t\t\t\tif res \u003c 0 {\n\t\t\t\t\treturn nil, false\n\t\t\t\t}\n\n\t\t\t\tw += utf8.EncodeRune(b[w:], rr)\n\t\t\t\tr += 5\n\t\t\t} else {\n\t\t\t\tdecode := escapeByteSet[s[r]]\n\t\t\t\tif decode == 0 {\n\t\t\t\t\treturn nil, false\n\t\t\t\t}\n\n\t\t\t\tif decode == doubleQuote || decode == backSlash || decode == slash {\n\t\t\t\t\tdecode = s[r]\n\t\t\t\t}\n\n\t\t\t\tb[w] = decode\n\t\t\t\tr++\n\t\t\t\tw++\n\t\t\t}\n\t\t} else if c == border || c \u003c 0x20 {\n\t\t\treturn nil, false\n\t\t} else if c \u003c utf8.RuneSelf {\n\t\t\tb[w] = c\n\t\t\tr++\n\t\t\tw++\n\t\t} else {\n\t\t\trr, size := utf8.DecodeRune(s[r:])\n\n\t\t\tif rr == utf8.RuneError \u0026\u0026 size == 1 {\n\t\t\t\treturn nil, false\n\t\t\t}\n\n\t\t\tr += size\n\t\t\tw += utf8.EncodeRune(b[w:], rr)\n\t\t}\n\t}\n\n\treturn b[:w], true\n}\n\n// processEscapedUTF8 processes the escape sequence in the given byte slice and\n// and converts them to UTF-8 characters. The function returns the length of the processed input and output.\n//\n// The input 'in' must contain the escape sequence to be processed,\n// and 'out' provides a space to store the converted characters.\n//\n// The function returns (input length, output length) if the escape sequence is correct.\n// Unicode escape sequences (e.g. \\uXXXX) are decoded to UTF-8, other default escape sequences are\n// converted to their corresponding special characters (e.g. \\n -\u003e newline).\n//\n// If the escape sequence is invalid, or if 'in' does not completely enclose the escape sequence,\n// function returns (-1, -1) to indicate an error.\nfunc processEscapedUTF8(in, out []byte) (int, int, error) {\n\tif len(in) \u003c 2 || in[0] != backSlash {\n\t\treturn -1, -1, errors.New(\"invalid escape sequence\")\n\t}\n\n\tescapeSeqLen := 2\n\tescapeChar := in[1]\n\n\tif escapeChar != 'u' {\n\t\tval := escapeByteSet[escapeChar]\n\t\tif val == 0 {\n\t\t\treturn -1, -1, errors.New(\"invalid escape sequence\")\n\t\t}\n\n\t\tout[0] = val\n\t\treturn escapeSeqLen, 1, nil\n\t}\n\n\tr, size := decodeUnicodeEscape(in)\n\tif size == -1 {\n\t\treturn -1, -1, errors.New(\"invalid escape sequence\")\n\t}\n\n\toutLen := utf8.EncodeRune(out, r)\n\n\treturn size, outLen, nil\n}\n"},{"Name":"eisel_lemire.gno","Body":"// Copyright 2020 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage eisel_lemire\n\n// This file implements the Eisel-Lemire ParseFloat algorithm, published in\n// 2020 and discussed extensively at\n// https://nigeltao.github.io/blog/2020/eisel-lemire.html\n//\n// The original C++ implementation is at\n// https://github.com/lemire/fast_double_parser/blob/644bef4306059d3be01a04e77d3cc84b379c596f/include/fast_double_parser.h#L840\n//\n// This Go re-implementation closely follows the C re-implementation at\n// https://github.com/google/wuffs/blob/ba3818cb6b473a2ed0b38ecfc07dbbd3a97e8ae7/internal/cgen/base/floatconv-submodule-code.c#L990\n//\n// Additional testing (on over several million test strings) is done by\n// https://github.com/nigeltao/parse-number-fxx-test-data/blob/5280dcfccf6d0b02a65ae282dad0b6d9de50e039/script/test-go-strconv.go\n\nimport (\n\t\"math\"\n\t\"math/bits\"\n)\n\nconst (\n\tfloat32ExponentBias = 127\n\tfloat64ExponentBias = 1023\n)\n\n// eiselLemire64 parses a floating-point number from its mantissa and exponent representation.\n// This implementation is based on the Eisel-Lemire ParseFloat algorithm, which is efficient\n// and precise for converting strings to floating-point numbers.\n//\n// Arguments:\n// man (uint64): The mantissa part of the floating-point number.\n// exp10 (int): The exponent part, representing the power of 10.\n// neg (bool): Indicates if the number is negative.\n//\n// Returns:\n// f (float64): The parsed floating-point number.\n// ok (bool): Indicates whether the parsing was successful.\n//\n// The function starts by handling special cases, such as zero mantissa.\n// It then checks if the exponent is within the allowed range.\n// After that, it normalizes the mantissa by left-shifting it to fill\n// the leading zeros. This is followed by the main algorithm logic that\n// converts the normalized mantissa and exponent into a 64-bit floating-point number.\n// The function returns this number along with a boolean indicating the success of the operation.\nfunc EiselLemire64(man uint64, exp10 int, neg bool) (f float64, ok bool) {\n\t// The terse comments in this function body refer to sections of the\n\t// https://nigeltao.github.io/blog/2020/eisel-lemire.html blog post.\n\n\t// Exp10 Range.\n\tif man == 0 {\n\t\tif neg {\n\t\t\tf = math.Float64frombits(0x80000000_00000000) // Negative zero.\n\t\t}\n\n\t\treturn f, true\n\t}\n\n\tif exp10 \u003c detailedPowersOfTenMinExp10 || detailedPowersOfTenMaxExp10 \u003c exp10 {\n\t\treturn 0, false\n\t}\n\n\t// Normalization.\n\tclz := bits.LeadingZeros64(man)\n\tman \u003c\u003c= uint(clz)\n\tretExp2 := uint64(217706*exp10\u003e\u003e16+64+float64ExponentBias) - uint64(clz)\n\n\t// Multiplication.\n\txHi, xLo := bits.Mul64(man, detailedPowersOfTen[exp10-detailedPowersOfTenMinExp10][1])\n\n\t// Wider Approximation.\n\tif xHi\u00260x1FF == 0x1FF \u0026\u0026 xLo+man \u003c man {\n\t\tyHi, yLo := bits.Mul64(man, detailedPowersOfTen[exp10-detailedPowersOfTenMinExp10][0])\n\t\tmergedHi, mergedLo := xHi, xLo+yHi\n\t\tif mergedLo \u003c xLo {\n\t\t\tmergedHi++\n\t\t}\n\n\t\tif mergedHi\u00260x1FF == 0x1FF \u0026\u0026 mergedLo+1 == 0 \u0026\u0026 yLo+man \u003c man {\n\t\t\treturn 0, false\n\t\t}\n\n\t\txHi, xLo = mergedHi, mergedLo\n\t}\n\n\t// Shifting to 54 Bits.\n\tmsb := xHi \u003e\u003e 63\n\tretMantissa := xHi \u003e\u003e (msb + 9)\n\tretExp2 -= 1 ^ msb\n\n\t// Half-way Ambiguity.\n\tif xLo == 0 \u0026\u0026 xHi\u00260x1FF == 0 \u0026\u0026 retMantissa\u00263 == 1 {\n\t\treturn 0, false\n\t}\n\n\t// From 54 to 53 Bits.\n\tretMantissa += retMantissa \u0026 1\n\tretMantissa \u003e\u003e= 1\n\tif retMantissa\u003e\u003e53 \u003e 0 {\n\t\tretMantissa \u003e\u003e= 1\n\t\tretExp2 += 1\n\t}\n\n\t// retExp2 is a uint64. Zero or underflow means that we're in subnormal\n\t// float64 space. 0x7FF or above means that we're in Inf/NaN float64 space.\n\t//\n\t// The if block is equivalent to (but has fewer branches than):\n\t//   if retExp2 \u003c= 0 || retExp2 \u003e= 0x7FF { etc }\n\tif retExp2-1 \u003e= 0x7FF-1 {\n\t\treturn 0, false\n\t}\n\n\tretBits := retExp2\u003c\u003c52 | retMantissa\u00260x000FFFFF_FFFFFFFF\n\tif neg {\n\t\tretBits |= 0x80000000_00000000\n\t}\n\n\treturn math.Float64frombits(retBits), true\n}\n\n// detailedPowersOfTen{Min,Max}Exp10 is the power of 10 represented by the\n// first and last rows of detailedPowersOfTen. Both bounds are inclusive.\nconst (\n\tdetailedPowersOfTenMinExp10 = -348\n\tdetailedPowersOfTenMaxExp10 = +347\n)\n\n// detailedPowersOfTen contains 128-bit mantissa approximations (rounded down)\n// to the powers of 10. For example:\n//\n//   - 1e43  (0xE596B7B0_C643C719                   * (2 ** 79))\n//   - 1e43 = (0xE596B7B0_C643C719_6D9CCD05_D0000000 * (2 ** 15))\n//\n// The mantissas are explicitly listed. The exponents are implied by a linear\n// expression with slope 217706.0/65536.0  log(10)/log(2).\n//\n// The table was generated by\n// https://github.com/google/wuffs/blob/ba3818cb6b473a2ed0b38ecfc07dbbd3a97e8ae7/script/print-mpb-powers-of-10.go\nvar detailedPowersOfTen = [...][2]uint64{\n\t{0x1732C869CD60E453, 0xFA8FD5A0081C0288}, // 1e-348\n\t{0x0E7FBD42205C8EB4, 0x9C99E58405118195}, // 1e-347\n\t{0x521FAC92A873B261, 0xC3C05EE50655E1FA}, // 1e-346\n\t{0xE6A797B752909EF9, 0xF4B0769E47EB5A78}, // 1e-345\n\t{0x9028BED2939A635C, 0x98EE4A22ECF3188B}, // 1e-344\n\t{0x7432EE873880FC33, 0xBF29DCABA82FDEAE}, // 1e-343\n\t{0x113FAA2906A13B3F, 0xEEF453D6923BD65A}, // 1e-342\n\t{0x4AC7CA59A424C507, 0x9558B4661B6565F8}, // 1e-341\n\t{0x5D79BCF00D2DF649, 0xBAAEE17FA23EBF76}, // 1e-340\n\t{0xF4D82C2C107973DC, 0xE95A99DF8ACE6F53}, // 1e-339\n\t{0x79071B9B8A4BE869, 0x91D8A02BB6C10594}, // 1e-338\n\t{0x9748E2826CDEE284, 0xB64EC836A47146F9}, // 1e-337\n\t{0xFD1B1B2308169B25, 0xE3E27A444D8D98B7}, // 1e-336\n\t{0xFE30F0F5E50E20F7, 0x8E6D8C6AB0787F72}, // 1e-335\n\t{0xBDBD2D335E51A935, 0xB208EF855C969F4F}, // 1e-334\n\t{0xAD2C788035E61382, 0xDE8B2B66B3BC4723}, // 1e-333\n\t{0x4C3BCB5021AFCC31, 0x8B16FB203055AC76}, // 1e-332\n\t{0xDF4ABE242A1BBF3D, 0xADDCB9E83C6B1793}, // 1e-331\n\t{0xD71D6DAD34A2AF0D, 0xD953E8624B85DD78}, // 1e-330\n\t{0x8672648C40E5AD68, 0x87D4713D6F33AA6B}, // 1e-329\n\t{0x680EFDAF511F18C2, 0xA9C98D8CCB009506}, // 1e-328\n\t{0x0212BD1B2566DEF2, 0xD43BF0EFFDC0BA48}, // 1e-327\n\t{0x014BB630F7604B57, 0x84A57695FE98746D}, // 1e-326\n\t{0x419EA3BD35385E2D, 0xA5CED43B7E3E9188}, // 1e-325\n\t{0x52064CAC828675B9, 0xCF42894A5DCE35EA}, // 1e-324\n\t{0x7343EFEBD1940993, 0x818995CE7AA0E1B2}, // 1e-323\n\t{0x1014EBE6C5F90BF8, 0xA1EBFB4219491A1F}, // 1e-322\n\t{0xD41A26E077774EF6, 0xCA66FA129F9B60A6}, // 1e-321\n\t{0x8920B098955522B4, 0xFD00B897478238D0}, // 1e-320\n\t{0x55B46E5F5D5535B0, 0x9E20735E8CB16382}, // 1e-319\n\t{0xEB2189F734AA831D, 0xC5A890362FDDBC62}, // 1e-318\n\t{0xA5E9EC7501D523E4, 0xF712B443BBD52B7B}, // 1e-317\n\t{0x47B233C92125366E, 0x9A6BB0AA55653B2D}, // 1e-316\n\t{0x999EC0BB696E840A, 0xC1069CD4EABE89F8}, // 1e-315\n\t{0xC00670EA43CA250D, 0xF148440A256E2C76}, // 1e-314\n\t{0x380406926A5E5728, 0x96CD2A865764DBCA}, // 1e-313\n\t{0xC605083704F5ECF2, 0xBC807527ED3E12BC}, // 1e-312\n\t{0xF7864A44C633682E, 0xEBA09271E88D976B}, // 1e-311\n\t{0x7AB3EE6AFBE0211D, 0x93445B8731587EA3}, // 1e-310\n\t{0x5960EA05BAD82964, 0xB8157268FDAE9E4C}, // 1e-309\n\t{0x6FB92487298E33BD, 0xE61ACF033D1A45DF}, // 1e-308\n\t{0xA5D3B6D479F8E056, 0x8FD0C16206306BAB}, // 1e-307\n\t{0x8F48A4899877186C, 0xB3C4F1BA87BC8696}, // 1e-306\n\t{0x331ACDABFE94DE87, 0xE0B62E2929ABA83C}, // 1e-305\n\t{0x9FF0C08B7F1D0B14, 0x8C71DCD9BA0B4925}, // 1e-304\n\t{0x07ECF0AE5EE44DD9, 0xAF8E5410288E1B6F}, // 1e-303\n\t{0xC9E82CD9F69D6150, 0xDB71E91432B1A24A}, // 1e-302\n\t{0xBE311C083A225CD2, 0x892731AC9FAF056E}, // 1e-301\n\t{0x6DBD630A48AAF406, 0xAB70FE17C79AC6CA}, // 1e-300\n\t{0x092CBBCCDAD5B108, 0xD64D3D9DB981787D}, // 1e-299\n\t{0x25BBF56008C58EA5, 0x85F0468293F0EB4E}, // 1e-298\n\t{0xAF2AF2B80AF6F24E, 0xA76C582338ED2621}, // 1e-297\n\t{0x1AF5AF660DB4AEE1, 0xD1476E2C07286FAA}, // 1e-296\n\t{0x50D98D9FC890ED4D, 0x82CCA4DB847945CA}, // 1e-295\n\t{0xE50FF107BAB528A0, 0xA37FCE126597973C}, // 1e-294\n\t{0x1E53ED49A96272C8, 0xCC5FC196FEFD7D0C}, // 1e-293\n\t{0x25E8E89C13BB0F7A, 0xFF77B1FCBEBCDC4F}, // 1e-292\n\t{0x77B191618C54E9AC, 0x9FAACF3DF73609B1}, // 1e-291\n\t{0xD59DF5B9EF6A2417, 0xC795830D75038C1D}, // 1e-290\n\t{0x4B0573286B44AD1D, 0xF97AE3D0D2446F25}, // 1e-289\n\t{0x4EE367F9430AEC32, 0x9BECCE62836AC577}, // 1e-288\n\t{0x229C41F793CDA73F, 0xC2E801FB244576D5}, // 1e-287\n\t{0x6B43527578C1110F, 0xF3A20279ED56D48A}, // 1e-286\n\t{0x830A13896B78AAA9, 0x9845418C345644D6}, // 1e-285\n\t{0x23CC986BC656D553, 0xBE5691EF416BD60C}, // 1e-284\n\t{0x2CBFBE86B7EC8AA8, 0xEDEC366B11C6CB8F}, // 1e-283\n\t{0x7BF7D71432F3D6A9, 0x94B3A202EB1C3F39}, // 1e-282\n\t{0xDAF5CCD93FB0CC53, 0xB9E08A83A5E34F07}, // 1e-281\n\t{0xD1B3400F8F9CFF68, 0xE858AD248F5C22C9}, // 1e-280\n\t{0x23100809B9C21FA1, 0x91376C36D99995BE}, // 1e-279\n\t{0xABD40A0C2832A78A, 0xB58547448FFFFB2D}, // 1e-278\n\t{0x16C90C8F323F516C, 0xE2E69915B3FFF9F9}, // 1e-277\n\t{0xAE3DA7D97F6792E3, 0x8DD01FAD907FFC3B}, // 1e-276\n\t{0x99CD11CFDF41779C, 0xB1442798F49FFB4A}, // 1e-275\n\t{0x40405643D711D583, 0xDD95317F31C7FA1D}, // 1e-274\n\t{0x482835EA666B2572, 0x8A7D3EEF7F1CFC52}, // 1e-273\n\t{0xDA3243650005EECF, 0xAD1C8EAB5EE43B66}, // 1e-272\n\t{0x90BED43E40076A82, 0xD863B256369D4A40}, // 1e-271\n\t{0x5A7744A6E804A291, 0x873E4F75E2224E68}, // 1e-270\n\t{0x711515D0A205CB36, 0xA90DE3535AAAE202}, // 1e-269\n\t{0x0D5A5B44CA873E03, 0xD3515C2831559A83}, // 1e-268\n\t{0xE858790AFE9486C2, 0x8412D9991ED58091}, // 1e-267\n\t{0x626E974DBE39A872, 0xA5178FFF668AE0B6}, // 1e-266\n\t{0xFB0A3D212DC8128F, 0xCE5D73FF402D98E3}, // 1e-265\n\t{0x7CE66634BC9D0B99, 0x80FA687F881C7F8E}, // 1e-264\n\t{0x1C1FFFC1EBC44E80, 0xA139029F6A239F72}, // 1e-263\n\t{0xA327FFB266B56220, 0xC987434744AC874E}, // 1e-262\n\t{0x4BF1FF9F0062BAA8, 0xFBE9141915D7A922}, // 1e-261\n\t{0x6F773FC3603DB4A9, 0x9D71AC8FADA6C9B5}, // 1e-260\n\t{0xCB550FB4384D21D3, 0xC4CE17B399107C22}, // 1e-259\n\t{0x7E2A53A146606A48, 0xF6019DA07F549B2B}, // 1e-258\n\t{0x2EDA7444CBFC426D, 0x99C102844F94E0FB}, // 1e-257\n\t{0xFA911155FEFB5308, 0xC0314325637A1939}, // 1e-256\n\t{0x793555AB7EBA27CA, 0xF03D93EEBC589F88}, // 1e-255\n\t{0x4BC1558B2F3458DE, 0x96267C7535B763B5}, // 1e-254\n\t{0x9EB1AAEDFB016F16, 0xBBB01B9283253CA2}, // 1e-253\n\t{0x465E15A979C1CADC, 0xEA9C227723EE8BCB}, // 1e-252\n\t{0x0BFACD89EC191EC9, 0x92A1958A7675175F}, // 1e-251\n\t{0xCEF980EC671F667B, 0xB749FAED14125D36}, // 1e-250\n\t{0x82B7E12780E7401A, 0xE51C79A85916F484}, // 1e-249\n\t{0xD1B2ECB8B0908810, 0x8F31CC0937AE58D2}, // 1e-248\n\t{0x861FA7E6DCB4AA15, 0xB2FE3F0B8599EF07}, // 1e-247\n\t{0x67A791E093E1D49A, 0xDFBDCECE67006AC9}, // 1e-246\n\t{0xE0C8BB2C5C6D24E0, 0x8BD6A141006042BD}, // 1e-245\n\t{0x58FAE9F773886E18, 0xAECC49914078536D}, // 1e-244\n\t{0xAF39A475506A899E, 0xDA7F5BF590966848}, // 1e-243\n\t{0x6D8406C952429603, 0x888F99797A5E012D}, // 1e-242\n\t{0xC8E5087BA6D33B83, 0xAAB37FD7D8F58178}, // 1e-241\n\t{0xFB1E4A9A90880A64, 0xD5605FCDCF32E1D6}, // 1e-240\n\t{0x5CF2EEA09A55067F, 0x855C3BE0A17FCD26}, // 1e-239\n\t{0xF42FAA48C0EA481E, 0xA6B34AD8C9DFC06F}, // 1e-238\n\t{0xF13B94DAF124DA26, 0xD0601D8EFC57B08B}, // 1e-237\n\t{0x76C53D08D6B70858, 0x823C12795DB6CE57}, // 1e-236\n\t{0x54768C4B0C64CA6E, 0xA2CB1717B52481ED}, // 1e-235\n\t{0xA9942F5DCF7DFD09, 0xCB7DDCDDA26DA268}, // 1e-234\n\t{0xD3F93B35435D7C4C, 0xFE5D54150B090B02}, // 1e-233\n\t{0xC47BC5014A1A6DAF, 0x9EFA548D26E5A6E1}, // 1e-232\n\t{0x359AB6419CA1091B, 0xC6B8E9B0709F109A}, // 1e-231\n\t{0xC30163D203C94B62, 0xF867241C8CC6D4C0}, // 1e-230\n\t{0x79E0DE63425DCF1D, 0x9B407691D7FC44F8}, // 1e-229\n\t{0x985915FC12F542E4, 0xC21094364DFB5636}, // 1e-228\n\t{0x3E6F5B7B17B2939D, 0xF294B943E17A2BC4}, // 1e-227\n\t{0xA705992CEECF9C42, 0x979CF3CA6CEC5B5A}, // 1e-226\n\t{0x50C6FF782A838353, 0xBD8430BD08277231}, // 1e-225\n\t{0xA4F8BF5635246428, 0xECE53CEC4A314EBD}, // 1e-224\n\t{0x871B7795E136BE99, 0x940F4613AE5ED136}, // 1e-223\n\t{0x28E2557B59846E3F, 0xB913179899F68584}, // 1e-222\n\t{0x331AEADA2FE589CF, 0xE757DD7EC07426E5}, // 1e-221\n\t{0x3FF0D2C85DEF7621, 0x9096EA6F3848984F}, // 1e-220\n\t{0x0FED077A756B53A9, 0xB4BCA50B065ABE63}, // 1e-219\n\t{0xD3E8495912C62894, 0xE1EBCE4DC7F16DFB}, // 1e-218\n\t{0x64712DD7ABBBD95C, 0x8D3360F09CF6E4BD}, // 1e-217\n\t{0xBD8D794D96AACFB3, 0xB080392CC4349DEC}, // 1e-216\n\t{0xECF0D7A0FC5583A0, 0xDCA04777F541C567}, // 1e-215\n\t{0xF41686C49DB57244, 0x89E42CAAF9491B60}, // 1e-214\n\t{0x311C2875C522CED5, 0xAC5D37D5B79B6239}, // 1e-213\n\t{0x7D633293366B828B, 0xD77485CB25823AC7}, // 1e-212\n\t{0xAE5DFF9C02033197, 0x86A8D39EF77164BC}, // 1e-211\n\t{0xD9F57F830283FDFC, 0xA8530886B54DBDEB}, // 1e-210\n\t{0xD072DF63C324FD7B, 0xD267CAA862A12D66}, // 1e-209\n\t{0x4247CB9E59F71E6D, 0x8380DEA93DA4BC60}, // 1e-208\n\t{0x52D9BE85F074E608, 0xA46116538D0DEB78}, // 1e-207\n\t{0x67902E276C921F8B, 0xCD795BE870516656}, // 1e-206\n\t{0x00BA1CD8A3DB53B6, 0x806BD9714632DFF6}, // 1e-205\n\t{0x80E8A40ECCD228A4, 0xA086CFCD97BF97F3}, // 1e-204\n\t{0x6122CD128006B2CD, 0xC8A883C0FDAF7DF0}, // 1e-203\n\t{0x796B805720085F81, 0xFAD2A4B13D1B5D6C}, // 1e-202\n\t{0xCBE3303674053BB0, 0x9CC3A6EEC6311A63}, // 1e-201\n\t{0xBEDBFC4411068A9C, 0xC3F490AA77BD60FC}, // 1e-200\n\t{0xEE92FB5515482D44, 0xF4F1B4D515ACB93B}, // 1e-199\n\t{0x751BDD152D4D1C4A, 0x991711052D8BF3C5}, // 1e-198\n\t{0xD262D45A78A0635D, 0xBF5CD54678EEF0B6}, // 1e-197\n\t{0x86FB897116C87C34, 0xEF340A98172AACE4}, // 1e-196\n\t{0xD45D35E6AE3D4DA0, 0x9580869F0E7AAC0E}, // 1e-195\n\t{0x8974836059CCA109, 0xBAE0A846D2195712}, // 1e-194\n\t{0x2BD1A438703FC94B, 0xE998D258869FACD7}, // 1e-193\n\t{0x7B6306A34627DDCF, 0x91FF83775423CC06}, // 1e-192\n\t{0x1A3BC84C17B1D542, 0xB67F6455292CBF08}, // 1e-191\n\t{0x20CABA5F1D9E4A93, 0xE41F3D6A7377EECA}, // 1e-190\n\t{0x547EB47B7282EE9C, 0x8E938662882AF53E}, // 1e-189\n\t{0xE99E619A4F23AA43, 0xB23867FB2A35B28D}, // 1e-188\n\t{0x6405FA00E2EC94D4, 0xDEC681F9F4C31F31}, // 1e-187\n\t{0xDE83BC408DD3DD04, 0x8B3C113C38F9F37E}, // 1e-186\n\t{0x9624AB50B148D445, 0xAE0B158B4738705E}, // 1e-185\n\t{0x3BADD624DD9B0957, 0xD98DDAEE19068C76}, // 1e-184\n\t{0xE54CA5D70A80E5D6, 0x87F8A8D4CFA417C9}, // 1e-183\n\t{0x5E9FCF4CCD211F4C, 0xA9F6D30A038D1DBC}, // 1e-182\n\t{0x7647C3200069671F, 0xD47487CC8470652B}, // 1e-181\n\t{0x29ECD9F40041E073, 0x84C8D4DFD2C63F3B}, // 1e-180\n\t{0xF468107100525890, 0xA5FB0A17C777CF09}, // 1e-179\n\t{0x7182148D4066EEB4, 0xCF79CC9DB955C2CC}, // 1e-178\n\t{0xC6F14CD848405530, 0x81AC1FE293D599BF}, // 1e-177\n\t{0xB8ADA00E5A506A7C, 0xA21727DB38CB002F}, // 1e-176\n\t{0xA6D90811F0E4851C, 0xCA9CF1D206FDC03B}, // 1e-175\n\t{0x908F4A166D1DA663, 0xFD442E4688BD304A}, // 1e-174\n\t{0x9A598E4E043287FE, 0x9E4A9CEC15763E2E}, // 1e-173\n\t{0x40EFF1E1853F29FD, 0xC5DD44271AD3CDBA}, // 1e-172\n\t{0xD12BEE59E68EF47C, 0xF7549530E188C128}, // 1e-171\n\t{0x82BB74F8301958CE, 0x9A94DD3E8CF578B9}, // 1e-170\n\t{0xE36A52363C1FAF01, 0xC13A148E3032D6E7}, // 1e-169\n\t{0xDC44E6C3CB279AC1, 0xF18899B1BC3F8CA1}, // 1e-168\n\t{0x29AB103A5EF8C0B9, 0x96F5600F15A7B7E5}, // 1e-167\n\t{0x7415D448F6B6F0E7, 0xBCB2B812DB11A5DE}, // 1e-166\n\t{0x111B495B3464AD21, 0xEBDF661791D60F56}, // 1e-165\n\t{0xCAB10DD900BEEC34, 0x936B9FCEBB25C995}, // 1e-164\n\t{0x3D5D514F40EEA742, 0xB84687C269EF3BFB}, // 1e-163\n\t{0x0CB4A5A3112A5112, 0xE65829B3046B0AFA}, // 1e-162\n\t{0x47F0E785EABA72AB, 0x8FF71A0FE2C2E6DC}, // 1e-161\n\t{0x59ED216765690F56, 0xB3F4E093DB73A093}, // 1e-160\n\t{0x306869C13EC3532C, 0xE0F218B8D25088B8}, // 1e-159\n\t{0x1E414218C73A13FB, 0x8C974F7383725573}, // 1e-158\n\t{0xE5D1929EF90898FA, 0xAFBD2350644EEACF}, // 1e-157\n\t{0xDF45F746B74ABF39, 0xDBAC6C247D62A583}, // 1e-156\n\t{0x6B8BBA8C328EB783, 0x894BC396CE5DA772}, // 1e-155\n\t{0x066EA92F3F326564, 0xAB9EB47C81F5114F}, // 1e-154\n\t{0xC80A537B0EFEFEBD, 0xD686619BA27255A2}, // 1e-153\n\t{0xBD06742CE95F5F36, 0x8613FD0145877585}, // 1e-152\n\t{0x2C48113823B73704, 0xA798FC4196E952E7}, // 1e-151\n\t{0xF75A15862CA504C5, 0xD17F3B51FCA3A7A0}, // 1e-150\n\t{0x9A984D73DBE722FB, 0x82EF85133DE648C4}, // 1e-149\n\t{0xC13E60D0D2E0EBBA, 0xA3AB66580D5FDAF5}, // 1e-148\n\t{0x318DF905079926A8, 0xCC963FEE10B7D1B3}, // 1e-147\n\t{0xFDF17746497F7052, 0xFFBBCFE994E5C61F}, // 1e-146\n\t{0xFEB6EA8BEDEFA633, 0x9FD561F1FD0F9BD3}, // 1e-145\n\t{0xFE64A52EE96B8FC0, 0xC7CABA6E7C5382C8}, // 1e-144\n\t{0x3DFDCE7AA3C673B0, 0xF9BD690A1B68637B}, // 1e-143\n\t{0x06BEA10CA65C084E, 0x9C1661A651213E2D}, // 1e-142\n\t{0x486E494FCFF30A62, 0xC31BFA0FE5698DB8}, // 1e-141\n\t{0x5A89DBA3C3EFCCFA, 0xF3E2F893DEC3F126}, // 1e-140\n\t{0xF89629465A75E01C, 0x986DDB5C6B3A76B7}, // 1e-139\n\t{0xF6BBB397F1135823, 0xBE89523386091465}, // 1e-138\n\t{0x746AA07DED582E2C, 0xEE2BA6C0678B597F}, // 1e-137\n\t{0xA8C2A44EB4571CDC, 0x94DB483840B717EF}, // 1e-136\n\t{0x92F34D62616CE413, 0xBA121A4650E4DDEB}, // 1e-135\n\t{0x77B020BAF9C81D17, 0xE896A0D7E51E1566}, // 1e-134\n\t{0x0ACE1474DC1D122E, 0x915E2486EF32CD60}, // 1e-133\n\t{0x0D819992132456BA, 0xB5B5ADA8AAFF80B8}, // 1e-132\n\t{0x10E1FFF697ED6C69, 0xE3231912D5BF60E6}, // 1e-131\n\t{0xCA8D3FFA1EF463C1, 0x8DF5EFABC5979C8F}, // 1e-130\n\t{0xBD308FF8A6B17CB2, 0xB1736B96B6FD83B3}, // 1e-129\n\t{0xAC7CB3F6D05DDBDE, 0xDDD0467C64BCE4A0}, // 1e-128\n\t{0x6BCDF07A423AA96B, 0x8AA22C0DBEF60EE4}, // 1e-127\n\t{0x86C16C98D2C953C6, 0xAD4AB7112EB3929D}, // 1e-126\n\t{0xE871C7BF077BA8B7, 0xD89D64D57A607744}, // 1e-125\n\t{0x11471CD764AD4972, 0x87625F056C7C4A8B}, // 1e-124\n\t{0xD598E40D3DD89BCF, 0xA93AF6C6C79B5D2D}, // 1e-123\n\t{0x4AFF1D108D4EC2C3, 0xD389B47879823479}, // 1e-122\n\t{0xCEDF722A585139BA, 0x843610CB4BF160CB}, // 1e-121\n\t{0xC2974EB4EE658828, 0xA54394FE1EEDB8FE}, // 1e-120\n\t{0x733D226229FEEA32, 0xCE947A3DA6A9273E}, // 1e-119\n\t{0x0806357D5A3F525F, 0x811CCC668829B887}, // 1e-118\n\t{0xCA07C2DCB0CF26F7, 0xA163FF802A3426A8}, // 1e-117\n\t{0xFC89B393DD02F0B5, 0xC9BCFF6034C13052}, // 1e-116\n\t{0xBBAC2078D443ACE2, 0xFC2C3F3841F17C67}, // 1e-115\n\t{0xD54B944B84AA4C0D, 0x9D9BA7832936EDC0}, // 1e-114\n\t{0x0A9E795E65D4DF11, 0xC5029163F384A931}, // 1e-113\n\t{0x4D4617B5FF4A16D5, 0xF64335BCF065D37D}, // 1e-112\n\t{0x504BCED1BF8E4E45, 0x99EA0196163FA42E}, // 1e-111\n\t{0xE45EC2862F71E1D6, 0xC06481FB9BCF8D39}, // 1e-110\n\t{0x5D767327BB4E5A4C, 0xF07DA27A82C37088}, // 1e-109\n\t{0x3A6A07F8D510F86F, 0x964E858C91BA2655}, // 1e-108\n\t{0x890489F70A55368B, 0xBBE226EFB628AFEA}, // 1e-107\n\t{0x2B45AC74CCEA842E, 0xEADAB0ABA3B2DBE5}, // 1e-106\n\t{0x3B0B8BC90012929D, 0x92C8AE6B464FC96F}, // 1e-105\n\t{0x09CE6EBB40173744, 0xB77ADA0617E3BBCB}, // 1e-104\n\t{0xCC420A6A101D0515, 0xE55990879DDCAABD}, // 1e-103\n\t{0x9FA946824A12232D, 0x8F57FA54C2A9EAB6}, // 1e-102\n\t{0x47939822DC96ABF9, 0xB32DF8E9F3546564}, // 1e-101\n\t{0x59787E2B93BC56F7, 0xDFF9772470297EBD}, // 1e-100\n\t{0x57EB4EDB3C55B65A, 0x8BFBEA76C619EF36}, // 1e-99\n\t{0xEDE622920B6B23F1, 0xAEFAE51477A06B03}, // 1e-98\n\t{0xE95FAB368E45ECED, 0xDAB99E59958885C4}, // 1e-97\n\t{0x11DBCB0218EBB414, 0x88B402F7FD75539B}, // 1e-96\n\t{0xD652BDC29F26A119, 0xAAE103B5FCD2A881}, // 1e-95\n\t{0x4BE76D3346F0495F, 0xD59944A37C0752A2}, // 1e-94\n\t{0x6F70A4400C562DDB, 0x857FCAE62D8493A5}, // 1e-93\n\t{0xCB4CCD500F6BB952, 0xA6DFBD9FB8E5B88E}, // 1e-92\n\t{0x7E2000A41346A7A7, 0xD097AD07A71F26B2}, // 1e-91\n\t{0x8ED400668C0C28C8, 0x825ECC24C873782F}, // 1e-90\n\t{0x728900802F0F32FA, 0xA2F67F2DFA90563B}, // 1e-89\n\t{0x4F2B40A03AD2FFB9, 0xCBB41EF979346BCA}, // 1e-88\n\t{0xE2F610C84987BFA8, 0xFEA126B7D78186BC}, // 1e-87\n\t{0x0DD9CA7D2DF4D7C9, 0x9F24B832E6B0F436}, // 1e-86\n\t{0x91503D1C79720DBB, 0xC6EDE63FA05D3143}, // 1e-85\n\t{0x75A44C6397CE912A, 0xF8A95FCF88747D94}, // 1e-84\n\t{0xC986AFBE3EE11ABA, 0x9B69DBE1B548CE7C}, // 1e-83\n\t{0xFBE85BADCE996168, 0xC24452DA229B021B}, // 1e-82\n\t{0xFAE27299423FB9C3, 0xF2D56790AB41C2A2}, // 1e-81\n\t{0xDCCD879FC967D41A, 0x97C560BA6B0919A5}, // 1e-80\n\t{0x5400E987BBC1C920, 0xBDB6B8E905CB600F}, // 1e-79\n\t{0x290123E9AAB23B68, 0xED246723473E3813}, // 1e-78\n\t{0xF9A0B6720AAF6521, 0x9436C0760C86E30B}, // 1e-77\n\t{0xF808E40E8D5B3E69, 0xB94470938FA89BCE}, // 1e-76\n\t{0xB60B1D1230B20E04, 0xE7958CB87392C2C2}, // 1e-75\n\t{0xB1C6F22B5E6F48C2, 0x90BD77F3483BB9B9}, // 1e-74\n\t{0x1E38AEB6360B1AF3, 0xB4ECD5F01A4AA828}, // 1e-73\n\t{0x25C6DA63C38DE1B0, 0xE2280B6C20DD5232}, // 1e-72\n\t{0x579C487E5A38AD0E, 0x8D590723948A535F}, // 1e-71\n\t{0x2D835A9DF0C6D851, 0xB0AF48EC79ACE837}, // 1e-70\n\t{0xF8E431456CF88E65, 0xDCDB1B2798182244}, // 1e-69\n\t{0x1B8E9ECB641B58FF, 0x8A08F0F8BF0F156B}, // 1e-68\n\t{0xE272467E3D222F3F, 0xAC8B2D36EED2DAC5}, // 1e-67\n\t{0x5B0ED81DCC6ABB0F, 0xD7ADF884AA879177}, // 1e-66\n\t{0x98E947129FC2B4E9, 0x86CCBB52EA94BAEA}, // 1e-65\n\t{0x3F2398D747B36224, 0xA87FEA27A539E9A5}, // 1e-64\n\t{0x8EEC7F0D19A03AAD, 0xD29FE4B18E88640E}, // 1e-63\n\t{0x1953CF68300424AC, 0x83A3EEEEF9153E89}, // 1e-62\n\t{0x5FA8C3423C052DD7, 0xA48CEAAAB75A8E2B}, // 1e-61\n\t{0x3792F412CB06794D, 0xCDB02555653131B6}, // 1e-60\n\t{0xE2BBD88BBEE40BD0, 0x808E17555F3EBF11}, // 1e-59\n\t{0x5B6ACEAEAE9D0EC4, 0xA0B19D2AB70E6ED6}, // 1e-58\n\t{0xF245825A5A445275, 0xC8DE047564D20A8B}, // 1e-57\n\t{0xEED6E2F0F0D56712, 0xFB158592BE068D2E}, // 1e-56\n\t{0x55464DD69685606B, 0x9CED737BB6C4183D}, // 1e-55\n\t{0xAA97E14C3C26B886, 0xC428D05AA4751E4C}, // 1e-54\n\t{0xD53DD99F4B3066A8, 0xF53304714D9265DF}, // 1e-53\n\t{0xE546A8038EFE4029, 0x993FE2C6D07B7FAB}, // 1e-52\n\t{0xDE98520472BDD033, 0xBF8FDB78849A5F96}, // 1e-51\n\t{0x963E66858F6D4440, 0xEF73D256A5C0F77C}, // 1e-50\n\t{0xDDE7001379A44AA8, 0x95A8637627989AAD}, // 1e-49\n\t{0x5560C018580D5D52, 0xBB127C53B17EC159}, // 1e-48\n\t{0xAAB8F01E6E10B4A6, 0xE9D71B689DDE71AF}, // 1e-47\n\t{0xCAB3961304CA70E8, 0x9226712162AB070D}, // 1e-46\n\t{0x3D607B97C5FD0D22, 0xB6B00D69BB55C8D1}, // 1e-45\n\t{0x8CB89A7DB77C506A, 0xE45C10C42A2B3B05}, // 1e-44\n\t{0x77F3608E92ADB242, 0x8EB98A7A9A5B04E3}, // 1e-43\n\t{0x55F038B237591ED3, 0xB267ED1940F1C61C}, // 1e-42\n\t{0x6B6C46DEC52F6688, 0xDF01E85F912E37A3}, // 1e-41\n\t{0x2323AC4B3B3DA015, 0x8B61313BBABCE2C6}, // 1e-40\n\t{0xABEC975E0A0D081A, 0xAE397D8AA96C1B77}, // 1e-39\n\t{0x96E7BD358C904A21, 0xD9C7DCED53C72255}, // 1e-38\n\t{0x7E50D64177DA2E54, 0x881CEA14545C7575}, // 1e-37\n\t{0xDDE50BD1D5D0B9E9, 0xAA242499697392D2}, // 1e-36\n\t{0x955E4EC64B44E864, 0xD4AD2DBFC3D07787}, // 1e-35\n\t{0xBD5AF13BEF0B113E, 0x84EC3C97DA624AB4}, // 1e-34\n\t{0xECB1AD8AEACDD58E, 0xA6274BBDD0FADD61}, // 1e-33\n\t{0x67DE18EDA5814AF2, 0xCFB11EAD453994BA}, // 1e-32\n\t{0x80EACF948770CED7, 0x81CEB32C4B43FCF4}, // 1e-31\n\t{0xA1258379A94D028D, 0xA2425FF75E14FC31}, // 1e-30\n\t{0x096EE45813A04330, 0xCAD2F7F5359A3B3E}, // 1e-29\n\t{0x8BCA9D6E188853FC, 0xFD87B5F28300CA0D}, // 1e-28\n\t{0x775EA264CF55347D, 0x9E74D1B791E07E48}, // 1e-27\n\t{0x95364AFE032A819D, 0xC612062576589DDA}, // 1e-26\n\t{0x3A83DDBD83F52204, 0xF79687AED3EEC551}, // 1e-25\n\t{0xC4926A9672793542, 0x9ABE14CD44753B52}, // 1e-24\n\t{0x75B7053C0F178293, 0xC16D9A0095928A27}, // 1e-23\n\t{0x5324C68B12DD6338, 0xF1C90080BAF72CB1}, // 1e-22\n\t{0xD3F6FC16EBCA5E03, 0x971DA05074DA7BEE}, // 1e-21\n\t{0x88F4BB1CA6BCF584, 0xBCE5086492111AEA}, // 1e-20\n\t{0x2B31E9E3D06C32E5, 0xEC1E4A7DB69561A5}, // 1e-19\n\t{0x3AFF322E62439FCF, 0x9392EE8E921D5D07}, // 1e-18\n\t{0x09BEFEB9FAD487C2, 0xB877AA3236A4B449}, // 1e-17\n\t{0x4C2EBE687989A9B3, 0xE69594BEC44DE15B}, // 1e-16\n\t{0x0F9D37014BF60A10, 0x901D7CF73AB0ACD9}, // 1e-15\n\t{0x538484C19EF38C94, 0xB424DC35095CD80F}, // 1e-14\n\t{0x2865A5F206B06FB9, 0xE12E13424BB40E13}, // 1e-13\n\t{0xF93F87B7442E45D3, 0x8CBCCC096F5088CB}, // 1e-12\n\t{0xF78F69A51539D748, 0xAFEBFF0BCB24AAFE}, // 1e-11\n\t{0xB573440E5A884D1B, 0xDBE6FECEBDEDD5BE}, // 1e-10\n\t{0x31680A88F8953030, 0x89705F4136B4A597}, // 1e-9\n\t{0xFDC20D2B36BA7C3D, 0xABCC77118461CEFC}, // 1e-8\n\t{0x3D32907604691B4C, 0xD6BF94D5E57A42BC}, // 1e-7\n\t{0xA63F9A49C2C1B10F, 0x8637BD05AF6C69B5}, // 1e-6\n\t{0x0FCF80DC33721D53, 0xA7C5AC471B478423}, // 1e-5\n\t{0xD3C36113404EA4A8, 0xD1B71758E219652B}, // 1e-4\n\t{0x645A1CAC083126E9, 0x83126E978D4FDF3B}, // 1e-3\n\t{0x3D70A3D70A3D70A3, 0xA3D70A3D70A3D70A}, // 1e-2\n\t{0xCCCCCCCCCCCCCCCC, 0xCCCCCCCCCCCCCCCC}, // 1e-1\n\t{0x0000000000000000, 0x8000000000000000}, // 1e0\n\t{0x0000000000000000, 0xA000000000000000}, // 1e1\n\t{0x0000000000000000, 0xC800000000000000}, // 1e2\n\t{0x0000000000000000, 0xFA00000000000000}, // 1e3\n\t{0x0000000000000000, 0x9C40000000000000}, // 1e4\n\t{0x0000000000000000, 0xC350000000000000}, // 1e5\n\t{0x0000000000000000, 0xF424000000000000}, // 1e6\n\t{0x0000000000000000, 0x9896800000000000}, // 1e7\n\t{0x0000000000000000, 0xBEBC200000000000}, // 1e8\n\t{0x0000000000000000, 0xEE6B280000000000}, // 1e9\n\t{0x0000000000000000, 0x9502F90000000000}, // 1e10\n\t{0x0000000000000000, 0xBA43B74000000000}, // 1e11\n\t{0x0000000000000000, 0xE8D4A51000000000}, // 1e12\n\t{0x0000000000000000, 0x9184E72A00000000}, // 1e13\n\t{0x0000000000000000, 0xB5E620F480000000}, // 1e14\n\t{0x0000000000000000, 0xE35FA931A0000000}, // 1e15\n\t{0x0000000000000000, 0x8E1BC9BF04000000}, // 1e16\n\t{0x0000000000000000, 0xB1A2BC2EC5000000}, // 1e17\n\t{0x0000000000000000, 0xDE0B6B3A76400000}, // 1e18\n\t{0x0000000000000000, 0x8AC7230489E80000}, // 1e19\n\t{0x0000000000000000, 0xAD78EBC5AC620000}, // 1e20\n\t{0x0000000000000000, 0xD8D726B7177A8000}, // 1e21\n\t{0x0000000000000000, 0x878678326EAC9000}, // 1e22\n\t{0x0000000000000000, 0xA968163F0A57B400}, // 1e23\n\t{0x0000000000000000, 0xD3C21BCECCEDA100}, // 1e24\n\t{0x0000000000000000, 0x84595161401484A0}, // 1e25\n\t{0x0000000000000000, 0xA56FA5B99019A5C8}, // 1e26\n\t{0x0000000000000000, 0xCECB8F27F4200F3A}, // 1e27\n\t{0x4000000000000000, 0x813F3978F8940984}, // 1e28\n\t{0x5000000000000000, 0xA18F07D736B90BE5}, // 1e29\n\t{0xA400000000000000, 0xC9F2C9CD04674EDE}, // 1e30\n\t{0x4D00000000000000, 0xFC6F7C4045812296}, // 1e31\n\t{0xF020000000000000, 0x9DC5ADA82B70B59D}, // 1e32\n\t{0x6C28000000000000, 0xC5371912364CE305}, // 1e33\n\t{0xC732000000000000, 0xF684DF56C3E01BC6}, // 1e34\n\t{0x3C7F400000000000, 0x9A130B963A6C115C}, // 1e35\n\t{0x4B9F100000000000, 0xC097CE7BC90715B3}, // 1e36\n\t{0x1E86D40000000000, 0xF0BDC21ABB48DB20}, // 1e37\n\t{0x1314448000000000, 0x96769950B50D88F4}, // 1e38\n\t{0x17D955A000000000, 0xBC143FA4E250EB31}, // 1e39\n\t{0x5DCFAB0800000000, 0xEB194F8E1AE525FD}, // 1e40\n\t{0x5AA1CAE500000000, 0x92EFD1B8D0CF37BE}, // 1e41\n\t{0xF14A3D9E40000000, 0xB7ABC627050305AD}, // 1e42\n\t{0x6D9CCD05D0000000, 0xE596B7B0C643C719}, // 1e43\n\t{0xE4820023A2000000, 0x8F7E32CE7BEA5C6F}, // 1e44\n\t{0xDDA2802C8A800000, 0xB35DBF821AE4F38B}, // 1e45\n\t{0xD50B2037AD200000, 0xE0352F62A19E306E}, // 1e46\n\t{0x4526F422CC340000, 0x8C213D9DA502DE45}, // 1e47\n\t{0x9670B12B7F410000, 0xAF298D050E4395D6}, // 1e48\n\t{0x3C0CDD765F114000, 0xDAF3F04651D47B4C}, // 1e49\n\t{0xA5880A69FB6AC800, 0x88D8762BF324CD0F}, // 1e50\n\t{0x8EEA0D047A457A00, 0xAB0E93B6EFEE0053}, // 1e51\n\t{0x72A4904598D6D880, 0xD5D238A4ABE98068}, // 1e52\n\t{0x47A6DA2B7F864750, 0x85A36366EB71F041}, // 1e53\n\t{0x999090B65F67D924, 0xA70C3C40A64E6C51}, // 1e54\n\t{0xFFF4B4E3F741CF6D, 0xD0CF4B50CFE20765}, // 1e55\n\t{0xBFF8F10E7A8921A4, 0x82818F1281ED449F}, // 1e56\n\t{0xAFF72D52192B6A0D, 0xA321F2D7226895C7}, // 1e57\n\t{0x9BF4F8A69F764490, 0xCBEA6F8CEB02BB39}, // 1e58\n\t{0x02F236D04753D5B4, 0xFEE50B7025C36A08}, // 1e59\n\t{0x01D762422C946590, 0x9F4F2726179A2245}, // 1e60\n\t{0x424D3AD2B7B97EF5, 0xC722F0EF9D80AAD6}, // 1e61\n\t{0xD2E0898765A7DEB2, 0xF8EBAD2B84E0D58B}, // 1e62\n\t{0x63CC55F49F88EB2F, 0x9B934C3B330C8577}, // 1e63\n\t{0x3CBF6B71C76B25FB, 0xC2781F49FFCFA6D5}, // 1e64\n\t{0x8BEF464E3945EF7A, 0xF316271C7FC3908A}, // 1e65\n\t{0x97758BF0E3CBB5AC, 0x97EDD871CFDA3A56}, // 1e66\n\t{0x3D52EEED1CBEA317, 0xBDE94E8E43D0C8EC}, // 1e67\n\t{0x4CA7AAA863EE4BDD, 0xED63A231D4C4FB27}, // 1e68\n\t{0x8FE8CAA93E74EF6A, 0x945E455F24FB1CF8}, // 1e69\n\t{0xB3E2FD538E122B44, 0xB975D6B6EE39E436}, // 1e70\n\t{0x60DBBCA87196B616, 0xE7D34C64A9C85D44}, // 1e71\n\t{0xBC8955E946FE31CD, 0x90E40FBEEA1D3A4A}, // 1e72\n\t{0x6BABAB6398BDBE41, 0xB51D13AEA4A488DD}, // 1e73\n\t{0xC696963C7EED2DD1, 0xE264589A4DCDAB14}, // 1e74\n\t{0xFC1E1DE5CF543CA2, 0x8D7EB76070A08AEC}, // 1e75\n\t{0x3B25A55F43294BCB, 0xB0DE65388CC8ADA8}, // 1e76\n\t{0x49EF0EB713F39EBE, 0xDD15FE86AFFAD912}, // 1e77\n\t{0x6E3569326C784337, 0x8A2DBF142DFCC7AB}, // 1e78\n\t{0x49C2C37F07965404, 0xACB92ED9397BF996}, // 1e79\n\t{0xDC33745EC97BE906, 0xD7E77A8F87DAF7FB}, // 1e80\n\t{0x69A028BB3DED71A3, 0x86F0AC99B4E8DAFD}, // 1e81\n\t{0xC40832EA0D68CE0C, 0xA8ACD7C0222311BC}, // 1e82\n\t{0xF50A3FA490C30190, 0xD2D80DB02AABD62B}, // 1e83\n\t{0x792667C6DA79E0FA, 0x83C7088E1AAB65DB}, // 1e84\n\t{0x577001B891185938, 0xA4B8CAB1A1563F52}, // 1e85\n\t{0xED4C0226B55E6F86, 0xCDE6FD5E09ABCF26}, // 1e86\n\t{0x544F8158315B05B4, 0x80B05E5AC60B6178}, // 1e87\n\t{0x696361AE3DB1C721, 0xA0DC75F1778E39D6}, // 1e88\n\t{0x03BC3A19CD1E38E9, 0xC913936DD571C84C}, // 1e89\n\t{0x04AB48A04065C723, 0xFB5878494ACE3A5F}, // 1e90\n\t{0x62EB0D64283F9C76, 0x9D174B2DCEC0E47B}, // 1e91\n\t{0x3BA5D0BD324F8394, 0xC45D1DF942711D9A}, // 1e92\n\t{0xCA8F44EC7EE36479, 0xF5746577930D6500}, // 1e93\n\t{0x7E998B13CF4E1ECB, 0x9968BF6ABBE85F20}, // 1e94\n\t{0x9E3FEDD8C321A67E, 0xBFC2EF456AE276E8}, // 1e95\n\t{0xC5CFE94EF3EA101E, 0xEFB3AB16C59B14A2}, // 1e96\n\t{0xBBA1F1D158724A12, 0x95D04AEE3B80ECE5}, // 1e97\n\t{0x2A8A6E45AE8EDC97, 0xBB445DA9CA61281F}, // 1e98\n\t{0xF52D09D71A3293BD, 0xEA1575143CF97226}, // 1e99\n\t{0x593C2626705F9C56, 0x924D692CA61BE758}, // 1e100\n\t{0x6F8B2FB00C77836C, 0xB6E0C377CFA2E12E}, // 1e101\n\t{0x0B6DFB9C0F956447, 0xE498F455C38B997A}, // 1e102\n\t{0x4724BD4189BD5EAC, 0x8EDF98B59A373FEC}, // 1e103\n\t{0x58EDEC91EC2CB657, 0xB2977EE300C50FE7}, // 1e104\n\t{0x2F2967B66737E3ED, 0xDF3D5E9BC0F653E1}, // 1e105\n\t{0xBD79E0D20082EE74, 0x8B865B215899F46C}, // 1e106\n\t{0xECD8590680A3AA11, 0xAE67F1E9AEC07187}, // 1e107\n\t{0xE80E6F4820CC9495, 0xDA01EE641A708DE9}, // 1e108\n\t{0x3109058D147FDCDD, 0x884134FE908658B2}, // 1e109\n\t{0xBD4B46F0599FD415, 0xAA51823E34A7EEDE}, // 1e110\n\t{0x6C9E18AC7007C91A, 0xD4E5E2CDC1D1EA96}, // 1e111\n\t{0x03E2CF6BC604DDB0, 0x850FADC09923329E}, // 1e112\n\t{0x84DB8346B786151C, 0xA6539930BF6BFF45}, // 1e113\n\t{0xE612641865679A63, 0xCFE87F7CEF46FF16}, // 1e114\n\t{0x4FCB7E8F3F60C07E, 0x81F14FAE158C5F6E}, // 1e115\n\t{0xE3BE5E330F38F09D, 0xA26DA3999AEF7749}, // 1e116\n\t{0x5CADF5BFD3072CC5, 0xCB090C8001AB551C}, // 1e117\n\t{0x73D9732FC7C8F7F6, 0xFDCB4FA002162A63}, // 1e118\n\t{0x2867E7FDDCDD9AFA, 0x9E9F11C4014DDA7E}, // 1e119\n\t{0xB281E1FD541501B8, 0xC646D63501A1511D}, // 1e120\n\t{0x1F225A7CA91A4226, 0xF7D88BC24209A565}, // 1e121\n\t{0x3375788DE9B06958, 0x9AE757596946075F}, // 1e122\n\t{0x0052D6B1641C83AE, 0xC1A12D2FC3978937}, // 1e123\n\t{0xC0678C5DBD23A49A, 0xF209787BB47D6B84}, // 1e124\n\t{0xF840B7BA963646E0, 0x9745EB4D50CE6332}, // 1e125\n\t{0xB650E5A93BC3D898, 0xBD176620A501FBFF}, // 1e126\n\t{0xA3E51F138AB4CEBE, 0xEC5D3FA8CE427AFF}, // 1e127\n\t{0xC66F336C36B10137, 0x93BA47C980E98CDF}, // 1e128\n\t{0xB80B0047445D4184, 0xB8A8D9BBE123F017}, // 1e129\n\t{0xA60DC059157491E5, 0xE6D3102AD96CEC1D}, // 1e130\n\t{0x87C89837AD68DB2F, 0x9043EA1AC7E41392}, // 1e131\n\t{0x29BABE4598C311FB, 0xB454E4A179DD1877}, // 1e132\n\t{0xF4296DD6FEF3D67A, 0xE16A1DC9D8545E94}, // 1e133\n\t{0x1899E4A65F58660C, 0x8CE2529E2734BB1D}, // 1e134\n\t{0x5EC05DCFF72E7F8F, 0xB01AE745B101E9E4}, // 1e135\n\t{0x76707543F4FA1F73, 0xDC21A1171D42645D}, // 1e136\n\t{0x6A06494A791C53A8, 0x899504AE72497EBA}, // 1e137\n\t{0x0487DB9D17636892, 0xABFA45DA0EDBDE69}, // 1e138\n\t{0x45A9D2845D3C42B6, 0xD6F8D7509292D603}, // 1e139\n\t{0x0B8A2392BA45A9B2, 0x865B86925B9BC5C2}, // 1e140\n\t{0x8E6CAC7768D7141E, 0xA7F26836F282B732}, // 1e141\n\t{0x3207D795430CD926, 0xD1EF0244AF2364FF}, // 1e142\n\t{0x7F44E6BD49E807B8, 0x8335616AED761F1F}, // 1e143\n\t{0x5F16206C9C6209A6, 0xA402B9C5A8D3A6E7}, // 1e144\n\t{0x36DBA887C37A8C0F, 0xCD036837130890A1}, // 1e145\n\t{0xC2494954DA2C9789, 0x802221226BE55A64}, // 1e146\n\t{0xF2DB9BAA10B7BD6C, 0xA02AA96B06DEB0FD}, // 1e147\n\t{0x6F92829494E5ACC7, 0xC83553C5C8965D3D}, // 1e148\n\t{0xCB772339BA1F17F9, 0xFA42A8B73ABBF48C}, // 1e149\n\t{0xFF2A760414536EFB, 0x9C69A97284B578D7}, // 1e150\n\t{0xFEF5138519684ABA, 0xC38413CF25E2D70D}, // 1e151\n\t{0x7EB258665FC25D69, 0xF46518C2EF5B8CD1}, // 1e152\n\t{0xEF2F773FFBD97A61, 0x98BF2F79D5993802}, // 1e153\n\t{0xAAFB550FFACFD8FA, 0xBEEEFB584AFF8603}, // 1e154\n\t{0x95BA2A53F983CF38, 0xEEAABA2E5DBF6784}, // 1e155\n\t{0xDD945A747BF26183, 0x952AB45CFA97A0B2}, // 1e156\n\t{0x94F971119AEEF9E4, 0xBA756174393D88DF}, // 1e157\n\t{0x7A37CD5601AAB85D, 0xE912B9D1478CEB17}, // 1e158\n\t{0xAC62E055C10AB33A, 0x91ABB422CCB812EE}, // 1e159\n\t{0x577B986B314D6009, 0xB616A12B7FE617AA}, // 1e160\n\t{0xED5A7E85FDA0B80B, 0xE39C49765FDF9D94}, // 1e161\n\t{0x14588F13BE847307, 0x8E41ADE9FBEBC27D}, // 1e162\n\t{0x596EB2D8AE258FC8, 0xB1D219647AE6B31C}, // 1e163\n\t{0x6FCA5F8ED9AEF3BB, 0xDE469FBD99A05FE3}, // 1e164\n\t{0x25DE7BB9480D5854, 0x8AEC23D680043BEE}, // 1e165\n\t{0xAF561AA79A10AE6A, 0xADA72CCC20054AE9}, // 1e166\n\t{0x1B2BA1518094DA04, 0xD910F7FF28069DA4}, // 1e167\n\t{0x90FB44D2F05D0842, 0x87AA9AFF79042286}, // 1e168\n\t{0x353A1607AC744A53, 0xA99541BF57452B28}, // 1e169\n\t{0x42889B8997915CE8, 0xD3FA922F2D1675F2}, // 1e170\n\t{0x69956135FEBADA11, 0x847C9B5D7C2E09B7}, // 1e171\n\t{0x43FAB9837E699095, 0xA59BC234DB398C25}, // 1e172\n\t{0x94F967E45E03F4BB, 0xCF02B2C21207EF2E}, // 1e173\n\t{0x1D1BE0EEBAC278F5, 0x8161AFB94B44F57D}, // 1e174\n\t{0x6462D92A69731732, 0xA1BA1BA79E1632DC}, // 1e175\n\t{0x7D7B8F7503CFDCFE, 0xCA28A291859BBF93}, // 1e176\n\t{0x5CDA735244C3D43E, 0xFCB2CB35E702AF78}, // 1e177\n\t{0x3A0888136AFA64A7, 0x9DEFBF01B061ADAB}, // 1e178\n\t{0x088AAA1845B8FDD0, 0xC56BAEC21C7A1916}, // 1e179\n\t{0x8AAD549E57273D45, 0xF6C69A72A3989F5B}, // 1e180\n\t{0x36AC54E2F678864B, 0x9A3C2087A63F6399}, // 1e181\n\t{0x84576A1BB416A7DD, 0xC0CB28A98FCF3C7F}, // 1e182\n\t{0x656D44A2A11C51D5, 0xF0FDF2D3F3C30B9F}, // 1e183\n\t{0x9F644AE5A4B1B325, 0x969EB7C47859E743}, // 1e184\n\t{0x873D5D9F0DDE1FEE, 0xBC4665B596706114}, // 1e185\n\t{0xA90CB506D155A7EA, 0xEB57FF22FC0C7959}, // 1e186\n\t{0x09A7F12442D588F2, 0x9316FF75DD87CBD8}, // 1e187\n\t{0x0C11ED6D538AEB2F, 0xB7DCBF5354E9BECE}, // 1e188\n\t{0x8F1668C8A86DA5FA, 0xE5D3EF282A242E81}, // 1e189\n\t{0xF96E017D694487BC, 0x8FA475791A569D10}, // 1e190\n\t{0x37C981DCC395A9AC, 0xB38D92D760EC4455}, // 1e191\n\t{0x85BBE253F47B1417, 0xE070F78D3927556A}, // 1e192\n\t{0x93956D7478CCEC8E, 0x8C469AB843B89562}, // 1e193\n\t{0x387AC8D1970027B2, 0xAF58416654A6BABB}, // 1e194\n\t{0x06997B05FCC0319E, 0xDB2E51BFE9D0696A}, // 1e195\n\t{0x441FECE3BDF81F03, 0x88FCF317F22241E2}, // 1e196\n\t{0xD527E81CAD7626C3, 0xAB3C2FDDEEAAD25A}, // 1e197\n\t{0x8A71E223D8D3B074, 0xD60B3BD56A5586F1}, // 1e198\n\t{0xF6872D5667844E49, 0x85C7056562757456}, // 1e199\n\t{0xB428F8AC016561DB, 0xA738C6BEBB12D16C}, // 1e200\n\t{0xE13336D701BEBA52, 0xD106F86E69D785C7}, // 1e201\n\t{0xECC0024661173473, 0x82A45B450226B39C}, // 1e202\n\t{0x27F002D7F95D0190, 0xA34D721642B06084}, // 1e203\n\t{0x31EC038DF7B441F4, 0xCC20CE9BD35C78A5}, // 1e204\n\t{0x7E67047175A15271, 0xFF290242C83396CE}, // 1e205\n\t{0x0F0062C6E984D386, 0x9F79A169BD203E41}, // 1e206\n\t{0x52C07B78A3E60868, 0xC75809C42C684DD1}, // 1e207\n\t{0xA7709A56CCDF8A82, 0xF92E0C3537826145}, // 1e208\n\t{0x88A66076400BB691, 0x9BBCC7A142B17CCB}, // 1e209\n\t{0x6ACFF893D00EA435, 0xC2ABF989935DDBFE}, // 1e210\n\t{0x0583F6B8C4124D43, 0xF356F7EBF83552FE}, // 1e211\n\t{0xC3727A337A8B704A, 0x98165AF37B2153DE}, // 1e212\n\t{0x744F18C0592E4C5C, 0xBE1BF1B059E9A8D6}, // 1e213\n\t{0x1162DEF06F79DF73, 0xEDA2EE1C7064130C}, // 1e214\n\t{0x8ADDCB5645AC2BA8, 0x9485D4D1C63E8BE7}, // 1e215\n\t{0x6D953E2BD7173692, 0xB9A74A0637CE2EE1}, // 1e216\n\t{0xC8FA8DB6CCDD0437, 0xE8111C87C5C1BA99}, // 1e217\n\t{0x1D9C9892400A22A2, 0x910AB1D4DB9914A0}, // 1e218\n\t{0x2503BEB6D00CAB4B, 0xB54D5E4A127F59C8}, // 1e219\n\t{0x2E44AE64840FD61D, 0xE2A0B5DC971F303A}, // 1e220\n\t{0x5CEAECFED289E5D2, 0x8DA471A9DE737E24}, // 1e221\n\t{0x7425A83E872C5F47, 0xB10D8E1456105DAD}, // 1e222\n\t{0xD12F124E28F77719, 0xDD50F1996B947518}, // 1e223\n\t{0x82BD6B70D99AAA6F, 0x8A5296FFE33CC92F}, // 1e224\n\t{0x636CC64D1001550B, 0xACE73CBFDC0BFB7B}, // 1e225\n\t{0x3C47F7E05401AA4E, 0xD8210BEFD30EFA5A}, // 1e226\n\t{0x65ACFAEC34810A71, 0x8714A775E3E95C78}, // 1e227\n\t{0x7F1839A741A14D0D, 0xA8D9D1535CE3B396}, // 1e228\n\t{0x1EDE48111209A050, 0xD31045A8341CA07C}, // 1e229\n\t{0x934AED0AAB460432, 0x83EA2B892091E44D}, // 1e230\n\t{0xF81DA84D5617853F, 0xA4E4B66B68B65D60}, // 1e231\n\t{0x36251260AB9D668E, 0xCE1DE40642E3F4B9}, // 1e232\n\t{0xC1D72B7C6B426019, 0x80D2AE83E9CE78F3}, // 1e233\n\t{0xB24CF65B8612F81F, 0xA1075A24E4421730}, // 1e234\n\t{0xDEE033F26797B627, 0xC94930AE1D529CFC}, // 1e235\n\t{0x169840EF017DA3B1, 0xFB9B7CD9A4A7443C}, // 1e236\n\t{0x8E1F289560EE864E, 0x9D412E0806E88AA5}, // 1e237\n\t{0xF1A6F2BAB92A27E2, 0xC491798A08A2AD4E}, // 1e238\n\t{0xAE10AF696774B1DB, 0xF5B5D7EC8ACB58A2}, // 1e239\n\t{0xACCA6DA1E0A8EF29, 0x9991A6F3D6BF1765}, // 1e240\n\t{0x17FD090A58D32AF3, 0xBFF610B0CC6EDD3F}, // 1e241\n\t{0xDDFC4B4CEF07F5B0, 0xEFF394DCFF8A948E}, // 1e242\n\t{0x4ABDAF101564F98E, 0x95F83D0A1FB69CD9}, // 1e243\n\t{0x9D6D1AD41ABE37F1, 0xBB764C4CA7A4440F}, // 1e244\n\t{0x84C86189216DC5ED, 0xEA53DF5FD18D5513}, // 1e245\n\t{0x32FD3CF5B4E49BB4, 0x92746B9BE2F8552C}, // 1e246\n\t{0x3FBC8C33221DC2A1, 0xB7118682DBB66A77}, // 1e247\n\t{0x0FABAF3FEAA5334A, 0xE4D5E82392A40515}, // 1e248\n\t{0x29CB4D87F2A7400E, 0x8F05B1163BA6832D}, // 1e249\n\t{0x743E20E9EF511012, 0xB2C71D5BCA9023F8}, // 1e250\n\t{0x914DA9246B255416, 0xDF78E4B2BD342CF6}, // 1e251\n\t{0x1AD089B6C2F7548E, 0x8BAB8EEFB6409C1A}, // 1e252\n\t{0xA184AC2473B529B1, 0xAE9672ABA3D0C320}, // 1e253\n\t{0xC9E5D72D90A2741E, 0xDA3C0F568CC4F3E8}, // 1e254\n\t{0x7E2FA67C7A658892, 0x8865899617FB1871}, // 1e255\n\t{0xDDBB901B98FEEAB7, 0xAA7EEBFB9DF9DE8D}, // 1e256\n\t{0x552A74227F3EA565, 0xD51EA6FA85785631}, // 1e257\n\t{0xD53A88958F87275F, 0x8533285C936B35DE}, // 1e258\n\t{0x8A892ABAF368F137, 0xA67FF273B8460356}, // 1e259\n\t{0x2D2B7569B0432D85, 0xD01FEF10A657842C}, // 1e260\n\t{0x9C3B29620E29FC73, 0x8213F56A67F6B29B}, // 1e261\n\t{0x8349F3BA91B47B8F, 0xA298F2C501F45F42}, // 1e262\n\t{0x241C70A936219A73, 0xCB3F2F7642717713}, // 1e263\n\t{0xED238CD383AA0110, 0xFE0EFB53D30DD4D7}, // 1e264\n\t{0xF4363804324A40AA, 0x9EC95D1463E8A506}, // 1e265\n\t{0xB143C6053EDCD0D5, 0xC67BB4597CE2CE48}, // 1e266\n\t{0xDD94B7868E94050A, 0xF81AA16FDC1B81DA}, // 1e267\n\t{0xCA7CF2B4191C8326, 0x9B10A4E5E9913128}, // 1e268\n\t{0xFD1C2F611F63A3F0, 0xC1D4CE1F63F57D72}, // 1e269\n\t{0xBC633B39673C8CEC, 0xF24A01A73CF2DCCF}, // 1e270\n\t{0xD5BE0503E085D813, 0x976E41088617CA01}, // 1e271\n\t{0x4B2D8644D8A74E18, 0xBD49D14AA79DBC82}, // 1e272\n\t{0xDDF8E7D60ED1219E, 0xEC9C459D51852BA2}, // 1e273\n\t{0xCABB90E5C942B503, 0x93E1AB8252F33B45}, // 1e274\n\t{0x3D6A751F3B936243, 0xB8DA1662E7B00A17}, // 1e275\n\t{0x0CC512670A783AD4, 0xE7109BFBA19C0C9D}, // 1e276\n\t{0x27FB2B80668B24C5, 0x906A617D450187E2}, // 1e277\n\t{0xB1F9F660802DEDF6, 0xB484F9DC9641E9DA}, // 1e278\n\t{0x5E7873F8A0396973, 0xE1A63853BBD26451}, // 1e279\n\t{0xDB0B487B6423E1E8, 0x8D07E33455637EB2}, // 1e280\n\t{0x91CE1A9A3D2CDA62, 0xB049DC016ABC5E5F}, // 1e281\n\t{0x7641A140CC7810FB, 0xDC5C5301C56B75F7}, // 1e282\n\t{0xA9E904C87FCB0A9D, 0x89B9B3E11B6329BA}, // 1e283\n\t{0x546345FA9FBDCD44, 0xAC2820D9623BF429}, // 1e284\n\t{0xA97C177947AD4095, 0xD732290FBACAF133}, // 1e285\n\t{0x49ED8EABCCCC485D, 0x867F59A9D4BED6C0}, // 1e286\n\t{0x5C68F256BFFF5A74, 0xA81F301449EE8C70}, // 1e287\n\t{0x73832EEC6FFF3111, 0xD226FC195C6A2F8C}, // 1e288\n\t{0xC831FD53C5FF7EAB, 0x83585D8FD9C25DB7}, // 1e289\n\t{0xBA3E7CA8B77F5E55, 0xA42E74F3D032F525}, // 1e290\n\t{0x28CE1BD2E55F35EB, 0xCD3A1230C43FB26F}, // 1e291\n\t{0x7980D163CF5B81B3, 0x80444B5E7AA7CF85}, // 1e292\n\t{0xD7E105BCC332621F, 0xA0555E361951C366}, // 1e293\n\t{0x8DD9472BF3FEFAA7, 0xC86AB5C39FA63440}, // 1e294\n\t{0xB14F98F6F0FEB951, 0xFA856334878FC150}, // 1e295\n\t{0x6ED1BF9A569F33D3, 0x9C935E00D4B9D8D2}, // 1e296\n\t{0x0A862F80EC4700C8, 0xC3B8358109E84F07}, // 1e297\n\t{0xCD27BB612758C0FA, 0xF4A642E14C6262C8}, // 1e298\n\t{0x8038D51CB897789C, 0x98E7E9CCCFBD7DBD}, // 1e299\n\t{0xE0470A63E6BD56C3, 0xBF21E44003ACDD2C}, // 1e300\n\t{0x1858CCFCE06CAC74, 0xEEEA5D5004981478}, // 1e301\n\t{0x0F37801E0C43EBC8, 0x95527A5202DF0CCB}, // 1e302\n\t{0xD30560258F54E6BA, 0xBAA718E68396CFFD}, // 1e303\n\t{0x47C6B82EF32A2069, 0xE950DF20247C83FD}, // 1e304\n\t{0x4CDC331D57FA5441, 0x91D28B7416CDD27E}, // 1e305\n\t{0xE0133FE4ADF8E952, 0xB6472E511C81471D}, // 1e306\n\t{0x58180FDDD97723A6, 0xE3D8F9E563A198E5}, // 1e307\n\t{0x570F09EAA7EA7648, 0x8E679C2F5E44FF8F}, // 1e308\n\t{0x2CD2CC6551E513DA, 0xB201833B35D63F73}, // 1e309\n\t{0xF8077F7EA65E58D1, 0xDE81E40A034BCF4F}, // 1e310\n\t{0xFB04AFAF27FAF782, 0x8B112E86420F6191}, // 1e311\n\t{0x79C5DB9AF1F9B563, 0xADD57A27D29339F6}, // 1e312\n\t{0x18375281AE7822BC, 0xD94AD8B1C7380874}, // 1e313\n\t{0x8F2293910D0B15B5, 0x87CEC76F1C830548}, // 1e314\n\t{0xB2EB3875504DDB22, 0xA9C2794AE3A3C69A}, // 1e315\n\t{0x5FA60692A46151EB, 0xD433179D9C8CB841}, // 1e316\n\t{0xDBC7C41BA6BCD333, 0x849FEEC281D7F328}, // 1e317\n\t{0x12B9B522906C0800, 0xA5C7EA73224DEFF3}, // 1e318\n\t{0xD768226B34870A00, 0xCF39E50FEAE16BEF}, // 1e319\n\t{0xE6A1158300D46640, 0x81842F29F2CCE375}, // 1e320\n\t{0x60495AE3C1097FD0, 0xA1E53AF46F801C53}, // 1e321\n\t{0x385BB19CB14BDFC4, 0xCA5E89B18B602368}, // 1e322\n\t{0x46729E03DD9ED7B5, 0xFCF62C1DEE382C42}, // 1e323\n\t{0x6C07A2C26A8346D1, 0x9E19DB92B4E31BA9}, // 1e324\n\t{0xC7098B7305241885, 0xC5A05277621BE293}, // 1e325\n\t{0xB8CBEE4FC66D1EA7, 0xF70867153AA2DB38}, // 1e326\n\t{0x737F74F1DC043328, 0x9A65406D44A5C903}, // 1e327\n\t{0x505F522E53053FF2, 0xC0FE908895CF3B44}, // 1e328\n\t{0x647726B9E7C68FEF, 0xF13E34AABB430A15}, // 1e329\n\t{0x5ECA783430DC19F5, 0x96C6E0EAB509E64D}, // 1e330\n\t{0xB67D16413D132072, 0xBC789925624C5FE0}, // 1e331\n\t{0xE41C5BD18C57E88F, 0xEB96BF6EBADF77D8}, // 1e332\n\t{0x8E91B962F7B6F159, 0x933E37A534CBAAE7}, // 1e333\n\t{0x723627BBB5A4ADB0, 0xB80DC58E81FE95A1}, // 1e334\n\t{0xCEC3B1AAA30DD91C, 0xE61136F2227E3B09}, // 1e335\n\t{0x213A4F0AA5E8A7B1, 0x8FCAC257558EE4E6}, // 1e336\n\t{0xA988E2CD4F62D19D, 0xB3BD72ED2AF29E1F}, // 1e337\n\t{0x93EB1B80A33B8605, 0xE0ACCFA875AF45A7}, // 1e338\n\t{0xBC72F130660533C3, 0x8C6C01C9498D8B88}, // 1e339\n\t{0xEB8FAD7C7F8680B4, 0xAF87023B9BF0EE6A}, // 1e340\n\t{0xA67398DB9F6820E1, 0xDB68C2CA82ED2A05}, // 1e341\n\t{0x88083F8943A1148C, 0x892179BE91D43A43}, // 1e342\n\t{0x6A0A4F6B948959B0, 0xAB69D82E364948D4}, // 1e343\n\t{0x848CE34679ABB01C, 0xD6444E39C3DB9B09}, // 1e344\n\t{0xF2D80E0C0C0B4E11, 0x85EAB0E41A6940E5}, // 1e345\n\t{0x6F8E118F0F0E2195, 0xA7655D1D2103911F}, // 1e346\n\t{0x4B7195F2D2D1A9FB, 0xD13EB46469447567}, // 1e347\n}\n"},{"Name":"gno.mod","Body":"module gno.land/p/demo/json/ryu\n"},{"Name":"path_test.gno","Body":"package json\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseJSONPath(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tpath     string\n\t\texpected []string\n\t}{\n\t\t{name: \"Empty string path\", path: \"\", expected: []string{}},\n\t\t{name: \"Root only path\", path: \"$\", expected: []string{\"$\"}},\n\t\t{name: \"Root with dot path\", path: \"$.\", expected: []string{\"$\"}},\n\t\t{name: \"All objects in path\", path: \"$..\", expected: []string{\"$\", \"..\"}},\n\t\t{name: \"Only children in path\", path: \"$.*\", expected: []string{\"$\", \"*\"}},\n\t\t{name: \"All objects' children in path\", path: \"$..*\", expected: []string{\"$\", \"..\", \"*\"}},\n\t\t{name: \"Simple dot notation path\", path: \"$.root.element\", expected: []string{\"$\", \"root\", \"element\"}},\n\t\t{name: \"Complex dot notation path with wildcard\", path: \"$.root.*.element\", expected: []string{\"$\", \"root\", \"*\", \"element\"}},\n\t\t{name: \"Path with array wildcard\", path: \"$.phoneNumbers[*].type\", expected: []string{\"$\", \"phoneNumbers\", \"*\", \"type\"}},\n\t\t{name: \"Path with filter expression\", path: \"$.store.book[?(@.price \u003c 10)].title\", expected: []string{\"$\", \"store\", \"book\", \"?(@.price \u003c 10)\", \"title\"}},\n\t\t{name: \"Path with formula\", path: \"$..phoneNumbers..('ty' + 'pe')\", expected: []string{\"$\", \"..\", \"phoneNumbers\", \"..\", \"('ty' + 'pe')\"}},\n\t\t{name: \"Simple bracket notation path\", path: \"$['root']['element']\", expected: []string{\"$\", \"'root'\", \"'element'\"}},\n\t\t{name: \"Complex bracket notation path with wildcard\", path: \"$['root'][*]['element']\", expected: []string{\"$\", \"'root'\", \"*\", \"'element'\"}},\n\t\t{name: \"Bracket notation path with integer index\", path: \"$['store']['book'][0]['title']\", expected: []string{\"$\", \"'store'\", \"'book'\", \"0\", \"'title'\"}},\n\t\t{name: \"Complex path with wildcard in bracket notation\", path: \"$['root'].*['element']\", expected: []string{\"$\", \"'root'\", \"*\", \"'element'\"}},\n\t\t{name: \"Mixed notation path with dot after bracket\", path: \"$.['root'].*.['element']\", expected: []string{\"$\", \"'root'\", \"*\", \"'element'\"}},\n\t\t{name: \"Mixed notation path with dot before bracket\", path: \"$['root'].*.['element']\", expected: []string{\"$\", \"'root'\", \"*\", \"'element'\"}},\n\t\t{name: \"Single character path with root\", path: \"$.a\", expected: []string{\"$\", \"a\"}},\n\t\t{name: \"Multiple characters path with root\", path: \"$.abc\", expected: []string{\"$\", \"abc\"}},\n\t\t{name: \"Multiple segments path with root\", path: \"$.a.b.c\", expected: []string{\"$\", \"a\", \"b\", \"c\"}},\n\t\t{name: \"Multiple segments path with wildcard and root\", path: \"$.a.*.c\", expected: []string{\"$\", \"a\", \"*\", \"c\"}},\n\t\t{name: \"Multiple segments path with filter and root\", path: \"$.a[?(@.b == 'c')].d\", expected: []string{\"$\", \"a\", \"?(@.b == 'c')\", \"d\"}},\n\t\t{name: \"Complex path with multiple filters\", path: \"$.a[?(@.b == 'c')].d[?(@.e == 'f')].g\", expected: []string{\"$\", \"a\", \"?(@.b == 'c')\", \"d\", \"?(@.e == 'f')\", \"g\"}},\n\t\t{name: \"Complex path with multiple filters and wildcards\", path: \"$.a[?(@.b == 'c')].*.d[?(@.e == 'f')].g\", expected: []string{\"$\", \"a\", \"?(@.b == 'c')\", \"*\", \"d\", \"?(@.e == 'f')\", \"g\"}},\n\t\t{name: \"Path with array index and root\", path: \"$.a[0].b\", expected: []string{\"$\", \"a\", \"0\", \"b\"}},\n\t\t{name: \"Path with multiple array indices and root\", path: \"$.a[0].b[1].c\", expected: []string{\"$\", \"a\", \"0\", \"b\", \"1\", \"c\"}},\n\t\t{name: \"Path with array index, wildcard and root\", path: \"$.a[0].*.c\", expected: []string{\"$\", \"a\", \"0\", \"*\", \"c\"}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\treult, _ := ParsePath(tt.path)\n\t\t\tif !isEqualSlice(reult, tt.expected) {\n\t\t\t\tt.Errorf(\"ParsePath(%s) expected: %v, got: %v\", tt.path, tt.expected, reult)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc isEqualSlice(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n"},{"Name":"escape_test.gno","Body":"package json\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\t\"unicode/utf8\"\n)\n\nfunc TestHexToInt(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tc    byte\n\t\twant int\n\t}{\n\t\t{\"Digit 0\", '0', 0},\n\t\t{\"Digit 9\", '9', 9},\n\t\t{\"Uppercase A\", 'A', 10},\n\t\t{\"Uppercase F\", 'F', 15},\n\t\t{\"Lowercase a\", 'a', 10},\n\t\t{\"Lowercase f\", 'f', 15},\n\t\t{\"Invalid character1\", 'g', badHex},\n\t\t{\"Invalid character2\", 'G', badHex},\n\t\t{\"Invalid character3\", 'z', badHex},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := h2i(tt.c); got != tt.want {\n\t\t\t\tt.Errorf(\"h2i() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIsSurrogatePair(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tr        rune\n\t\texpected bool\n\t}{\n\t\t{\"high surrogate start\", 0xD800, true},\n\t\t{\"high surrogate end\", 0xDBFF, true},\n\t\t{\"low surrogate start\", 0xDC00, true},\n\t\t{\"low surrogate end\", 0xDFFF, true},\n\t\t{\"Non-surrogate\", 0x0000, false},\n\t\t{\"Non-surrogate 2\", 0xE000, false},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif got := isSurrogatePair(tc.r); got != tc.expected {\n\t\t\t\tt.Errorf(\"isSurrogate() = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCombineSurrogates(t *testing.T) {\n\ttestCases := []struct {\n\t\thigh, low rune\n\t\texpected  rune\n\t}{\n\t\t{0xD83D, 0xDC36, 0x1F436}, //  U+1F436 DOG FACE\n\t\t{0xD83D, 0xDE00, 0x1F600}, //  U+1F600 GRINNING FACE\n\t\t{0xD83C, 0xDF03, 0x1F303}, //  U+1F303 NIGHT WITH STARS\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := combineSurrogates(tc.high, tc.low)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"combineSurrogates(%U, %U) = %U; want %U\", tc.high, tc.low, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestDecodeSingleUnicodeEscape(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []byte\n\t\texpected rune\n\t\tisValid  bool\n\t}{\n\t\t// valid unicode escape sequences\n\t\t{[]byte(`\\u0041`), 'A', true},\n\t\t{[]byte(`\\u03B1`), '', true},\n\t\t{[]byte(`\\u00E9`), '', true}, // valid non-English character\n\t\t{[]byte(`\\u0021`), '!', true}, // valid special character\n\t\t{[]byte(`\\uFF11`), '', true},\n\t\t{[]byte(`\\uD83D`), 0xD83D, true},\n\t\t{[]byte(`\\uDE03`), 0xDE03, true},\n\n\t\t// invalid unicode escape sequences\n\t\t{[]byte(`\\u004`), utf8.RuneError, false},  // too short\n\t\t{[]byte(`\\uXYZW`), utf8.RuneError, false}, // invalid hex\n\t\t{[]byte(`\\u00G1`), utf8.RuneError, false}, // non-hex character\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult, isValid := decodeSingleUnicodeEscape(tc.input)\n\t\tif result != tc.expected || isValid != tc.isValid {\n\t\t\tt.Errorf(\"decodeSingleUnicodeEscape(%s) = (%U, %v); want (%U, %v)\", tc.input, result, isValid, tc.expected, tc.isValid)\n\t\t}\n\t}\n}\n\nfunc TestDecodeUnicodeEscape(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected rune\n\t\tsize     int\n\t}{\n\t\t{\"\\\\u0041\", 'A', 6},\n\t\t{\"\\\\u03B1\", '', 6},\n\t\t{\"\\\\u1F600\", 0x1F60, 6},\n\t\t{\"\\\\uD830\\\\uDE03\", 0x1C203, 12},\n\t\t{\"\\\\uD800\\\\uDC00\", 0x00010000, 12},\n\n\t\t{\"\\\\u004\", utf8.RuneError, -1},\n\t\t{\"\\\\uXYZW\", utf8.RuneError, -1},\n\t\t{\"\\\\uD83D\\\\u0041\", utf8.RuneError, -1},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tr, size := decodeUnicodeEscape([]byte(tc.input))\n\t\tif r != tc.expected || size != tc.size {\n\t\t\tt.Errorf(\"decodeUnicodeEscape(%q) = (%U, %d); want (%U, %d)\", tc.input, r, size, tc.expected, tc.size)\n\t\t}\n\t}\n}\n\nfunc TestUnescapeToUTF8(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput       []byte\n\t\texpectedIn  int\n\t\texpectedOut int\n\t\tisError     bool\n\t}{\n\t\t// valid escape sequences\n\t\t{[]byte(`\\n`), 2, 1, false},\n\t\t{[]byte(`\\t`), 2, 1, false},\n\t\t{[]byte(`\\u0041`), 6, 1, false},\n\t\t{[]byte(`\\u03B1`), 6, 2, false},\n\t\t{[]byte(`\\uD830\\uDE03`), 12, 4, false},\n\n\t\t// invalid escape sequences\n\t\t{[]byte(`\\`), -1, -1, true},            // incomplete escape sequence\n\t\t{[]byte(`\\x`), -1, -1, true},           // invalid escape character\n\t\t{[]byte(`\\u`), -1, -1, true},           // incomplete unicode escape sequence\n\t\t{[]byte(`\\u004`), -1, -1, true},        // invalid unicode escape sequence\n\t\t{[]byte(`\\uXYZW`), -1, -1, true},       // invalid unicode escape sequence\n\t\t{[]byte(`\\uD83D\\u0041`), -1, -1, true}, // invalid unicode escape sequence\n\t}\n\n\tfor _, tc := range testCases {\n\t\tinput := make([]byte, len(tc.input))\n\t\tcopy(input, tc.input)\n\t\toutput := make([]byte, utf8.UTFMax)\n\t\tinLen, outLen, err := processEscapedUTF8(input, output)\n\t\tif (err != nil) != tc.isError {\n\t\t\tt.Errorf(\"processEscapedUTF8(%q) = %v; want %v\", tc.input, err, tc.isError)\n\t\t}\n\n\t\tif inLen != tc.expectedIn || outLen != tc.expectedOut {\n\t\t\tt.Errorf(\"processEscapedUTF8(%q) = (%d, %d); want (%d, %d)\", tc.input, inLen, outLen, tc.expectedIn, tc.expectedOut)\n\t\t}\n\t}\n}\n\nfunc TestUnescape(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []byte\n\t\texpected []byte\n\t}{\n\t\t{\"NoEscape\", []byte(\"hello world\"), []byte(\"hello world\")},\n\t\t{\"SingleEscape\", []byte(\"hello\\\\nworld\"), []byte(\"hello\\nworld\")},\n\t\t{\"MultipleEscapes\", []byte(\"line1\\\\nline2\\\\r\\\\nline3\"), []byte(\"line1\\nline2\\r\\nline3\")},\n\t\t{\"UnicodeEscape\", []byte(\"snowman:\\\\u2603\"), []byte(\"snowman:\\u2603\")},\n\t\t{\"Complex\", []byte(\"tc\\\\n\\\\u2603\\\\r\\\\nend\"), []byte(\"tc\\n\\u2603\\r\\nend\")},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\toutput, _ := Unescape(tc.input, make([]byte, len(tc.input)+10))\n\t\t\tif !bytes.Equal(output, tc.expected) {\n\t\t\t\tt.Errorf(\"unescape(%q) = %q; want %q\", tc.input, output, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnquoteBytes(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []byte\n\t\tborder   byte\n\t\texpected []byte\n\t\tok       bool\n\t}{\n\t\t{[]byte(\"\\\"hello\\\"\"), '\"', []byte(\"hello\"), true},\n\t\t{[]byte(\"'hello'\"), '\\'', []byte(\"hello\"), true},\n\t\t{[]byte(\"\\\"hello\"), '\"', nil, false},\n\t\t{[]byte(\"hello\\\"\"), '\"', nil, false},\n\t\t{[]byte(\"\\\"he\\\\\\\"llo\\\"\"), '\"', []byte(\"he\\\"llo\"), true},\n\t\t{[]byte(\"\\\"he\\\\nllo\\\"\"), '\"', []byte(\"he\\nllo\"), true},\n\t\t{[]byte(\"\\\"\\\"\"), '\"', []byte(\"\"), true},\n\t\t{[]byte(\"''\"), '\\'', []byte(\"\"), true},\n\t\t{[]byte(\"\\\"\\\\u0041\\\"\"), '\"', []byte(\"A\"), true},\n\t\t{[]byte(`\"Hello, \"`), '\"', []byte(\"Hello, \"), true},\n\t\t{[]byte(`\"Hello, \\x80\"`), '\"', nil, false},\n\t}\n\n\tfor _, tc := range tests {\n\t\tresult, pass := unquoteBytes(tc.input, tc.border)\n\n\t\tif pass != tc.ok {\n\t\t\tt.Errorf(\"unquoteBytes(%q) = %v; want %v\", tc.input, pass, tc.ok)\n\t\t}\n\n\t\tif !bytes.Equal(result, tc.expected) {\n\t\t\tt.Errorf(\"unquoteBytes(%q) = %q; want %q\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n"},{"Name":"table.gno","Body":"// Code generated by running \"go generate\". DO NOT EDIT.\n\n// Copyright 2018 Ulf Adams\n// Modifications copyright 2019 Caleb Spare\n//\n// The contents of this file may be used under the terms of the Apache License,\n// Version 2.0.\n//\n//    (See accompanying file LICENSE or copy at\n//     http://www.apache.org/licenses/LICENSE-2.0)\n//\n// Unless required by applicable law or agreed to in writing, this software\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.\n//\n// The code in this file is part of a Go translation of the C code written by\n// Ulf Adams which may be found at https://github.com/ulfjack/ryu. That source\n// code is licensed under Apache 2.0 and this code is derivative work thereof.\n\npackage ryu\n\nconst pow5NumBits32 = 61\n\nvar pow5Split32 = [...]uint64{\n\t1152921504606846976, 1441151880758558720, 1801439850948198400, 2251799813685248000,\n\t1407374883553280000, 1759218604441600000, 2199023255552000000, 1374389534720000000,\n\t1717986918400000000, 2147483648000000000, 1342177280000000000, 1677721600000000000,\n\t2097152000000000000, 1310720000000000000, 1638400000000000000, 2048000000000000000,\n\t1280000000000000000, 1600000000000000000, 2000000000000000000, 1250000000000000000,\n\t1562500000000000000, 1953125000000000000, 1220703125000000000, 1525878906250000000,\n\t1907348632812500000, 1192092895507812500, 1490116119384765625, 1862645149230957031,\n\t1164153218269348144, 1455191522836685180, 1818989403545856475, 2273736754432320594,\n\t1421085471520200371, 1776356839400250464, 2220446049250313080, 1387778780781445675,\n\t1734723475976807094, 2168404344971008868, 1355252715606880542, 1694065894508600678,\n\t2117582368135750847, 1323488980084844279, 1654361225106055349, 2067951531382569187,\n\t1292469707114105741, 1615587133892632177, 2019483917365790221,\n}\n\nconst pow5InvNumBits32 = 59\n\nvar pow5InvSplit32 = [...]uint64{\n\t576460752303423489, 461168601842738791, 368934881474191033, 295147905179352826,\n\t472236648286964522, 377789318629571618, 302231454903657294, 483570327845851670,\n\t386856262276681336, 309485009821345069, 495176015714152110, 396140812571321688,\n\t316912650057057351, 507060240091291761, 405648192073033409, 324518553658426727,\n\t519229685853482763, 415383748682786211, 332306998946228969, 531691198313966350,\n\t425352958651173080, 340282366920938464, 544451787073501542, 435561429658801234,\n\t348449143727040987, 557518629963265579, 446014903970612463, 356811923176489971,\n\t570899077082383953, 456719261665907162, 365375409332725730,\n}\n\nconst pow5NumBits64 = 121\n\nvar pow5Split64 = [...]uint128{\n\t{0, 72057594037927936},\n\t{0, 90071992547409920},\n\t{0, 112589990684262400},\n\t{0, 140737488355328000},\n\t{0, 87960930222080000},\n\t{0, 109951162777600000},\n\t{0, 137438953472000000},\n\t{0, 85899345920000000},\n\t{0, 107374182400000000},\n\t{0, 134217728000000000},\n\t{0, 83886080000000000},\n\t{0, 104857600000000000},\n\t{0, 131072000000000000},\n\t{0, 81920000000000000},\n\t{0, 102400000000000000},\n\t{0, 128000000000000000},\n\t{0, 80000000000000000},\n\t{0, 100000000000000000},\n\t{0, 125000000000000000},\n\t{0, 78125000000000000},\n\t{0, 97656250000000000},\n\t{0, 122070312500000000},\n\t{0, 76293945312500000},\n\t{0, 95367431640625000},\n\t{0, 119209289550781250},\n\t{4611686018427387904, 74505805969238281},\n\t{10376293541461622784, 93132257461547851},\n\t{8358680908399640576, 116415321826934814},\n\t{612489549322387456, 72759576141834259},\n\t{14600669991935148032, 90949470177292823},\n\t{13639151471491547136, 113686837721616029},\n\t{3213881284082270208, 142108547152020037},\n\t{4314518811765112832, 88817841970012523},\n\t{781462496279003136, 111022302462515654},\n\t{10200200157203529728, 138777878078144567},\n\t{13292654125893287936, 86736173798840354},\n\t{7392445620511834112, 108420217248550443},\n\t{4628871007212404736, 135525271560688054},\n\t{16728102434789916672, 84703294725430033},\n\t{7075069988205232128, 105879118406787542},\n\t{18067209522111315968, 132348898008484427},\n\t{8986162942105878528, 82718061255302767},\n\t{6621017659204960256, 103397576569128459},\n\t{3664586055578812416, 129246970711410574},\n\t{16125424340018921472, 80779356694631608},\n\t{1710036351314100224, 100974195868289511},\n\t{15972603494424788992, 126217744835361888},\n\t{9982877184015493120, 78886090522101180},\n\t{12478596480019366400, 98607613152626475},\n\t{10986559581596820096, 123259516440783094},\n\t{2254913720070624656, 77037197775489434},\n\t{12042014186943056628, 96296497219361792},\n\t{15052517733678820785, 120370621524202240},\n\t{9407823583549262990, 75231638452626400},\n\t{11759779479436578738, 94039548065783000},\n\t{14699724349295723422, 117549435082228750},\n\t{4575641699882439235, 73468396926392969},\n\t{10331238143280436948, 91835496157991211},\n\t{8302361660673158281, 114794370197489014},\n\t{1154580038986672043, 143492962746861268},\n\t{9944984561221445835, 89683101716788292},\n\t{12431230701526807293, 112103877145985365},\n\t{1703980321626345405, 140129846432481707},\n\t{17205888765512323542, 87581154020301066},\n\t{12283988920035628619, 109476442525376333},\n\t{1519928094762372062, 136845553156720417},\n\t{12479170105294952299, 85528470722950260},\n\t{15598962631618690374, 106910588403687825},\n\t{5663645234241199255, 133638235504609782},\n\t{17374836326682913246, 83523897190381113},\n\t{7883487353071477846, 104404871487976392},\n\t{9854359191339347308, 130506089359970490},\n\t{10770660513014479971, 81566305849981556},\n\t{13463325641268099964, 101957882312476945},\n\t{2994098996302961243, 127447352890596182},\n\t{15706369927971514489, 79654595556622613},\n\t{5797904354682229399, 99568244445778267},\n\t{2635694424925398845, 124460305557222834},\n\t{6258995034005762182, 77787690973264271},\n\t{3212057774079814824, 97234613716580339},\n\t{17850130272881932242, 121543267145725423},\n\t{18073860448192289507, 75964541966078389},\n\t{8757267504958198172, 94955677457597987},\n\t{6334898362770359811, 118694596821997484},\n\t{13182683513586250689, 74184123013748427},\n\t{11866668373555425458, 92730153767185534},\n\t{5609963430089506015, 115912692208981918},\n\t{17341285199088104971, 72445432630613698},\n\t{12453234462005355406, 90556790788267123},\n\t{10954857059079306353, 113195988485333904},\n\t{13693571323849132942, 141494985606667380},\n\t{17781854114260483896, 88434366004167112},\n\t{3780573569116053255, 110542957505208891},\n\t{114030942967678664, 138178696881511114},\n\t{4682955357782187069, 86361685550944446},\n\t{15077066234082509644, 107952106938680557},\n\t{5011274737320973344, 134940133673350697},\n\t{14661261756894078100, 84337583545844185},\n\t{4491519140835433913, 105421979432305232},\n\t{5614398926044292391, 131777474290381540},\n\t{12732371365632458552, 82360921431488462},\n\t{6692092170185797382, 102951151789360578},\n\t{17588487249587022536, 128688939736700722},\n\t{15604490549419276989, 80430587335437951},\n\t{14893927168346708332, 100538234169297439},\n\t{14005722942005997511, 125672792711621799},\n\t{15671105866394830300, 78545495444763624},\n\t{1142138259283986260, 98181869305954531},\n\t{15262730879387146537, 122727336632443163},\n\t{7233363790403272633, 76704585395276977},\n\t{13653390756431478696, 95880731744096221},\n\t{3231680390257184658, 119850914680120277},\n\t{4325643253124434363, 74906821675075173},\n\t{10018740084832930858, 93633527093843966},\n\t{3300053069186387764, 117041908867304958},\n\t{15897591223523656064, 73151193042065598},\n\t{10648616992549794273, 91438991302581998},\n\t{4087399203832467033, 114298739128227498},\n\t{14332621041645359599, 142873423910284372},\n\t{18181260187883125557, 89295889943927732},\n\t{4279831161144355331, 111619862429909666},\n\t{14573160988285219972, 139524828037387082},\n\t{13719911636105650386, 87203017523366926},\n\t{7926517508277287175, 109003771904208658},\n\t{684774848491833161, 136254714880260823},\n\t{7345513307948477581, 85159196800163014},\n\t{18405263671790372785, 106448996000203767},\n\t{18394893571310578077, 133061245000254709},\n\t{13802651491282805250, 83163278125159193},\n\t{3418256308821342851, 103954097656448992},\n\t{4272820386026678563, 129942622070561240},\n\t{2670512741266674102, 81214138794100775},\n\t{17173198981865506339, 101517673492625968},\n\t{3019754653622331308, 126897091865782461},\n\t{4193189667727651020, 79310682416114038},\n\t{14464859121514339583, 99138353020142547},\n\t{13469387883465536574, 123922941275178184},\n\t{8418367427165960359, 77451838296986365},\n\t{15134645302384838353, 96814797871232956},\n\t{471562554271496325, 121018497339041196},\n\t{9518098633274461011, 75636560836900747},\n\t{7285937273165688360, 94545701046125934},\n\t{18330793628311886258, 118182126307657417},\n\t{4539216990053847055, 73863828942285886},\n\t{14897393274422084627, 92329786177857357},\n\t{4786683537745442072, 115412232722321697},\n\t{14520892257159371055, 72132645451451060},\n\t{18151115321449213818, 90165806814313825},\n\t{8853836096529353561, 112707258517892282},\n\t{1843923083806916143, 140884073147365353},\n\t{12681666973447792349, 88052545717103345},\n\t{2017025661527576725, 110065682146379182},\n\t{11744654113764246714, 137582102682973977},\n\t{422879793461572340, 85988814176858736},\n\t{528599741826965425, 107486017721073420},\n\t{660749677283706782, 134357522151341775},\n\t{7330497575943398595, 83973451344588609},\n\t{13774807988356636147, 104966814180735761},\n\t{3383451930163631472, 131208517725919702},\n\t{15949715511634433382, 82005323578699813},\n\t{6102086334260878016, 102506654473374767},\n\t{3015921899398709616, 128133318091718459},\n\t{18025852251620051174, 80083323807324036},\n\t{4085571240815512351, 100104154759155046},\n\t{14330336087874166247, 125130193448943807},\n\t{15873989082562435760, 78206370905589879},\n\t{15230800334775656796, 97757963631987349},\n\t{5203442363187407284, 122197454539984187},\n\t{946308467778435600, 76373409087490117},\n\t{5794571603150432404, 95466761359362646},\n\t{16466586540792816313, 119333451699203307},\n\t{7985773578781816244, 74583407312002067},\n\t{5370530955049882401, 93229259140002584},\n\t{6713163693812353001, 116536573925003230},\n\t{18030785363914884337, 72835358703127018},\n\t{13315109668038829614, 91044198378908773},\n\t{2808829029766373305, 113805247973635967},\n\t{17346094342490130344, 142256559967044958},\n\t{6229622945628943561, 88910349979403099},\n\t{3175342663608791547, 111137937474253874},\n\t{13192550366365765242, 138922421842817342},\n\t{3633657960551215372, 86826513651760839},\n\t{18377130505971182927, 108533142064701048},\n\t{4524669058754427043, 135666427580876311},\n\t{9745447189362598758, 84791517238047694},\n\t{2958436949848472639, 105989396547559618},\n\t{12921418224165366607, 132486745684449522},\n\t{12687572408530742033, 82804216052780951},\n\t{11247779492236039638, 103505270065976189},\n\t{224666310012885835, 129381587582470237},\n\t{2446259452971747599, 80863492239043898},\n\t{12281196353069460307, 101079365298804872},\n\t{15351495441336825384, 126349206623506090},\n\t{14206370669262903769, 78968254139691306},\n\t{8534591299723853903, 98710317674614133},\n\t{15279925143082205283, 123387897093267666},\n\t{14161639232853766206, 77117435683292291},\n\t{13090363022639819853, 96396794604115364},\n\t{16362953778299774816, 120495993255144205},\n\t{12532689120651053212, 75309995784465128},\n\t{15665861400813816515, 94137494730581410},\n\t{10358954714162494836, 117671868413226763},\n\t{4168503687137865320, 73544917758266727},\n\t{598943590494943747, 91931147197833409},\n\t{5360365506546067587, 114913933997291761},\n\t{11312142901609972388, 143642417496614701},\n\t{9375932322719926695, 89776510935384188},\n\t{11719915403399908368, 112220638669230235},\n\t{10038208235822497557, 140275798336537794},\n\t{10885566165816448877, 87672373960336121},\n\t{18218643725697949000, 109590467450420151},\n\t{18161618638695048346, 136988084313025189},\n\t{13656854658398099168, 85617552695640743},\n\t{12459382304570236056, 107021940869550929},\n\t{1739169825430631358, 133777426086938662},\n\t{14922039196176308311, 83610891304336663},\n\t{14040862976792997485, 104513614130420829},\n\t{3716020665709083144, 130642017663026037},\n\t{4628355925281870917, 81651261039391273},\n\t{10397130925029726550, 102064076299239091},\n\t{8384727637859770284, 127580095374048864},\n\t{5240454773662356427, 79737559608780540},\n\t{6550568467077945534, 99671949510975675},\n\t{3576524565420044014, 124589936888719594},\n\t{6847013871814915412, 77868710555449746},\n\t{17782139376623420074, 97335888194312182},\n\t{13004302183924499284, 121669860242890228},\n\t{17351060901807587860, 76043662651806392},\n\t{3242082053549933210, 95054578314757991},\n\t{17887660622219580224, 118818222893447488},\n\t{11179787888887237640, 74261389308404680},\n\t{13974734861109047050, 92826736635505850},\n\t{8245046539531533005, 116033420794382313},\n\t{16682369133275677888, 72520887996488945},\n\t{7017903361312433648, 90651109995611182},\n\t{17995751238495317868, 113313887494513977},\n\t{8659630992836983623, 141642359368142472},\n\t{5412269370523114764, 88526474605089045},\n\t{11377022731581281359, 110658093256361306},\n\t{4997906377621825891, 138322616570451633},\n\t{14652906532082110942, 86451635356532270},\n\t{9092761128247862869, 108064544195665338},\n\t{2142579373455052779, 135080680244581673},\n\t{12868327154477877747, 84425425152863545},\n\t{2250350887815183471, 105531781441079432},\n\t{2812938609768979339, 131914726801349290},\n\t{6369772649532999991, 82446704250843306},\n\t{17185587848771025797, 103058380313554132},\n\t{3035240737254230630, 128822975391942666},\n\t{6508711479211282048, 80514359619964166},\n\t{17359261385868878368, 100642949524955207},\n\t{17087390713908710056, 125803686906194009},\n\t{3762090168551861929, 78627304316371256},\n\t{4702612710689827411, 98284130395464070},\n\t{15101637925217060072, 122855162994330087},\n\t{16356052730901744401, 76784476871456304},\n\t{1998321839917628885, 95980596089320381},\n\t{7109588318324424010, 119975745111650476},\n\t{13666864735807540814, 74984840694781547},\n\t{12471894901332038114, 93731050868476934},\n\t{6366496589810271835, 117163813585596168},\n\t{3979060368631419896, 73227383490997605},\n\t{9585511479216662775, 91534229363747006},\n\t{2758517312166052660, 114417786704683758},\n\t{12671518677062341634, 143022233380854697},\n\t{1002170145522881665, 89388895863034186},\n\t{10476084718758377889, 111736119828792732},\n\t{13095105898447972362, 139670149785990915},\n\t{5878598177316288774, 87293843616244322},\n\t{16571619758500136775, 109117304520305402},\n\t{11491152661270395161, 136396630650381753},\n\t{264441385652915120, 85247894156488596},\n\t{330551732066143900, 106559867695610745},\n\t{5024875683510067779, 133199834619513431},\n\t{10058076329834874218, 83249896637195894},\n\t{3349223375438816964, 104062370796494868},\n\t{4186529219298521205, 130077963495618585},\n\t{14145795808130045513, 81298727184761615},\n\t{13070558741735168987, 101623408980952019},\n\t{11726512408741573330, 127029261226190024},\n\t{7329070255463483331, 79393288266368765},\n\t{13773023837756742068, 99241610332960956},\n\t{17216279797195927585, 124052012916201195},\n\t{8454331864033760789, 77532508072625747},\n\t{5956228811614813082, 96915635090782184},\n\t{7445286014518516353, 121144543863477730},\n\t{9264989777501460624, 75715339914673581},\n\t{16192923240304213684, 94644174893341976},\n\t{1794409976670715490, 118305218616677471},\n\t{8039035263060279037, 73940761635423419},\n\t{5437108060397960892, 92425952044279274},\n\t{16019757112352226923, 115532440055349092},\n\t{788976158365366019, 72207775034593183},\n\t{14821278253238871236, 90259718793241478},\n\t{9303225779693813237, 112824648491551848},\n\t{11629032224617266546, 141030810614439810},\n\t{11879831158813179495, 88144256634024881},\n\t{1014730893234310657, 110180320792531102},\n\t{10491785653397664129, 137725400990663877},\n\t{8863209042587234033, 86078375619164923},\n\t{6467325284806654637, 107597969523956154},\n\t{17307528642863094104, 134497461904945192},\n\t{10817205401789433815, 84060913690590745},\n\t{18133192770664180173, 105076142113238431},\n\t{18054804944902837312, 131345177641548039},\n\t{18201782118205355176, 82090736025967524},\n\t{4305483574047142354, 102613420032459406},\n\t{14605226504413703751, 128266775040574257},\n\t{2210737537617482988, 80166734400358911},\n\t{16598479977304017447, 100208418000448638},\n\t{11524727934775246001, 125260522500560798},\n\t{2591268940807140847, 78287826562850499},\n\t{17074144231291089770, 97859783203563123},\n\t{16730994270686474309, 122324729004453904},\n\t{10456871419179046443, 76452955627783690},\n\t{3847717237119032246, 95566194534729613},\n\t{9421332564826178211, 119457743168412016},\n\t{5888332853016361382, 74661089480257510},\n\t{16583788103125227536, 93326361850321887},\n\t{16118049110479146516, 116657952312902359},\n\t{16991309721690548428, 72911220195563974},\n\t{12015765115258409727, 91139025244454968},\n\t{15019706394073012159, 113923781555568710},\n\t{9551260955736489391, 142404726944460888},\n\t{5969538097335305869, 89002954340288055},\n\t{2850236603241744433, 111253692925360069},\n}\n\nconst pow5InvNumBits64 = 122\n\nvar pow5InvSplit64 = [...]uint128{\n\t{1, 288230376151711744},\n\t{3689348814741910324, 230584300921369395},\n\t{2951479051793528259, 184467440737095516},\n\t{17118578500402463900, 147573952589676412},\n\t{12632330341676300947, 236118324143482260},\n\t{10105864273341040758, 188894659314785808},\n\t{15463389048156653253, 151115727451828646},\n\t{17362724847566824558, 241785163922925834},\n\t{17579528692795369969, 193428131138340667},\n\t{6684925324752475329, 154742504910672534},\n\t{18074578149087781173, 247588007857076054},\n\t{18149011334012135262, 198070406285660843},\n\t{3451162622983977240, 158456325028528675},\n\t{5521860196774363583, 253530120045645880},\n\t{4417488157419490867, 202824096036516704},\n\t{7223339340677503017, 162259276829213363},\n\t{7867994130342094503, 259614842926741381},\n\t{2605046489531765280, 207691874341393105},\n\t{2084037191625412224, 166153499473114484},\n\t{10713157136084480204, 265845599156983174},\n\t{12259874523609494487, 212676479325586539},\n\t{13497248433629505913, 170141183460469231},\n\t{14216899864323388813, 272225893536750770},\n\t{11373519891458711051, 217780714829400616},\n\t{5409467098425058518, 174224571863520493},\n\t{4965798542738183305, 278759314981632789},\n\t{7661987648932456967, 223007451985306231},\n\t{2440241304404055250, 178405961588244985},\n\t{3904386087046488400, 285449538541191976},\n\t{17880904128604832013, 228359630832953580},\n\t{14304723302883865611, 182687704666362864},\n\t{15133127457049002812, 146150163733090291},\n\t{16834306301794583852, 233840261972944466},\n\t{9778096226693756759, 187072209578355573},\n\t{15201174610838826053, 149657767662684458},\n\t{2185786488890659746, 239452428260295134},\n\t{5437978005854438120, 191561942608236107},\n\t{15418428848909281466, 153249554086588885},\n\t{6222742084545298729, 245199286538542217},\n\t{16046240111861969953, 196159429230833773},\n\t{1768945645263844993, 156927543384667019},\n\t{10209010661905972635, 251084069415467230},\n\t{8167208529524778108, 200867255532373784},\n\t{10223115638361732810, 160693804425899027},\n\t{1599589762411131202, 257110087081438444},\n\t{4969020624670815285, 205688069665150755},\n\t{3975216499736652228, 164550455732120604},\n\t{13739044029062464211, 263280729171392966},\n\t{7301886408508061046, 210624583337114373},\n\t{13220206756290269483, 168499666669691498},\n\t{17462981995322520850, 269599466671506397},\n\t{6591687966774196033, 215679573337205118},\n\t{12652048002903177473, 172543658669764094},\n\t{9175230360419352987, 276069853871622551},\n\t{3650835473593572067, 220855883097298041},\n\t{17678063637842498946, 176684706477838432},\n\t{13527506561580357021, 282695530364541492},\n\t{3443307619780464970, 226156424291633194},\n\t{6443994910566282300, 180925139433306555},\n\t{5155195928453025840, 144740111546645244},\n\t{15627011115008661990, 231584178474632390},\n\t{12501608892006929592, 185267342779705912},\n\t{2622589484121723027, 148213874223764730},\n\t{4196143174594756843, 237142198758023568},\n\t{10735612169159626121, 189713759006418854},\n\t{12277838550069611220, 151771007205135083},\n\t{15955192865369467629, 242833611528216133},\n\t{1696107848069843133, 194266889222572907},\n\t{12424932722681605476, 155413511378058325},\n\t{1433148282581017146, 248661618204893321},\n\t{15903913885032455010, 198929294563914656},\n\t{9033782293284053685, 159143435651131725},\n\t{14454051669254485895, 254629497041810760},\n\t{11563241335403588716, 203703597633448608},\n\t{16629290697806691620, 162962878106758886},\n\t{781423413297334329, 260740604970814219},\n\t{4314487545379777786, 208592483976651375},\n\t{3451590036303822229, 166873987181321100},\n\t{5522544058086115566, 266998379490113760},\n\t{4418035246468892453, 213598703592091008},\n\t{10913125826658934609, 170878962873672806},\n\t{10082303693170474728, 273406340597876490},\n\t{8065842954536379782, 218725072478301192},\n\t{17520720807854834795, 174980057982640953},\n\t{5897060404116273733, 279968092772225526},\n\t{1028299508551108663, 223974474217780421},\n\t{15580034865808528224, 179179579374224336},\n\t{17549358155809824511, 286687326998758938},\n\t{2971440080422128639, 229349861599007151},\n\t{17134547323305344204, 183479889279205720},\n\t{13707637858644275364, 146783911423364576},\n\t{14553522944347019935, 234854258277383322},\n\t{4264120725993795302, 187883406621906658},\n\t{10789994210278856888, 150306725297525326},\n\t{9885293106962350374, 240490760476040522},\n\t{529536856086059653, 192392608380832418},\n\t{7802327114352668369, 153914086704665934},\n\t{1415676938738538420, 246262538727465495},\n\t{1132541550990830736, 197010030981972396},\n\t{15663428499760305882, 157608024785577916},\n\t{17682787970132668764, 252172839656924666},\n\t{10456881561364224688, 201738271725539733},\n\t{15744202878575200397, 161390617380431786},\n\t{17812026976236499989, 258224987808690858},\n\t{3181575136763469022, 206579990246952687},\n\t{13613306553636506187, 165263992197562149},\n\t{10713244041592678929, 264422387516099439},\n\t{12259944048016053467, 211537910012879551},\n\t{6118606423670932450, 169230328010303641},\n\t{2411072648389671274, 270768524816485826},\n\t{16686253377679378312, 216614819853188660},\n\t{13349002702143502650, 173291855882550928},\n\t{17669055508687693916, 277266969412081485},\n\t{14135244406950155133, 221813575529665188},\n\t{240149081334393137, 177450860423732151},\n\t{11452284974360759988, 283921376677971441},\n\t{5472479164746697667, 227137101342377153},\n\t{11756680961281178780, 181709681073901722},\n\t{2026647139541122378, 145367744859121378},\n\t{18000030682233437097, 232588391774594204},\n\t{18089373360528660001, 186070713419675363},\n\t{3403452244197197031, 148856570735740291},\n\t{16513570034941246220, 238170513177184465},\n\t{13210856027952996976, 190536410541747572},\n\t{3189987192878576934, 152429128433398058},\n\t{1414630693863812771, 243886605493436893},\n\t{8510402184574870864, 195109284394749514},\n\t{10497670562401807014, 156087427515799611},\n\t{9417575270359070576, 249739884025279378},\n\t{14912757845771077107, 199791907220223502},\n\t{4551508647133041040, 159833525776178802},\n\t{10971762650154775986, 255733641241886083},\n\t{16156107749607641435, 204586912993508866},\n\t{9235537384944202825, 163669530394807093},\n\t{11087511001168814197, 261871248631691349},\n\t{12559357615676961681, 209496998905353079},\n\t{13736834907283479668, 167597599124282463},\n\t{18289587036911657145, 268156158598851941},\n\t{10942320814787415393, 214524926879081553},\n\t{16132554281313752961, 171619941503265242},\n\t{11054691591134363444, 274591906405224388},\n\t{16222450902391311402, 219673525124179510},\n\t{12977960721913049122, 175738820099343608},\n\t{17075388340318968271, 281182112158949773},\n\t{2592264228029443648, 224945689727159819},\n\t{5763160197165465241, 179956551781727855},\n\t{9221056315464744386, 287930482850764568},\n\t{14755542681855616155, 230344386280611654},\n\t{15493782960226403247, 184275509024489323},\n\t{1326979923955391628, 147420407219591459},\n\t{9501865507812447252, 235872651551346334},\n\t{11290841220991868125, 188698121241077067},\n\t{1653975347309673853, 150958496992861654},\n\t{10025058185179298811, 241533595188578646},\n\t{4330697733401528726, 193226876150862917},\n\t{14532604630946953951, 154581500920690333},\n\t{1116074521063664381, 247330401473104534},\n\t{4582208431592841828, 197864321178483627},\n\t{14733813189500004432, 158291456942786901},\n\t{16195403473716186445, 253266331108459042},\n\t{5577625149489128510, 202613064886767234},\n\t{8151448934333213131, 162090451909413787},\n\t{16731667109675051333, 259344723055062059},\n\t{17074682502481951390, 207475778444049647},\n\t{6281048372501740465, 165980622755239718},\n\t{6360328581260874421, 265568996408383549},\n\t{8777611679750609860, 212455197126706839},\n\t{10711438158542398211, 169964157701365471},\n\t{9759603424184016492, 271942652322184754},\n\t{11497031554089123517, 217554121857747803},\n\t{16576322872755119460, 174043297486198242},\n\t{11764721337440549842, 278469275977917188},\n\t{16790474699436260520, 222775420782333750},\n\t{13432379759549008416, 178220336625867000},\n\t{3045063541568861850, 285152538601387201},\n\t{17193446092222730773, 228122030881109760},\n\t{13754756873778184618, 182497624704887808},\n\t{18382503128506368341, 145998099763910246},\n\t{3586563302416817083, 233596959622256395},\n\t{2869250641933453667, 186877567697805116},\n\t{17052795772514404226, 149502054158244092},\n\t{12527077977055405469, 239203286653190548},\n\t{17400360011128145022, 191362629322552438},\n\t{2852241564676785048, 153090103458041951},\n\t{15631632947708587046, 244944165532867121},\n\t{8815957543424959314, 195955332426293697},\n\t{18120812478965698421, 156764265941034957},\n\t{14235904707377476180, 250822825505655932},\n\t{4010026136418160298, 200658260404524746},\n\t{17965416168102169531, 160526608323619796},\n\t{2919224165770098987, 256842573317791675},\n\t{2335379332616079190, 205474058654233340},\n\t{1868303466092863352, 164379246923386672},\n\t{6678634360490491686, 263006795077418675},\n\t{5342907488392393349, 210405436061934940},\n\t{4274325990713914679, 168324348849547952},\n\t{10528270399884173809, 269318958159276723},\n\t{15801313949391159694, 215455166527421378},\n\t{1573004715287196786, 172364133221937103},\n\t{17274202803427156150, 275782613155099364},\n\t{17508711057483635243, 220626090524079491},\n\t{10317620031244997871, 176500872419263593},\n\t{12818843235250086271, 282401395870821749},\n\t{13944423402941979340, 225921116696657399},\n\t{14844887537095493795, 180736893357325919},\n\t{15565258844418305359, 144589514685860735},\n\t{6457670077359736959, 231343223497377177},\n\t{16234182506113520537, 185074578797901741},\n\t{9297997190148906106, 148059663038321393},\n\t{11187446689496339446, 236895460861314229},\n\t{12639306166338981880, 189516368689051383},\n\t{17490142562555006151, 151613094951241106},\n\t{2158786396894637579, 242580951921985771},\n\t{16484424376483351356, 194064761537588616},\n\t{9498190686444770762, 155251809230070893},\n\t{11507756283569722895, 248402894768113429},\n\t{12895553841597688639, 198722315814490743},\n\t{17695140702761971558, 158977852651592594},\n\t{17244178680193423523, 254364564242548151},\n\t{10105994129412828495, 203491651394038521},\n\t{4395446488788352473, 162793321115230817},\n\t{10722063196803274280, 260469313784369307},\n\t{1198952927958798777, 208375451027495446},\n\t{15716557601334680315, 166700360821996356},\n\t{17767794532651667857, 266720577315194170},\n\t{14214235626121334286, 213376461852155336},\n\t{7682039686155157106, 170701169481724269},\n\t{1223217053622520399, 273121871170758831},\n\t{15735968901865657612, 218497496936607064},\n\t{16278123936234436413, 174797997549285651},\n\t{219556594781725998, 279676796078857043},\n\t{7554342905309201445, 223741436863085634},\n\t{9732823138989271479, 178993149490468507},\n\t{815121763415193074, 286389039184749612},\n\t{11720143854957885429, 229111231347799689},\n\t{13065463898708218666, 183288985078239751},\n\t{6763022304224664610, 146631188062591801},\n\t{3442138057275642729, 234609900900146882},\n\t{13821756890046245153, 187687920720117505},\n\t{11057405512036996122, 150150336576094004},\n\t{6623802375033462826, 240240538521750407},\n\t{16367088344252501231, 192192430817400325},\n\t{13093670675402000985, 153753944653920260},\n\t{2503129006933649959, 246006311446272417},\n\t{13070549649772650937, 196805049157017933},\n\t{17835137349301941396, 157444039325614346},\n\t{2710778055689733971, 251910462920982955},\n\t{2168622444551787177, 201528370336786364},\n\t{5424246770383340065, 161222696269429091},\n\t{1300097203129523457, 257956314031086546},\n\t{15797473021471260058, 206365051224869236},\n\t{8948629602435097724, 165092040979895389},\n\t{3249760919670425388, 264147265567832623},\n\t{9978506365220160957, 211317812454266098},\n\t{15361502721659949412, 169054249963412878},\n\t{2442311466204457120, 270486799941460606},\n\t{16711244431931206989, 216389439953168484},\n\t{17058344360286875914, 173111551962534787},\n\t{12535955717491360170, 276978483140055660},\n\t{10028764573993088136, 221582786512044528},\n\t{15401709288678291155, 177266229209635622},\n\t{9885339602917624555, 283625966735416996},\n\t{4218922867592189321, 226900773388333597},\n\t{14443184738299482427, 181520618710666877},\n\t{4175850161155765295, 145216494968533502},\n\t{10370709072591134795, 232346391949653603},\n\t{15675264887556728482, 185877113559722882},\n\t{5161514280561562140, 148701690847778306},\n\t{879725219414678777, 237922705356445290},\n\t{703780175531743021, 190338164285156232},\n\t{11631070584651125387, 152270531428124985},\n\t{162968861732249003, 243632850284999977},\n\t{11198421533611530172, 194906280227999981},\n\t{5269388412147313814, 155925024182399985},\n\t{8431021459435702103, 249480038691839976},\n\t{3055468352806651359, 199584030953471981},\n\t{17201769941212962380, 159667224762777584},\n\t{16454785461715008838, 255467559620444135},\n\t{13163828369372007071, 204374047696355308},\n\t{17909760324981426303, 163499238157084246},\n\t{2830174816776909822, 261598781051334795},\n\t{2264139853421527858, 209279024841067836},\n\t{16568707141704863579, 167423219872854268},\n\t{4373838538276319787, 267877151796566830},\n\t{3499070830621055830, 214301721437253464},\n\t{6488605479238754987, 171441377149802771},\n\t{3003071137298187333, 274306203439684434},\n\t{6091805724580460189, 219444962751747547},\n\t{15941491023890099121, 175555970201398037},\n\t{10748990379256517301, 280889552322236860},\n\t{8599192303405213841, 224711641857789488},\n\t{14258051472207991719, 179769313486231590},\n}\n"},{"Name":"floatconv.gno","Body":"// Copyright 2018 Ulf Adams\n// Modifications copyright 2019 Caleb Spare\n//\n// The contents of this file may be used under the terms of the Apache License,\n// Version 2.0.\n//\n//    (See accompanying file LICENSE or copy at\n//     http://www.apache.org/licenses/LICENSE-2.0)\n//\n// Unless required by applicable law or agreed to in writing, this software\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.\n//\n// The code in this file is part of a Go translation of the C code originally written by\n// Ulf Adams, which can be found at https://github.com/ulfjack/ryu. The original source\n// code is licensed under the Apache License 2.0. This code is a derivative work thereof,\n// adapted and modified to meet the specifications of the Gno language project.\n//\n// original Go implementation can be found at https://github.com/cespare/ryu.\n//\n// Please note that the modifications are also under the Apache License 2.0 unless\n// otherwise specified.\n\n// Package ryu implements the Ryu algorithm for quickly converting floating\n// point numbers into strings.\npackage ryu\n\nimport (\n\t\"math\"\n)\n\nconst (\n\tmantBits32 = 23\n\texpBits32  = 8\n\tbias32     = 127\n\n\tmantBits64 = 52\n\texpBits64  = 11\n\tbias64     = 1023\n)\n\n// FormatFloat64 converts a 64-bit floating point number f to a string.\n// It behaves like strconv.FormatFloat(f, 'e', -1, 64).\nfunc FormatFloat64(f float64) string {\n\tb := make([]byte, 0, 24)\n\tb = AppendFloat64(b, f)\n\treturn string(b)\n}\n\n// AppendFloat64 appends the string form of the 64-bit floating point number f,\n// as generated by FormatFloat64, to b and returns the extended buffer.\nfunc AppendFloat64(b []byte, f float64) []byte {\n\t// Step 1: Decode the floating-point number.\n\t// Unify normalized and subnormal cases.\n\tu := math.Float64bits(f)\n\tneg := u\u003e\u003e(mantBits64+expBits64) != 0\n\tmant := u \u0026 (uint64(1)\u003c\u003cmantBits64 - 1)\n\texp := (u \u003e\u003e mantBits64) \u0026 (uint64(1)\u003c\u003cexpBits64 - 1)\n\n\t// Exit early for easy cases.\n\tif exp == uint64(1)\u003c\u003cexpBits64-1 || (exp == 0 \u0026\u0026 mant == 0) {\n\t\treturn appendSpecial(b, neg, exp == 0, mant == 0)\n\t}\n\n\td, ok := float64ToDecimalExactInt(mant, exp)\n\tif !ok {\n\t\td = float64ToDecimal(mant, exp)\n\t}\n\treturn d.append(b, neg)\n}\n\nfunc appendSpecial(b []byte, neg, expZero, mantZero bool) []byte {\n\tif !mantZero {\n\t\treturn append(b, \"NaN\"...)\n\t}\n\tif !expZero {\n\t\tif neg {\n\t\t\treturn append(b, \"-Inf\"...)\n\t\t}\n\n\t\treturn append(b, \"+Inf\"...)\n\t}\n\n\tif neg {\n\t\tb = append(b, '-')\n\t}\n\treturn append(b, \"0e+00\"...)\n}\n\nfunc boolToInt(b bool) int {\n\tif b {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc boolToUint32(b bool) uint32 {\n\tif b {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc boolToUint64(b bool) uint64 {\n\tif b {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc assert(t bool, msg string) {\n\tif !t {\n\t\tpanic(msg)\n\t}\n}\n\n// log10Pow2 returns floor(log_10(2^e)).\nfunc log10Pow2(e int32) uint32 {\n\t// The first value this approximation fails for is 2^1651\n\t// which is just greater than 10^297.\n\tassert(e \u003e= 0, \"e \u003e= 0\")\n\tassert(e \u003c= 1650, \"e \u003c= 1650\")\n\treturn (uint32(e) * 78913) \u003e\u003e 18\n}\n\n// log10Pow5 returns floor(log_10(5^e)).\nfunc log10Pow5(e int32) uint32 {\n\t// The first value this approximation fails for is 5^2621\n\t// which is just greater than 10^1832.\n\tassert(e \u003e= 0, \"e \u003e= 0\")\n\tassert(e \u003c= 2620, \"e \u003c= 2620\")\n\treturn (uint32(e) * 732923) \u003e\u003e 20\n}\n\n// pow5Bits returns ceil(log_2(5^e)), or else 1 if e==0.\nfunc pow5Bits(e int32) int32 {\n\t// This approximation works up to the point that the multiplication\n\t// overflows at e = 3529. If the multiplication were done in 64 bits,\n\t// it would fail at 5^4004 which is just greater than 2^9297.\n\tassert(e \u003e= 0, \"e \u003e= 0\")\n\tassert(e \u003c= 3528, \"e \u003c= 3528\")\n\treturn int32((uint32(e)*1217359)\u003e\u003e19 + 1)\n}\n"},{"Name":"ryu64.gno","Body":"package ryu\n\nimport (\n\t\"math/bits\"\n)\n\ntype uint128 struct {\n\tlo uint64\n\thi uint64\n}\n\n// dec64 is a floating decimal type representing m * 10^e.\ntype dec64 struct {\n\tm uint64\n\te int32\n}\n\nfunc (d dec64) append(b []byte, neg bool) []byte {\n\t// Step 5: Print the decimal representation.\n\tif neg {\n\t\tb = append(b, '-')\n\t}\n\n\tout := d.m\n\toutLen := decimalLen64(out)\n\tbufLen := outLen\n\tif bufLen \u003e 1 {\n\t\tbufLen++ // extra space for '.'\n\t}\n\n\t// Print the decimal digits.\n\tn := len(b)\n\tif cap(b)-len(b) \u003e= bufLen {\n\t\t// Avoid function call in the common case.\n\t\tb = b[:len(b)+bufLen]\n\t} else {\n\t\tb = append(b, make([]byte, bufLen)...)\n\t}\n\n\t// Avoid expensive 64-bit divisions.\n\t// We have at most 17 digits, and uint32 can store 9 digits.\n\t// If the output doesn't fit into a uint32, cut off 8 digits\n\t// so the rest will fit into a uint32.\n\tvar i int\n\tif out\u003e\u003e32 \u003e 0 {\n\t\tvar out32 uint32\n\t\tout, out32 = out/1e8, uint32(out%1e8)\n\t\tfor ; i \u003c 8; i++ {\n\t\t\tb[n+outLen-i] = '0' + byte(out32%10)\n\t\t\tout32 /= 10\n\t\t}\n\t}\n\tout32 := uint32(out)\n\tfor ; i \u003c outLen-1; i++ {\n\t\tb[n+outLen-i] = '0' + byte(out32%10)\n\t\tout32 /= 10\n\t}\n\tb[n] = '0' + byte(out32%10)\n\n\t// Print the '.' if needed.\n\tif outLen \u003e 1 {\n\t\tb[n+1] = '.'\n\t}\n\n\t// Print the exponent.\n\tb = append(b, 'e')\n\texp := d.e + int32(outLen) - 1\n\tif exp \u003c 0 {\n\t\tb = append(b, '-')\n\t\texp = -exp\n\t} else {\n\t\t// Unconditionally print a + here to match strconv's formatting.\n\t\tb = append(b, '+')\n\t}\n\t// Always print at least two digits to match strconv's formatting.\n\td2 := exp % 10\n\texp /= 10\n\td1 := exp % 10\n\td0 := exp / 10\n\tif d0 \u003e 0 {\n\t\tb = append(b, '0'+byte(d0))\n\t}\n\tb = append(b, '0'+byte(d1), '0'+byte(d2))\n\n\treturn b\n}\n\nfunc float64ToDecimalExactInt(mant, exp uint64) (d dec64, ok bool) {\n\te := exp - bias64\n\tif e \u003e mantBits64 {\n\t\treturn d, false\n\t}\n\tshift := mantBits64 - e\n\tmant |= 1 \u003c\u003c mantBits64 // implicit 1\n\td.m = mant \u003e\u003e shift\n\tif d.m\u003c\u003cshift != mant {\n\t\treturn d, false\n\t}\n\n\tfor d.m%10 == 0 {\n\t\td.m /= 10\n\t\td.e++\n\t}\n\treturn d, true\n}\n\nfunc float64ToDecimal(mant, exp uint64) dec64 {\n\tvar e2 int32\n\tvar m2 uint64\n\tif exp == 0 {\n\t\t// We subtract 2 so that the bounds computation has\n\t\t// 2 additional bits.\n\t\te2 = 1 - bias64 - mantBits64 - 2\n\t\tm2 = mant\n\t} else {\n\t\te2 = int32(exp) - bias64 - mantBits64 - 2\n\t\tm2 = uint64(1)\u003c\u003cmantBits64 | mant\n\t}\n\teven := m2\u00261 == 0\n\tacceptBounds := even\n\n\t// Step 2: Determine the interval of valid decimal representations.\n\tmv := 4 * m2\n\tmmShift := boolToUint64(mant != 0 || exp \u003c= 1)\n\t// We would compute mp and mm like this:\n\t// mp := 4 * m2 + 2;\n\t// mm := mv - 1 - mmShift;\n\n\t// Step 3: Convert to a decimal power base uing 128-bit arithmetic.\n\tvar (\n\t\tvr, vp, vm        uint64\n\t\te10               int32\n\t\tvmIsTrailingZeros bool\n\t\tvrIsTrailingZeros bool\n\t)\n\tif e2 \u003e= 0 {\n\t\t// This expression is slightly faster than max(0, log10Pow2(e2) - 1).\n\t\tq := log10Pow2(e2) - boolToUint32(e2 \u003e 3)\n\t\te10 = int32(q)\n\t\tk := pow5InvNumBits64 + pow5Bits(int32(q)) - 1\n\t\ti := -e2 + int32(q) + k\n\t\tmul := pow5InvSplit64[q]\n\t\tvr = mulShift64(4*m2, mul, i)\n\t\tvp = mulShift64(4*m2+2, mul, i)\n\t\tvm = mulShift64(4*m2-1-mmShift, mul, i)\n\t\tif q \u003c= 21 {\n\t\t\t// This should use q \u003c= 22, but I think 21 is also safe.\n\t\t\t// Smaller values may still be safe, but it's more\n\t\t\t// difficult to reason about them. Only one of mp, mv,\n\t\t\t// and mm can be a multiple of 5, if any.\n\t\t\tif mv%5 == 0 {\n\t\t\t\tvrIsTrailingZeros = multipleOfPowerOfFive64(mv, q)\n\t\t\t} else if acceptBounds {\n\t\t\t\t// Same as min(e2 + (^mm \u0026 1), pow5Factor64(mm)) \u003e= q\n\t\t\t\t// \u003c=\u003e e2 + (^mm \u0026 1) \u003e= q \u0026\u0026 pow5Factor64(mm) \u003e= q\n\t\t\t\t// \u003c=\u003e true \u0026\u0026 pow5Factor64(mm) \u003e= q, since e2 \u003e= q.\n\t\t\t\tvmIsTrailingZeros = multipleOfPowerOfFive64(mv-1-mmShift, q)\n\t\t\t} else if multipleOfPowerOfFive64(mv+2, q) {\n\t\t\t\tvp--\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// This expression is slightly faster than max(0, log10Pow5(-e2) - 1).\n\t\tq := log10Pow5(-e2) - boolToUint32(-e2 \u003e 1)\n\t\te10 = int32(q) + e2\n\t\ti := -e2 - int32(q)\n\t\tk := pow5Bits(i) - pow5NumBits64\n\t\tj := int32(q) - k\n\t\tmul := pow5Split64[i]\n\t\tvr = mulShift64(4*m2, mul, j)\n\t\tvp = mulShift64(4*m2+2, mul, j)\n\t\tvm = mulShift64(4*m2-1-mmShift, mul, j)\n\t\tif q \u003c= 1 {\n\t\t\t// {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n\t\t\t// mv = 4 * m2, so it always has at least two trailing 0 bits.\n\t\t\tvrIsTrailingZeros = true\n\t\t\tif acceptBounds {\n\t\t\t\t// mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.\n\t\t\t\tvmIsTrailingZeros = mmShift == 1\n\t\t\t} else {\n\t\t\t\t// mp = mv + 2, so it always has at least one trailing 0 bit.\n\t\t\t\tvp--\n\t\t\t}\n\t\t} else if q \u003c 63 { // TODO(ulfjack/cespare): Use a tighter bound here.\n\t\t\t// We need to compute min(ntz(mv), pow5Factor64(mv) - e2) \u003e= q - 1\n\t\t\t// \u003c=\u003e ntz(mv) \u003e= q - 1 \u0026\u0026 pow5Factor64(mv) - e2 \u003e= q - 1\n\t\t\t// \u003c=\u003e ntz(mv) \u003e= q - 1 (e2 is negative and -e2 \u003e= q)\n\t\t\t// \u003c=\u003e (mv \u0026 ((1 \u003c\u003c (q - 1)) - 1)) == 0\n\t\t\t// We also need to make sure that the left shift does not overflow.\n\t\t\tvrIsTrailingZeros = multipleOfPowerOfTwo64(mv, q-1)\n\t\t}\n\t}\n\n\t// Step 4: Find the shortest decimal representation\n\t// in the interval of valid representations.\n\tvar removed int32\n\tvar lastRemovedDigit uint8\n\tvar out uint64\n\t// On average, we remove ~2 digits.\n\tif vmIsTrailingZeros || vrIsTrailingZeros {\n\t\t// General case, which happens rarely (~0.7%).\n\t\tfor {\n\t\t\tvpDiv10 := vp / 10\n\t\t\tvmDiv10 := vm / 10\n\t\t\tif vpDiv10 \u003c= vmDiv10 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tvmMod10 := vm % 10\n\t\t\tvrDiv10 := vr / 10\n\t\t\tvrMod10 := vr % 10\n\t\t\tvmIsTrailingZeros = vmIsTrailingZeros \u0026\u0026 vmMod10 == 0\n\t\t\tvrIsTrailingZeros = vrIsTrailingZeros \u0026\u0026 lastRemovedDigit == 0\n\t\t\tlastRemovedDigit = uint8(vrMod10)\n\t\t\tvr = vrDiv10\n\t\t\tvp = vpDiv10\n\t\t\tvm = vmDiv10\n\t\t\tremoved++\n\t\t}\n\t\tif vmIsTrailingZeros {\n\t\t\tfor {\n\t\t\t\tvmDiv10 := vm / 10\n\t\t\t\tvmMod10 := vm % 10\n\t\t\t\tif vmMod10 != 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tvpDiv10 := vp / 10\n\t\t\t\tvrDiv10 := vr / 10\n\t\t\t\tvrMod10 := vr % 10\n\t\t\t\tvrIsTrailingZeros = vrIsTrailingZeros \u0026\u0026 lastRemovedDigit == 0\n\t\t\t\tlastRemovedDigit = uint8(vrMod10)\n\t\t\t\tvr = vrDiv10\n\t\t\t\tvp = vpDiv10\n\t\t\t\tvm = vmDiv10\n\t\t\t\tremoved++\n\t\t\t}\n\t\t}\n\t\tif vrIsTrailingZeros \u0026\u0026 lastRemovedDigit == 5 \u0026\u0026 vr%2 == 0 {\n\t\t\t// Round even if the exact number is .....50..0.\n\t\t\tlastRemovedDigit = 4\n\t\t}\n\t\tout = vr\n\t\t// We need to take vr + 1 if vr is outside bounds\n\t\t// or we need to round up.\n\t\tif (vr == vm \u0026\u0026 (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit \u003e= 5 {\n\t\t\tout++\n\t\t}\n\t} else {\n\t\t// Specialized for the common case (~99.3%).\n\t\t// Percentages below are relative to this.\n\t\troundUp := false\n\t\tfor vp/100 \u003e vm/100 {\n\t\t\t// Optimization: remove two digits at a time (~86.2%).\n\t\t\troundUp = vr%100 \u003e= 50\n\t\t\tvr /= 100\n\t\t\tvp /= 100\n\t\t\tvm /= 100\n\t\t\tremoved += 2\n\t\t}\n\t\t// Loop iterations below (approximately), without optimization above:\n\t\t// 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%\n\t\t// Loop iterations below (approximately), with optimization above:\n\t\t// 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%\n\t\tfor vp/10 \u003e vm/10 {\n\t\t\troundUp = vr%10 \u003e= 5\n\t\t\tvr /= 10\n\t\t\tvp /= 10\n\t\t\tvm /= 10\n\t\t\tremoved++\n\t\t}\n\t\t// We need to take vr + 1 if vr is outside bounds\n\t\t// or we need to round up.\n\t\tout = vr + boolToUint64(vr == vm || roundUp)\n\t}\n\n\treturn dec64{m: out, e: e10 + removed}\n}\n\nvar powersOf10 = [...]uint64{\n\t1e0,\n\t1e1,\n\t1e2,\n\t1e3,\n\t1e4,\n\t1e5,\n\t1e6,\n\t1e7,\n\t1e8,\n\t1e9,\n\t1e10,\n\t1e11,\n\t1e12,\n\t1e13,\n\t1e14,\n\t1e15,\n\t1e16,\n\t1e17,\n\t// We only need to find the length of at most 17 digit numbers.\n}\n\nfunc decimalLen64(u uint64) int {\n\t// http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n\tlog2 := 64 - bits.LeadingZeros64(u) - 1\n\tt := (log2 + 1) * 1233 \u003e\u003e 12\n\treturn t - boolToInt(u \u003c powersOf10[t]) + 1\n}\n\nfunc mulShift64(m uint64, mul uint128, shift int32) uint64 {\n\thihi, hilo := bits.Mul64(m, mul.hi)\n\tlohi, _ := bits.Mul64(m, mul.lo)\n\tsum := uint128{hi: hihi, lo: lohi + hilo}\n\tif sum.lo \u003c lohi {\n\t\tsum.hi++ // overflow\n\t}\n\treturn shiftRight128(sum, shift-64)\n}\n\nfunc shiftRight128(v uint128, shift int32) uint64 {\n\t// The shift value is always modulo 64.\n\t// In the current implementation of the 64-bit version\n\t// of Ryu, the shift value is always \u003c 64.\n\t// (It is in the range [2, 59].)\n\t// Check this here in case a future change requires larger shift\n\t// values. In this case this function needs to be adjusted.\n\tassert(shift \u003c 64, \"shift \u003c 64\")\n\treturn (v.hi \u003c\u003c uint64(64-shift)) | (v.lo \u003e\u003e uint(shift))\n}\n\nfunc pow5Factor64(v uint64) uint32 {\n\tfor n := uint32(0); ; n++ {\n\t\tq, r := v/5, v%5\n\t\tif r != 0 {\n\t\t\treturn n\n\t\t}\n\t\tv = q\n\t}\n}\n\nfunc multipleOfPowerOfFive64(v uint64, p uint32) bool {\n\treturn pow5Factor64(v) \u003e= p\n}\n\nfunc multipleOfPowerOfTwo64(v uint64, p uint32) bool {\n\treturn uint32(bits.TrailingZeros64(v)) \u003e= p\n}\n"},{"Name":"floatconv_test.gno","Body":"package ryu\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestFormatFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    float64\n\t\texpected string\n\t}{\n\t\t{\"positive infinity\", math.Inf(1), \"+Inf\"},\n\t\t{\"negative infinity\", math.Inf(-1), \"-Inf\"},\n\t\t{\"NaN\", math.NaN(), \"NaN\"},\n\t\t{\"zero\", 0.0, \"0e+00\"},\n\t\t{\"negative zero\", -0.0, \"0e+00\"},\n\t\t{\"positive number\", 3.14159, \"3.14159e+00\"},\n\t\t{\"negative number\", -2.71828, \"-2.71828e+00\"},\n\t\t{\"very small number\", 1.23e-20, \"1.23e-20\"},\n\t\t{\"very large number\", 1.23e+20, \"1.23e+20\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := FormatFloat64(test.value)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"FormatFloat64(%v) = %q, expected %q\", test.value, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"Name":"buffer.gno","Body":"package json\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype buffer struct {\n\tdata   []byte\n\tlength int\n\tindex  int\n\n\tlast  States\n\tstate States\n\tclass Classes\n}\n\n// newBuffer creates a new buffer with the given data\nfunc newBuffer(data []byte) *buffer {\n\treturn \u0026buffer{\n\t\tdata:   data,\n\t\tlength: len(data),\n\t\tlast:   GO,\n\t\tstate:  GO,\n\t}\n}\n\n// first retrieves the first non-whitespace (or other escaped) character in the buffer.\nfunc (b *buffer) first() (byte, error) {\n\tfor ; b.index \u003c b.length; b.index++ {\n\t\tc := b.data[b.index]\n\n\t\tif !(c == whiteSpace || c == carriageReturn || c == newLine || c == tab) {\n\t\t\treturn c, nil\n\t\t}\n\t}\n\n\treturn 0, io.EOF\n}\n\n// current returns the byte of the current index.\nfunc (b *buffer) current() (byte, error) {\n\tif b.index \u003e= b.length {\n\t\treturn 0, io.EOF\n\t}\n\n\treturn b.data[b.index], nil\n}\n\n// next moves to the next byte and returns it.\nfunc (b *buffer) next() (byte, error) {\n\tb.index++\n\treturn b.current()\n}\n\n// step just moves to the next position.\nfunc (b *buffer) step() error {\n\t_, err := b.next()\n\treturn err\n}\n\n// move moves the index by the given position.\nfunc (b *buffer) move(pos int) error {\n\tnewIndex := b.index + pos\n\n\tif newIndex \u003e b.length {\n\t\treturn io.EOF\n\t}\n\n\tb.index = newIndex\n\n\treturn nil\n}\n\n// slice returns the slice from the current index to the given position.\nfunc (b *buffer) slice(pos int) ([]byte, error) {\n\tend := b.index + pos\n\n\tif end \u003e b.length {\n\t\treturn nil, io.EOF\n\t}\n\n\treturn b.data[b.index:end], nil\n}\n\n// sliceFromIndices returns a slice of the buffer's data starting from 'start' up to (but not including) 'stop'.\nfunc (b *buffer) sliceFromIndices(start, stop int) []byte {\n\tif start \u003e b.length {\n\t\tstart = b.length\n\t}\n\n\tif stop \u003e b.length {\n\t\tstop = b.length\n\t}\n\n\treturn b.data[start:stop]\n}\n\n// skip moves the index to skip the given byte.\nfunc (b *buffer) skip(bs byte) error {\n\tfor b.index \u003c b.length {\n\t\tif b.data[b.index] == bs \u0026\u0026 !b.backslash() {\n\t\t\treturn nil\n\t\t}\n\n\t\tb.index++\n\t}\n\n\treturn io.EOF\n}\n\n// skipAny moves the index until it encounters one of the given set of bytes.\nfunc (b *buffer) skipAny(endTokens map[byte]bool) error {\n\tfor b.index \u003c b.length {\n\t\tif _, exists := endTokens[b.data[b.index]]; exists {\n\t\t\treturn nil\n\t\t}\n\n\t\tb.index++\n\t}\n\n\t// build error message\n\tvar tokens []string\n\tfor token := range endTokens {\n\t\ttokens = append(tokens, string(token))\n\t}\n\n\treturn ufmt.Errorf(\n\t\t\"EOF reached before encountering one of the expected tokens: %s\",\n\t\tstrings.Join(tokens, \", \"),\n\t)\n}\n\n// skipAndReturnIndex moves the buffer index forward by one and returns the new index.\nfunc (b *buffer) skipAndReturnIndex() (int, error) {\n\terr := b.step()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn b.index, nil\n}\n\n// skipUntil moves the buffer index forward until it encounters a byte contained in the endTokens set.\nfunc (b *buffer) skipUntil(endTokens map[byte]bool) (int, error) {\n\tfor b.index \u003c b.length {\n\t\tcurrentByte, err := b.current()\n\t\tif err != nil {\n\t\t\treturn b.index, err\n\t\t}\n\n\t\t// Check if the current byte is in the set of end tokens.\n\t\tif _, exists := endTokens[currentByte]; exists {\n\t\t\treturn b.index, nil\n\t\t}\n\n\t\tb.index++\n\t}\n\n\treturn b.index, io.EOF\n}\n\n// significantTokens is a map where the keys are the significant characters in a JSON path.\n// The values in the map are all true, which allows us to use the map as a set for quick lookups.\nvar significantTokens = map[byte]bool{\n\tdot:          true, // access properties of an object\n\tdollarSign:   true, // root object\n\tatSign:       true, // current object\n\tbracketOpen:  true, // start of an array index or filter expression\n\tbracketClose: true, // end of an array index or filter expression\n}\n\n// filterTokens stores the filter expression tokens.\nvar filterTokens = map[byte]bool{\n\taesterisk: true, // wildcard\n\tandSign:   true,\n\torSign:    true,\n}\n\n// skipToNextSignificantToken advances the buffer index to the next significant character.\n// Significant characters are defined based on the JSON path syntax.\nfunc (b *buffer) skipToNextSignificantToken() {\n\tfor b.index \u003c b.length {\n\t\tcurrent := b.data[b.index]\n\n\t\tif _, ok := significantTokens[current]; ok {\n\t\t\tbreak\n\t\t}\n\n\t\tb.index++\n\t}\n}\n\n// backslash checks to see if the number of backslashes before the current index is odd.\n//\n// This is used to check if the current character is escaped. However, unlike the \"unescape\" function,\n// \"backslash\" only serves to check the number of backslashes.\nfunc (b *buffer) backslash() bool {\n\tif b.index == 0 {\n\t\treturn false\n\t}\n\n\tcount := 0\n\tfor i := b.index - 1; ; i-- {\n\t\tif i \u003e= b.length || b.data[i] != backSlash {\n\t\t\tbreak\n\t\t}\n\n\t\tcount++\n\n\t\tif i == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn count%2 != 0\n}\n\n// numIndex holds a map of valid numeric characters\nvar numIndex = map[byte]bool{\n\t'0': true,\n\t'1': true,\n\t'2': true,\n\t'3': true,\n\t'4': true,\n\t'5': true,\n\t'6': true,\n\t'7': true,\n\t'8': true,\n\t'9': true,\n\t'.': true,\n\t'e': true,\n\t'E': true,\n}\n\n// pathToken checks if the current token is a valid JSON path token.\nfunc (b *buffer) pathToken() error {\n\tvar stack []byte\n\n\tinToken := false\n\tinNumber := false\n\tfirst := b.index\n\n\tfor b.index \u003c b.length {\n\t\tc := b.data[b.index]\n\n\t\tswitch {\n\t\tcase c == doubleQuote || c == singleQuote:\n\t\t\tinToken = true\n\t\t\tif err := b.step(); err != nil {\n\t\t\t\treturn errors.New(\"error stepping through buffer\")\n\t\t\t}\n\n\t\t\tif err := b.skip(c); err != nil {\n\t\t\t\treturn errors.New(\"unmatched quote in path\")\n\t\t\t}\n\n\t\t\tif b.index \u003e= b.length {\n\t\t\t\treturn errors.New(\"unmatched quote in path\")\n\t\t\t}\n\n\t\tcase c == bracketOpen || c == parenOpen:\n\t\t\tinToken = true\n\t\t\tstack = append(stack, c)\n\n\t\tcase c == bracketClose || c == parenClose:\n\t\t\tinToken = true\n\t\t\tif len(stack) == 0 || (c == bracketClose \u0026\u0026 stack[len(stack)-1] != bracketOpen) || (c == parenClose \u0026\u0026 stack[len(stack)-1] != parenOpen) {\n\t\t\t\treturn errors.New(\"mismatched bracket or parenthesis\")\n\t\t\t}\n\n\t\t\tstack = stack[:len(stack)-1]\n\n\t\tcase pathStateContainsValidPathToken(c):\n\t\t\tinToken = true\n\n\t\tcase c == plus || c == minus:\n\t\t\tif inNumber || (b.index \u003e 0 \u0026\u0026 numIndex[b.data[b.index-1]]) {\n\t\t\t\tinToken = true\n\t\t\t} else if !inToken \u0026\u0026 (b.index+1 \u003c b.length \u0026\u0026 numIndex[b.data[b.index+1]]) {\n\t\t\t\tinToken = true\n\t\t\t\tinNumber = true\n\t\t\t} else if !inToken {\n\t\t\t\treturn errors.New(\"unexpected operator at start of token\")\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif len(stack) != 0 || inToken {\n\t\t\t\tinToken = true\n\t\t\t} else {\n\t\t\t\tgoto end\n\t\t\t}\n\t\t}\n\n\t\tb.index++\n\t}\n\nend:\n\tif len(stack) != 0 {\n\t\treturn errors.New(\"unclosed bracket or parenthesis at end of path\")\n\t}\n\n\tif first == b.index {\n\t\treturn errors.New(\"no token found\")\n\t}\n\n\tif inNumber \u0026\u0026 !numIndex[b.data[b.index-1]] {\n\t\tinNumber = false\n\t}\n\n\treturn nil\n}\n\nfunc pathStateContainsValidPathToken(c byte) bool {\n\tif _, ok := significantTokens[c]; ok {\n\t\treturn true\n\t}\n\n\tif _, ok := filterTokens[c]; ok {\n\t\treturn true\n\t}\n\n\tif _, ok := numIndex[c]; ok {\n\t\treturn true\n\t}\n\n\tif 'A' \u003c= c \u0026\u0026 c \u003c= 'Z' || 'a' \u003c= c \u0026\u0026 c \u003c= 'z' {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (b *buffer) numeric(token bool) error {\n\tif token {\n\t\tb.last = GO\n\t}\n\n\tfor ; b.index \u003c b.length; b.index++ {\n\t\tb.class = b.getClasses(doubleQuote)\n\t\tif b.class == __ {\n\t\t\treturn errors.New(\"invalid token found while parsing path\")\n\t\t}\n\n\t\tb.state = StateTransitionTable[b.last][b.class]\n\t\tif b.state == __ {\n\t\t\tif token {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn errors.New(\"invalid token found while parsing path\")\n\t\t}\n\n\t\tif b.state \u003c __ {\n\t\t\treturn nil\n\t\t}\n\n\t\tif b.state \u003c MI || b.state \u003e E3 {\n\t\t\treturn nil\n\t\t}\n\n\t\tb.last = b.state\n\t}\n\n\tif b.last != ZE \u0026\u0026 b.last != IN \u0026\u0026 b.last != FR \u0026\u0026 b.last != E3 {\n\t\treturn errors.New(\"invalid token found while parsing path\")\n\t}\n\n\treturn nil\n}\n\nfunc (b *buffer) getClasses(c byte) Classes {\n\tif b.data[b.index] \u003e= 128 {\n\t\treturn C_ETC\n\t}\n\n\tif c == singleQuote {\n\t\treturn QuoteAsciiClasses[b.data[b.index]]\n\t}\n\n\treturn AsciiClasses[b.data[b.index]]\n}\n\nfunc (b *buffer) getState() States {\n\tb.last = b.state\n\n\tb.class = b.getClasses(doubleQuote)\n\tif b.class == __ {\n\t\treturn __\n\t}\n\n\tb.state = StateTransitionTable[b.last][b.class]\n\n\treturn b.state\n}\n\n// string parses a string token from the buffer.\nfunc (b *buffer) string(search byte, token bool) error {\n\tif token {\n\t\tb.last = GO\n\t}\n\n\tfor ; b.index \u003c b.length; b.index++ {\n\t\tb.class = b.getClasses(search)\n\n\t\tif b.class == __ {\n\t\t\treturn errors.New(\"invalid token found while parsing path\")\n\t\t}\n\n\t\tb.state = StateTransitionTable[b.last][b.class]\n\t\tif b.state == __ {\n\t\t\treturn errors.New(\"invalid token found while parsing path\")\n\t\t}\n\n\t\tif b.state \u003c __ {\n\t\t\tbreak\n\t\t}\n\n\t\tb.last = b.state\n\t}\n\n\treturn nil\n}\n\nfunc (b *buffer) word(bs []byte) error {\n\tvar c byte\n\n\tmax := len(bs)\n\tindex := 0\n\n\tfor ; b.index \u003c b.length; b.index++ {\n\t\tc = b.data[b.index]\n\n\t\tif c != bs[index] {\n\t\t\treturn errors.New(\"invalid token found while parsing path\")\n\t\t}\n\n\t\tindex++\n\t\tif index \u003e= max {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif index != max {\n\t\treturn errors.New(\"invalid token found while parsing path\")\n\t}\n\n\treturn nil\n}\n\nfunc numberKind2f64(value interface{}) (result float64, err error) {\n\tswitch typed := value.(type) {\n\tcase float64:\n\t\tresult = typed\n\tcase float32:\n\t\tresult = float64(typed)\n\tcase int:\n\t\tresult = float64(typed)\n\tcase int8:\n\t\tresult = float64(typed)\n\tcase int16:\n\t\tresult = float64(typed)\n\tcase int32:\n\t\tresult = float64(typed)\n\tcase int64:\n\t\tresult = float64(typed)\n\tcase uint:\n\t\tresult = float64(typed)\n\tcase uint8:\n\t\tresult = float64(typed)\n\tcase uint16:\n\t\tresult = float64(typed)\n\tcase uint32:\n\t\tresult = float64(typed)\n\tcase uint64:\n\t\tresult = float64(typed)\n\tdefault:\n\t\terr = ufmt.Errorf(\"invalid number type: %T\", value)\n\t}\n\n\treturn\n}\n"},{"Name":"encode_test.gno","Body":"package json\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshal_Primitive(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tnode *Node\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tnode: NullNode(\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tnode: BoolNode(\"\", true),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tnode: BoolNode(\"\", false),\n\t\t},\n\t\t{\n\t\t\tname: `\"string\"`,\n\t\t\tnode: StringNode(\"\", \"string\"),\n\t\t},\n\t\t{\n\t\t\tname: `\"one \\\"encoded\\\" string\"`,\n\t\t\tnode: StringNode(\"\", `one \"encoded\" string`),\n\t\t},\n\t\t{\n\t\t\tname: `{\"foo\":\"bar\"}`,\n\t\t\tnode: ObjectNode(\"\", map[string]*Node{\n\t\t\t\t\"foo\": StringNode(\"foo\", \"bar\"),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"42\",\n\t\t\tnode: NumberNode(\"\", 42),\n\t\t},\n\t\t// TODO: fix output for not to use scientific notation\n\t\t{\n\t\t\tname: \"1.005e+02\",\n\t\t\tnode: NumberNode(\"\", 100.5),\n\t\t},\n\t\t{\n\t\t\tname: `[1,2,3]`,\n\t\t\tnode: ArrayNode(\"\", []*Node{\n\t\t\t\tNumberNode(\"0\", 1),\n\t\t\t\tNumberNode(\"2\", 2),\n\t\t\t\tNumberNode(\"3\", 3),\n\t\t\t}),\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvalue, err := Marshal(test.node)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t} else if string(value) != test.name {\n\t\t\t\tt.Errorf(\"wrong result: '%s', expected '%s'\", value, test.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMarshal_Object(t *testing.T) {\n\tnode := ObjectNode(\"\", map[string]*Node{\n\t\t\"foo\": StringNode(\"foo\", \"bar\"),\n\t\t\"baz\": NumberNode(\"baz\", 100500),\n\t\t\"qux\": NullNode(\"qux\"),\n\t})\n\n\tmustKey := []string{\"foo\", \"baz\", \"qux\"}\n\n\tvalue, err := Marshal(node)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err)\n\t}\n\n\t// the order of keys in the map is not guaranteed\n\t// so we need to unmarshal the result and check the keys\n\tdecoded, err := Unmarshal(value)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err)\n\t}\n\n\tfor _, key := range mustKey {\n\t\tif node, err := decoded.GetKey(key); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t} else {\n\t\t\tif node == nil {\n\t\t\t\tt.Errorf(\"node is nil\")\n\t\t\t} else if node.key == nil {\n\t\t\t\tt.Errorf(\"key is nil\")\n\t\t\t} else if *node.key != key {\n\t\t\t\tt.Errorf(\"wrong key: '%s', expected '%s'\", *node.key, key)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc valueNode(prev *Node, key string, typ ValueType, val interface{}) *Node {\n\tcurr := \u0026Node{\n\t\tprev:     prev,\n\t\tdata:     nil,\n\t\tkey:      \u0026key,\n\t\tborders:  [2]int{0, 0},\n\t\tvalue:    val,\n\t\tmodified: true,\n\t}\n\n\tif val != nil {\n\t\tcurr.nodeType = typ\n\t}\n\n\treturn curr\n}\n\nfunc TestMarshal_Errors(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tnode func() (node *Node)\n\t}{\n\t\t{\n\t\t\tname: \"nil\",\n\t\t\tnode: func() (node *Node) {\n\t\t\t\treturn\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"broken\",\n\t\t\tnode: func() (node *Node) {\n\t\t\t\tnode = Must(Unmarshal([]byte(`{}`)))\n\t\t\t\tnode.borders[1] = 0\n\t\t\t\treturn\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Numeric\",\n\t\t\tnode: func() (node *Node) {\n\t\t\t\treturn valueNode(nil, \"\", Number, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\tnode: func() (node *Node) {\n\t\t\t\treturn valueNode(nil, \"\", String, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Bool\",\n\t\t\tnode: func() (node *Node) {\n\t\t\t\treturn valueNode(nil, \"\", Boolean, 1)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Array_1\",\n\t\t\tnode: func() (node *Node) {\n\t\t\t\tnode = ArrayNode(\"\", nil)\n\t\t\t\tnode.next[\"1\"] = NullNode(\"1\")\n\t\t\t\treturn\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Array_2\",\n\t\t\tnode: func() (node *Node) {\n\t\t\t\treturn ArrayNode(\"\", []*Node{valueNode(nil, \"\", Boolean, 1)})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tnode: func() (node *Node) {\n\t\t\t\treturn ObjectNode(\"\", map[string]*Node{\"key\": valueNode(nil, \"key\", Boolean, 1)})\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvalue, err := Marshal(test.node())\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error\")\n\t\t\t} else if len(value) != 0 {\n\t\t\t\tt.Errorf(\"wrong result\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMarshal_Nil(t *testing.T) {\n\t_, err := Marshal(nil)\n\tif err == nil {\n\t\tt.Error(\"Expected error for nil node, but got nil\")\n\t}\n}\n\nfunc TestMarshal_NotModified(t *testing.T) {\n\tnode := \u0026Node{}\n\t_, err := Marshal(node)\n\tif err == nil {\n\t\tt.Error(\"Expected error for not modified node, but got nil\")\n\t}\n}\n\nfunc TestMarshalCycleReference(t *testing.T) {\n\tnode1 := \u0026Node{\n\t\tkey:      stringPtr(\"node1\"),\n\t\tnodeType: String,\n\t\tnext: map[string]*Node{\n\t\t\t\"next\": nil,\n\t\t},\n\t}\n\n\tnode2 := \u0026Node{\n\t\tkey:      stringPtr(\"node2\"),\n\t\tnodeType: String,\n\t\tprev:     node1,\n\t}\n\n\tnode1.next[\"next\"] = node2\n\n\t_, err := Marshal(node1)\n\tif err == nil {\n\t\tt.Error(\"Expected error for cycle reference, but got nil\")\n\t}\n}\n\nfunc TestMarshalNoCycleReference(t *testing.T) {\n\tnode1 := \u0026Node{\n\t\tkey:      stringPtr(\"node1\"),\n\t\tnodeType: String,\n\t\tvalue:    \"value1\",\n\t\tmodified: true,\n\t}\n\n\tnode2 := \u0026Node{\n\t\tkey:      stringPtr(\"node2\"),\n\t\tnodeType: String,\n\t\tvalue:    \"value2\",\n\t\tmodified: true,\n\t}\n\n\t_, err := Marshal(node1)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n\n\t_, err = Marshal(node2)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n}\n\nfunc stringPtr(s string) *string {\n\treturn \u0026s\n}\n"},{"Name":"node.gno","Body":"package json\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// Node represents a JSON node.\ntype Node struct {\n\tprev     *Node            // prev is the parent node of the current node.\n\tnext     map[string]*Node // next is the child nodes of the current node.\n\tkey      *string          // key holds the key of the current node in the parent node.\n\tdata     []byte           // byte slice of JSON data\n\tvalue    interface{}      // value holds the value of the current node.\n\tnodeType ValueType        // NodeType holds the type of the current node. (Object, Array, String, Number, Boolean, Null)\n\tindex    *int             // index holds the index of the current node in the parent array node.\n\tborders  [2]int           // borders stores the start and end index of the current node in the data.\n\tmodified bool             // modified indicates the current node is changed or not.\n}\n\n// NewNode creates a new node instance with the given parent node, buffer, type, and key.\nfunc NewNode(prev *Node, b *buffer, typ ValueType, key **string) (*Node, error) {\n\tcurr := \u0026Node{\n\t\tprev:     prev,\n\t\tdata:     b.data,\n\t\tborders:  [2]int{b.index, 0},\n\t\tkey:      *key,\n\t\tnodeType: typ,\n\t\tmodified: false,\n\t}\n\n\tif typ == Object || typ == Array {\n\t\tcurr.next = make(map[string]*Node)\n\t}\n\n\tif prev != nil {\n\t\tif prev.IsArray() {\n\t\t\tsize := len(prev.next)\n\t\t\tcurr.index = \u0026size\n\n\t\t\tprev.next[strconv.Itoa(size)] = curr\n\t\t} else if prev.IsObject() {\n\t\t\tif key == nil {\n\t\t\t\treturn nil, errors.New(\"key is required for object\")\n\t\t\t}\n\n\t\t\tprev.next[**key] = curr\n\t\t} else {\n\t\t\treturn nil, errors.New(\"invalid parent type\")\n\t\t}\n\t}\n\n\treturn curr, nil\n}\n\n// load retrieves the value of the current node.\nfunc (n *Node) load() interface{} {\n\treturn n.value\n}\n\n// Changed checks the current node is changed or not.\nfunc (n *Node) Changed() bool {\n\treturn n.modified\n}\n\n// Key returns the key of the current node.\nfunc (n *Node) Key() string {\n\tif n == nil || n.key == nil {\n\t\treturn \"\"\n\t}\n\n\treturn *n.key\n}\n\n// HasKey checks the current node has the given key or not.\nfunc (n *Node) HasKey(key string) bool {\n\tif n == nil {\n\t\treturn false\n\t}\n\n\t_, ok := n.next[key]\n\treturn ok\n}\n\n// GetKey returns the value of the given key from the current object node.\nfunc (n *Node) GetKey(key string) (*Node, error) {\n\tif n == nil {\n\t\treturn nil, errors.New(\"node is nil\")\n\t}\n\n\tif n.Type() != Object {\n\t\treturn nil, ufmt.Errorf(\"target node is not object type. got: %s\", n.Type().String())\n\t}\n\n\tvalue, ok := n.next[key]\n\tif !ok {\n\t\treturn nil, ufmt.Errorf(\"key not found: %s\", key)\n\t}\n\n\treturn value, nil\n}\n\n// MustKey returns the value of the given key from the current object node.\nfunc (n *Node) MustKey(key string) *Node {\n\tval, err := n.GetKey(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn val\n}\n\n// UniqueKeyLists traverses the current JSON nodes and collects all the unique keys.\nfunc (n *Node) UniqueKeyLists() []string {\n\tvar collectKeys func(*Node) []string\n\tcollectKeys = func(node *Node) []string {\n\t\tif node == nil || !node.IsObject() {\n\t\t\treturn nil\n\t\t}\n\n\t\tresult := make(map[string]bool)\n\t\tfor key, childNode := range node.next {\n\t\t\tresult[key] = true\n\t\t\tchildKeys := collectKeys(childNode)\n\t\t\tfor _, childKey := range childKeys {\n\t\t\t\tresult[childKey] = true\n\t\t\t}\n\t\t}\n\n\t\tkeys := make([]string, 0, len(result))\n\t\tfor key := range result {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t\treturn keys\n\t}\n\n\treturn collectKeys(n)\n}\n\n// Empty returns true if the current node is empty.\nfunc (n *Node) Empty() bool {\n\tif n == nil {\n\t\treturn false\n\t}\n\n\treturn len(n.next) == 0\n}\n\n// Type returns the type (ValueType) of the current node.\nfunc (n *Node) Type() ValueType {\n\treturn n.nodeType\n}\n\n// Value returns the value of the current node.\n//\n// Usage:\n//\n//\troot := Unmarshal([]byte(`{\"key\": \"value\"}`))\n//\tval, err := root.MustKey(\"key\").Value()\n//\tif err != nil {\n//\t\tt.Errorf(\"Value returns error: %v\", err)\n//\t}\n//\n//\tresult: \"value\"\nfunc (n *Node) Value() (value interface{}, err error) {\n\tvalue = n.load()\n\n\tif value == nil {\n\t\tswitch n.nodeType {\n\t\tcase Null:\n\t\t\treturn nil, nil\n\n\t\tcase Number:\n\t\t\tvalue, err = ParseFloatLiteral(n.source())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tn.value = value\n\n\t\tcase String:\n\t\t\tvar ok bool\n\t\t\tvalue, ok = Unquote(n.source(), doubleQuote)\n\t\t\tif !ok {\n\t\t\t\treturn \"\", errors.New(\"invalid string value\")\n\t\t\t}\n\n\t\t\tn.value = value\n\n\t\tcase Boolean:\n\t\t\tif len(n.source()) == 0 {\n\t\t\t\treturn nil, errors.New(\"empty boolean value\")\n\t\t\t}\n\n\t\t\tb := n.source()[0]\n\t\t\tvalue = b == 't' || b == 'T'\n\t\t\tn.value = value\n\n\t\tcase Array:\n\t\t\telems := make([]*Node, len(n.next))\n\n\t\t\tfor _, e := range n.next {\n\t\t\t\telems[*e.index] = e\n\t\t\t}\n\n\t\t\tvalue = elems\n\t\t\tn.value = value\n\n\t\tcase Object:\n\t\t\tobj := make(map[string]*Node, len(n.next))\n\n\t\t\tfor k, v := range n.next {\n\t\t\t\tobj[k] = v\n\t\t\t}\n\n\t\t\tvalue = obj\n\t\t\tn.value = value\n\t\t}\n\t}\n\n\treturn value, nil\n}\n\n// Delete removes the current node from the parent node.\n//\n// Usage:\n//\n//\troot := Unmarshal([]byte(`{\"key\": \"value\"}`))\n//\tif err := root.MustKey(\"key\").Delete(); err != nil {\n//\t\tt.Errorf(\"Delete returns error: %v\", err)\n//\t}\n//\n//\tresult: {} (empty object)\nfunc (n *Node) Delete() error {\n\tif n == nil {\n\t\treturn errors.New(\"can't delete nil node\")\n\t}\n\n\tif n.prev == nil {\n\t\treturn nil\n\t}\n\n\treturn n.prev.remove(n)\n}\n\n// Size returns the size (length) of the current array node.\n//\n// Usage:\n//\n//\troot := ArrayNode(\"\", []*Node{StringNode(\"\", \"foo\"), NumberNode(\"\", 1)})\n//\tif root == nil {\n//\t\tt.Errorf(\"ArrayNode returns nil\")\n//\t}\n//\n//\tif root.Size() != 2 {\n//\t\tt.Errorf(\"ArrayNode returns wrong size: %d\", root.Size())\n//\t}\nfunc (n *Node) Size() int {\n\tif n == nil {\n\t\treturn 0\n\t}\n\n\treturn len(n.next)\n}\n\n// Index returns the index of the current node in the parent array node.\n//\n// Usage:\n//\n//\troot := ArrayNode(\"\", []*Node{StringNode(\"\", \"foo\"), NumberNode(\"\", 1)})\n//\tif root == nil {\n//\t\tt.Errorf(\"ArrayNode returns nil\")\n//\t}\n//\n//\tif root.MustIndex(1).Index() != 1 {\n//\t\tt.Errorf(\"Index returns wrong index: %d\", root.MustIndex(1).Index())\n//\t}\n//\n// We can also use the index to the byte slice of the JSON data directly.\n//\n// Example:\n//\n//\troot := Unmarshal([]byte(`[\"foo\", 1]`))\n//\tif root == nil {\n//\t\tt.Errorf(\"Unmarshal returns nil\")\n//\t}\n//\n//\tif string(root.MustIndex(1).source()) != \"1\" {\n//\t\tt.Errorf(\"source returns wrong result: %s\", root.MustIndex(1).source())\n//\t}\nfunc (n *Node) Index() int {\n\tif n == nil || n.index == nil {\n\t\treturn -1\n\t}\n\n\treturn *n.index\n}\n\n// MustIndex returns the array element at the given index.\n//\n// If the index is negative, it returns the index is from the end of the array.\n// Also, it panics if the index is not found.\n//\n// check the Index method for detailed usage.\nfunc (n *Node) MustIndex(expectIdx int) *Node {\n\tval, err := n.GetIndex(expectIdx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn val\n}\n\n// GetIndex returns the array element at the given index.\n//\n// if the index is negative, it returns the index is from the end of the array.\nfunc (n *Node) GetIndex(idx int) (*Node, error) {\n\tif n == nil {\n\t\treturn nil, errors.New(\"node is nil\")\n\t}\n\n\tif !n.IsArray() {\n\t\treturn nil, errors.New(\"node is not array\")\n\t}\n\n\tif idx \u003e n.Size() {\n\t\treturn nil, errors.New(\"input index exceeds the array size\")\n\t}\n\n\tif idx \u003c 0 {\n\t\tidx += len(n.next)\n\t}\n\n\tchild, ok := n.next[strconv.Itoa(idx)]\n\tif !ok {\n\t\treturn nil, errors.New(\"index not found\")\n\t}\n\n\treturn child, nil\n}\n\n// DeleteIndex removes the array element at the given index.\nfunc (n *Node) DeleteIndex(idx int) error {\n\tnode, err := n.GetIndex(idx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn n.remove(node)\n}\n\n// NullNode creates a new null type node.\n//\n// Usage:\n//\n//\t_ := NullNode(\"\")\nfunc NullNode(key string) *Node {\n\treturn \u0026Node{\n\t\tkey:      \u0026key,\n\t\tvalue:    nil,\n\t\tnodeType: Null,\n\t\tmodified: true,\n\t}\n}\n\n// NumberNode creates a new number type node.\n//\n// Usage:\n//\n//\troot := NumberNode(\"\", 1)\n//\tif root == nil {\n//\t\tt.Errorf(\"NumberNode returns nil\")\n//\t}\nfunc NumberNode(key string, value float64) *Node {\n\treturn \u0026Node{\n\t\tkey:      \u0026key,\n\t\tvalue:    value,\n\t\tnodeType: Number,\n\t\tmodified: true,\n\t}\n}\n\n// StringNode creates a new string type node.\n//\n// Usage:\n//\n//\troot := StringNode(\"\", \"foo\")\n//\tif root == nil {\n//\t\tt.Errorf(\"StringNode returns nil\")\n//\t}\nfunc StringNode(key string, value string) *Node {\n\treturn \u0026Node{\n\t\tkey:      \u0026key,\n\t\tvalue:    value,\n\t\tnodeType: String,\n\t\tmodified: true,\n\t}\n}\n\n// BoolNode creates a new given boolean value node.\n//\n// Usage:\n//\n//\troot := BoolNode(\"\", true)\n//\tif root == nil {\n//\t\tt.Errorf(\"BoolNode returns nil\")\n//\t}\nfunc BoolNode(key string, value bool) *Node {\n\treturn \u0026Node{\n\t\tkey:      \u0026key,\n\t\tvalue:    value,\n\t\tnodeType: Boolean,\n\t\tmodified: true,\n\t}\n}\n\n// ArrayNode creates a new array type node.\n//\n// If the given value is nil, it creates an empty array node.\n//\n// Usage:\n//\n//\troot := ArrayNode(\"\", []*Node{StringNode(\"\", \"foo\"), NumberNode(\"\", 1)})\n//\tif root == nil {\n//\t\tt.Errorf(\"ArrayNode returns nil\")\n//\t}\nfunc ArrayNode(key string, value []*Node) *Node {\n\tcurr := \u0026Node{\n\t\tkey:      \u0026key,\n\t\tnodeType: Array,\n\t\tmodified: true,\n\t}\n\n\tcurr.next = make(map[string]*Node, len(value))\n\tif value != nil {\n\t\tcurr.value = value\n\n\t\tfor i, v := range value {\n\t\t\tidx := i\n\t\t\tcurr.next[strconv.Itoa(i)] = v\n\n\t\t\tv.prev = curr\n\t\t\tv.index = \u0026idx\n\t\t}\n\t}\n\n\treturn curr\n}\n\n// ObjectNode creates a new object type node.\n//\n// If the given value is nil, it creates an empty object node.\n//\n// next is a map of key and value pairs of the object.\nfunc ObjectNode(key string, value map[string]*Node) *Node {\n\tcurr := \u0026Node{\n\t\tnodeType: Object,\n\t\tkey:      \u0026key,\n\t\tnext:     value,\n\t\tmodified: true,\n\t}\n\n\tif value != nil {\n\t\tcurr.value = value\n\n\t\tfor key, val := range value {\n\t\t\tvkey := key\n\t\t\tval.prev = curr\n\t\t\tval.key = \u0026vkey\n\t\t}\n\t} else {\n\t\tcurr.next = make(map[string]*Node)\n\t}\n\n\treturn curr\n}\n\n// IsArray returns true if the current node is array type.\nfunc (n *Node) IsArray() bool {\n\treturn n.nodeType == Array\n}\n\n// IsObject returns true if the current node is object type.\nfunc (n *Node) IsObject() bool {\n\treturn n.nodeType == Object\n}\n\n// IsNull returns true if the current node is null type.\nfunc (n *Node) IsNull() bool {\n\treturn n.nodeType == Null\n}\n\n// IsBool returns true if the current node is boolean type.\nfunc (n *Node) IsBool() bool {\n\treturn n.nodeType == Boolean\n}\n\n// IsString returns true if the current node is string type.\nfunc (n *Node) IsString() bool {\n\treturn n.nodeType == String\n}\n\n// IsNumber returns true if the current node is number type.\nfunc (n *Node) IsNumber() bool {\n\treturn n.nodeType == Number\n}\n\n// ready checks the current node is ready or not.\n//\n// the meaning of ready is the current node is parsed and has a valid value.\nfunc (n *Node) ready() bool {\n\treturn n.borders[1] != 0\n}\n\n// source returns the source of the current node.\nfunc (n *Node) source() []byte {\n\tif n == nil {\n\t\treturn nil\n\t}\n\n\tif n.ready() \u0026\u0026 !n.modified \u0026\u0026 n.data != nil {\n\t\treturn (n.data)[n.borders[0]:n.borders[1]]\n\t}\n\n\treturn nil\n}\n\n// root returns the root node of the current node.\nfunc (n *Node) root() *Node {\n\tif n == nil {\n\t\treturn nil\n\t}\n\n\tcurr := n\n\tfor curr.prev != nil {\n\t\tcurr = curr.prev\n\t}\n\n\treturn curr\n}\n\n// GetNull returns the null value if current node is null type.\n//\n// Usage:\n//\n//\troot := Unmarshal([]byte(\"null\"))\n//\tval, err := root.GetNull()\n//\tif err != nil {\n//\t\tt.Errorf(\"GetNull returns error: %v\", err)\n//\t}\n//\tif val != nil {\n//\t\tt.Errorf(\"GetNull returns wrong result: %v\", val)\n//\t}\nfunc (n *Node) GetNull() (interface{}, error) {\n\tif n == nil {\n\t\treturn nil, errors.New(\"node is nil\")\n\t}\n\n\tif !n.IsNull() {\n\t\treturn nil, errors.New(\"node is not null\")\n\t}\n\n\treturn nil, nil\n}\n\n// MustNull returns the null value if current node is null type.\n//\n// It panics if the current node is not null type.\nfunc (n *Node) MustNull() interface{} {\n\tv, err := n.GetNull()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn v\n}\n\n// GetNumeric returns the numeric (int/float) value if current node is number type.\n//\n// Usage:\n//\n//\troot := Unmarshal([]byte(\"10.5\"))\n//\tval, err := root.GetNumeric()\n//\tif err != nil {\n//\t\tt.Errorf(\"GetNumeric returns error: %v\", err)\n//\t}\n//\tprintln(val) // 10.5\nfunc (n *Node) GetNumeric() (float64, error) {\n\tif n == nil {\n\t\treturn 0, errors.New(\"node is nil\")\n\t}\n\n\tif n.nodeType != Number {\n\t\treturn 0, errors.New(\"node is not number\")\n\t}\n\n\tval, err := n.Value()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tv, ok := val.(float64)\n\tif !ok {\n\t\treturn 0, errors.New(\"node is not number\")\n\t}\n\n\treturn v, nil\n}\n\n// MustNumeric returns the numeric (int/float) value if current node is number type.\n//\n// It panics if the current node is not number type.\nfunc (n *Node) MustNumeric() float64 {\n\tv, err := n.GetNumeric()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn v\n}\n\n// GetString returns the string value if current node is string type.\n//\n// Usage:\n//\n//\troot, err := Unmarshal([]byte(\"foo\"))\n//\tif err != nil {\n//\t\tt.Errorf(\"Error on Unmarshal(): %s\", err)\n//\t}\n//\n//\tstr, err := root.GetString()\n//\tif err != nil {\n//\t\tt.Errorf(\"should retrieve string value: %s\", err)\n//\t}\n//\n//\tprintln(str) // \"foo\"\nfunc (n *Node) GetString() (string, error) {\n\tif n == nil {\n\t\treturn \"\", errors.New(\"string node is empty\")\n\t}\n\n\tif !n.IsString() {\n\t\treturn \"\", errors.New(\"node type is not string\")\n\t}\n\n\tval, err := n.Value()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tv, ok := val.(string)\n\tif !ok {\n\t\treturn \"\", errors.New(\"node is not string\")\n\t}\n\n\treturn v, nil\n}\n\n// MustString returns the string value if current node is string type.\n//\n// It panics if the current node is not string type.\nfunc (n *Node) MustString() string {\n\tv, err := n.GetString()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn v\n}\n\n// GetBool returns the boolean value if current node is boolean type.\n//\n// Usage:\n//\n//\troot := Unmarshal([]byte(\"true\"))\n//\tval, err := root.GetBool()\n//\tif err != nil {\n//\t\tt.Errorf(\"GetBool returns error: %v\", err)\n//\t}\n//\tprintln(val) // true\nfunc (n *Node) GetBool() (bool, error) {\n\tif n == nil {\n\t\treturn false, errors.New(\"node is nil\")\n\t}\n\n\tif n.nodeType != Boolean {\n\t\treturn false, errors.New(\"node is not boolean\")\n\t}\n\n\tval, err := n.Value()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tv, ok := val.(bool)\n\tif !ok {\n\t\treturn false, errors.New(\"node is not boolean\")\n\t}\n\n\treturn v, nil\n}\n\n// MustBool returns the boolean value if current node is boolean type.\n//\n// It panics if the current node is not boolean type.\nfunc (n *Node) MustBool() bool {\n\tv, err := n.GetBool()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn v\n}\n\n// GetArray returns the array value if current node is array type.\n//\n// Usage:\n//\n//\t\troot := Must(Unmarshal([]byte(`[\"foo\", 1]`)))\n//\t\tarr, err := root.GetArray()\n//\t\tif err != nil {\n//\t\t\tt.Errorf(\"GetArray returns error: %v\", err)\n//\t\t}\n//\n//\t\tfor _, val := range arr {\n//\t\t\tprintln(val)\n//\t\t}\n//\n//\t result: \"foo\", 1\nfunc (n *Node) GetArray() ([]*Node, error) {\n\tif n == nil {\n\t\treturn nil, errors.New(\"node is nil\")\n\t}\n\n\tif n.nodeType != Array {\n\t\treturn nil, errors.New(\"node is not array\")\n\t}\n\n\tval, err := n.Value()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv, ok := val.([]*Node)\n\tif !ok {\n\t\treturn nil, errors.New(\"node is not array\")\n\t}\n\n\treturn v, nil\n}\n\n// MustArray returns the array value if current node is array type.\n//\n// It panics if the current node is not array type.\nfunc (n *Node) MustArray() []*Node {\n\tv, err := n.GetArray()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn v\n}\n\n// AppendArray appends the given values to the current array node.\n//\n// If the current node is not array type, it returns an error.\n//\n// Example 1:\n//\n//\troot := Must(Unmarshal([]byte(`[{\"foo\":\"bar\"}]`)))\n//\tif err := root.AppendArray(NullNode(\"\")); err != nil {\n//\t\tt.Errorf(\"should not return error: %s\", err)\n//\t}\n//\n//\tresult: [{\"foo\":\"bar\"}, null]\n//\n// Example 2:\n//\n//\troot := Must(Unmarshal([]byte(`[\"bar\", \"baz\"]`)))\n//\terr := root.AppendArray(NumberNode(\"\", 1), StringNode(\"\", \"foo\"))\n//\tif err != nil {\n//\t\tt.Errorf(\"AppendArray returns error: %v\", err)\n//\t }\n//\n//\tresult: [\"bar\", \"baz\", 1, \"foo\"]\nfunc (n *Node) AppendArray(value ...*Node) error {\n\tif !n.IsArray() {\n\t\treturn errors.New(\"can't append value to non-array node\")\n\t}\n\n\tfor _, val := range value {\n\t\tif err := n.append(nil, val); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tn.mark()\n\treturn nil\n}\n\n// ArrayEach executes the callback for each element in the JSON array.\n//\n// Usage:\n//\n//\tjsonArrayNode.ArrayEach(func(i int, valueNode *Node) {\n//\t    ufmt.Println(i, valueNode)\n//\t})\nfunc (n *Node) ArrayEach(callback func(i int, target *Node)) {\n\tif n == nil || !n.IsArray() {\n\t\treturn\n\t}\n\n\tfor idx := 0; idx \u003c len(n.next); idx++ {\n\t\telement, err := n.GetIndex(idx)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tcallback(idx, element)\n\t}\n}\n\n// GetObject returns the object value if current node is object type.\n//\n// Usage:\n//\n//\troot := Must(Unmarshal([]byte(`{\"key\": \"value\"}`)))\n//\tobj, err := root.GetObject()\n//\tif err != nil {\n//\t\tt.Errorf(\"GetObject returns error: %v\", err)\n//\t}\n//\n//\tresult: map[string]*Node{\"key\": StringNode(\"key\", \"value\")}\nfunc (n *Node) GetObject() (map[string]*Node, error) {\n\tif n == nil {\n\t\treturn nil, errors.New(\"node is nil\")\n\t}\n\n\tif !n.IsObject() {\n\t\treturn nil, errors.New(\"node is not object\")\n\t}\n\n\tval, err := n.Value()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv, ok := val.(map[string]*Node)\n\tif !ok {\n\t\treturn nil, errors.New(\"node is not object\")\n\t}\n\n\treturn v, nil\n}\n\n// MustObject returns the object value if current node is object type.\n//\n// It panics if the current node is not object type.\nfunc (n *Node) MustObject() map[string]*Node {\n\tv, err := n.GetObject()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn v\n}\n\n// AppendObject appends the given key and value to the current object node.\n//\n// If the current node is not object type, it returns an error.\nfunc (n *Node) AppendObject(key string, value *Node) error {\n\tif !n.IsObject() {\n\t\treturn errors.New(\"can't append value to non-object node\")\n\t}\n\n\tif err := n.append(\u0026key, value); err != nil {\n\t\treturn err\n\t}\n\n\tn.mark()\n\treturn nil\n}\n\n// ObjectEach executes the callback for each key-value pair in the JSON object.\n//\n// Usage:\n//\n//\tjsonObjectNode.ObjectEach(func(key string, valueNode *Node) {\n//\t    ufmt.Println(key, valueNode)\n//\t})\nfunc (n *Node) ObjectEach(callback func(key string, value *Node)) {\n\tif n == nil || !n.IsObject() {\n\t\treturn\n\t}\n\n\tfor key, child := range n.next {\n\t\tcallback(key, child)\n\t}\n}\n\n// String converts the node to a string representation.\nfunc (n *Node) String() string {\n\tif n == nil {\n\t\treturn \"\"\n\t}\n\n\tif n.ready() \u0026\u0026 !n.modified {\n\t\treturn string(n.source())\n\t}\n\n\tval, err := Marshal(n)\n\tif err != nil {\n\t\treturn \"error: \" + err.Error()\n\t}\n\n\treturn string(val)\n}\n\n// Path builds the path of the current node.\n//\n// For example:\n//\n//\t{ \"key\": { \"sub\": [ \"val1\", \"val2\" ] }}\n//\n// The path of \"val2\" is: $.key.sub[1]\nfunc (n *Node) Path() string {\n\tif n == nil {\n\t\treturn \"\"\n\t}\n\n\tvar sb strings.Builder\n\n\tif n.prev == nil {\n\t\tsb.WriteString(\"$\")\n\t} else {\n\t\tsb.WriteString(n.prev.Path())\n\n\t\tif n.key != nil {\n\t\t\tsb.WriteString(\"['\" + n.Key() + \"']\")\n\t\t} else {\n\t\t\tsb.WriteString(\"[\" + strconv.Itoa(n.Index()) + \"]\")\n\t\t}\n\t}\n\n\treturn sb.String()\n}\n\n// mark marks the current node as modified.\nfunc (n *Node) mark() {\n\tnode := n\n\tfor node != nil \u0026\u0026 !node.modified {\n\t\tnode.modified = true\n\t\tnode = node.prev\n\t}\n}\n\n// isContainer checks the current node type is array or object.\nfunc (n *Node) isContainer() bool {\n\treturn n.IsArray() || n.IsObject()\n}\n\n// remove removes the value from the current container type node.\nfunc (n *Node) remove(v *Node) error {\n\tif !n.isContainer() {\n\t\treturn ufmt.Errorf(\n\t\t\t\"can't remove value from non-array or non-object node. got=%s\",\n\t\t\tn.Type().String(),\n\t\t)\n\t}\n\n\tif v.prev != n {\n\t\treturn errors.New(\"invalid parent node\")\n\t}\n\n\tn.mark()\n\tif n.IsArray() {\n\t\tdelete(n.next, strconv.Itoa(*v.index))\n\t\tn.dropIndex(*v.index)\n\t} else {\n\t\tdelete(n.next, *v.key)\n\t}\n\n\tv.prev = nil\n\treturn nil\n}\n\n// dropIndex rebase the index of current array node values.\nfunc (n *Node) dropIndex(idx int) {\n\tfor i := idx + 1; i \u003c= len(n.next); i++ {\n\t\tprv := i - 1\n\t\tif curr, ok := n.next[strconv.Itoa(i)]; ok {\n\t\t\tcurr.index = \u0026prv\n\t\t\tn.next[strconv.Itoa(prv)] = curr\n\t\t}\n\n\t\tdelete(n.next, strconv.Itoa(i))\n\t}\n}\n\n// append is a helper function to append the given value to the current container type node.\nfunc (n *Node) append(key *string, val *Node) error {\n\tif n.isSameOrParentNode(val) {\n\t\treturn errors.New(\"can't append same or parent node\")\n\t}\n\n\tif val.prev != nil {\n\t\tif err := val.prev.remove(val); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tval.prev = n\n\tval.key = key\n\n\tif key == nil {\n\t\tsize := len(n.next)\n\t\tval.index = \u0026size\n\t\tn.next[strconv.Itoa(size)] = val\n\t} else {\n\t\tif old, ok := n.next[*key]; ok {\n\t\t\tif err := n.remove(old); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tn.next[*key] = val\n\t}\n\n\treturn nil\n}\n\nfunc (n *Node) isSameOrParentNode(nd *Node) bool {\n\treturn n == nd || n.isParentNode(nd)\n}\n\nfunc (n *Node) isParentNode(nd *Node) bool {\n\tif n == nil {\n\t\treturn false\n\t}\n\n\tfor curr := nd.prev; curr != nil; curr = curr.prev {\n\t\tif curr == n {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// cptrs returns the pointer of the given string value.\nfunc cptrs(cpy *string) *string {\n\tif cpy == nil {\n\t\treturn nil\n\t}\n\n\tval := *cpy\n\n\treturn \u0026val\n}\n\n// cptri returns the pointer of the given integer value.\nfunc cptri(i *int) *int {\n\tif i == nil {\n\t\treturn nil\n\t}\n\n\tval := *i\n\treturn \u0026val\n}\n\n// Must panics if the given node is not fulfilled the expectation.\n// Usage:\n//\n//\tnode := Must(Unmarshal([]byte(`{\"key\": \"value\"}`))\nfunc Must(root *Node, expect error) *Node {\n\tif expect != nil {\n\t\tpanic(expect)\n\t}\n\n\treturn root\n}\n"},{"Name":"decode.gno","Body":"// ref: https://github.com/spyzhov/ajson/blob/master/decode.go\n\npackage json\n\nimport (\n\t\"errors\"\n\t\"io\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// This limits the max nesting depth to prevent stack overflow.\n// This is permitted by https://tools.ietf.org/html/rfc7159#section-9\nconst maxNestingDepth = 10000\n\n// Unmarshal parses the JSON-encoded data and returns a Node.\n// The data must be a valid JSON-encoded value.\n//\n// Usage:\n//\n//\tnode, err := json.Unmarshal([]byte(`{\"key\": \"value\"}`))\n//\tif err != nil {\n//\t\tufmt.Println(err)\n//\t}\n//\tprintln(node) // {\"key\": \"value\"}\nfunc Unmarshal(data []byte) (*Node, error) {\n\tbuf := newBuffer(data)\n\n\tvar (\n\t\tstate   States\n\t\tkey     *string\n\t\tcurrent *Node\n\t\tnesting int\n\t\tuseKey  = func() **string {\n\t\t\ttmp := cptrs(key)\n\t\t\tkey = nil\n\t\t\treturn \u0026tmp\n\t\t}\n\t\terr error\n\t)\n\n\tif _, err = buf.first(); err != nil {\n\t\treturn nil, io.EOF\n\t}\n\n\tfor {\n\t\tstate = buf.getState()\n\t\tif state == __ {\n\t\t\treturn nil, unexpectedTokenError(buf.data, buf.index)\n\t\t}\n\n\t\t// region state machine\n\t\tif state \u003e= GO {\n\t\t\tswitch buf.state {\n\t\t\tcase ST: // string\n\t\t\t\tif current != nil \u0026\u0026 current.IsObject() \u0026\u0026 key == nil {\n\t\t\t\t\t// key detected\n\t\t\t\t\tif key, err = getString(buf); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\tbuf.state = CO\n\t\t\t\t} else {\n\t\t\t\t\tcurrent, nesting, err = createNestedNode(current, buf, String, nesting, useKey())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\terr = buf.string(doubleQuote, false)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent, nesting = updateNode(current, buf, nesting, true)\n\t\t\t\t\tbuf.state = OK\n\t\t\t\t}\n\n\t\t\tcase MI, ZE, IN: // number\n\t\t\t\tcurrent, err = processNumericNode(current, buf, useKey())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\tcase T1, F1: // boolean\n\t\t\t\tliteral := falseLiteral\n\t\t\t\tif buf.state == T1 {\n\t\t\t\t\tliteral = trueLiteral\n\t\t\t\t}\n\n\t\t\t\tcurrent, nesting, err = processLiteralNode(current, buf, Boolean, literal, useKey(), nesting)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\tcase N1: // null\n\t\t\t\tcurrent, nesting, err = processLiteralNode(current, buf, Null, nullLiteral, useKey(), nesting)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// region action\n\t\t\tswitch state {\n\t\t\tcase ec, cc: // \u003cempty\u003e }\n\t\t\t\tif key != nil {\n\t\t\t\t\treturn nil, unexpectedTokenError(buf.data, buf.index)\n\t\t\t\t}\n\n\t\t\t\tcurrent, nesting, err = updateNodeAndSetBufferState(current, buf, nesting, Object)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\tcase bc: // ]\n\t\t\t\tcurrent, nesting, err = updateNodeAndSetBufferState(current, buf, nesting, Array)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\tcase co, bo: // { [\n\t\t\t\tvalTyp, bState := Object, OB\n\t\t\t\tif state == bo {\n\t\t\t\t\tvalTyp, bState = Array, AR\n\t\t\t\t}\n\n\t\t\t\tcurrent, nesting, err = createNestedNode(current, buf, valTyp, nesting, useKey())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tbuf.state = bState\n\n\t\t\tcase cm: // ,\n\t\t\t\tif current == nil {\n\t\t\t\t\treturn nil, unexpectedTokenError(buf.data, buf.index)\n\t\t\t\t}\n\n\t\t\t\tif !current.isContainer() {\n\t\t\t\t\treturn nil, unexpectedTokenError(buf.data, buf.index)\n\t\t\t\t}\n\n\t\t\t\tif current.IsObject() {\n\t\t\t\t\tbuf.state = KE // key expected\n\t\t\t\t} else {\n\t\t\t\t\tbuf.state = VA // value expected\n\t\t\t\t}\n\n\t\t\tcase cl: // :\n\t\t\t\tif current == nil || !current.IsObject() || key == nil {\n\t\t\t\t\treturn nil, unexpectedTokenError(buf.data, buf.index)\n\t\t\t\t}\n\n\t\t\t\tbuf.state = VA\n\n\t\t\tdefault:\n\t\t\t\treturn nil, unexpectedTokenError(buf.data, buf.index)\n\t\t\t}\n\t\t}\n\n\t\tif buf.step() != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif _, err = buf.first(); err != nil {\n\t\t\terr = nil\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif current == nil || buf.state != OK {\n\t\treturn nil, io.EOF\n\t}\n\n\troot := current.root()\n\tif !root.ready() {\n\t\treturn nil, io.EOF\n\t}\n\n\treturn root, err\n}\n\n// UnmarshalSafe parses the JSON-encoded data and returns a Node.\nfunc UnmarshalSafe(data []byte) (*Node, error) {\n\tvar safe []byte\n\tsafe = append(safe, data...)\n\treturn Unmarshal(safe)\n}\n\n// processNumericNode creates a new node, processes a numeric value,\n// sets the node's borders, and moves to the previous node.\nfunc processNumericNode(current *Node, buf *buffer, key **string) (*Node, error) {\n\tvar err error\n\tcurrent, err = createNode(current, buf, Number, key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = buf.numeric(false); err != nil {\n\t\treturn nil, err\n\t}\n\n\tcurrent.borders[1] = buf.index\n\tif current.prev != nil {\n\t\tcurrent = current.prev\n\t}\n\n\tbuf.index -= 1\n\tbuf.state = OK\n\n\treturn current, nil\n}\n\n// processLiteralNode creates a new node, processes a literal value,\n// sets the node's borders, and moves to the previous node.\nfunc processLiteralNode(\n\tcurrent *Node,\n\tbuf *buffer,\n\tliteralType ValueType,\n\tliteralValue []byte,\n\tuseKey **string,\n\tnesting int,\n) (*Node, int, error) {\n\tvar err error\n\tcurrent, nesting, err = createLiteralNode(current, buf, literalType, literalValue, useKey, nesting)\n\tif err != nil {\n\t\treturn nil, nesting, err\n\t}\n\treturn current, nesting, nil\n}\n\n// isValidContainerType checks if the current node is a valid container (object or array).\n// The container must satisfy the following conditions:\n//  1. The current node must not be nil.\n//  2. The current node must be an object or array.\n//  3. The current node must not be ready.\nfunc isValidContainerType(current *Node, nodeType ValueType) bool {\n\tswitch nodeType {\n\tcase Object:\n\t\treturn current != nil \u0026\u0026 current.IsObject() \u0026\u0026 !current.ready()\n\tcase Array:\n\t\treturn current != nil \u0026\u0026 current.IsArray() \u0026\u0026 !current.ready()\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// getString extracts a string from the buffer and advances the buffer index past the string.\nfunc getString(b *buffer) (*string, error) {\n\tstart := b.index\n\tif err := b.string(doubleQuote, false); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalue, ok := Unquote(b.data[start:b.index+1], doubleQuote)\n\tif !ok {\n\t\treturn nil, unexpectedTokenError(b.data, start)\n\t}\n\n\treturn \u0026value, nil\n}\n\n// createNode creates a new node and sets the key if it is not nil.\nfunc createNode(\n\tcurrent *Node,\n\tbuf *buffer,\n\tnodeType ValueType,\n\tkey **string,\n) (*Node, error) {\n\tvar err error\n\tcurrent, err = NewNode(current, buf, nodeType, key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn current, nil\n}\n\n// createNestedNode creates a new nested node (array or object) and sets the key if it is not nil.\nfunc createNestedNode(\n\tcurrent *Node,\n\tbuf *buffer,\n\tnodeType ValueType,\n\tnesting int,\n\tkey **string,\n) (*Node, int, error) {\n\tvar err error\n\tif nesting, err = checkNestingDepth(nesting); err != nil {\n\t\treturn nil, nesting, err\n\t}\n\n\tif current, err = createNode(current, buf, nodeType, key); err != nil {\n\t\treturn nil, nesting, err\n\t}\n\n\treturn current, nesting, nil\n}\n\n// createLiteralNode creates a new literal node and sets the key if it is not nil.\n// The literal is a byte slice that represents a boolean or null value.\nfunc createLiteralNode(\n\tcurrent *Node,\n\tbuf *buffer,\n\tliteralType ValueType,\n\tliteral []byte,\n\tuseKey **string,\n\tnesting int,\n) (*Node, int, error) {\n\tvar err error\n\tif current, err = createNode(current, buf, literalType, useKey); err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tif err = buf.word(literal); err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tcurrent, nesting = updateNode(current, buf, nesting, false)\n\tbuf.state = OK\n\n\treturn current, nesting, nil\n}\n\n// updateNode updates the current node and returns the previous node.\nfunc updateNode(\n\tcurrent *Node, buf *buffer, nesting int, decreaseLevel bool,\n) (*Node, int) {\n\tcurrent.borders[1] = buf.index + 1\n\n\tprev := current.prev\n\tif prev == nil {\n\t\treturn current, nesting\n\t}\n\n\tcurrent = prev\n\tif decreaseLevel {\n\t\tnesting--\n\t}\n\n\treturn current, nesting\n}\n\n// updateNodeAndSetBufferState updates the current node and sets the buffer state to OK.\nfunc updateNodeAndSetBufferState(\n\tcurrent *Node,\n\tbuf *buffer,\n\tnesting int,\n\ttyp ValueType,\n) (*Node, int, error) {\n\tif !isValidContainerType(current, typ) {\n\t\treturn nil, nesting, unexpectedTokenError(buf.data, buf.index)\n\t}\n\n\tcurrent, nesting = updateNode(current, buf, nesting, true)\n\tbuf.state = OK\n\n\treturn current, nesting, nil\n}\n\n// checkNestingDepth checks if the nesting depth is within the maximum allowed depth.\nfunc checkNestingDepth(nesting int) (int, error) {\n\tif nesting \u003e= maxNestingDepth {\n\t\treturn nesting, errors.New(\"maximum nesting depth exceeded\")\n\t}\n\n\treturn nesting + 1, nil\n}\n\nfunc unexpectedTokenError(data []byte, index int) error {\n\treturn ufmt.Errorf(\"unexpected token at index %d. data %b\", index, data)\n}\n"},{"Name":"path.gno","Body":"package json\n\nimport (\n\t\"errors\"\n)\n\n// ParsePath takes a JSONPath string and returns a slice of strings representing the path segments.\nfunc ParsePath(path string) ([]string, error) {\n\tbuf := newBuffer([]byte(path))\n\tresult := make([]string, 0)\n\n\tfor {\n\t\tb, err := buf.current()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch {\n\t\tcase b == dollarSign || b == atSign:\n\t\t\tresult = append(result, string(b))\n\t\t\tbuf.step()\n\n\t\tcase b == dot:\n\t\t\tbuf.step()\n\n\t\t\tif next, _ := buf.current(); next == dot {\n\t\t\t\tbuf.step()\n\t\t\t\tresult = append(result, \"..\")\n\n\t\t\t\textractNextSegment(buf, \u0026result)\n\t\t\t} else {\n\t\t\t\textractNextSegment(buf, \u0026result)\n\t\t\t}\n\n\t\tcase b == bracketOpen:\n\t\t\tstart := buf.index\n\t\t\tbuf.step()\n\n\t\t\tfor {\n\t\t\t\tif buf.index \u003e= buf.length || buf.data[buf.index] == bracketClose {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tbuf.step()\n\t\t\t}\n\n\t\t\tif buf.index \u003e= buf.length {\n\t\t\t\treturn nil, errors.New(\"unexpected end of path\")\n\t\t\t}\n\n\t\t\tsegment := string(buf.sliceFromIndices(start+1, buf.index))\n\t\t\tresult = append(result, segment)\n\n\t\t\tbuf.step()\n\n\t\tdefault:\n\t\t\tbuf.step()\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// extractNextSegment extracts the segment from the current index\n// to the next significant character and adds it to the resulting slice.\nfunc extractNextSegment(buf *buffer, result *[]string) {\n\tstart := buf.index\n\tbuf.skipToNextSignificantToken()\n\n\tif buf.index \u003c= start {\n\t\treturn\n\t}\n\n\tsegment := string(buf.sliceFromIndices(start, buf.index))\n\tif segment != \"\" {\n\t\t*result = append(*result, segment)\n\t}\n}\n"},{"Name":"internal.gno","Body":"package json\n\n// Reference: https://github.com/freddierice/php_source/blob/467ed5d6edff72219afd3e644516f131118ef48e/ext/json/JSON_parser.c\n// Copyright (c) 2005 JSON.org\n\n// Go implementation is taken from: https://github.com/spyzhov/ajson/blob/master/internal/state.go\n\ntype (\n\tStates  int8 // possible states of the parser\n\tClasses int8 // JSON string character types\n)\n\nconst __ = -1\n\n// enum classes\nconst (\n\tC_SPACE Classes = iota /* space */\n\tC_WHITE                /* other whitespace */\n\tC_LCURB                /* {  */\n\tC_RCURB                /* } */\n\tC_LSQRB                /* [ */\n\tC_RSQRB                /* ] */\n\tC_COLON                /* : */\n\tC_COMMA                /* , */\n\tC_QUOTE                /* \" */\n\tC_BACKS                /* \\ */\n\tC_SLASH                /* / */\n\tC_PLUS                 /* + */\n\tC_MINUS                /* - */\n\tC_POINT                /* . */\n\tC_ZERO                 /* 0 */\n\tC_DIGIT                /* 123456789 */\n\tC_LOW_A                /* a */\n\tC_LOW_B                /* b */\n\tC_LOW_C                /* c */\n\tC_LOW_D                /* d */\n\tC_LOW_E                /* e */\n\tC_LOW_F                /* f */\n\tC_LOW_L                /* l */\n\tC_LOW_N                /* n */\n\tC_LOW_R                /* r */\n\tC_LOW_S                /* s */\n\tC_LOW_T                /* t */\n\tC_LOW_U                /* u */\n\tC_ABCDF                /* ABCDF */\n\tC_E                    /* E */\n\tC_ETC                  /* everything else */\n)\n\n// AsciiClasses array maps the 128 ASCII characters into character classes.\nvar AsciiClasses = [128]Classes{\n\t/*\n\t   This array maps the 128 ASCII characters into character classes.\n\t   The remaining Unicode characters should be mapped to C_ETC.\n\t   Non-whitespace control characters are errors.\n\t*/\n\t__, __, __, __, __, __, __, __,\n\t__, C_WHITE, C_WHITE, __, __, C_WHITE, __, __,\n\t__, __, __, __, __, __, __, __,\n\t__, __, __, __, __, __, __, __,\n\n\tC_SPACE, C_ETC, C_QUOTE, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_PLUS, C_COMMA, C_MINUS, C_POINT, C_SLASH,\n\tC_ZERO, C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT,\n\tC_DIGIT, C_DIGIT, C_COLON, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC,\n\n\tC_ETC, C_ABCDF, C_ABCDF, C_ABCDF, C_ABCDF, C_E, C_ABCDF, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_LSQRB, C_BACKS, C_RSQRB, C_ETC, C_ETC,\n\n\tC_ETC, C_LOW_A, C_LOW_B, C_LOW_C, C_LOW_D, C_LOW_E, C_LOW_F, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_ETC, C_LOW_L, C_ETC, C_LOW_N, C_ETC,\n\tC_ETC, C_ETC, C_LOW_R, C_LOW_S, C_LOW_T, C_LOW_U, C_ETC, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_LCURB, C_ETC, C_RCURB, C_ETC, C_ETC,\n}\n\n// QuoteAsciiClasses is a HACK for single quote from AsciiClasses\nvar QuoteAsciiClasses = [128]Classes{\n\t/*\n\t   This array maps the 128 ASCII characters into character classes.\n\t   The remaining Unicode characters should be mapped to C_ETC.\n\t   Non-whitespace control characters are errors.\n\t*/\n\t__, __, __, __, __, __, __, __,\n\t__, C_WHITE, C_WHITE, __, __, C_WHITE, __, __,\n\t__, __, __, __, __, __, __, __,\n\t__, __, __, __, __, __, __, __,\n\n\tC_SPACE, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_QUOTE,\n\tC_ETC, C_ETC, C_ETC, C_PLUS, C_COMMA, C_MINUS, C_POINT, C_SLASH,\n\tC_ZERO, C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT,\n\tC_DIGIT, C_DIGIT, C_COLON, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC,\n\n\tC_ETC, C_ABCDF, C_ABCDF, C_ABCDF, C_ABCDF, C_E, C_ABCDF, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_LSQRB, C_BACKS, C_RSQRB, C_ETC, C_ETC,\n\n\tC_ETC, C_LOW_A, C_LOW_B, C_LOW_C, C_LOW_D, C_LOW_E, C_LOW_F, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_ETC, C_LOW_L, C_ETC, C_LOW_N, C_ETC,\n\tC_ETC, C_ETC, C_LOW_R, C_LOW_S, C_LOW_T, C_LOW_U, C_ETC, C_ETC,\n\tC_ETC, C_ETC, C_ETC, C_LCURB, C_ETC, C_RCURB, C_ETC, C_ETC,\n}\n\n/*\nThe state codes.\n*/\nconst (\n\tGO States = iota /* start    */\n\tOK               /* ok       */\n\tOB               /* object   */\n\tKE               /* key      */\n\tCO               /* colon    */\n\tVA               /* value    */\n\tAR               /* array    */\n\tST               /* string   */\n\tES               /* escape   */\n\tU1               /* u1       */\n\tU2               /* u2       */\n\tU3               /* u3       */\n\tU4               /* u4       */\n\tMI               /* minus    */\n\tZE               /* zero     */\n\tIN               /* integer  */\n\tDT               /* dot      */\n\tFR               /* fraction */\n\tE1               /* e        */\n\tE2               /* ex       */\n\tE3               /* exp      */\n\tT1               /* tr       */\n\tT2               /* tru      */\n\tT3               /* true     */\n\tF1               /* fa       */\n\tF2               /* fal      */\n\tF3               /* fals     */\n\tF4               /* false    */\n\tN1               /* nu       */\n\tN2               /* nul      */\n\tN3               /* null     */\n)\n\n// List of action codes.\n// these constants are defining an action that should be performed under certain conditions.\nconst (\n\tcl States = -2 /* colon           */\n\tcm States = -3 /* comma           */\n\tqt States = -4 /* quote           */\n\tbo States = -5 /* bracket open    */\n\tco States = -6 /* curly bracket open  */\n\tbc States = -7 /* bracket close   */\n\tcc States = -8 /* curly bracket close */\n\tec States = -9 /* curly bracket empty */\n)\n\n// StateTransitionTable is the state transition table takes the current state and the current symbol, and returns either\n// a new state or an action. An action is represented as a negative number. A JSON text is accepted if at the end of the\n// text the state is OK and if the mode is DONE.\nvar StateTransitionTable = [31][31]States{\n\t/*\n\t   The state transition table takes the current state and the current symbol,\n\t   and returns either a new state or an action. An action is represented as a\n\t   negative number. A JSON text is accepted if at the end of the text the\n\t   state is OK and if the mode is DONE.\n\t                  white                                                    1-9                                                ABCDF   etc\n\t            space   |   {   }   [   ]   :   ,   \"   \\   /   +   -   .   0   |   a   b   c   d   e   f   l   n   r   s   t   u   |   E   |*/\n\t/*start  GO*/ {GO, GO, co, __, bo, __, __, __, ST, __, __, __, MI, __, ZE, IN, __, __, __, __, __, F1, __, N1, __, __, T1, __, __, __, __},\n\t/*ok     OK*/ {OK, OK, __, cc, __, bc, __, cm, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*object OB*/ {OB, OB, __, ec, __, __, __, __, ST, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*key    KE*/ {KE, KE, __, __, __, __, __, __, ST, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*colon  CO*/ {CO, CO, __, __, __, __, cl, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*value  VA*/ {VA, VA, co, __, bo, __, __, __, ST, __, __, __, MI, __, ZE, IN, __, __, __, __, __, F1, __, N1, __, __, T1, __, __, __, __},\n\t/*array  AR*/ {AR, AR, co, __, bo, bc, __, __, ST, __, __, __, MI, __, ZE, IN, __, __, __, __, __, F1, __, N1, __, __, T1, __, __, __, __},\n\t/*string ST*/ {ST, __, ST, ST, ST, ST, ST, ST, qt, ES, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST, ST},\n\t/*escape ES*/ {__, __, __, __, __, __, __, __, ST, ST, ST, __, __, __, __, __, __, ST, __, __, __, ST, __, ST, ST, __, ST, U1, __, __, __},\n\t/*u1     U1*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, U2, U2, U2, U2, U2, U2, U2, U2, __, __, __, __, __, __, U2, U2, __},\n\t/*u2     U2*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, U3, U3, U3, U3, U3, U3, U3, U3, __, __, __, __, __, __, U3, U3, __},\n\t/*u3     U3*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, U4, U4, U4, U4, U4, U4, U4, U4, __, __, __, __, __, __, U4, U4, __},\n\t/*u4     U4*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, ST, ST, ST, ST, ST, ST, ST, ST, __, __, __, __, __, __, ST, ST, __},\n\t/*minus  MI*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, ZE, IN, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*zero   ZE*/ {OK, OK, __, cc, __, bc, __, cm, __, __, __, __, __, DT, __, __, __, __, __, __, E1, __, __, __, __, __, __, __, __, E1, __},\n\t/*int    IN*/ {OK, OK, __, cc, __, bc, __, cm, __, __, __, __, __, DT, IN, IN, __, __, __, __, E1, __, __, __, __, __, __, __, __, E1, __},\n\t/*dot    DT*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, FR, FR, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*frac   FR*/ {OK, OK, __, cc, __, bc, __, cm, __, __, __, __, __, __, FR, FR, __, __, __, __, E1, __, __, __, __, __, __, __, __, E1, __},\n\t/*e      E1*/ {__, __, __, __, __, __, __, __, __, __, __, E2, E2, __, E3, E3, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*ex     E2*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, E3, E3, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*exp    E3*/ {OK, OK, __, cc, __, bc, __, cm, __, __, __, __, __, __, E3, E3, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*tr     T1*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, T2, __, __, __, __, __, __},\n\t/*tru    T2*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, T3, __, __, __},\n\t/*true   T3*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, OK, __, __, __, __, __, __, __, __, __, __},\n\t/*fa     F1*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, F2, __, __, __, __, __, __, __, __, __, __, __, __, __, __},\n\t/*fal    F2*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, F3, __, __, __, __, __, __, __, __},\n\t/*fals   F3*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, F4, __, __, __, __, __},\n\t/*false  F4*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, OK, __, __, __, __, __, __, __, __, __, __},\n\t/*nu     N1*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, N2, __, __, __},\n\t/*nul    N2*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, N3, __, __, __, __, __, __, __, __},\n\t/*null   N3*/ {__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, OK, __, __, __, __, __, __, __, __},\n}\n"},{"Name":"parser_test.gno","Body":"package json\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestParseStringLiteral(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tisError  bool\n\t}{\n\t\t{`\"Hello, World!\"`, \"\\\"Hello, World!\\\"\", false},\n\t\t{`\\uFF11`, \"\\uFF11\", false},\n\t\t{`\\uFFFF`, \"\\uFFFF\", false},\n\t\t{`true`, \"true\", false},\n\t\t{`false`, \"false\", false},\n\t\t{`\\uDF00`, \"\", true},\n\t}\n\n\tfor i, tt := range tests {\n\t\ts, err := ParseStringLiteral([]byte(tt.input))\n\n\t\tif !tt.isError \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"%d. unexpected error: %s\", i, err)\n\t\t}\n\n\t\tif tt.isError \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"%d. expected error, but not error\", i)\n\t\t}\n\n\t\tif s != tt.expected {\n\t\t\tt.Errorf(\"%d. expected=%s, but actual=%s\", i, tt.expected, s)\n\t\t}\n\t}\n}\n\nfunc TestParseBoolLiteral(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t\tisError  bool\n\t}{\n\t\t{`true`, true, false},\n\t\t{`false`, false, false},\n\t\t{`TRUE`, false, true},\n\t\t{`FALSE`, false, true},\n\t\t{`foo`, false, true},\n\t\t{`\"true\"`, false, true},\n\t\t{`\"false\"`, false, true},\n\t}\n\n\tfor i, tt := range tests {\n\t\tb, err := ParseBoolLiteral([]byte(tt.input))\n\n\t\tif !tt.isError \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"%d. unexpected error: %s\", i, err)\n\t\t}\n\n\t\tif tt.isError \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"%d. expected error, but not error\", i)\n\t\t}\n\n\t\tif b != tt.expected {\n\t\t\tt.Errorf(\"%d. expected=%t, but actual=%t\", i, tt.expected, b)\n\t\t}\n\t}\n}\n\nfunc TestParseFloatLiteral(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected float64\n\t}{\n\t\t{\"123\", 123},\n\t\t{\"-123\", -123},\n\t\t{\"123.456\", 123.456},\n\t\t{\"-123.456\", -123.456},\n\t\t{\"12345678.1234567890\", 12345678.1234567890},\n\t\t{\"-12345678.09123456789\", -12345678.09123456789},\n\t\t{\"0.123\", 0.123},\n\t\t{\"-0.123\", -0.123},\n\t\t{\"\", -1},\n\t\t{\"abc\", -1},\n\t\t{\"123.45.6\", -1},\n\t\t{\"999999999999999999999\", -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot, _ := ParseFloatLiteral([]byte(tt.input))\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"ParseFloatLiteral(%s): got %v, want %v\", tt.input, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseFloatWithScientificNotation(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected float64\n\t}{\n\t\t{\"1e6\", 1000000},\n\t\t{\"1E6\", 1000000},\n\t\t{\"1.23e10\", 1.23e10},\n\t\t{\"1.23E10\", 1.23e10},\n\t\t{\"-1.23e10\", -1.23e10},\n\t\t{\"-1.23E10\", -1.23e10},\n\t\t{\"2.45e-8\", 2.45e-8},\n\t\t{\"2.45E-8\", 2.45e-8},\n\t\t{\"-2.45e-8\", -2.45e-8},\n\t\t{\"-2.45E-8\", -2.45e-8},\n\t\t{\"5e0\", 5},\n\t\t{\"-5e0\", -5},\n\t\t{\"5E+0\", 5},\n\t\t{\"5e+1\", 50},\n\t\t{\"1e-1\", 0.1},\n\t\t{\"1E-1\", 0.1},\n\t\t{\"-1e-1\", -0.1},\n\t\t{\"-1E-1\", -0.1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot, err := ParseFloatLiteral([]byte(tt.input))\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"ParseFloatLiteral(%s): got %v, want %v\", tt.input, got, tt.expected)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ParseFloatLiteral(%s): got error %v\", tt.input, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseFloat_May_Interoperability_Problem(t *testing.T) {\n\ttests := []struct {\n\t\tinput     string\n\t\tshouldErr bool\n\t}{\n\t\t{\"3.141592653589793238462643383279\", true},\n\t\t{\"1E400\", false}, // TODO: should error\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\t_, err := ParseFloatLiteral([]byte(tt.input))\n\t\t\tif tt.shouldErr \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"ParseFloatLiteral(%s): expected error, but not error\", tt.input)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseIntLiteral(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected int64\n\t}{\n\t\t{\"0\", 0},\n\t\t{\"1\", 1},\n\t\t{\"-1\", -1},\n\t\t{\"12345\", 12345},\n\t\t{\"-12345\", -12345},\n\t\t{\"9223372036854775807\", 9223372036854775807},\n\t\t{\"-9223372036854775808\", -9223372036854775808},\n\t\t{\"-92233720368547758081\", 0},\n\t\t{\"18446744073709551616\", 0},\n\t\t{\"9223372036854775808\", 0},\n\t\t{\"-9223372036854775809\", 0},\n\t\t{\"\", 0},\n\t\t{\"abc\", 0},\n\t\t{\"12345x\", 0},\n\t\t{\"123e5\", 0},\n\t\t{\"9223372036854775807x\", 0},\n\t\t{\"27670116110564327410\", 0},\n\t\t{\"-27670116110564327410\", 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot, _ := ParseIntLiteral([]byte(tt.input))\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"ParseIntLiteral(%s): got %v, want %v\", tt.input, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"Name":"token.gno","Body":"package json\n\nconst (\n\tbracketOpen    = '['\n\tbracketClose   = ']'\n\tparenOpen      = '('\n\tparenClose     = ')'\n\tcurlyOpen      = '{'\n\tcurlyClose     = '}'\n\tcomma          = ','\n\tdot            = '.'\n\tcolon          = ':'\n\tbackTick       = '`'\n\tsingleQuote    = '\\''\n\tdoubleQuote    = '\"'\n\temptyString    = \"\"\n\twhiteSpace     = ' '\n\tplus           = '+'\n\tminus          = '-'\n\taesterisk      = '*'\n\tbang           = '!'\n\tquestion       = '?'\n\tnewLine        = '\\n'\n\ttab            = '\\t'\n\tcarriageReturn = '\\r'\n\tformFeed       = '\\f'\n\tbackSpace      = '\\b'\n\tslash          = '/'\n\tbackSlash      = '\\\\'\n\tunderScore     = '_'\n\tdollarSign     = '$'\n\tatSign         = '@'\n\tandSign        = '\u0026'\n\torSign         = '|'\n)\n\nvar (\n\ttrueLiteral  = []byte(\"true\")\n\tfalseLiteral = []byte(\"false\")\n\tnullLiteral  = []byte(\"null\")\n)\n\ntype ValueType int\n\nconst (\n\tNotExist ValueType = iota\n\tString\n\tNumber\n\tFloat\n\tObject\n\tArray\n\tBoolean\n\tNull\n\tUnknown\n)\n\nfunc (v ValueType) String() string {\n\tswitch v {\n\tcase NotExist:\n\t\treturn \"not-exist\"\n\tcase String:\n\t\treturn \"string\"\n\tcase Number:\n\t\treturn \"number\"\n\tcase Object:\n\t\treturn \"object\"\n\tcase Array:\n\t\treturn \"array\"\n\tcase Boolean:\n\t\treturn \"boolean\"\n\tcase Null:\n\t\treturn \"null\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n"},{"Name":"node_test.gno","Body":"package json\n\nimport (\n\t\"bytes\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tnilKey   *string\n\tdummyKey = \"key\"\n)\n\ntype _args struct {\n\tprev *Node\n\tbuf  *buffer\n\ttyp  ValueType\n\tkey  **string\n}\n\ntype simpleNode struct {\n\tname string\n\tnode *Node\n}\n\nfunc TestNode_CreateNewNode(t *testing.T) {\n\trel := \u0026dummyKey\n\n\ttests := []struct {\n\t\tname        string\n\t\targs        _args\n\t\texpectCurr  *Node\n\t\texpectErr   bool\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname: \"child for non container type\",\n\t\t\targs: _args{\n\t\t\t\tprev: BoolNode(\"\", true),\n\t\t\t\tbuf:  newBuffer(make([]byte, 10)),\n\t\t\t\ttyp:  Boolean,\n\t\t\t\tkey:  \u0026rel,\n\t\t\t},\n\t\t\texpectCurr: nil,\n\t\t\texpectErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.expectPanic {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"%s panic occurred when not expected: %v\", tt.name, r)\n\t\t\t\t} else if tt.expectPanic {\n\t\t\t\t\tt.Errorf(\"%s expected panic but didn't occur\", tt.name)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot, err := NewNode(tt.args.prev, tt.args.buf, tt.args.typ, tt.args.key)\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"%s error = %v, expect error %v\", tt.name, err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tt.expectErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareNodes(got, tt.expectCurr) {\n\t\t\t\tt.Errorf(\"%s got = %v, want %v\", tt.name, got, tt.expectCurr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_Value(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tdata        []byte\n\t\t_type       ValueType\n\t\texpected    interface{}\n\t\terrExpected bool\n\t}{\n\t\t{name: \"null\", data: []byte(\"null\"), _type: Null, expected: nil},\n\t\t{name: \"1\", data: []byte(\"1\"), _type: Number, expected: float64(1)},\n\t\t{name: \".1\", data: []byte(\".1\"), _type: Number, expected: float64(.1)},\n\t\t{name: \"-.1e1\", data: []byte(\"-.1e1\"), _type: Number, expected: float64(-1)},\n\t\t{name: \"string\", data: []byte(\"\\\"foo\\\"\"), _type: String, expected: \"foo\"},\n\t\t{name: \"space\", data: []byte(\"\\\"foo bar\\\"\"), _type: String, expected: \"foo bar\"},\n\t\t{name: \"true\", data: []byte(\"true\"), _type: Boolean, expected: true},\n\t\t{name: \"invalid true\", data: []byte(\"tru\"), _type: Unknown, errExpected: true},\n\t\t{name: \"invalid false\", data: []byte(\"fals\"), _type: Unknown, errExpected: true},\n\t\t{name: \"false\", data: []byte(\"false\"), _type: Boolean, expected: false},\n\t\t{name: \"e1\", data: []byte(\"e1\"), _type: Unknown, errExpected: true},\n\t\t{name: \"1a\", data: []byte(\"1a\"), _type: Unknown, errExpected: true},\n\t\t{name: \"string error\", data: []byte(\"\\\"foo\\nbar\\\"\"), _type: String, errExpected: true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tcurr := \u0026Node{\n\t\t\t\tdata:     tt.data,\n\t\t\t\tnodeType: tt._type,\n\t\t\t\tborders:  [2]int{0, len(tt.data)},\n\t\t\t}\n\n\t\t\tgot, err := curr.Value()\n\t\t\tif err != nil {\n\t\t\t\tif !tt.errExpected {\n\t\t\t\t\tt.Errorf(\"%s error = %v, expect error %v\", tt.name, err, tt.errExpected)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"%s got = %v, want %v\", tt.name, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_Delete(t *testing.T) {\n\troot := Must(Unmarshal([]byte(`{\"foo\":\"bar\"}`)))\n\tif err := root.Delete(); err != nil {\n\t\tt.Errorf(\"Delete returns error: %v\", err)\n\t}\n\n\tif value, err := Marshal(root); err != nil {\n\t\tt.Errorf(\"Marshal returns error: %v\", err)\n\t} else if string(value) != `{\"foo\":\"bar\"}` {\n\t\tt.Errorf(\"Marshal returns wrong value: %s\", string(value))\n\t}\n\n\tfoo := root.MustKey(\"foo\")\n\tif err := foo.Delete(); err != nil {\n\t\tt.Errorf(\"Delete returns error while handling foo: %v\", err)\n\t}\n\n\tif value, err := Marshal(root); err != nil {\n\t\tt.Errorf(\"Marshal returns error: %v\", err)\n\t} else if string(value) != `{}` {\n\t\tt.Errorf(\"Marshal returns wrong value: %s\", string(value))\n\t}\n\n\tif value, err := Marshal(foo); err != nil {\n\t\tt.Errorf(\"Marshal returns error: %v\", err)\n\t} else if string(value) != `\"bar\"` {\n\t\tt.Errorf(\"Marshal returns wrong value: %s\", string(value))\n\t}\n\n\tif foo.prev != nil {\n\t\tt.Errorf(\"foo.prev should be nil\")\n\t}\n}\n\nfunc TestNode_ObjectNode(t *testing.T) {\n\tobjs := map[string]*Node{\n\t\t\"key1\": NullNode(\"null\"),\n\t\t\"key2\": NumberNode(\"answer\", 42),\n\t\t\"key3\": StringNode(\"string\", \"foobar\"),\n\t\t\"key4\": BoolNode(\"bool\", true),\n\t}\n\n\tnode := ObjectNode(\"test\", objs)\n\n\tif len(node.next) != len(objs) {\n\t\tt.Errorf(\"ObjectNode: want %v got %v\", len(objs), len(node.next))\n\t}\n\n\tfor k, v := range objs {\n\t\tif node.next[k] == nil {\n\t\t\tt.Errorf(\"ObjectNode: want %v got %v\", v, node.next[k])\n\t\t}\n\t}\n}\n\nfunc TestNode_AppendObject(t *testing.T) {\n\tif err := Must(Unmarshal([]byte(`{\"foo\":\"bar\",\"baz\":null}`))).AppendObject(\"biz\", NullNode(\"\")); err != nil {\n\t\tt.Errorf(\"AppendArray should return error\")\n\t}\n\n\troot := Must(Unmarshal([]byte(`{\"foo\":\"bar\"}`)))\n\tif err := root.AppendObject(\"baz\", NullNode(\"\")); err != nil {\n\t\tt.Errorf(\"AppendObject should not return error: %s\", err)\n\t}\n\n\tif value, err := Marshal(root); err != nil {\n\t\tt.Errorf(\"Marshal returns error: %v\", err)\n\t} else if isSameObject(string(value), `\"{\"foo\":\"bar\",\"baz\":null}\"`) {\n\t\tt.Errorf(\"Marshal returns wrong value: %s\", string(value))\n\t}\n\n\t// FIXME: this may fail if execute test in more than 3 times in a row.\n\tif err := root.AppendObject(\"biz\", NumberNode(\"\", 42)); err != nil {\n\t\tt.Errorf(\"AppendObject returns error: %v\", err)\n\t}\n\n\tval, err := Marshal(root)\n\tif err != nil {\n\t\tt.Errorf(\"Marshal returns error: %v\", err)\n\t}\n\n\t// FIXME: this may fail if execute test in more than 3 times in a row.\n\tif isSameObject(string(val), `\"{\"foo\":\"bar\",\"baz\":null,\"biz\":42}\"`) {\n\t\tt.Errorf(\"Marshal returns wrong value: %s\", string(val))\n\t}\n}\n\nfunc TestNode_ArrayNode(t *testing.T) {\n\tarr := []*Node{\n\t\tNullNode(\"nil\"),\n\t\tNumberNode(\"num\", 42),\n\t\tStringNode(\"str\", \"foobar\"),\n\t\tBoolNode(\"bool\", true),\n\t}\n\n\tnode := ArrayNode(\"test\", arr)\n\n\tif len(node.next) != len(arr) {\n\t\tt.Errorf(\"ArrayNode: want %v got %v\", len(arr), len(node.next))\n\t}\n\n\tfor i, v := range arr {\n\t\tif node.next[strconv.Itoa(i)] == nil {\n\t\t\tt.Errorf(\"ArrayNode: want %v got %v\", v, node.next[strconv.Itoa(i)])\n\t\t}\n\t}\n}\n\nfunc TestNode_AppendArray(t *testing.T) {\n\tif err := Must(Unmarshal([]byte(`[{\"foo\":\"bar\"}]`))).AppendArray(NullNode(\"\")); err != nil {\n\t\tt.Errorf(\"should return error\")\n\t}\n\n\troot := Must(Unmarshal([]byte(`[{\"foo\":\"bar\"}]`)))\n\tif err := root.AppendArray(NullNode(\"\")); err != nil {\n\t\tt.Errorf(\"should not return error: %s\", err)\n\t}\n\n\tif value, err := Marshal(root); err != nil {\n\t\tt.Errorf(\"Marshal returns error: %v\", err)\n\t} else if string(value) != `[{\"foo\":\"bar\"},null]` {\n\t\tt.Errorf(\"Marshal returns wrong value: %s\", string(value))\n\t}\n\n\tif err := root.AppendArray(\n\t\tNumberNode(\"\", 1),\n\t\tStringNode(\"\", \"foo\"),\n\t\tMust(Unmarshal([]byte(`[0,1,null,true,\"example\"]`))),\n\t\tMust(Unmarshal([]byte(`{\"foo\": true, \"bar\": null, \"baz\": 123}`))),\n\t); err != nil {\n\t\tt.Errorf(\"AppendArray returns error: %v\", err)\n\t}\n\n\tif value, err := Marshal(root); err != nil {\n\t\tt.Errorf(\"Marshal returns error: %v\", err)\n\t} else if string(value) != `[{\"foo\":\"bar\"},null,1,\"foo\",[0,1,null,true,\"example\"],{\"foo\": true, \"bar\": null, \"baz\": 123}]` {\n\t\tt.Errorf(\"Marshal returns wrong value: %s\", string(value))\n\t}\n}\n\n/******** value getter ********/\n\nfunc TestNode_GetBool(t *testing.T) {\n\troot, err := Unmarshal([]byte(`true`))\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err.Error())\n\t\treturn\n\t}\n\n\tvalue, err := root.GetBool()\n\tif err != nil {\n\t\tt.Errorf(\"Error on root.GetBool(): %s\", err.Error())\n\t}\n\n\tif !value {\n\t\tt.Errorf(\"root.GetBool() is corrupted\")\n\t}\n}\n\nfunc TestNode_GetBool_Fail(t *testing.T) {\n\ttests := []simpleNode{\n\t\t{\"nil node\", (*Node)(nil)},\n\t\t{\"literally null node\", NullNode(\"\")},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif _, err := tt.node.GetBool(); err == nil {\n\t\t\t\tt.Errorf(\"%s should be an error\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_IsBool(t *testing.T) {\n\ttests := []simpleNode{\n\t\t{\"true\", BoolNode(\"\", true)},\n\t\t{\"false\", BoolNode(\"\", false)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif !tt.node.IsBool() {\n\t\t\t\tt.Errorf(\"%s should be a bool\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_IsBool_With_Unmarshal(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tjson []byte\n\t\twant bool\n\t}{\n\t\t{\"true\", []byte(\"true\"), true},\n\t\t{\"false\", []byte(\"false\"), true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\troot, err := Unmarshal(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error on Unmarshal(): %s\", err.Error())\n\t\t\t}\n\n\t\t\tif root.IsBool() != tt.want {\n\t\t\t\tt.Errorf(\"%s should be a bool\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar nullJson = []byte(`null`)\n\nfunc TestNode_GetNull(t *testing.T) {\n\troot, err := Unmarshal(nullJson)\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err.Error())\n\t}\n\n\tvalue, err := root.GetNull()\n\tif err != nil {\n\t\tt.Errorf(\"error occurred while getting null, %s\", err)\n\t}\n\n\tif value != nil {\n\t\tt.Errorf(\"value is not matched. expected: nil, got: %v\", value)\n\t}\n}\n\nfunc TestNode_GetNull_Fail(t *testing.T) {\n\ttests := []simpleNode{\n\t\t{\"nil node\", (*Node)(nil)},\n\t\t{\"number node is null\", NumberNode(\"\", 42)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif _, err := tt.node.GetNull(); err == nil {\n\t\t\t\tt.Errorf(\"%s should be an error\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_MustNull(t *testing.T) {\n\troot, err := Unmarshal(nullJson)\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err.Error())\n\t}\n\n\tvalue := root.MustNull()\n\tif value != nil {\n\t\tt.Errorf(\"value is not matched. expected: nil, got: %v\", value)\n\t}\n}\n\nfunc TestNode_GetNumeric_Float(t *testing.T) {\n\troot, err := Unmarshal([]byte(`123.456`))\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err)\n\t\treturn\n\t}\n\n\tvalue, err := root.GetNumeric()\n\tif err != nil {\n\t\tt.Errorf(\"Error on root.GetNumeric(): %s\", err)\n\t}\n\n\tif value != float64(123.456) {\n\t\tt.Errorf(ufmt.Sprintf(\"value is not matched. expected: 123.456, got: %v\", value))\n\t}\n}\n\nfunc TestNode_GetNumeric_Scientific_Notation(t *testing.T) {\n\troot, err := Unmarshal([]byte(`1e3`))\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err)\n\t\treturn\n\t}\n\n\tvalue, err := root.GetNumeric()\n\tif err != nil {\n\t\tt.Errorf(\"Error on root.GetNumeric(): %s\", err)\n\t}\n\n\tif value != float64(1000) {\n\t\tt.Errorf(ufmt.Sprintf(\"value is not matched. expected: 1000, got: %v\", value))\n\t}\n}\n\nfunc TestNode_GetNumeric_With_Unmarshal(t *testing.T) {\n\troot, err := Unmarshal([]byte(`123`))\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err)\n\t\treturn\n\t}\n\n\tvalue, err := root.GetNumeric()\n\tif err != nil {\n\t\tt.Errorf(\"Error on root.GetNumeric(): %s\", err)\n\t}\n\n\tif value != float64(123) {\n\t\tt.Errorf(ufmt.Sprintf(\"value is not matched. expected: 123, got: %v\", value))\n\t}\n}\n\nfunc TestNode_GetNumeric_Fail(t *testing.T) {\n\ttests := []simpleNode{\n\t\t{\"nil node\", (*Node)(nil)},\n\t\t{\"null node\", NullNode(\"\")},\n\t\t{\"string node\", StringNode(\"\", \"123\")},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif _, err := tt.node.GetNumeric(); err == nil {\n\t\t\t\tt.Errorf(\"%s should be an error\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_GetString(t *testing.T) {\n\troot, err := Unmarshal([]byte(`\"123foobar 3456\"`))\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err)\n\t}\n\n\tvalue, err := root.GetString()\n\tif err != nil {\n\t\tt.Errorf(\"Error on root.GetString(): %s\", err)\n\t}\n\n\tif value != \"123foobar 3456\" {\n\t\tt.Errorf(ufmt.Sprintf(\"value is not matched. expected: 123, got: %s\", value))\n\t}\n}\n\nfunc TestNode_GetString_Fail(t *testing.T) {\n\ttests := []simpleNode{\n\t\t{\"nil node\", (*Node)(nil)},\n\t\t{\"null node\", NullNode(\"\")},\n\t\t{\"number node\", NumberNode(\"\", 123)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif _, err := tt.node.GetString(); err == nil {\n\t\t\t\tt.Errorf(\"%s should be an error\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_MustString(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdata []byte\n\t}{\n\t\t{\"foo\", []byte(`\"foo\"`)},\n\t\t{\"foo bar\", []byte(`\"foo bar\"`)},\n\t\t{\"\", []byte(`\"\"`)},\n\t\t{\"\", []byte(`\"\"`)},\n\t\t{\"\", []byte(`\"\"`)},\n\t\t{\"\", []byte(`\"\"`)},\n\t\t{\"one \\\"encoded\\\" string\", []byte(`\"one \\\"encoded\\\" string\"`)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\troot, err := Unmarshal(tt.data)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error on Unmarshal(): %s\", err)\n\t\t\t}\n\n\t\t\tvalue := root.MustString()\n\t\t\tif value != tt.name {\n\t\t\t\tt.Errorf(\"value is not matched. expected: %s, got: %s\", tt.name, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_Array(t *testing.T) {\n\troot, err := Unmarshal([]byte(\" [1,[\\\"1\\\",[1,[1,2,3]]]]\\r\\n\"))\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal: %s\", err.Error())\n\t}\n\n\tif root == nil {\n\t\tt.Errorf(\"Error on Unmarshal: root is nil\")\n\t}\n\n\tif root.Type() != Array {\n\t\tt.Errorf(\"Error on Unmarshal: wrong type\")\n\t}\n\n\tarray, err := root.GetArray()\n\tif err != nil {\n\t\tt.Errorf(\"error occurred while getting array, %s\", err)\n\t} else if len(array) != 2 {\n\t\tt.Errorf(\"expected 2 elements, got %d\", len(array))\n\t} else if val, err := array[0].GetNumeric(); err != nil {\n\t\tt.Errorf(\"value of array[0] is not numeric. got: %v\", array[0].value)\n\t} else if val != 1 {\n\t\tt.Errorf(\"Error on array[0].GetNumeric(): expected to be '1', got: %v\", val)\n\t} else if val, err := array[1].GetArray(); err != nil {\n\t\tt.Errorf(\"error occurred while getting array, %s\", err.Error())\n\t} else if len(val) != 2 {\n\t\tt.Errorf(\"Error on array[1].GetArray(): expected 2 elements, got %d\", len(val))\n\t} else if el, err := val[0].GetString(); err != nil {\n\t\tt.Errorf(\"error occurred while getting string, %s\", err.Error())\n\t} else if el != \"1\" {\n\t\tt.Errorf(\"Error on val[0].GetString(): expected to be '1', got: %s\", el)\n\t}\n}\n\nvar sampleArr = []byte(`[-1, 2, 3, 4, 5, 6]`)\n\nfunc TestNode_GetArray(t *testing.T) {\n\troot, err := Unmarshal(sampleArr)\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err)\n\t\treturn\n\t}\n\n\tarray, err := root.GetArray()\n\tif err != nil {\n\t\tt.Errorf(\"Error on root.GetArray(): %s\", err)\n\t}\n\n\tif len(array) != 6 {\n\t\tt.Errorf(ufmt.Sprintf(\"length is not matched. expected: 3, got: %d\", len(array)))\n\t}\n\n\tfor i, node := range array {\n\t\tfor j, val := range []int{-1, 2, 3, 4, 5, 6} {\n\t\t\tif i == j {\n\t\t\t\tif v, err := node.GetNumeric(); err != nil {\n\t\t\t\t\tt.Errorf(ufmt.Sprintf(\"Error on node.GetNumeric(): %s\", err))\n\t\t\t\t} else if v != float64(val) {\n\t\t\t\t\tt.Errorf(ufmt.Sprintf(\"value is not matched. expected: %d, got: %v\", val, v))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNode_GetArray_Fail(t *testing.T) {\n\ttests := []simpleNode{\n\t\t{\"nil node\", (*Node)(nil)},\n\t\t{\"null node\", NullNode(\"\")},\n\t\t{\"number node\", NumberNode(\"\", 123)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif _, err := tt.node.GetArray(); err == nil {\n\t\t\t\tt.Errorf(\"%s should be an error\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_IsArray(t *testing.T) {\n\troot, err := Unmarshal(sampleArr)\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err)\n\t\treturn\n\t}\n\n\tif root.Type() != Array {\n\t\tt.Errorf(ufmt.Sprintf(\"Must be an array. got: %s\", root.Type().String()))\n\t}\n}\n\nfunc TestNode_ArrayEach(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tjson:     `[]`,\n\t\t\texpected: []int{},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tjson:     `[42]`,\n\t\t\texpected: []int{42},\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tjson:     `[1, 2, 3, 4, 5]`,\n\t\t\texpected: []int{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements but all values are same\",\n\t\t\tjson:     `[1, 1, 1, 1, 1]`,\n\t\t\texpected: []int{1, 1, 1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements with non-numeric values\",\n\t\t\tjson:     `[\"a\", \"b\", \"c\", \"d\", \"e\"]`,\n\t\t\texpected: []int{},\n\t\t},\n\t\t{\n\t\t\tname:     \"non-array node\",\n\t\t\tjson:     `{\"not\": \"an array\"}`,\n\t\t\texpected: []int{},\n\t\t},\n\t\t{\n\t\t\tname:     \"array containing numeric and non-numeric elements\",\n\t\t\tjson:     `[\"1\", 2, 3, \"4\", 5, \"6\"]`,\n\t\t\texpected: []int{2, 3, 5},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\troot, err := Unmarshal([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unmarshal failed: %v\", err)\n\t\t\t}\n\n\t\t\tvar result []int // callback result\n\t\t\troot.ArrayEach(func(index int, element *Node) {\n\t\t\t\tif val, err := strconv.Atoi(element.String()); err == nil {\n\t\t\t\t\tresult = append(result, val)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif len(result) != len(tc.expected) {\n\t\t\t\tt.Errorf(\"%s: expected %d elements, got %d\", tc.name, len(tc.expected), len(result))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor i, val := range result {\n\t\t\t\tif val != tc.expected[i] {\n\t\t\t\t\tt.Errorf(\"%s: expected value at index %d to be %d, got %d\", tc.name, i, tc.expected[i], val)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_Key(t *testing.T) {\n\troot, err := Unmarshal([]byte(`{\"foo\": true, \"bar\": null, \"baz\": 123, \"biz\": [1,2,3]}`))\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err.Error())\n\t}\n\n\tobj := root.MustObject()\n\tfor key, node := range obj {\n\t\tif key != node.Key() {\n\t\t\tt.Errorf(\"Key() = %v, want %v\", node.Key(), key)\n\t\t}\n\t}\n\n\tkeys := []string{\"foo\", \"bar\", \"baz\", \"biz\"}\n\tfor _, key := range keys {\n\t\tif obj[key].Key() != key {\n\t\t\tt.Errorf(\"Key() = %v, want %v\", obj[key].Key(), key)\n\t\t}\n\t}\n\n\t// TODO: resolve stack overflow\n\t// if root.MustKey(\"foo\").Clone().Key() != \"\" {\n\t// \tt.Errorf(\"wrong key found for cloned key\")\n\t// }\n\n\tif (*Node)(nil).Key() != \"\" {\n\t\tt.Errorf(\"wrong key found for nil node\")\n\t}\n}\n\nfunc TestNode_Size(t *testing.T) {\n\troot, err := Unmarshal(sampleArr)\n\tif err != nil {\n\t\tt.Errorf(\"error occurred while unmarshal\")\n\t}\n\n\tsize := root.Size()\n\tif size != 6 {\n\t\tt.Errorf(ufmt.Sprintf(\"Size() must be 6. got: %v\", size))\n\t}\n\n\tif (*Node)(nil).Size() != 0 {\n\t\tt.Errorf(ufmt.Sprintf(\"Size() must be 0. got: %v\", (*Node)(nil).Size()))\n\t}\n}\n\nfunc TestNode_Index(t *testing.T) {\n\troot, err := Unmarshal([]byte(`[1, 2, 3, 4, 5, 6]`))\n\tif err != nil {\n\t\tt.Error(\"error occurred while unmarshal\")\n\t}\n\n\tarr := root.MustArray()\n\tfor i, node := range arr {\n\t\tif i != node.Index() {\n\t\t\tt.Errorf(ufmt.Sprintf(\"Index() must be nil. got: %v\", i))\n\t\t}\n\t}\n}\n\nfunc TestNode_Index_Fail(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tnode *Node\n\t\twant int\n\t}{\n\t\t{\"nil node\", (*Node)(nil), -1},\n\t\t{\"null node\", NullNode(\"\"), -1},\n\t\t{\"object node\", ObjectNode(\"\", nil), -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.node.Index(); got != tt.want {\n\t\t\t\tt.Errorf(\"Index() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_GetIndex(t *testing.T) {\n\troot := Must(Unmarshal([]byte(`[1, 2, 3, 4, 5, 6]`)))\n\texpected := []int{1, 2, 3, 4, 5, 6}\n\n\tif len(expected) != root.Size() {\n\t\tt.Errorf(\"length is not matched. expected: %d, got: %d\", len(expected), root.Size())\n\t}\n\n\t// TODO: if length exceeds, stack overflow occurs. need to fix\n\tfor i, v := range expected {\n\t\tval, err := root.GetIndex(i)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error occurred while getting index %d, %s\", i, err)\n\t\t}\n\n\t\tif val.MustNumeric() != float64(v) {\n\t\t\tt.Errorf(\"value is not matched. expected: %d, got: %v\", v, val.MustNumeric())\n\t\t}\n\t}\n}\n\nfunc TestNode_GetIndex_InputIndex_Exceed_Original_Node_Index(t *testing.T) {\n\troot, err := Unmarshal([]byte(`[1, 2, 3, 4, 5, 6]`))\n\tif err != nil {\n\t\tt.Errorf(\"error occurred while unmarshal\")\n\t}\n\n\t_, err = root.GetIndex(10)\n\tif err == nil {\n\t\tt.Errorf(\"GetIndex should return error\")\n\t}\n}\n\nfunc TestNode_DeleteIndex(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\texpected string\n\t\tindex    int\n\t\tok       bool\n\t}{\n\t\t{`null`, ``, 0, false},\n\t\t{`1`, ``, 0, false},\n\t\t{`{}`, ``, 0, false},\n\t\t{`{\"foo\":\"bar\"}`, ``, 0, false},\n\t\t{`true`, ``, 0, false},\n\t\t{`[]`, ``, 0, false},\n\t\t{`[]`, ``, -1, false},\n\t\t{`[1]`, `[]`, 0, true},\n\t\t{`[{}]`, `[]`, 0, true},\n\t\t{`[{}, [], 42]`, `[{}, []]`, -1, true},\n\t\t{`[{}, [], 42]`, `[[], 42]`, 0, true},\n\t\t{`[{}, [], 42]`, `[{}, 42]`, 1, true},\n\t\t{`[{}, [], 42]`, `[{}, []]`, 2, true},\n\t\t{`[{}, [], 42]`, ``, 10, false},\n\t\t{`[{}, [], 42]`, ``, -10, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\troot := Must(Unmarshal([]byte(tt.name)))\n\t\t\terr := root.DeleteIndex(tt.index)\n\t\t\tif err != nil \u0026\u0026 tt.ok {\n\t\t\t\tt.Errorf(\"DeleteIndex returns error: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_GetKey(t *testing.T) {\n\troot, err := Unmarshal([]byte(`{\"foo\": true, \"bar\": null}`))\n\tif err != nil {\n\t\tt.Error(\"error occurred while unmarshal\")\n\t}\n\n\tvalue, err := root.GetKey(\"foo\")\n\tif err != nil {\n\t\tt.Errorf(\"error occurred while getting key, %s\", err)\n\t}\n\n\tif value.MustBool() != true {\n\t\tt.Errorf(\"value is not matched. expected: true, got: %v\", value.MustBool())\n\t}\n\n\tvalue, err = root.GetKey(\"bar\")\n\tif err != nil {\n\t\tt.Errorf(\"error occurred while getting key, %s\", err)\n\t}\n\n\t_, err = root.GetKey(\"baz\")\n\tif err == nil {\n\t\tt.Errorf(\"key baz is not exist. must be failed\")\n\t}\n\n\tif value.MustNull() != nil {\n\t\tt.Errorf(\"value is not matched. expected: nil, got: %v\", value.MustNull())\n\t}\n}\n\nfunc TestNode_GetKey_Fail(t *testing.T) {\n\ttests := []simpleNode{\n\t\t{\"nil node\", (*Node)(nil)},\n\t\t{\"null node\", NullNode(\"\")},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif _, err := tt.node.GetKey(\"\"); err == nil {\n\t\t\t\tt.Errorf(\"%s should be an error\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_GetUniqueKeyList(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\tname:     \"simple foo/bar\",\n\t\t\tjson:     `{\"foo\": true, \"bar\": null}`,\n\t\t\texpected: []string{\"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tjson:     `{}`,\n\t\t\texpected: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\tjson: `{\n\t\t\t\t\"outer\": {\n\t\t\t\t\t\"inner\": {\n\t\t\t\t\t\t\"key\": \"value\"\n\t\t\t\t\t},\n\t\t\t\t\t\"array\": [1, 2, 3]\n\t\t\t\t},\n\t\t\t\t\"another\": \"item\"\n\t\t\t}`,\n\t\t\texpected: []string{\"outer\", \"inner\", \"key\", \"array\", \"another\"},\n\t\t},\n\t\t{\n\t\t\tname: \"complex object\",\n\t\t\tjson: `{\n\t\t\t\t\"Image\": {\n\t\t\t\t\t\"Width\": 800,\n\t\t\t\t\t\"Height\": 600,\n\t\t\t\t\t\"Title\": \"View from 15th Floor\",\n\t\t\t\t\t\"Thumbnail\": {\n\t\t\t\t\t\t\"Url\": \"http://www.example.com/image/481989943\",\n\t\t\t\t\t\t\"Height\": 125,\n\t\t\t\t\t\t\"Width\": 100\n\t\t\t\t\t},\n\t\t\t\t\t\"Animated\": false,\n\t\t\t\t\t\"IDs\": [116, 943, 234, 38793]\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpected: []string{\"Image\", \"Width\", \"Height\", \"Title\", \"Thumbnail\", \"Url\", \"Animated\", \"IDs\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\troot, err := Unmarshal([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error occurred while unmarshal\")\n\t\t\t}\n\n\t\t\tvalue := root.UniqueKeyLists()\n\t\t\tif len(value) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"%s length must be %v. got: %v. retrieved keys: %s\", tt.name, len(tt.expected), len(value), value)\n\t\t\t}\n\n\t\t\tfor _, key := range value {\n\t\t\t\tif !contains(tt.expected, key) {\n\t\t\t\t\tt.Errorf(\"EachKey() must be in %v. got: %v\", tt.expected, key)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TODO: resolve stack overflow\nfunc TestNode_IsEmpty(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tnode     *Node\n\t\texpected bool\n\t}{\n\t\t{\"nil node\", (*Node)(nil), false}, // nil node is not empty.\n\t\t// {\"null node\", NullNode(\"\"), true},\n\t\t{\"empty object\", ObjectNode(\"\", nil), true},\n\t\t{\"empty array\", ArrayNode(\"\", nil), true},\n\t\t{\"non-empty object\", ObjectNode(\"\", map[string]*Node{\"foo\": BoolNode(\"foo\", true)}), false},\n\t\t{\"non-empty array\", ArrayNode(\"\", []*Node{BoolNode(\"0\", true)}), false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.node.Empty(); got != tt.expected {\n\t\t\t\tt.Errorf(\"%s = %v, want %v\", tt.name, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_Index_EmptyList(t *testing.T) {\n\troot, err := Unmarshal([]byte(`[]`))\n\tif err != nil {\n\t\tt.Errorf(\"error occurred while unmarshal\")\n\t}\n\n\tarray := root.MustArray()\n\tfor i, node := range array {\n\t\tif i != node.Index() {\n\t\t\tt.Errorf(ufmt.Sprintf(\"Index() must be nil. got: %v\", i))\n\t\t}\n\t}\n}\n\nfunc TestNode_GetObject(t *testing.T) {\n\troot, err := Unmarshal([]byte(`{\"foo\": true,\"bar\": null}`))\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err.Error())\n\t\treturn\n\t}\n\n\tvalue, err := root.GetObject()\n\tif err != nil {\n\t\tt.Errorf(\"Error on root.GetObject(): %s\", err.Error())\n\t}\n\n\tif _, ok := value[\"foo\"]; !ok {\n\t\tt.Errorf(\"root.GetObject() is corrupted: foo\")\n\t}\n\n\tif _, ok := value[\"bar\"]; !ok {\n\t\tt.Errorf(\"root.GetObject() is corrupted: bar\")\n\t}\n}\n\nfunc TestNode_GetObject_Fail(t *testing.T) {\n\ttests := []simpleNode{\n\t\t{\"nil node\", (*Node)(nil)},\n\t\t{\"get object from null node\", NullNode(\"\")},\n\t\t{\"not object node\", NumberNode(\"\", 123)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif _, err := tt.node.GetObject(); err == nil {\n\t\t\t\tt.Errorf(\"%s should be an error\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_ObjectEach(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\texpected map[string]int\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tjson:     `{}`,\n\t\t\texpected: make(map[string]int),\n\t\t},\n\t\t{\n\t\t\tname:     \"single key-value pair\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\texpected: map[string]int{\"key\": 42},\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tjson:     `{\"one\": 1, \"two\": 2, \"three\": 3}`,\n\t\t\texpected: map[string]int{\"one\": 1, \"two\": 2, \"three\": 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs with some non-numeric values\",\n\t\t\tjson:     `{\"one\": 1, \"two\": \"2\", \"three\": 3, \"four\": \"4\"}`,\n\t\t\texpected: map[string]int{\"one\": 1, \"three\": 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"non-object node\",\n\t\t\tjson:     `[\"not\", \"an\", \"object\"]`,\n\t\t\texpected: make(map[string]int),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\troot, err := Unmarshal([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unmarshal failed: %v\", err)\n\t\t\t}\n\n\t\t\tresult := make(map[string]int)\n\t\t\troot.ObjectEach(func(key string, value *Node) {\n\t\t\t\t// extract integer values from the object\n\t\t\t\tif val, err := strconv.Atoi(value.String()); err == nil {\n\t\t\t\t\tresult[key] = val\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif len(result) != len(tc.expected) {\n\t\t\t\tt.Errorf(\"%s: expected %d key-value pairs, got %d\", tc.name, len(tc.expected), len(result))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor key, val := range tc.expected {\n\t\t\t\tif result[key] != val {\n\t\t\t\t\tt.Errorf(\"%s: expected value for key %s to be %d, got %d\", tc.name, key, val, result[key])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_ExampleMust(t *testing.T) {\n\tdata := []byte(`{\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n        }\n    }`)\n\n\troot := Must(Unmarshal(data))\n\tif root.Size() != 1 {\n\t\tt.Errorf(\"root.Size() must be 1. got: %v\", root.Size())\n\t}\n\n\tufmt.Sprintf(\"Object has %d inheritors inside\", root.Size())\n\t// Output:\n\t// Object has 1 inheritors inside\n}\n\n// Calculate AVG price from different types of objects, JSON from: https://goessner.net/articles/JsonPath/index.html#e3\nfunc TestExampleUnmarshal(t *testing.T) {\n\tdata := []byte(`{ \"store\": {\n    \"book\": [ \n      { \"category\": \"reference\",\n        \"author\": \"Nigel Rees\",\n        \"title\": \"Sayings of the Century\",\n        \"price\": 8.95\n      },\n      { \"category\": \"fiction\",\n        \"author\": \"Evelyn Waugh\",\n        \"title\": \"Sword of Honour\",\n        \"price\": 12.99\n      },\n      { \"category\": \"fiction\",\n        \"author\": \"Herman Melville\",\n        \"title\": \"Moby Dick\",\n        \"isbn\": \"0-553-21311-3\",\n        \"price\": 8.99\n      },\n      { \"category\": \"fiction\",\n        \"author\": \"J. R. R. Tolkien\",\n        \"title\": \"The Lord of the Rings\",\n        \"isbn\": \"0-395-19395-8\",\n        \"price\": 22.99\n      }\n    ],\n    \"bicycle\": { \"color\": \"red\",\n      \"price\": 19.95\n    },\n    \"tools\": null\n  }\n}`)\n\n\troot, err := Unmarshal(data)\n\tif err != nil {\n\t\tt.Errorf(\"error occurred when unmarshal\")\n\t}\n\n\tstore := root.MustKey(\"store\").MustObject()\n\n\tvar prices float64\n\tsize := 0\n\tfor _, objects := range store {\n\t\tif objects.IsArray() \u0026\u0026 objects.Size() \u003e 0 {\n\t\t\tsize += objects.Size()\n\t\t\tfor _, object := range objects.MustArray() {\n\t\t\t\tprices += object.MustKey(\"price\").MustNumeric()\n\t\t\t}\n\t\t} else if objects.IsObject() \u0026\u0026 objects.HasKey(\"price\") {\n\t\t\tsize++\n\t\t\tprices += objects.MustKey(\"price\").MustNumeric()\n\t\t}\n\t}\n\n\tresult := int(prices / float64(size))\n\tufmt.Sprintf(\"AVG price: %d\", result)\n}\n\nfunc TestNode_ExampleMust_panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdata := []byte(`{]`)\n\troot := Must(Unmarshal(data))\n\tufmt.Sprintf(\"Object has %d inheritors inside\", root.Size())\n}\n\nfunc TestNode_Path(t *testing.T) {\n\tdata := []byte(`{\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n          }\n      }`)\n\n\troot, err := Unmarshal(data)\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(): %s\", err.Error())\n\t\treturn\n\t}\n\n\tif root.Path() != \"$\" {\n\t\tt.Errorf(\"Wrong root.Path()\")\n\t}\n\n\telement := root.MustKey(\"Image\").MustKey(\"Thumbnail\").MustKey(\"Url\")\n\tif element.Path() != \"$['Image']['Thumbnail']['Url']\" {\n\t\tt.Errorf(\"Wrong path found: %s\", element.Path())\n\t}\n\n\tif (*Node)(nil).Path() != \"\" {\n\t\tt.Errorf(\"Wrong (nil).Path()\")\n\t}\n}\n\nfunc TestNode_Path2(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tnode *Node\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"Node with key\",\n\t\t\tnode: \u0026Node{\n\t\t\t\tprev: \u0026Node{},\n\t\t\t\tkey:  func() *string { s := \"key\"; return \u0026s }(),\n\t\t\t},\n\t\t\twant: \"$['key']\",\n\t\t},\n\t\t{\n\t\t\tname: \"Node with index\",\n\t\t\tnode: \u0026Node{\n\t\t\t\tprev:  \u0026Node{},\n\t\t\t\tindex: func() *int { i := 1; return \u0026i }(),\n\t\t\t},\n\t\t\twant: \"$[1]\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.node.Path(); got != tt.want {\n\t\t\t\tt.Errorf(\"Path() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_Root(t *testing.T) {\n\troot := \u0026Node{}\n\tchild := \u0026Node{prev: root}\n\tgrandChild := \u0026Node{prev: child}\n\n\ttests := []struct {\n\t\tname string\n\t\tnode *Node\n\t\twant *Node\n\t}{\n\t\t{\n\t\t\tname: \"Root node\",\n\t\t\tnode: root,\n\t\t\twant: root,\n\t\t},\n\t\t{\n\t\t\tname: \"Child node\",\n\t\t\tnode: child,\n\t\t\twant: root,\n\t\t},\n\t\t{\n\t\t\tname: \"Grandchild node\",\n\t\t\tnode: grandChild,\n\t\t\twant: root,\n\t\t},\n\t\t{\n\t\t\tname: \"Node is nil\",\n\t\t\tnode: nil,\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.node.root(); got != tt.want {\n\t\t\t\tt.Errorf(\"root() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc contains(slice []string, item string) bool {\n\tfor _, a := range slice {\n\t\tif a == item {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// ignore the sequence of keys by ordering them.\n// need to avoid import encoding/json and reflect package.\n// because gno does not support them for now.\n// TODO: use encoding/json to compare the result after if possible in gno.\nfunc isSameObject(a, b string) bool {\n\taPairs := strings.Split(strings.Trim(a, \"{}\"), \",\")\n\tbPairs := strings.Split(strings.Trim(b, \"{}\"), \",\")\n\n\taMap := make(map[string]string)\n\tbMap := make(map[string]string)\n\tfor _, pair := range aPairs {\n\t\tkv := strings.Split(pair, \":\")\n\t\tkey := strings.Trim(kv[0], `\"`)\n\t\tvalue := strings.Trim(kv[1], `\"`)\n\t\taMap[key] = value\n\t}\n\tfor _, pair := range bPairs {\n\t\tkv := strings.Split(pair, \":\")\n\t\tkey := strings.Trim(kv[0], `\"`)\n\t\tvalue := strings.Trim(kv[1], `\"`)\n\t\tbMap[key] = value\n\t}\n\n\taKeys := make([]string, 0, len(aMap))\n\tbKeys := make([]string, 0, len(bMap))\n\tfor k := range aMap {\n\t\taKeys = append(aKeys, k)\n\t}\n\n\tfor k := range bMap {\n\t\tbKeys = append(bKeys, k)\n\t}\n\n\tsort.Strings(aKeys)\n\tsort.Strings(bKeys)\n\n\tif len(aKeys) != len(bKeys) {\n\t\treturn false\n\t}\n\n\tfor i := range aKeys {\n\t\tif aKeys[i] != bKeys[i] {\n\t\t\treturn false\n\t\t}\n\n\t\tif aMap[aKeys[i]] != bMap[bKeys[i]] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc compareNodes(n1, n2 *Node) bool {\n\tif n1 == nil || n2 == nil {\n\t\treturn n1 == n2\n\t}\n\n\tif n1.key != n2.key {\n\t\treturn false\n\t}\n\n\tif !bytes.Equal(n1.data, n2.data) {\n\t\treturn false\n\t}\n\n\tif n1.index != n2.index {\n\t\treturn false\n\t}\n\n\tif n1.borders != n2.borders {\n\t\treturn false\n\t}\n\n\tif n1.modified != n2.modified {\n\t\treturn false\n\t}\n\n\tif n1.nodeType != n2.nodeType {\n\t\treturn false\n\t}\n\n\tif !compareNodes(n1.prev, n2.prev) {\n\t\treturn false\n\t}\n\n\tif len(n1.next) != len(n2.next) {\n\t\treturn false\n\t}\n\n\tfor k, v := range n1.next {\n\t\tif !compareNodes(v, n2.next[k]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n"},{"Name":"buffer_test.gno","Body":"package json\n\nimport (\n\t\"testing\"\n)\n\nfunc TestBufferCurrent(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tbuffer   *buffer\n\t\texpected byte\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname: \"Valid current byte\",\n\t\t\tbuffer: \u0026buffer{\n\t\t\t\tdata:   []byte(\"test\"),\n\t\t\t\tlength: 4,\n\t\t\t\tindex:  1,\n\t\t\t},\n\t\t\texpected: 'e',\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"EOF\",\n\t\t\tbuffer: \u0026buffer{\n\t\t\t\tdata:   []byte(\"test\"),\n\t\t\t\tlength: 4,\n\t\t\t\tindex:  4,\n\t\t\t},\n\t\t\texpected: 0,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.buffer.current()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"buffer.current() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"buffer.current() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBufferStep(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tbuffer  *buffer\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Valid step\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"EOF error\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 3},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := tt.buffer.step()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"buffer.step() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBufferNext(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tbuffer  *buffer\n\t\twant    byte\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Valid next byte\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\twant:    'e',\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"EOF error\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 3},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.buffer.next()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"buffer.next() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"buffer.next() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBufferSlice(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tbuffer  *buffer\n\t\tpos     int\n\t\twant    []byte\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Valid slice -- 0 characters\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\tpos:     0,\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Valid slice -- 1 character\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\tpos:     1,\n\t\t\twant:    []byte(\"t\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Valid slice -- 2 characters\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 1},\n\t\t\tpos:     2,\n\t\t\twant:    []byte(\"es\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Valid slice -- 3 characters\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\tpos:     3,\n\t\t\twant:    []byte(\"tes\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Valid slice -- 4 characters\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\tpos:     4,\n\t\t\twant:    []byte(\"test\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"EOF error\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 3},\n\t\t\tpos:     2,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.buffer.slice(tt.pos)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"buffer.slice() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"buffer.slice() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBufferMove(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tbuffer  *buffer\n\t\tpos     int\n\t\twantErr bool\n\t\twantIdx int\n\t}{\n\t\t{\n\t\t\tname:    \"Valid move\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 1},\n\t\t\tpos:     2,\n\t\t\twantErr: false,\n\t\t\twantIdx: 3,\n\t\t},\n\t\t{\n\t\t\tname:    \"Move beyond length\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 1},\n\t\t\tpos:     4,\n\t\t\twantErr: true,\n\t\t\twantIdx: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := tt.buffer.move(tt.pos)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"buffer.move() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t\tif tt.buffer.index != tt.wantIdx {\n\t\t\t\tt.Errorf(\"buffer.move() index = %v, want %v\", tt.buffer.index, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBufferSkip(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tbuffer  *buffer\n\t\tb       byte\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Skip byte\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\tb:       'e',\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Skip to EOF\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\tb:       'x',\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := tt.buffer.skip(tt.b)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"buffer.skip() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBufferSkipAny(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tbuffer  *buffer\n\t\ts       map[byte]bool\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Skip any valid byte\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\ts:       map[byte]bool{'e': true, 'o': true},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Skip any to EOF\",\n\t\t\tbuffer:  \u0026buffer{data: []byte(\"test\"), length: 4, index: 0},\n\t\t\ts:       map[byte]bool{'x': true, 'y': true},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := tt.buffer.skipAny(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"buffer.skipAny() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSkipToNextSignificantToken(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []byte\n\t\texpected int\n\t}{\n\t\t{\"No significant chars\", []byte(\"abc\"), 3},\n\t\t{\"One significant char at start\", []byte(\".abc\"), 0},\n\t\t{\"Significant char in middle\", []byte(\"ab.c\"), 2},\n\t\t{\"Multiple significant chars\", []byte(\"a$.c\"), 1},\n\t\t{\"Significant char at end\", []byte(\"abc$\"), 3},\n\t\t{\"Only significant chars\", []byte(\"$.\"), 0},\n\t\t{\"Empty string\", []byte(\"\"), 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tb := newBuffer(tt.input)\n\t\t\tb.skipToNextSignificantToken()\n\t\t\tif b.index != tt.expected {\n\t\t\t\tt.Errorf(\"after skipToNextSignificantToken(), got index = %v, want %v\", b.index, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc mockBuffer(s string) *buffer {\n\treturn newBuffer([]byte(s))\n}\n\nfunc TestSkipAndReturnIndex(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected int\n\t}{\n\t\t{\"StartOfString\", \"\", 0},\n\t\t{\"MiddleOfString\", \"abcdef\", 1},\n\t\t{\"EndOfString\", \"abc\", 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tbuf := mockBuffer(tt.input)\n\t\t\tgot, err := buf.skipAndReturnIndex()\n\t\t\tif err != nil \u0026\u0026 tt.input != \"\" { // Expect no error unless input is empty\n\t\t\t\tt.Errorf(\"skipAndReturnIndex() error = %v\", err)\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"skipAndReturnIndex() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSkipUntil(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\ttokens   map[byte]bool\n\t\texpected int\n\t}{\n\t\t{\"SkipToToken\", \"abcdefg\", map[byte]bool{'c': true}, 2},\n\t\t{\"SkipToEnd\", \"abcdefg\", map[byte]bool{'h': true}, 7},\n\t\t{\"SkipNone\", \"abcdefg\", map[byte]bool{'a': true}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tbuf := mockBuffer(tt.input)\n\t\t\tgot, err := buf.skipUntil(tt.tokens)\n\t\t\tif err != nil \u0026\u0026 got != len(tt.input) { // Expect error only if reached end without finding token\n\t\t\t\tt.Errorf(\"skipUntil() error = %v\", err)\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"skipUntil() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSliceFromIndices(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tstart    int\n\t\tend      int\n\t\texpected string\n\t}{\n\t\t{\"FullString\", \"abcdefg\", 0, 7, \"abcdefg\"},\n\t\t{\"Substring\", \"abcdefg\", 2, 5, \"cde\"},\n\t\t{\"OutOfBounds\", \"abcdefg\", 5, 10, \"fg\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tbuf := mockBuffer(tt.input)\n\t\t\tgot := buf.sliceFromIndices(tt.start, tt.end)\n\t\t\tif string(got) != tt.expected {\n\t\t\t\tt.Errorf(\"sliceFromIndices() = %v, want %v\", string(got), tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBufferToken(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tpath  string\n\t\tindex int\n\t\tisErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"Simple valid path\",\n\t\t\tpath:  \"@.length\",\n\t\t\tindex: 8,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"Path with array expr\",\n\t\t\tpath:  \"@['foo'].0.bar\",\n\t\t\tindex: 14,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"Path with array expr and simple fomula\",\n\t\t\tpath:  \"@['foo'].[(@.length - 1)].*\",\n\t\t\tindex: 27,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"Path with filter expr\",\n\t\t\tpath:  \"@['foo'].[?(@.bar == 1 \u0026 @.baz \u003c @.length)].*\",\n\t\t\tindex: 45,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"addition of foo and bar\",\n\t\t\tpath:  \"@.foo+@.bar\",\n\t\t\tindex: 11,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"logical AND of foo and bar\",\n\t\t\tpath:  \"@.foo \u0026\u0026 @.bar\",\n\t\t\tindex: 14,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"logical OR of foo and bar\",\n\t\t\tpath:  \"@.foo || @.bar\",\n\t\t\tindex: 14,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"accessing third element of foo\",\n\t\t\tpath:  \"@.foo,3\",\n\t\t\tindex: 7,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"accessing last element of array\",\n\t\t\tpath:  \"@.length-1\",\n\t\t\tindex: 10,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number 1\",\n\t\t\tpath:  \"1\",\n\t\t\tindex: 1,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"float\",\n\t\t\tpath:  \"3.1e4\",\n\t\t\tindex: 5,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"float with minus\",\n\t\t\tpath:  \"3.1e-4\",\n\t\t\tindex: 6,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"float with plus\",\n\t\t\tpath:  \"3.1e+4\",\n\t\t\tindex: 6,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative number\",\n\t\t\tpath:  \"-12345\",\n\t\t\tindex: 6,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative float\",\n\t\t\tpath:  \"-3.1e4\",\n\t\t\tindex: 6,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative float with minus\",\n\t\t\tpath:  \"-3.1e-4\",\n\t\t\tindex: 7,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative float with plus\",\n\t\t\tpath:  \"-3.1e+4\",\n\t\t\tindex: 7,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string number\",\n\t\t\tpath:  \"'12345'\",\n\t\t\tindex: 7,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string with backslash\",\n\t\t\tpath:  \"'foo \\\\'bar '\",\n\t\t\tindex: 12,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string with inner double quotes\",\n\t\t\tpath:  \"'foo \\\"bar \\\"'\",\n\t\t\tindex: 12,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parenthesis 1\",\n\t\t\tpath:  \"(@abc)\",\n\t\t\tindex: 6,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parenthesis 2\",\n\t\t\tpath:  \"[()]\",\n\t\t\tindex: 4,\n\t\t\tisErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parenthesis mismatch\",\n\t\t\tpath:  \"[(])\",\n\t\t\tindex: 2,\n\t\t\tisErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"parenthesis mismatch 2\",\n\t\t\tpath:  \"(\",\n\t\t\tindex: 1,\n\t\t\tisErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"parenthesis mismatch 3\",\n\t\t\tpath:  \"())]\",\n\t\t\tindex: 2,\n\t\t\tisErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"bracket mismatch\",\n\t\t\tpath:  \"[()\",\n\t\t\tindex: 3,\n\t\t\tisErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"bracket mismatch 2\",\n\t\t\tpath:  \"()]\",\n\t\t\tindex: 2,\n\t\t\tisErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"path does not close bracket\",\n\t\t\tpath:  \"@.foo[)\",\n\t\t\tindex: 6,\n\t\t\tisErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tbuf := newBuffer([]byte(tt.path))\n\n\t\t\terr := buf.pathToken()\n\t\t\tif tt.isErr {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected an error for path `%s`, but got none\", tt.path)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 tt.isErr {\n\t\t\t\tt.Errorf(\"Expected an error for path `%s`, but got none\", tt.path)\n\t\t\t}\n\n\t\t\tif buf.index != tt.index {\n\t\t\t\tt.Errorf(\"Expected final index %d, got %d (token: `%s`) for path `%s`\", tt.index, buf.index, string(buf.data[buf.index]), tt.path)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBufferFirst(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdata     []byte\n\t\texpected byte\n\t}{\n\t\t{\n\t\t\tname:     \"Valid first byte\",\n\t\t\tdata:     []byte(\"test\"),\n\t\t\texpected: 't',\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty buffer\",\n\t\t\tdata:     []byte(\"\"),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Whitespace buffer\",\n\t\t\tdata:     []byte(\"   \"),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace in middle\",\n\t\t\tdata:     []byte(\"hello world\"),\n\t\t\texpected: 'h',\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tb := newBuffer(tt.data)\n\n\t\t\tgot, err := b.first()\n\t\t\tif err != nil \u0026\u0026 tt.expected != 0 {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Expected first byte to be %q, got %q\", tt.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"Name":"parser.gno","Body":"package json\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"strconv\"\n\n\tel \"gno.land/p/demo/json/eisel_lemire\"\n)\n\nconst (\n\tabsMinInt64 = 1 \u003c\u003c 63\n\tmaxInt64    = absMinInt64 - 1\n\tmaxUint64   = 1\u003c\u003c64 - 1\n)\n\nconst unescapeStackBufSize = 64\n\n// PaseStringLiteral parses a string from the given byte slice.\nfunc ParseStringLiteral(data []byte) (string, error) {\n\tvar buf [unescapeStackBufSize]byte\n\n\tbf, err := Unescape(data, buf[:])\n\tif err != nil {\n\t\treturn \"\", errors.New(\"invalid string input found while parsing string value\")\n\t}\n\n\treturn string(bf), nil\n}\n\n// ParseBoolLiteral parses a boolean value from the given byte slice.\nfunc ParseBoolLiteral(data []byte) (bool, error) {\n\tswitch {\n\tcase bytes.Equal(data, trueLiteral):\n\t\treturn true, nil\n\tcase bytes.Equal(data, falseLiteral):\n\t\treturn false, nil\n\tdefault:\n\t\treturn false, errors.New(\"JSON Error: malformed boolean value found while parsing boolean value\")\n\t}\n}\n\n// PaseFloatLiteral parses a float64 from the given byte slice.\n//\n// It utilizes double-precision (64-bit) floating-point format as defined\n// by the IEEE 754 standard, providing a decimal precision of approximately 15 digits.\nfunc ParseFloatLiteral(bytes []byte) (float64, error) {\n\tif len(bytes) == 0 {\n\t\treturn -1, errors.New(\"JSON Error: empty byte slice found while parsing float value\")\n\t}\n\n\tneg, bytes := trimNegativeSign(bytes)\n\n\tvar exponentPart []byte\n\tfor i, c := range bytes {\n\t\tif lower(c) == 'e' {\n\t\t\texponentPart = bytes[i+1:]\n\t\t\tbytes = bytes[:i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\tman, exp10, err := extractMantissaAndExp10(bytes)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tif len(exponentPart) \u003e 0 {\n\t\texp, err := strconv.Atoi(string(exponentPart))\n\t\tif err != nil {\n\t\t\treturn -1, errors.New(\"JSON Error: invalid exponent value found while parsing float value\")\n\t\t}\n\t\texp10 += exp\n\t}\n\n\t// for fast float64 conversion\n\tf, success := el.EiselLemire64(man, exp10, neg)\n\tif !success {\n\t\treturn 0, nil\n\t}\n\n\treturn f, nil\n}\n\nfunc ParseIntLiteral(bytes []byte) (int64, error) {\n\tif len(bytes) == 0 {\n\t\treturn 0, errors.New(\"JSON Error: empty byte slice found while parsing integer value\")\n\t}\n\n\tneg, bytes := trimNegativeSign(bytes)\n\n\tvar n uint64 = 0\n\tfor _, c := range bytes {\n\t\tif notDigit(c) {\n\t\t\treturn 0, errors.New(\"JSON Error: non-digit characters found while parsing integer value\")\n\t\t}\n\n\t\tif n \u003e maxUint64/10 {\n\t\t\treturn 0, errors.New(\"JSON Error: numeric value exceeds the range limit\")\n\t\t}\n\n\t\tn *= 10\n\n\t\tn1 := n + uint64(c-'0')\n\t\tif n1 \u003c n {\n\t\t\treturn 0, errors.New(\"JSON Error: numeric value exceeds the range limit\")\n\t\t}\n\n\t\tn = n1\n\t}\n\n\tif n \u003e maxInt64 {\n\t\tif neg \u0026\u0026 n == absMinInt64 {\n\t\t\treturn -absMinInt64, nil\n\t\t}\n\n\t\treturn 0, errors.New(\"JSON Error: numeric value exceeds the range limit\")\n\t}\n\n\tif neg {\n\t\treturn -int64(n), nil\n\t}\n\n\treturn int64(n), nil\n}\n\n// extractMantissaAndExp10 parses a byte slice representing a decimal number and extracts the mantissa and the exponent of its base-10 representation.\n// It iterates through the bytes, constructing the mantissa by treating each byte as a digit.\n// If a decimal point is encountered, the function keeps track of the position of the decimal point to calculate the exponent.\n// The function ensures that:\n// - The number contains at most one decimal point.\n// - All characters in the byte slice are digits or a single decimal point.\n// - The resulting mantissa does not overflow a uint64.\nfunc extractMantissaAndExp10(bytes []byte) (uint64, int, error) {\n\tvar (\n\t\tman          uint64\n\t\texp10        int\n\t\tdecimalFound bool\n\t)\n\n\tfor _, c := range bytes {\n\t\tif c == dot {\n\t\t\tif decimalFound {\n\t\t\t\treturn 0, 0, errors.New(\"JSON Error: multiple decimal points found while parsing float value\")\n\t\t\t}\n\t\t\tdecimalFound = true\n\t\t\tcontinue\n\t\t}\n\n\t\tif notDigit(c) {\n\t\t\treturn 0, 0, errors.New(\"JSON Error: non-digit characters found while parsing integer value\")\n\t\t}\n\n\t\tdigit := uint64(c - '0')\n\n\t\tif man \u003e (maxUint64-digit)/10 {\n\t\t\treturn 0, 0, errors.New(\"JSON Error: numeric value exceeds the range limit\")\n\t\t}\n\n\t\tman = man*10 + digit\n\n\t\tif decimalFound {\n\t\t\texp10--\n\t\t}\n\t}\n\n\treturn man, exp10, nil\n}\n\nfunc trimNegativeSign(bytes []byte) (bool, []byte) {\n\tif bytes[0] == minus {\n\t\treturn true, bytes[1:]\n\t}\n\n\treturn false, bytes\n}\n\nfunc notDigit(c byte) bool {\n\treturn (c \u0026 0xF0) != 0x30\n}\n\n// lower converts a byte to lower case if it is an uppercase letter.\nfunc lower(c byte) byte {\n\treturn c | 0x20\n}\n"},{"Name":"decode_test.gno","Body":"package json\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"testing\"\n)\n\ntype testNode struct {\n\tname  string\n\tinput []byte\n\t_type ValueType\n\tvalue []byte\n}\n\nfunc simpleValid(test *testNode, t *testing.T) {\n\troot, err := Unmarshal(test.input)\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal(%s): %s\", test.input, err.Error())\n\t} else if root == nil {\n\t\tt.Errorf(\"Error on Unmarshal(%s): root is nil\", test.name)\n\t} else if root.nodeType != test._type {\n\t\tt.Errorf(\"Error on Unmarshal(%s): wrong type\", test.name)\n\t} else if !bytes.Equal(root.source(), test.value) {\n\t\tt.Errorf(\"Error on Unmarshal(%s): %s != %s\", test.name, root.source(), test.value)\n\t}\n}\n\nfunc simpleInvalid(test *testNode, t *testing.T) {\n\troot, err := Unmarshal(test.input)\n\tif err == nil {\n\t\tt.Errorf(\"Error on Unmarshal(%s): error expected, got '%s'\", test.name, root.source())\n\t} else if root != nil {\n\t\tt.Errorf(\"Error on Unmarshal(%s): root is not nil\", test.name)\n\t}\n}\n\nfunc simpleCorrupted(name string) *testNode {\n\treturn \u0026testNode{name: name, input: []byte(name)}\n}\n\nfunc TestUnmarshal_StringSimpleSuccess(t *testing.T) {\n\ttests := []*testNode{\n\t\t{name: \"blank\", input: []byte(\"\\\"\\\"\"), _type: String, value: []byte(\"\\\"\\\"\")},\n\t\t{name: \"char\", input: []byte(\"\\\"c\\\"\"), _type: String, value: []byte(\"\\\"c\\\"\")},\n\t\t{name: \"word\", input: []byte(\"\\\"cat\\\"\"), _type: String, value: []byte(\"\\\"cat\\\"\")},\n\t\t{name: \"spaces\", input: []byte(\"  \\\"good cat or dog\\\"\\r\\n \"), _type: String, value: []byte(\"\\\"good cat or dog\\\"\")},\n\t\t{name: \"backslash\", input: []byte(\"\\\"good \\\\\\\"cat\\\\\\\"\\\"\"), _type: String, value: []byte(\"\\\"good \\\\\\\"cat\\\\\\\"\\\"\")},\n\t\t{name: \"backslash 2\", input: []byte(\"\\\"good \\\\\\\\\\\\\\\"cat\\\\\\\"\\\"\"), _type: String, value: []byte(\"\\\"good \\\\\\\\\\\\\\\"cat\\\\\\\"\\\"\")},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleValid(test, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_NumericSimpleSuccess(t *testing.T) {\n\ttests := []*testNode{\n\t\t{name: \"1\", input: []byte(\"1\"), _type: Number, value: []byte(\"1\")},\n\t\t{name: \"-1\", input: []byte(\"-1\"), _type: Number, value: []byte(\"-1\")},\n\n\t\t{name: \"1234567890\", input: []byte(\"1234567890\"), _type: Number, value: []byte(\"1234567890\")},\n\t\t{name: \"-123\", input: []byte(\"-123\"), _type: Number, value: []byte(\"-123\")},\n\n\t\t{name: \"123.456\", input: []byte(\"123.456\"), _type: Number, value: []byte(\"123.456\")},\n\t\t{name: \"-123.456\", input: []byte(\"-123.456\"), _type: Number, value: []byte(\"-123.456\")},\n\n\t\t{name: \"1e3\", input: []byte(\"1e3\"), _type: Number, value: []byte(\"1e3\")},\n\t\t{name: \"1e+3\", input: []byte(\"1e+3\"), _type: Number, value: []byte(\"1e+3\")},\n\t\t{name: \"1e-3\", input: []byte(\"1e-3\"), _type: Number, value: []byte(\"1e-3\")},\n\t\t{name: \"-1e3\", input: []byte(\"-1e3\"), _type: Number, value: []byte(\"-1e3\")},\n\t\t{name: \"-1e-3\", input: []byte(\"-1e-3\"), _type: Number, value: []byte(\"-1e-3\")},\n\n\t\t{name: \"1.123e3456\", input: []byte(\"1.123e3456\"), _type: Number, value: []byte(\"1.123e3456\")},\n\t\t{name: \"1.123e-3456\", input: []byte(\"1.123e-3456\"), _type: Number, value: []byte(\"1.123e-3456\")},\n\t\t{name: \"-1.123e3456\", input: []byte(\"-1.123e3456\"), _type: Number, value: []byte(\"-1.123e3456\")},\n\t\t{name: \"-1.123e-3456\", input: []byte(\"-1.123e-3456\"), _type: Number, value: []byte(\"-1.123e-3456\")},\n\n\t\t{name: \"1E3\", input: []byte(\"1E3\"), _type: Number, value: []byte(\"1E3\")},\n\t\t{name: \"1E-3\", input: []byte(\"1E-3\"), _type: Number, value: []byte(\"1E-3\")},\n\t\t{name: \"-1E3\", input: []byte(\"-1E3\"), _type: Number, value: []byte(\"-1E3\")},\n\t\t{name: \"-1E-3\", input: []byte(\"-1E-3\"), _type: Number, value: []byte(\"-1E-3\")},\n\n\t\t{name: \"1.123E3456\", input: []byte(\"1.123E3456\"), _type: Number, value: []byte(\"1.123E3456\")},\n\t\t{name: \"1.123E-3456\", input: []byte(\"1.123E-3456\"), _type: Number, value: []byte(\"1.123E-3456\")},\n\t\t{name: \"-1.123E3456\", input: []byte(\"-1.123E3456\"), _type: Number, value: []byte(\"-1.123E3456\")},\n\t\t{name: \"-1.123E-3456\", input: []byte(\"-1.123E-3456\"), _type: Number, value: []byte(\"-1.123E-3456\")},\n\n\t\t{name: \"-1.123E-3456 with spaces\", input: []byte(\" \\r -1.123E-3456 \\t\\n\"), _type: Number, value: []byte(\"-1.123E-3456\")},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\troot, err := Unmarshal(test.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error on Unmarshal(%s): %s\", test.name, err.Error())\n\t\t\t} else if root == nil {\n\t\t\t\tt.Errorf(\"Error on Unmarshal(%s): root is nil\", test.name)\n\t\t\t} else if root.nodeType != test._type {\n\t\t\t\tt.Errorf(\"Error on Unmarshal(%s): wrong type\", test.name)\n\t\t\t} else if !bytes.Equal(root.source(), test.value) {\n\t\t\t\tt.Errorf(\"Error on Unmarshal(%s): %s != %s\", test.name, root.source(), test.value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_StringSimpleCorrupted(t *testing.T) {\n\ttests := []*testNode{\n\t\t{name: \"white NL\", input: []byte(\"\\\"foo\\nbar\\\"\")},\n\t\t{name: \"white R\", input: []byte(\"\\\"foo\\rbar\\\"\")},\n\t\t{name: \"white Tab\", input: []byte(\"\\\"foo\\tbar\\\"\")},\n\t\t{name: \"wrong quotes\", input: []byte(\"'cat'\")},\n\t\t{name: \"double string\", input: []byte(\"\\\"Hello\\\" \\\"World\\\"\")},\n\t\t{name: \"quotes in quotes\", input: []byte(\"\\\"good \\\"cat\\\"\\\"\")},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleInvalid(test, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_ObjectSimpleSuccess(t *testing.T) {\n\ttests := []*testNode{\n\t\t{name: \"{}\", input: []byte(\"{}\"), _type: Object, value: []byte(\"{}\")},\n\t\t{name: `{ \\r\\n }`, input: []byte(\"{ \\r\\n }\"), _type: Object, value: []byte(\"{ \\r\\n }\")},\n\t\t{name: `{\"key\":1}`, input: []byte(`{\"key\":1}`), _type: Object, value: []byte(`{\"key\":1}`)},\n\t\t{name: `{\"key\":true}`, input: []byte(`{\"key\":true}`), _type: Object, value: []byte(`{\"key\":true}`)},\n\t\t{name: `{\"key\":\"value\"}`, input: []byte(`{\"key\":\"value\"}`), _type: Object, value: []byte(`{\"key\":\"value\"}`)},\n\t\t{name: `{\"foo\":\"bar\",\"baz\":\"foo\"}`, input: []byte(`{\"foo\":\"bar\", \"baz\":\"foo\"}`), _type: Object, value: []byte(`{\"foo\":\"bar\", \"baz\":\"foo\"}`)},\n\t\t{name: \"spaces\", input: []byte(`  {  \"foo\"  :  \"bar\"  , \"baz\"   :   \"foo\"   }    `), _type: Object, value: []byte(`{  \"foo\"  :  \"bar\"  , \"baz\"   :   \"foo\"   }`)},\n\t\t{name: \"nested\", input: []byte(`{\"foo\":{\"bar\":{\"baz\":{}}}}`), _type: Object, value: []byte(`{\"foo\":{\"bar\":{\"baz\":{}}}}`)},\n\t\t{name: \"array\", input: []byte(`{\"array\":[{},{},{\"foo\":[{\"bar\":[\"baz\"]}]}]}`), _type: Object, value: []byte(`{\"array\":[{},{},{\"foo\":[{\"bar\":[\"baz\"]}]}]}`)},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleValid(test, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_ObjectSimpleCorrupted(t *testing.T) {\n\ttests := []*testNode{\n\t\tsimpleCorrupted(\"{{{\\\"key\\\": \\\"foo\\\"{{{{\"),\n\t\tsimpleCorrupted(\"}\"),\n\t\tsimpleCorrupted(\"{ }}}}}}}\"),\n\t\tsimpleCorrupted(\" }\"),\n\t\tsimpleCorrupted(\"{,}\"),\n\t\tsimpleCorrupted(\"{:}\"),\n\t\tsimpleCorrupted(\"{100000}\"),\n\t\tsimpleCorrupted(\"{1:1}\"),\n\t\tsimpleCorrupted(\"{'1:2,3:4'}\"),\n\t\tsimpleCorrupted(`{\"d\"}`),\n\t\tsimpleCorrupted(`{\"foo\"}`),\n\t\tsimpleCorrupted(`{\"foo\":}`),\n\t\tsimpleCorrupted(`{:\"foo\"}`),\n\t\tsimpleCorrupted(`{\"foo\":bar}`),\n\t\tsimpleCorrupted(`{\"foo\":\"bar\",}`),\n\t\tsimpleCorrupted(`{}{}`),\n\t\tsimpleCorrupted(`{},{}`),\n\t\tsimpleCorrupted(`{[},{]}`),\n\t\tsimpleCorrupted(`{[,]}`),\n\t\tsimpleCorrupted(`{[]}`),\n\t\tsimpleCorrupted(`{}1`),\n\t\tsimpleCorrupted(`1{}`),\n\t\tsimpleCorrupted(`{\"x\"::1}`),\n\t\tsimpleCorrupted(`{null:null}`),\n\t\tsimpleCorrupted(`{\"foo:\"bar\"}`),\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleInvalid(test, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_NullSimpleCorrupted(t *testing.T) {\n\ttests := []*testNode{\n\t\t{name: \"nul\", input: []byte(\"nul\")},\n\t\t{name: \"nil\", input: []byte(\"nil\")},\n\t\t{name: \"nill\", input: []byte(\"nill\")},\n\t\t{name: \"NILL\", input: []byte(\"NILL\")},\n\t\t{name: \"Null\", input: []byte(\"Null\")},\n\t\t{name: \"NULL\", input: []byte(\"NULL\")},\n\t\t{name: \"spaces\", input: []byte(\"Nu ll\")},\n\t\t{name: \"null1\", input: []byte(\"null1\")},\n\t\t{name: \"double\", input: []byte(\"null null\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleInvalid(test, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_BoolSimpleSuccess(t *testing.T) {\n\ttests := []*testNode{\n\t\t{name: \"lower true\", input: []byte(\"true\"), _type: Boolean, value: []byte(\"true\")},\n\t\t{name: \"lower false\", input: []byte(\"false\"), _type: Boolean, value: []byte(\"false\")},\n\t\t{name: \"spaces true\", input: []byte(\"  true\\r\\n \"), _type: Boolean, value: []byte(\"true\")},\n\t\t{name: \"spaces false\", input: []byte(\"  false\\r\\n \"), _type: Boolean, value: []byte(\"false\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleValid(test, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_BoolSimpleCorrupted(t *testing.T) {\n\ttests := []*testNode{\n\t\tsimpleCorrupted(\"tru\"),\n\t\tsimpleCorrupted(\"fals\"),\n\t\tsimpleCorrupted(\"tre\"),\n\t\tsimpleCorrupted(\"fal se\"),\n\t\tsimpleCorrupted(\"true false\"),\n\t\tsimpleCorrupted(\"True\"),\n\t\tsimpleCorrupted(\"TRUE\"),\n\t\tsimpleCorrupted(\"False\"),\n\t\tsimpleCorrupted(\"FALSE\"),\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleInvalid(test, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_ArraySimpleSuccess(t *testing.T) {\n\ttests := []*testNode{\n\t\t{name: \"[]\", input: []byte(\"[]\"), _type: Array, value: []byte(\"[]\")},\n\t\t{name: \"[1]\", input: []byte(\"[1]\"), _type: Array, value: []byte(\"[1]\")},\n\t\t{name: \"[1,2,3]\", input: []byte(\"[1,2,3]\"), _type: Array, value: []byte(\"[1,2,3]\")},\n\t\t{name: \"[1, 2, 3]\", input: []byte(\"[1, 2, 3]\"), _type: Array, value: []byte(\"[1, 2, 3]\")},\n\t\t{name: \"[1,[2],3]\", input: []byte(\"[1,[2],3]\"), _type: Array, value: []byte(\"[1,[2],3]\")},\n\t\t{name: \"[[],[],[]]\", input: []byte(\"[[],[],[]]\"), _type: Array, value: []byte(\"[[],[],[]]\")},\n\t\t{name: \"[[[[[]]]]]\", input: []byte(\"[[[[[]]]]]\"), _type: Array, value: []byte(\"[[[[[]]]]]\")},\n\t\t{name: \"[true,null,1,\\\"foo\\\",[]]\", input: []byte(\"[true,null,1,\\\"foo\\\",[]]\"), _type: Array, value: []byte(\"[true,null,1,\\\"foo\\\",[]]\")},\n\t\t{name: \"spaces\", input: []byte(\"\\n\\r [\\n1\\n ]\\r\\n\"), _type: Array, value: []byte(\"[\\n1\\n ]\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleValid(test, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshal_ArraySimpleCorrupted(t *testing.T) {\n\ttests := []*testNode{\n\t\tsimpleCorrupted(\"[,]\"),\n\t\tsimpleCorrupted(\"[]\\\\\"),\n\t\tsimpleCorrupted(\"[1,]\"),\n\t\tsimpleCorrupted(\"[[]\"),\n\t\tsimpleCorrupted(\"[]]\"),\n\t\tsimpleCorrupted(\"1[]\"),\n\t\tsimpleCorrupted(\"[]1\"),\n\t\tsimpleCorrupted(\"[[]1]\"),\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsimpleInvalid(test, t)\n\t\t})\n\t}\n}\n\n// Examples from https://json.org/example.html\nfunc TestUnmarshal(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue string\n\t}{\n\t\t{\n\t\t\tname: \"glossary\",\n\t\t\tvalue: `{\n\t\t\t\t\"glossary\": {\n\t\t\t\t\t\"title\": \"example glossary\",\n\t\t\t\t\t\"GlossDiv\": {\n\t\t\t\t\t\t\"title\": \"S\",\n\t\t\t\t\t\t\"GlossList\": {\n\t\t\t\t\t\t\t\"GlossEntry\": {\n\t\t\t\t\t\t\t\t\"ID\": \"SGML\",\n\t\t\t\t\t\t\t\t\"SortAs\": \"SGML\",\n\t\t\t\t\t\t\t\t\"GlossTerm\": \"Standard Generalized Markup Language\",\n\t\t\t\t\t\t\t\t\"Acronym\": \"SGML\",\n\t\t\t\t\t\t\t\t\"Abbrev\": \"ISO 8879:1986\",\n\t\t\t\t\t\t\t\t\"GlossDef\": {\n\t\t\t\t\t\t\t\t\t\"para\": \"A meta-markup language, used to create markup languages such as DocBook.\",\n\t\t\t\t\t\t\t\t\t\"GlossSeeAlso\": [\"GML\", \"XML\"]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"GlossSee\": \"markup\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"menu\",\n\t\t\tvalue: `{\"menu\": {\n\t\t\t\t\"id\": \"file\",\n\t\t\t\t\"value\": \"File\",\n\t\t\t\t\"popup\": {\n\t\t\t\t  \"menuitem\": [\n\t\t\t\t\t{\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"},\n\t\t\t\t\t{\"value\": \"Open\", \"onclick\": \"OpenDoc()\"},\n\t\t\t\t\t{\"value\": \"Close\", \"onclick\": \"CloseDoc()\"}\n\t\t\t\t  ]\n\t\t\t\t}\n\t\t\t}}`,\n\t\t},\n\t\t{\n\t\t\tname: \"widget\",\n\t\t\tvalue: `{\"widget\": {\n\t\t\t\t\"debug\": \"on\",\n\t\t\t\t\"window\": {\n\t\t\t\t\t\"title\": \"Sample Konfabulator Widget\",\n\t\t\t\t\t\"name\": \"main_window\",\n\t\t\t\t\t\"width\": 500,\n\t\t\t\t\t\"height\": 500\n\t\t\t\t},\n\t\t\t\t\"image\": { \n\t\t\t\t\t\"src\": \"Images/Sun.png\",\n\t\t\t\t\t\"name\": \"sun1\",\n\t\t\t\t\t\"hOffset\": 250,\n\t\t\t\t\t\"vOffset\": 250,\n\t\t\t\t\t\"alignment\": \"center\"\n\t\t\t\t},\n\t\t\t\t\"text\": {\n\t\t\t\t\t\"data\": \"Click Here\",\n\t\t\t\t\t\"size\": 36,\n\t\t\t\t\t\"style\": \"bold\",\n\t\t\t\t\t\"name\": \"text1\",\n\t\t\t\t\t\"hOffset\": 250,\n\t\t\t\t\t\"vOffset\": 100,\n\t\t\t\t\t\"alignment\": \"center\",\n\t\t\t\t\t\"onMouseUp\": \"sun1.opacity = (sun1.opacity / 100) * 90;\"\n\t\t\t\t}\n\t\t\t}}    `,\n\t\t},\n\t\t{\n\t\t\tname: \"web-app\",\n\t\t\tvalue: `{\"web-app\": {\n\t\t\t\t\"servlet\": [   \n\t\t\t\t  {\n\t\t\t\t\t\"servlet-name\": \"cofaxCDS\",\n\t\t\t\t\t\"servlet-class\": \"org.cofax.cds.CDSServlet\",\n\t\t\t\t\t\"init-param\": {\n\t\t\t\t\t  \"configGlossary:installationAt\": \"Philadelphia, PA\",\n\t\t\t\t\t  \"configGlossary:adminEmail\": \"ksm@pobox.com\",\n\t\t\t\t\t  \"configGlossary:poweredBy\": \"Cofax\",\n\t\t\t\t\t  \"configGlossary:poweredByIcon\": \"/images/cofax.gif\",\n\t\t\t\t\t  \"configGlossary:staticPath\": \"/content/static\",\n\t\t\t\t\t  \"templateProcessorClass\": \"org.cofax.WysiwygTemplate\",\n\t\t\t\t\t  \"templateLoaderClass\": \"org.cofax.FilesTemplateLoader\",\n\t\t\t\t\t  \"templatePath\": \"templates\",\n\t\t\t\t\t  \"templateOverridePath\": \"\",\n\t\t\t\t\t  \"defaultListTemplate\": \"listTemplate.htm\",\n\t\t\t\t\t  \"defaultFileTemplate\": \"articleTemplate.htm\",\n\t\t\t\t\t  \"useJSP\": false,\n\t\t\t\t\t  \"jspListTemplate\": \"listTemplate.jsp\",\n\t\t\t\t\t  \"jspFileTemplate\": \"articleTemplate.jsp\",\n\t\t\t\t\t  \"cachePackageTagsTrack\": 200,\n\t\t\t\t\t  \"cachePackageTagsStore\": 200,\n\t\t\t\t\t  \"cachePackageTagsRefresh\": 60,\n\t\t\t\t\t  \"cacheTemplatesTrack\": 100,\n\t\t\t\t\t  \"cacheTemplatesStore\": 50,\n\t\t\t\t\t  \"cacheTemplatesRefresh\": 15,\n\t\t\t\t\t  \"cachePagesTrack\": 200,\n\t\t\t\t\t  \"cachePagesStore\": 100,\n\t\t\t\t\t  \"cachePagesRefresh\": 10,\n\t\t\t\t\t  \"cachePagesDirtyRead\": 10,\n\t\t\t\t\t  \"searchEngineListTemplate\": \"forSearchEnginesList.htm\",\n\t\t\t\t\t  \"searchEngineFileTemplate\": \"forSearchEngines.htm\",\n\t\t\t\t\t  \"searchEngineRobotsDb\": \"WEB-INF/robots.db\",\n\t\t\t\t\t  \"useDataStore\": true,\n\t\t\t\t\t  \"dataStoreClass\": \"org.cofax.SqlDataStore\",\n\t\t\t\t\t  \"redirectionClass\": \"org.cofax.SqlRedirection\",\n\t\t\t\t\t  \"dataStoreName\": \"cofax\",\n\t\t\t\t\t  \"dataStoreDriver\": \"com.microsoft.jdbc.sqlserver.SQLServerDriver\",\n\t\t\t\t\t  \"dataStoreUrl\": \"jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon\",\n\t\t\t\t\t  \"dataStoreUser\": \"sa\",\n\t\t\t\t\t  \"dataStorePassword\": \"dataStoreTestQuery\",\n\t\t\t\t\t  \"dataStoreTestQuery\": \"SET NOCOUNT ON;select test='test';\",\n\t\t\t\t\t  \"dataStoreLogFile\": \"/usr/local/tomcat/logs/datastore.log\",\n\t\t\t\t\t  \"dataStoreInitConns\": 10,\n\t\t\t\t\t  \"dataStoreMaxConns\": 100,\n\t\t\t\t\t  \"dataStoreConnUsageLimit\": 100,\n\t\t\t\t\t  \"dataStoreLogLevel\": \"debug\",\n\t\t\t\t\t  \"maxUrlLength\": 500}},\n\t\t\t\t  {\n\t\t\t\t\t\"servlet-name\": \"cofaxEmail\",\n\t\t\t\t\t\"servlet-class\": \"org.cofax.cds.EmailServlet\",\n\t\t\t\t\t\"init-param\": {\n\t\t\t\t\t\"mailHost\": \"mail1\",\n\t\t\t\t\t\"mailHostOverride\": \"mail2\"}},\n\t\t\t\t  {\n\t\t\t\t\t\"servlet-name\": \"cofaxAdmin\",\n\t\t\t\t\t\"servlet-class\": \"org.cofax.cds.AdminServlet\"},\n\t\t\t   \n\t\t\t\t  {\n\t\t\t\t\t\"servlet-name\": \"fileServlet\",\n\t\t\t\t\t\"servlet-class\": \"org.cofax.cds.FileServlet\"},\n\t\t\t\t  {\n\t\t\t\t\t\"servlet-name\": \"cofaxTools\",\n\t\t\t\t\t\"servlet-class\": \"org.cofax.cms.CofaxToolsServlet\",\n\t\t\t\t\t\"init-param\": {\n\t\t\t\t\t  \"templatePath\": \"toolstemplates/\",\n\t\t\t\t\t  \"log\": 1,\n\t\t\t\t\t  \"logLocation\": \"/usr/local/tomcat/logs/CofaxTools.log\",\n\t\t\t\t\t  \"logMaxSize\": \"\",\n\t\t\t\t\t  \"dataLog\": 1,\n\t\t\t\t\t  \"dataLogLocation\": \"/usr/local/tomcat/logs/dataLog.log\",\n\t\t\t\t\t  \"dataLogMaxSize\": \"\",\n\t\t\t\t\t  \"removePageCache\": \"/content/admin/remove?cache=pages\u0026id=\",\n\t\t\t\t\t  \"removeTemplateCache\": \"/content/admin/remove?cache=templates\u0026id=\",\n\t\t\t\t\t  \"fileTransferFolder\": \"/usr/local/tomcat/webapps/content/fileTransferFolder\",\n\t\t\t\t\t  \"lookInContext\": 1,\n\t\t\t\t\t  \"adminGroupID\": 4,\n\t\t\t\t\t  \"betaServer\": true}}],\n\t\t\t\t\"servlet-mapping\": {\n\t\t\t\t  \"cofaxCDS\": \"/\",\n\t\t\t\t  \"cofaxEmail\": \"/cofaxutil/aemail/*\",\n\t\t\t\t  \"cofaxAdmin\": \"/admin/*\",\n\t\t\t\t  \"fileServlet\": \"/static/*\",\n\t\t\t\t  \"cofaxTools\": \"/tools/*\"},\n\t\t\t   \n\t\t\t\t\"taglib\": {\n\t\t\t\t  \"taglib-uri\": \"cofax.tld\",\n\t\t\t\t  \"taglib-location\": \"/WEB-INF/tlds/cofax.tld\"}}}`,\n\t\t},\n\t\t{\n\t\t\tname: \"SVG Viewer\",\n\t\t\tvalue: `{\"menu\": {\n\t\t\t\t\"header\": \"SVG Viewer\",\n\t\t\t\t\"items\": [\n\t\t\t\t\t{\"id\": \"Open\"},\n\t\t\t\t\t{\"id\": \"OpenNew\", \"label\": \"Open New\"},\n\t\t\t\t\tnull,\n\t\t\t\t\t{\"id\": \"ZoomIn\", \"label\": \"Zoom In\"},\n\t\t\t\t\t{\"id\": \"ZoomOut\", \"label\": \"Zoom Out\"},\n\t\t\t\t\t{\"id\": \"OriginalView\", \"label\": \"Original View\"},\n\t\t\t\t\tnull,\n\t\t\t\t\t{\"id\": \"Quality\"},\n\t\t\t\t\t{\"id\": \"Pause\"},\n\t\t\t\t\t{\"id\": \"Mute\"},\n\t\t\t\t\tnull,\n\t\t\t\t\t{\"id\": \"Find\", \"label\": \"Find...\"},\n\t\t\t\t\t{\"id\": \"FindAgain\", \"label\": \"Find Again\"},\n\t\t\t\t\t{\"id\": \"Copy\"},\n\t\t\t\t\t{\"id\": \"CopyAgain\", \"label\": \"Copy Again\"},\n\t\t\t\t\t{\"id\": \"CopySVG\", \"label\": \"Copy SVG\"},\n\t\t\t\t\t{\"id\": \"ViewSVG\", \"label\": \"View SVG\"},\n\t\t\t\t\t{\"id\": \"ViewSource\", \"label\": \"View Source\"},\n\t\t\t\t\t{\"id\": \"SaveAs\", \"label\": \"Save As\"},\n\t\t\t\t\tnull,\n\t\t\t\t\t{\"id\": \"Help\"},\n\t\t\t\t\t{\"id\": \"About\", \"label\": \"About Adobe CVG Viewer...\"}\n\t\t\t\t]\n\t\t\t}}`,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := Unmarshal([]byte(test.value))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error on Unmarshal: %s\", err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnmarshalSafe(t *testing.T) {\n\tjson := []byte(`{ \"store\": {\n\t\t\"book\": [ \n\t\t  { \"category\": \"reference\",\n\t\t\t\"author\": \"Nigel Rees\",\n\t\t\t\"title\": \"Sayings of the Century\",\n\t\t\t\"price\": 8.95\n\t\t  },\n\t\t  { \"category\": \"fiction\",\n\t\t\t\"author\": \"Evelyn Waugh\",\n\t\t\t\"title\": \"Sword of Honour\",\n\t\t\t\"price\": 12.99\n\t\t  },\n\t\t  { \"category\": \"fiction\",\n\t\t\t\"author\": \"Herman Melville\",\n\t\t\t\"title\": \"Moby Dick\",\n\t\t\t\"isbn\": \"0-553-21311-3\",\n\t\t\t\"price\": 8.99\n\t\t  },\n\t\t  { \"category\": \"fiction\",\n\t\t\t\"author\": \"J. R. R. Tolkien\",\n\t\t\t\"title\": \"The Lord of the Rings\",\n\t\t\t\"isbn\": \"0-395-19395-8\",\n\t\t\t\"price\": 22.99\n\t\t  }\n\t\t],\n\t\t\"bicycle\": {\n\t\t  \"color\": \"red\",\n\t\t  \"price\": 19.95\n\t\t}\n\t  }\n\t}`)\n\tsafe, err := UnmarshalSafe(json)\n\tif err != nil {\n\t\tt.Errorf(\"Error on Unmarshal: %s\", err.Error())\n\t} else if safe == nil {\n\t\tt.Errorf(\"Error on Unmarshal: safe is nil\")\n\t} else {\n\t\troot, err := Unmarshal(json)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error on Unmarshal: %s\", err.Error())\n\t\t} else if root == nil {\n\t\t\tt.Errorf(\"Error on Unmarshal: root is nil\")\n\t\t} else if !bytes.Equal(root.source(), safe.source()) {\n\t\t\tt.Errorf(\"Error on UnmarshalSafe: values not same\")\n\t\t}\n\t}\n}\n\n// BenchmarkGoStdUnmarshal-8   \t   61698\t     19350 ns/op\t     288 B/op\t       6 allocs/op\n// BenchmarkUnmarshal-8        \t   45620\t     26165 ns/op\t   21889 B/op\t     367 allocs/op\n//\n// type bench struct {\n// \tName  string `json:\"name\"`\n// \tValue int    `json:\"value\"`\n// }\n\n// func BenchmarkGoStdUnmarshal(b *testing.B) {\n// \tdata := []byte(webApp)\n// \tfor i := 0; i \u003c b.N; i++ {\n// \t\terr := json.Unmarshal(data, \u0026bench{})\n// \t\tif err != nil {\n// \t\t\tb.Fatal(err)\n// \t\t}\n// \t}\n// }\n\n// func BenchmarkUnmarshal(b *testing.B) {\n// \tdata := []byte(webApp)\n// \tfor i := 0; i \u003c b.N; i++ {\n// \t\t_, err := Unmarshal(data)\n// \t\tif err != nil {\n// \t\t\tb.Fatal(err)\n// \t\t}\n// \t}\n// }\n"},{"Name":"indent_test.gno","Body":"package json\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestIndentJSON(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []byte\n\t\tindent   string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    []byte(`{}`),\n\t\t\tindent:   \"  \",\n\t\t\texpected: []byte(`{}`),\n\t\t},\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    []byte(`[]`),\n\t\t\tindent:   \"  \",\n\t\t\texpected: []byte(`[]`),\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    []byte(`{{}}`),\n\t\t\tindent:   \"\\t\",\n\t\t\texpected: []byte(\"{\\n\\t\\t{}\\n}\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    []byte(`[[[]]]`),\n\t\t\tindent:   \"\\t\",\n\t\t\texpected: []byte(\"[[\\n\\t\\t[\\n\\t\\t\\t\\t\\n\\t\\t]\\n]]\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"top-level array\",\n\t\t\tinput:    []byte(`[\"apple\",\"banana\",\"cherry\"]`),\n\t\t\tindent:   \"\\t\",\n\t\t\texpected: []byte(`[\"apple\",\"banana\",\"cherry\"]`),\n\t\t},\n\t\t{\n\t\t\tname:     \"array of arrays\",\n\t\t\tinput:    []byte(`[\"apple\",[\"banana\",\"cherry\"],\"date\"]`),\n\t\t\tindent:   \"  \",\n\t\t\texpected: []byte(\"[\\\"apple\\\",[\\n    \\\"banana\\\",\\n    \\\"cherry\\\"\\n],\\\"date\\\"]\"),\n\t\t},\n\n\t\t{\n\t\t\tname:     \"nested array in object\",\n\t\t\tinput:    []byte(`{\"fruits\":[\"apple\",[\"banana\",\"cherry\"],\"date\"]}`),\n\t\t\tindent:   \"  \",\n\t\t\texpected: []byte(\"{\\n    \\\"fruits\\\": [\\\"apple\\\",[\\n        \\\"banana\\\",\\n        \\\"cherry\\\"\\n    ],\\\"date\\\"]\\n}\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"complex nested structure\",\n\t\t\tinput:    []byte(`{\"data\":{\"array\":[1,2,3],\"bool\":true,\"nestedArray\":[[\"a\",\"b\"],\"c\"]}}`),\n\t\t\tindent:   \"  \",\n\t\t\texpected: []byte(\"{\\n    \\\"data\\\": {\\n        \\\"array\\\": [1,2,3],\\\"bool\\\": true,\\\"nestedArray\\\": [[\\n            \\\"a\\\",\\n            \\\"b\\\"\\n        ],\\\"c\\\"]\\n    }\\n}\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"custom ident character\",\n\t\t\tinput:    []byte(`{\"fruits\":[\"apple\",[\"banana\",\"cherry\"],\"date\"]}`),\n\t\t\tindent:   \"*\",\n\t\t\texpected: []byte(\"{\\n**\\\"fruits\\\": [\\\"apple\\\",[\\n****\\\"banana\\\",\\n****\\\"cherry\\\"\\n**],\\\"date\\\"]\\n}\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual, err := Indent(tt.input, tt.indent)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"IndentJSON() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !bytes.Equal(actual, tt.expected) {\n\t\t\t\tt.Errorf(\"IndentJSON() = %q, want %q\", actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"Name":"encode.gno","Body":"package json\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"math\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/json/ryu\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// Marshal returns the JSON encoding of a Node.\nfunc Marshal(node *Node) ([]byte, error) {\n\tvar (\n\t\tbuf  bytes.Buffer\n\t\tsVal string\n\t\tbVal bool\n\t\tnVal float64\n\t\toVal []byte\n\t\terr  error\n\t)\n\n\tif node == nil {\n\t\treturn nil, errors.New(\"node is nil\")\n\t}\n\n\tif !node.modified \u0026\u0026 !node.ready() {\n\t\treturn nil, errors.New(\"node is not ready\")\n\t}\n\n\tif !node.modified \u0026\u0026 node.ready() {\n\t\tbuf.Write(node.source())\n\t}\n\n\tif node.modified {\n\t\tswitch node.nodeType {\n\t\tcase Null:\n\t\t\tbuf.Write(nullLiteral)\n\n\t\tcase Number:\n\t\t\tnVal, err = node.GetNumeric()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// ufmt does not support %g. by doing so, we need to check if the number is an integer\n\t\t\t// after then, apply the correct format for each float and integer numbers.\n\t\t\tif math.Mod(nVal, 1.0) == 0 {\n\t\t\t\t// must convert float to integer. otherwise it will be overflowed.\n\t\t\t\tnum := ufmt.Sprintf(\"%d\", int(nVal))\n\t\t\t\tbuf.WriteString(num)\n\t\t\t} else {\n\t\t\t\t// use ryu algorithm to convert float to string\n\t\t\t\tnum := ryu.FormatFloat64(nVal)\n\t\t\t\tbuf.WriteString(num)\n\t\t\t}\n\n\t\tcase String:\n\t\t\tsVal, err = node.GetString()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tquoted := ufmt.Sprintf(\"%s\", strconv.Quote(sVal))\n\t\t\tbuf.WriteString(quoted)\n\n\t\tcase Boolean:\n\t\t\tbVal, err = node.GetBool()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tbStr := ufmt.Sprintf(\"%t\", bVal)\n\t\t\tbuf.WriteString(bStr)\n\n\t\tcase Array:\n\t\t\tbuf.WriteByte(bracketOpen)\n\n\t\t\tfor i := 0; i \u003c len(node.next); i++ {\n\t\t\t\tif i != 0 {\n\t\t\t\t\tbuf.WriteByte(comma)\n\t\t\t\t}\n\n\t\t\t\telem, ok := node.next[strconv.Itoa(i)]\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, ufmt.Errorf(\"array element %d is not found\", i)\n\t\t\t\t}\n\n\t\t\t\toVal, err = Marshal(elem)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tbuf.Write(oVal)\n\t\t\t}\n\n\t\t\tbuf.WriteByte(bracketClose)\n\n\t\tcase Object:\n\t\t\tbuf.WriteByte(curlyOpen)\n\n\t\t\tbVal = false\n\t\t\tfor k, v := range node.next {\n\t\t\t\tif bVal {\n\t\t\t\t\tbuf.WriteByte(comma)\n\t\t\t\t} else {\n\t\t\t\t\tbVal = true\n\t\t\t\t}\n\n\t\t\t\tkey := ufmt.Sprintf(\"%s\", strconv.Quote(k))\n\t\t\t\tbuf.WriteString(key)\n\t\t\t\tbuf.WriteByte(colon)\n\n\t\t\t\toVal, err = Marshal(v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tbuf.Write(oVal)\n\t\t\t}\n\n\t\t\tbuf.WriteByte(curlyClose)\n\t\t}\n\t}\n\n\treturn buf.Bytes(), nil\n}\n"},{"Name":"indent.gno","Body":"package json\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n)\n\n// indentGrowthFactor specifies the growth factor of indenting JSON input.\n// A factor no higher than 2 ensures that wasted space never exceeds 50%.\nconst indentGrowthFactor = 2\n\n// IndentJSON takes a JSON byte slice and a string for indentation,\n// then formats the JSON according to the specified indent string.\n// This function applies indentation rules as follows:\n//\n// 1. For top-level arrays and objects, no additional indentation is applied.\n//\n// 2. For nested structures like arrays within arrays or objects, indentation increases.\n//\n// 3. Indentation is applied after opening brackets ('[' or '{') and before closing brackets (']' or '}').\n//\n// 4. Commas and colons are handled appropriately to maintain valid JSON format.\n//\n// 5. Nested arrays within objects or arrays receive new lines and indentation based on their depth level.\n//\n// The function returns the formatted JSON as a byte slice and an error if any issues occurred during formatting.\nfunc Indent(data []byte, indent string) ([]byte, error) {\n\tvar (\n\t\tout        bytes.Buffer\n\t\tlevel      int\n\t\tinArray    bool\n\t\tarrayDepth int\n\t)\n\n\tfor i := 0; i \u003c len(data); i++ {\n\t\tc := data[i] // current character\n\n\t\tswitch c {\n\t\tcase bracketOpen:\n\t\t\tarrayDepth++\n\t\t\tif arrayDepth \u003e 1 {\n\t\t\t\tlevel++ // increase the level if it's nested array\n\t\t\t\tinArray = true\n\n\t\t\t\tif err := out.WriteByte(c); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tif err := writeNewlineAndIndent(\u0026out, level, indent); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// case of the top-level array\n\t\t\t\tinArray = true\n\t\t\t\tif err := out.WriteByte(c); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase bracketClose:\n\t\t\tif inArray \u0026\u0026 arrayDepth \u003e 1 { // nested array\n\t\t\t\tlevel--\n\t\t\t\tif err := writeNewlineAndIndent(\u0026out, level, indent); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tarrayDepth--\n\t\t\tif arrayDepth == 0 {\n\t\t\t\tinArray = false\n\t\t\t}\n\n\t\t\tif err := out.WriteByte(c); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\tcase curlyOpen:\n\t\t\t// check if the empty object or array\n\t\t\t// we don't need to apply the indent when it's empty containers.\n\t\t\tif i+1 \u003c len(data) \u0026\u0026 data[i+1] == curlyClose {\n\t\t\t\tif err := out.WriteByte(c); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\ti++ // skip next character\n\t\t\t\tif err := out.WriteByte(data[i]); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err := out.WriteByte(c); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tlevel++\n\t\t\t\tif err := writeNewlineAndIndent(\u0026out, level, indent); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase curlyClose:\n\t\t\tlevel--\n\t\t\tif err := writeNewlineAndIndent(\u0026out, level, indent); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err := out.WriteByte(c); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\tcase comma, colon:\n\t\t\tif err := out.WriteByte(c); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif inArray \u0026\u0026 arrayDepth \u003e 1 { // nested array\n\t\t\t\tif err := writeNewlineAndIndent(\u0026out, level, indent); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else if c == colon {\n\t\t\t\tif err := out.WriteByte(' '); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif err := out.WriteByte(c); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out.Bytes(), nil\n}\n\nfunc writeNewlineAndIndent(out *bytes.Buffer, level int, indent string) error {\n\tif err := out.WriteByte('\\n'); err != nil {\n\t\treturn err\n\t}\n\n\tidt := strings.Repeat(indent, level*indentGrowthFactor)\n\tif _, err := out.WriteString(idt); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"ilRTaF6H+EsQuOeH28314gi5niGBMzXWVq/PNuEcmV0encdneHYR61sAt/fLmz8BQwAUnHw1xhRrDMDzUUcBCg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372628"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"eisel_lemire","Path":"gno.land/p/demo/json/eisel_lemire","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"eisel_lemire.gno","Body":"// Copyright 2020 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage eisel_lemire\n\n// This file implements the Eisel-Lemire ParseFloat algorithm, published in\n// 2020 and discussed extensively at\n// https://nigeltao.github.io/blog/2020/eisel-lemire.html\n//\n// The original C++ implementation is at\n// https://github.com/lemire/fast_double_parser/blob/644bef4306059d3be01a04e77d3cc84b379c596f/include/fast_double_parser.h#L840\n//\n// This Go re-implementation closely follows the C re-implementation at\n// https://github.com/google/wuffs/blob/ba3818cb6b473a2ed0b38ecfc07dbbd3a97e8ae7/internal/cgen/base/floatconv-submodule-code.c#L990\n//\n// Additional testing (on over several million test strings) is done by\n// https://github.com/nigeltao/parse-number-fxx-test-data/blob/5280dcfccf6d0b02a65ae282dad0b6d9de50e039/script/test-go-strconv.go\n\nimport (\n\t\"math\"\n\t\"math/bits\"\n)\n\nconst (\n\tfloat32ExponentBias = 127\n\tfloat64ExponentBias = 1023\n)\n\n// eiselLemire64 parses a floating-point number from its mantissa and exponent representation.\n// This implementation is based on the Eisel-Lemire ParseFloat algorithm, which is efficient\n// and precise for converting strings to floating-point numbers.\n//\n// Arguments:\n// man (uint64): The mantissa part of the floating-point number.\n// exp10 (int): The exponent part, representing the power of 10.\n// neg (bool): Indicates if the number is negative.\n//\n// Returns:\n// f (float64): The parsed floating-point number.\n// ok (bool): Indicates whether the parsing was successful.\n//\n// The function starts by handling special cases, such as zero mantissa.\n// It then checks if the exponent is within the allowed range.\n// After that, it normalizes the mantissa by left-shifting it to fill\n// the leading zeros. This is followed by the main algorithm logic that\n// converts the normalized mantissa and exponent into a 64-bit floating-point number.\n// The function returns this number along with a boolean indicating the success of the operation.\nfunc EiselLemire64(man uint64, exp10 int, neg bool) (f float64, ok bool) {\n\t// The terse comments in this function body refer to sections of the\n\t// https://nigeltao.github.io/blog/2020/eisel-lemire.html blog post.\n\n\t// Exp10 Range.\n\tif man == 0 {\n\t\tif neg {\n\t\t\tf = math.Float64frombits(0x80000000_00000000) // Negative zero.\n\t\t}\n\n\t\treturn f, true\n\t}\n\n\tif exp10 \u003c detailedPowersOfTenMinExp10 || detailedPowersOfTenMaxExp10 \u003c exp10 {\n\t\treturn 0, false\n\t}\n\n\t// Normalization.\n\tclz := bits.LeadingZeros64(man)\n\tman \u003c\u003c= uint(clz)\n\tretExp2 := uint64(217706*exp10\u003e\u003e16+64+float64ExponentBias) - uint64(clz)\n\n\t// Multiplication.\n\txHi, xLo := bits.Mul64(man, detailedPowersOfTen[exp10-detailedPowersOfTenMinExp10][1])\n\n\t// Wider Approximation.\n\tif xHi\u00260x1FF == 0x1FF \u0026\u0026 xLo+man \u003c man {\n\t\tyHi, yLo := bits.Mul64(man, detailedPowersOfTen[exp10-detailedPowersOfTenMinExp10][0])\n\t\tmergedHi, mergedLo := xHi, xLo+yHi\n\t\tif mergedLo \u003c xLo {\n\t\t\tmergedHi++\n\t\t}\n\n\t\tif mergedHi\u00260x1FF == 0x1FF \u0026\u0026 mergedLo+1 == 0 \u0026\u0026 yLo+man \u003c man {\n\t\t\treturn 0, false\n\t\t}\n\n\t\txHi, xLo = mergedHi, mergedLo\n\t}\n\n\t// Shifting to 54 Bits.\n\tmsb := xHi \u003e\u003e 63\n\tretMantissa := xHi \u003e\u003e (msb + 9)\n\tretExp2 -= 1 ^ msb\n\n\t// Half-way Ambiguity.\n\tif xLo == 0 \u0026\u0026 xHi\u00260x1FF == 0 \u0026\u0026 retMantissa\u00263 == 1 {\n\t\treturn 0, false\n\t}\n\n\t// From 54 to 53 Bits.\n\tretMantissa += retMantissa \u0026 1\n\tretMantissa \u003e\u003e= 1\n\tif retMantissa\u003e\u003e53 \u003e 0 {\n\t\tretMantissa \u003e\u003e= 1\n\t\tretExp2 += 1\n\t}\n\n\t// retExp2 is a uint64. Zero or underflow means that we're in subnormal\n\t// float64 space. 0x7FF or above means that we're in Inf/NaN float64 space.\n\t//\n\t// The if block is equivalent to (but has fewer branches than):\n\t//   if retExp2 \u003c= 0 || retExp2 \u003e= 0x7FF { etc }\n\tif retExp2-1 \u003e= 0x7FF-1 {\n\t\treturn 0, false\n\t}\n\n\tretBits := retExp2\u003c\u003c52 | retMantissa\u00260x000FFFFF_FFFFFFFF\n\tif neg {\n\t\tretBits |= 0x80000000_00000000\n\t}\n\n\treturn math.Float64frombits(retBits), true\n}\n\n// detailedPowersOfTen{Min,Max}Exp10 is the power of 10 represented by the\n// first and last rows of detailedPowersOfTen. Both bounds are inclusive.\nconst (\n\tdetailedPowersOfTenMinExp10 = -348\n\tdetailedPowersOfTenMaxExp10 = +347\n)\n\n// detailedPowersOfTen contains 128-bit mantissa approximations (rounded down)\n// to the powers of 10. For example:\n//\n//   - 1e43  (0xE596B7B0_C643C719                   * (2 ** 79))\n//   - 1e43 = (0xE596B7B0_C643C719_6D9CCD05_D0000000 * (2 ** 15))\n//\n// The mantissas are explicitly listed. The exponents are implied by a linear\n// expression with slope 217706.0/65536.0  log(10)/log(2).\n//\n// The table was generated by\n// https://github.com/google/wuffs/blob/ba3818cb6b473a2ed0b38ecfc07dbbd3a97e8ae7/script/print-mpb-powers-of-10.go\nvar detailedPowersOfTen = [...][2]uint64{\n\t{0x1732C869CD60E453, 0xFA8FD5A0081C0288}, // 1e-348\n\t{0x0E7FBD42205C8EB4, 0x9C99E58405118195}, // 1e-347\n\t{0x521FAC92A873B261, 0xC3C05EE50655E1FA}, // 1e-346\n\t{0xE6A797B752909EF9, 0xF4B0769E47EB5A78}, // 1e-345\n\t{0x9028BED2939A635C, 0x98EE4A22ECF3188B}, // 1e-344\n\t{0x7432EE873880FC33, 0xBF29DCABA82FDEAE}, // 1e-343\n\t{0x113FAA2906A13B3F, 0xEEF453D6923BD65A}, // 1e-342\n\t{0x4AC7CA59A424C507, 0x9558B4661B6565F8}, // 1e-341\n\t{0x5D79BCF00D2DF649, 0xBAAEE17FA23EBF76}, // 1e-340\n\t{0xF4D82C2C107973DC, 0xE95A99DF8ACE6F53}, // 1e-339\n\t{0x79071B9B8A4BE869, 0x91D8A02BB6C10594}, // 1e-338\n\t{0x9748E2826CDEE284, 0xB64EC836A47146F9}, // 1e-337\n\t{0xFD1B1B2308169B25, 0xE3E27A444D8D98B7}, // 1e-336\n\t{0xFE30F0F5E50E20F7, 0x8E6D8C6AB0787F72}, // 1e-335\n\t{0xBDBD2D335E51A935, 0xB208EF855C969F4F}, // 1e-334\n\t{0xAD2C788035E61382, 0xDE8B2B66B3BC4723}, // 1e-333\n\t{0x4C3BCB5021AFCC31, 0x8B16FB203055AC76}, // 1e-332\n\t{0xDF4ABE242A1BBF3D, 0xADDCB9E83C6B1793}, // 1e-331\n\t{0xD71D6DAD34A2AF0D, 0xD953E8624B85DD78}, // 1e-330\n\t{0x8672648C40E5AD68, 0x87D4713D6F33AA6B}, // 1e-329\n\t{0x680EFDAF511F18C2, 0xA9C98D8CCB009506}, // 1e-328\n\t{0x0212BD1B2566DEF2, 0xD43BF0EFFDC0BA48}, // 1e-327\n\t{0x014BB630F7604B57, 0x84A57695FE98746D}, // 1e-326\n\t{0x419EA3BD35385E2D, 0xA5CED43B7E3E9188}, // 1e-325\n\t{0x52064CAC828675B9, 0xCF42894A5DCE35EA}, // 1e-324\n\t{0x7343EFEBD1940993, 0x818995CE7AA0E1B2}, // 1e-323\n\t{0x1014EBE6C5F90BF8, 0xA1EBFB4219491A1F}, // 1e-322\n\t{0xD41A26E077774EF6, 0xCA66FA129F9B60A6}, // 1e-321\n\t{0x8920B098955522B4, 0xFD00B897478238D0}, // 1e-320\n\t{0x55B46E5F5D5535B0, 0x9E20735E8CB16382}, // 1e-319\n\t{0xEB2189F734AA831D, 0xC5A890362FDDBC62}, // 1e-318\n\t{0xA5E9EC7501D523E4, 0xF712B443BBD52B7B}, // 1e-317\n\t{0x47B233C92125366E, 0x9A6BB0AA55653B2D}, // 1e-316\n\t{0x999EC0BB696E840A, 0xC1069CD4EABE89F8}, // 1e-315\n\t{0xC00670EA43CA250D, 0xF148440A256E2C76}, // 1e-314\n\t{0x380406926A5E5728, 0x96CD2A865764DBCA}, // 1e-313\n\t{0xC605083704F5ECF2, 0xBC807527ED3E12BC}, // 1e-312\n\t{0xF7864A44C633682E, 0xEBA09271E88D976B}, // 1e-311\n\t{0x7AB3EE6AFBE0211D, 0x93445B8731587EA3}, // 1e-310\n\t{0x5960EA05BAD82964, 0xB8157268FDAE9E4C}, // 1e-309\n\t{0x6FB92487298E33BD, 0xE61ACF033D1A45DF}, // 1e-308\n\t{0xA5D3B6D479F8E056, 0x8FD0C16206306BAB}, // 1e-307\n\t{0x8F48A4899877186C, 0xB3C4F1BA87BC8696}, // 1e-306\n\t{0x331ACDABFE94DE87, 0xE0B62E2929ABA83C}, // 1e-305\n\t{0x9FF0C08B7F1D0B14, 0x8C71DCD9BA0B4925}, // 1e-304\n\t{0x07ECF0AE5EE44DD9, 0xAF8E5410288E1B6F}, // 1e-303\n\t{0xC9E82CD9F69D6150, 0xDB71E91432B1A24A}, // 1e-302\n\t{0xBE311C083A225CD2, 0x892731AC9FAF056E}, // 1e-301\n\t{0x6DBD630A48AAF406, 0xAB70FE17C79AC6CA}, // 1e-300\n\t{0x092CBBCCDAD5B108, 0xD64D3D9DB981787D}, // 1e-299\n\t{0x25BBF56008C58EA5, 0x85F0468293F0EB4E}, // 1e-298\n\t{0xAF2AF2B80AF6F24E, 0xA76C582338ED2621}, // 1e-297\n\t{0x1AF5AF660DB4AEE1, 0xD1476E2C07286FAA}, // 1e-296\n\t{0x50D98D9FC890ED4D, 0x82CCA4DB847945CA}, // 1e-295\n\t{0xE50FF107BAB528A0, 0xA37FCE126597973C}, // 1e-294\n\t{0x1E53ED49A96272C8, 0xCC5FC196FEFD7D0C}, // 1e-293\n\t{0x25E8E89C13BB0F7A, 0xFF77B1FCBEBCDC4F}, // 1e-292\n\t{0x77B191618C54E9AC, 0x9FAACF3DF73609B1}, // 1e-291\n\t{0xD59DF5B9EF6A2417, 0xC795830D75038C1D}, // 1e-290\n\t{0x4B0573286B44AD1D, 0xF97AE3D0D2446F25}, // 1e-289\n\t{0x4EE367F9430AEC32, 0x9BECCE62836AC577}, // 1e-288\n\t{0x229C41F793CDA73F, 0xC2E801FB244576D5}, // 1e-287\n\t{0x6B43527578C1110F, 0xF3A20279ED56D48A}, // 1e-286\n\t{0x830A13896B78AAA9, 0x9845418C345644D6}, // 1e-285\n\t{0x23CC986BC656D553, 0xBE5691EF416BD60C}, // 1e-284\n\t{0x2CBFBE86B7EC8AA8, 0xEDEC366B11C6CB8F}, // 1e-283\n\t{0x7BF7D71432F3D6A9, 0x94B3A202EB1C3F39}, // 1e-282\n\t{0xDAF5CCD93FB0CC53, 0xB9E08A83A5E34F07}, // 1e-281\n\t{0xD1B3400F8F9CFF68, 0xE858AD248F5C22C9}, // 1e-280\n\t{0x23100809B9C21FA1, 0x91376C36D99995BE}, // 1e-279\n\t{0xABD40A0C2832A78A, 0xB58547448FFFFB2D}, // 1e-278\n\t{0x16C90C8F323F516C, 0xE2E69915B3FFF9F9}, // 1e-277\n\t{0xAE3DA7D97F6792E3, 0x8DD01FAD907FFC3B}, // 1e-276\n\t{0x99CD11CFDF41779C, 0xB1442798F49FFB4A}, // 1e-275\n\t{0x40405643D711D583, 0xDD95317F31C7FA1D}, // 1e-274\n\t{0x482835EA666B2572, 0x8A7D3EEF7F1CFC52}, // 1e-273\n\t{0xDA3243650005EECF, 0xAD1C8EAB5EE43B66}, // 1e-272\n\t{0x90BED43E40076A82, 0xD863B256369D4A40}, // 1e-271\n\t{0x5A7744A6E804A291, 0x873E4F75E2224E68}, // 1e-270\n\t{0x711515D0A205CB36, 0xA90DE3535AAAE202}, // 1e-269\n\t{0x0D5A5B44CA873E03, 0xD3515C2831559A83}, // 1e-268\n\t{0xE858790AFE9486C2, 0x8412D9991ED58091}, // 1e-267\n\t{0x626E974DBE39A872, 0xA5178FFF668AE0B6}, // 1e-266\n\t{0xFB0A3D212DC8128F, 0xCE5D73FF402D98E3}, // 1e-265\n\t{0x7CE66634BC9D0B99, 0x80FA687F881C7F8E}, // 1e-264\n\t{0x1C1FFFC1EBC44E80, 0xA139029F6A239F72}, // 1e-263\n\t{0xA327FFB266B56220, 0xC987434744AC874E}, // 1e-262\n\t{0x4BF1FF9F0062BAA8, 0xFBE9141915D7A922}, // 1e-261\n\t{0x6F773FC3603DB4A9, 0x9D71AC8FADA6C9B5}, // 1e-260\n\t{0xCB550FB4384D21D3, 0xC4CE17B399107C22}, // 1e-259\n\t{0x7E2A53A146606A48, 0xF6019DA07F549B2B}, // 1e-258\n\t{0x2EDA7444CBFC426D, 0x99C102844F94E0FB}, // 1e-257\n\t{0xFA911155FEFB5308, 0xC0314325637A1939}, // 1e-256\n\t{0x793555AB7EBA27CA, 0xF03D93EEBC589F88}, // 1e-255\n\t{0x4BC1558B2F3458DE, 0x96267C7535B763B5}, // 1e-254\n\t{0x9EB1AAEDFB016F16, 0xBBB01B9283253CA2}, // 1e-253\n\t{0x465E15A979C1CADC, 0xEA9C227723EE8BCB}, // 1e-252\n\t{0x0BFACD89EC191EC9, 0x92A1958A7675175F}, // 1e-251\n\t{0xCEF980EC671F667B, 0xB749FAED14125D36}, // 1e-250\n\t{0x82B7E12780E7401A, 0xE51C79A85916F484}, // 1e-249\n\t{0xD1B2ECB8B0908810, 0x8F31CC0937AE58D2}, // 1e-248\n\t{0x861FA7E6DCB4AA15, 0xB2FE3F0B8599EF07}, // 1e-247\n\t{0x67A791E093E1D49A, 0xDFBDCECE67006AC9}, // 1e-246\n\t{0xE0C8BB2C5C6D24E0, 0x8BD6A141006042BD}, // 1e-245\n\t{0x58FAE9F773886E18, 0xAECC49914078536D}, // 1e-244\n\t{0xAF39A475506A899E, 0xDA7F5BF590966848}, // 1e-243\n\t{0x6D8406C952429603, 0x888F99797A5E012D}, // 1e-242\n\t{0xC8E5087BA6D33B83, 0xAAB37FD7D8F58178}, // 1e-241\n\t{0xFB1E4A9A90880A64, 0xD5605FCDCF32E1D6}, // 1e-240\n\t{0x5CF2EEA09A55067F, 0x855C3BE0A17FCD26}, // 1e-239\n\t{0xF42FAA48C0EA481E, 0xA6B34AD8C9DFC06F}, // 1e-238\n\t{0xF13B94DAF124DA26, 0xD0601D8EFC57B08B}, // 1e-237\n\t{0x76C53D08D6B70858, 0x823C12795DB6CE57}, // 1e-236\n\t{0x54768C4B0C64CA6E, 0xA2CB1717B52481ED}, // 1e-235\n\t{0xA9942F5DCF7DFD09, 0xCB7DDCDDA26DA268}, // 1e-234\n\t{0xD3F93B35435D7C4C, 0xFE5D54150B090B02}, // 1e-233\n\t{0xC47BC5014A1A6DAF, 0x9EFA548D26E5A6E1}, // 1e-232\n\t{0x359AB6419CA1091B, 0xC6B8E9B0709F109A}, // 1e-231\n\t{0xC30163D203C94B62, 0xF867241C8CC6D4C0}, // 1e-230\n\t{0x79E0DE63425DCF1D, 0x9B407691D7FC44F8}, // 1e-229\n\t{0x985915FC12F542E4, 0xC21094364DFB5636}, // 1e-228\n\t{0x3E6F5B7B17B2939D, 0xF294B943E17A2BC4}, // 1e-227\n\t{0xA705992CEECF9C42, 0x979CF3CA6CEC5B5A}, // 1e-226\n\t{0x50C6FF782A838353, 0xBD8430BD08277231}, // 1e-225\n\t{0xA4F8BF5635246428, 0xECE53CEC4A314EBD}, // 1e-224\n\t{0x871B7795E136BE99, 0x940F4613AE5ED136}, // 1e-223\n\t{0x28E2557B59846E3F, 0xB913179899F68584}, // 1e-222\n\t{0x331AEADA2FE589CF, 0xE757DD7EC07426E5}, // 1e-221\n\t{0x3FF0D2C85DEF7621, 0x9096EA6F3848984F}, // 1e-220\n\t{0x0FED077A756B53A9, 0xB4BCA50B065ABE63}, // 1e-219\n\t{0xD3E8495912C62894, 0xE1EBCE4DC7F16DFB}, // 1e-218\n\t{0x64712DD7ABBBD95C, 0x8D3360F09CF6E4BD}, // 1e-217\n\t{0xBD8D794D96AACFB3, 0xB080392CC4349DEC}, // 1e-216\n\t{0xECF0D7A0FC5583A0, 0xDCA04777F541C567}, // 1e-215\n\t{0xF41686C49DB57244, 0x89E42CAAF9491B60}, // 1e-214\n\t{0x311C2875C522CED5, 0xAC5D37D5B79B6239}, // 1e-213\n\t{0x7D633293366B828B, 0xD77485CB25823AC7}, // 1e-212\n\t{0xAE5DFF9C02033197, 0x86A8D39EF77164BC}, // 1e-211\n\t{0xD9F57F830283FDFC, 0xA8530886B54DBDEB}, // 1e-210\n\t{0xD072DF63C324FD7B, 0xD267CAA862A12D66}, // 1e-209\n\t{0x4247CB9E59F71E6D, 0x8380DEA93DA4BC60}, // 1e-208\n\t{0x52D9BE85F074E608, 0xA46116538D0DEB78}, // 1e-207\n\t{0x67902E276C921F8B, 0xCD795BE870516656}, // 1e-206\n\t{0x00BA1CD8A3DB53B6, 0x806BD9714632DFF6}, // 1e-205\n\t{0x80E8A40ECCD228A4, 0xA086CFCD97BF97F3}, // 1e-204\n\t{0x6122CD128006B2CD, 0xC8A883C0FDAF7DF0}, // 1e-203\n\t{0x796B805720085F81, 0xFAD2A4B13D1B5D6C}, // 1e-202\n\t{0xCBE3303674053BB0, 0x9CC3A6EEC6311A63}, // 1e-201\n\t{0xBEDBFC4411068A9C, 0xC3F490AA77BD60FC}, // 1e-200\n\t{0xEE92FB5515482D44, 0xF4F1B4D515ACB93B}, // 1e-199\n\t{0x751BDD152D4D1C4A, 0x991711052D8BF3C5}, // 1e-198\n\t{0xD262D45A78A0635D, 0xBF5CD54678EEF0B6}, // 1e-197\n\t{0x86FB897116C87C34, 0xEF340A98172AACE4}, // 1e-196\n\t{0xD45D35E6AE3D4DA0, 0x9580869F0E7AAC0E}, // 1e-195\n\t{0x8974836059CCA109, 0xBAE0A846D2195712}, // 1e-194\n\t{0x2BD1A438703FC94B, 0xE998D258869FACD7}, // 1e-193\n\t{0x7B6306A34627DDCF, 0x91FF83775423CC06}, // 1e-192\n\t{0x1A3BC84C17B1D542, 0xB67F6455292CBF08}, // 1e-191\n\t{0x20CABA5F1D9E4A93, 0xE41F3D6A7377EECA}, // 1e-190\n\t{0x547EB47B7282EE9C, 0x8E938662882AF53E}, // 1e-189\n\t{0xE99E619A4F23AA43, 0xB23867FB2A35B28D}, // 1e-188\n\t{0x6405FA00E2EC94D4, 0xDEC681F9F4C31F31}, // 1e-187\n\t{0xDE83BC408DD3DD04, 0x8B3C113C38F9F37E}, // 1e-186\n\t{0x9624AB50B148D445, 0xAE0B158B4738705E}, // 1e-185\n\t{0x3BADD624DD9B0957, 0xD98DDAEE19068C76}, // 1e-184\n\t{0xE54CA5D70A80E5D6, 0x87F8A8D4CFA417C9}, // 1e-183\n\t{0x5E9FCF4CCD211F4C, 0xA9F6D30A038D1DBC}, // 1e-182\n\t{0x7647C3200069671F, 0xD47487CC8470652B}, // 1e-181\n\t{0x29ECD9F40041E073, 0x84C8D4DFD2C63F3B}, // 1e-180\n\t{0xF468107100525890, 0xA5FB0A17C777CF09}, // 1e-179\n\t{0x7182148D4066EEB4, 0xCF79CC9DB955C2CC}, // 1e-178\n\t{0xC6F14CD848405530, 0x81AC1FE293D599BF}, // 1e-177\n\t{0xB8ADA00E5A506A7C, 0xA21727DB38CB002F}, // 1e-176\n\t{0xA6D90811F0E4851C, 0xCA9CF1D206FDC03B}, // 1e-175\n\t{0x908F4A166D1DA663, 0xFD442E4688BD304A}, // 1e-174\n\t{0x9A598E4E043287FE, 0x9E4A9CEC15763E2E}, // 1e-173\n\t{0x40EFF1E1853F29FD, 0xC5DD44271AD3CDBA}, // 1e-172\n\t{0xD12BEE59E68EF47C, 0xF7549530E188C128}, // 1e-171\n\t{0x82BB74F8301958CE, 0x9A94DD3E8CF578B9}, // 1e-170\n\t{0xE36A52363C1FAF01, 0xC13A148E3032D6E7}, // 1e-169\n\t{0xDC44E6C3CB279AC1, 0xF18899B1BC3F8CA1}, // 1e-168\n\t{0x29AB103A5EF8C0B9, 0x96F5600F15A7B7E5}, // 1e-167\n\t{0x7415D448F6B6F0E7, 0xBCB2B812DB11A5DE}, // 1e-166\n\t{0x111B495B3464AD21, 0xEBDF661791D60F56}, // 1e-165\n\t{0xCAB10DD900BEEC34, 0x936B9FCEBB25C995}, // 1e-164\n\t{0x3D5D514F40EEA742, 0xB84687C269EF3BFB}, // 1e-163\n\t{0x0CB4A5A3112A5112, 0xE65829B3046B0AFA}, // 1e-162\n\t{0x47F0E785EABA72AB, 0x8FF71A0FE2C2E6DC}, // 1e-161\n\t{0x59ED216765690F56, 0xB3F4E093DB73A093}, // 1e-160\n\t{0x306869C13EC3532C, 0xE0F218B8D25088B8}, // 1e-159\n\t{0x1E414218C73A13FB, 0x8C974F7383725573}, // 1e-158\n\t{0xE5D1929EF90898FA, 0xAFBD2350644EEACF}, // 1e-157\n\t{0xDF45F746B74ABF39, 0xDBAC6C247D62A583}, // 1e-156\n\t{0x6B8BBA8C328EB783, 0x894BC396CE5DA772}, // 1e-155\n\t{0x066EA92F3F326564, 0xAB9EB47C81F5114F}, // 1e-154\n\t{0xC80A537B0EFEFEBD, 0xD686619BA27255A2}, // 1e-153\n\t{0xBD06742CE95F5F36, 0x8613FD0145877585}, // 1e-152\n\t{0x2C48113823B73704, 0xA798FC4196E952E7}, // 1e-151\n\t{0xF75A15862CA504C5, 0xD17F3B51FCA3A7A0}, // 1e-150\n\t{0x9A984D73DBE722FB, 0x82EF85133DE648C4}, // 1e-149\n\t{0xC13E60D0D2E0EBBA, 0xA3AB66580D5FDAF5}, // 1e-148\n\t{0x318DF905079926A8, 0xCC963FEE10B7D1B3}, // 1e-147\n\t{0xFDF17746497F7052, 0xFFBBCFE994E5C61F}, // 1e-146\n\t{0xFEB6EA8BEDEFA633, 0x9FD561F1FD0F9BD3}, // 1e-145\n\t{0xFE64A52EE96B8FC0, 0xC7CABA6E7C5382C8}, // 1e-144\n\t{0x3DFDCE7AA3C673B0, 0xF9BD690A1B68637B}, // 1e-143\n\t{0x06BEA10CA65C084E, 0x9C1661A651213E2D}, // 1e-142\n\t{0x486E494FCFF30A62, 0xC31BFA0FE5698DB8}, // 1e-141\n\t{0x5A89DBA3C3EFCCFA, 0xF3E2F893DEC3F126}, // 1e-140\n\t{0xF89629465A75E01C, 0x986DDB5C6B3A76B7}, // 1e-139\n\t{0xF6BBB397F1135823, 0xBE89523386091465}, // 1e-138\n\t{0x746AA07DED582E2C, 0xEE2BA6C0678B597F}, // 1e-137\n\t{0xA8C2A44EB4571CDC, 0x94DB483840B717EF}, // 1e-136\n\t{0x92F34D62616CE413, 0xBA121A4650E4DDEB}, // 1e-135\n\t{0x77B020BAF9C81D17, 0xE896A0D7E51E1566}, // 1e-134\n\t{0x0ACE1474DC1D122E, 0x915E2486EF32CD60}, // 1e-133\n\t{0x0D819992132456BA, 0xB5B5ADA8AAFF80B8}, // 1e-132\n\t{0x10E1FFF697ED6C69, 0xE3231912D5BF60E6}, // 1e-131\n\t{0xCA8D3FFA1EF463C1, 0x8DF5EFABC5979C8F}, // 1e-130\n\t{0xBD308FF8A6B17CB2, 0xB1736B96B6FD83B3}, // 1e-129\n\t{0xAC7CB3F6D05DDBDE, 0xDDD0467C64BCE4A0}, // 1e-128\n\t{0x6BCDF07A423AA96B, 0x8AA22C0DBEF60EE4}, // 1e-127\n\t{0x86C16C98D2C953C6, 0xAD4AB7112EB3929D}, // 1e-126\n\t{0xE871C7BF077BA8B7, 0xD89D64D57A607744}, // 1e-125\n\t{0x11471CD764AD4972, 0x87625F056C7C4A8B}, // 1e-124\n\t{0xD598E40D3DD89BCF, 0xA93AF6C6C79B5D2D}, // 1e-123\n\t{0x4AFF1D108D4EC2C3, 0xD389B47879823479}, // 1e-122\n\t{0xCEDF722A585139BA, 0x843610CB4BF160CB}, // 1e-121\n\t{0xC2974EB4EE658828, 0xA54394FE1EEDB8FE}, // 1e-120\n\t{0x733D226229FEEA32, 0xCE947A3DA6A9273E}, // 1e-119\n\t{0x0806357D5A3F525F, 0x811CCC668829B887}, // 1e-118\n\t{0xCA07C2DCB0CF26F7, 0xA163FF802A3426A8}, // 1e-117\n\t{0xFC89B393DD02F0B5, 0xC9BCFF6034C13052}, // 1e-116\n\t{0xBBAC2078D443ACE2, 0xFC2C3F3841F17C67}, // 1e-115\n\t{0xD54B944B84AA4C0D, 0x9D9BA7832936EDC0}, // 1e-114\n\t{0x0A9E795E65D4DF11, 0xC5029163F384A931}, // 1e-113\n\t{0x4D4617B5FF4A16D5, 0xF64335BCF065D37D}, // 1e-112\n\t{0x504BCED1BF8E4E45, 0x99EA0196163FA42E}, // 1e-111\n\t{0xE45EC2862F71E1D6, 0xC06481FB9BCF8D39}, // 1e-110\n\t{0x5D767327BB4E5A4C, 0xF07DA27A82C37088}, // 1e-109\n\t{0x3A6A07F8D510F86F, 0x964E858C91BA2655}, // 1e-108\n\t{0x890489F70A55368B, 0xBBE226EFB628AFEA}, // 1e-107\n\t{0x2B45AC74CCEA842E, 0xEADAB0ABA3B2DBE5}, // 1e-106\n\t{0x3B0B8BC90012929D, 0x92C8AE6B464FC96F}, // 1e-105\n\t{0x09CE6EBB40173744, 0xB77ADA0617E3BBCB}, // 1e-104\n\t{0xCC420A6A101D0515, 0xE55990879DDCAABD}, // 1e-103\n\t{0x9FA946824A12232D, 0x8F57FA54C2A9EAB6}, // 1e-102\n\t{0x47939822DC96ABF9, 0xB32DF8E9F3546564}, // 1e-101\n\t{0x59787E2B93BC56F7, 0xDFF9772470297EBD}, // 1e-100\n\t{0x57EB4EDB3C55B65A, 0x8BFBEA76C619EF36}, // 1e-99\n\t{0xEDE622920B6B23F1, 0xAEFAE51477A06B03}, // 1e-98\n\t{0xE95FAB368E45ECED, 0xDAB99E59958885C4}, // 1e-97\n\t{0x11DBCB0218EBB414, 0x88B402F7FD75539B}, // 1e-96\n\t{0xD652BDC29F26A119, 0xAAE103B5FCD2A881}, // 1e-95\n\t{0x4BE76D3346F0495F, 0xD59944A37C0752A2}, // 1e-94\n\t{0x6F70A4400C562DDB, 0x857FCAE62D8493A5}, // 1e-93\n\t{0xCB4CCD500F6BB952, 0xA6DFBD9FB8E5B88E}, // 1e-92\n\t{0x7E2000A41346A7A7, 0xD097AD07A71F26B2}, // 1e-91\n\t{0x8ED400668C0C28C8, 0x825ECC24C873782F}, // 1e-90\n\t{0x728900802F0F32FA, 0xA2F67F2DFA90563B}, // 1e-89\n\t{0x4F2B40A03AD2FFB9, 0xCBB41EF979346BCA}, // 1e-88\n\t{0xE2F610C84987BFA8, 0xFEA126B7D78186BC}, // 1e-87\n\t{0x0DD9CA7D2DF4D7C9, 0x9F24B832E6B0F436}, // 1e-86\n\t{0x91503D1C79720DBB, 0xC6EDE63FA05D3143}, // 1e-85\n\t{0x75A44C6397CE912A, 0xF8A95FCF88747D94}, // 1e-84\n\t{0xC986AFBE3EE11ABA, 0x9B69DBE1B548CE7C}, // 1e-83\n\t{0xFBE85BADCE996168, 0xC24452DA229B021B}, // 1e-82\n\t{0xFAE27299423FB9C3, 0xF2D56790AB41C2A2}, // 1e-81\n\t{0xDCCD879FC967D41A, 0x97C560BA6B0919A5}, // 1e-80\n\t{0x5400E987BBC1C920, 0xBDB6B8E905CB600F}, // 1e-79\n\t{0x290123E9AAB23B68, 0xED246723473E3813}, // 1e-78\n\t{0xF9A0B6720AAF6521, 0x9436C0760C86E30B}, // 1e-77\n\t{0xF808E40E8D5B3E69, 0xB94470938FA89BCE}, // 1e-76\n\t{0xB60B1D1230B20E04, 0xE7958CB87392C2C2}, // 1e-75\n\t{0xB1C6F22B5E6F48C2, 0x90BD77F3483BB9B9}, // 1e-74\n\t{0x1E38AEB6360B1AF3, 0xB4ECD5F01A4AA828}, // 1e-73\n\t{0x25C6DA63C38DE1B0, 0xE2280B6C20DD5232}, // 1e-72\n\t{0x579C487E5A38AD0E, 0x8D590723948A535F}, // 1e-71\n\t{0x2D835A9DF0C6D851, 0xB0AF48EC79ACE837}, // 1e-70\n\t{0xF8E431456CF88E65, 0xDCDB1B2798182244}, // 1e-69\n\t{0x1B8E9ECB641B58FF, 0x8A08F0F8BF0F156B}, // 1e-68\n\t{0xE272467E3D222F3F, 0xAC8B2D36EED2DAC5}, // 1e-67\n\t{0x5B0ED81DCC6ABB0F, 0xD7ADF884AA879177}, // 1e-66\n\t{0x98E947129FC2B4E9, 0x86CCBB52EA94BAEA}, // 1e-65\n\t{0x3F2398D747B36224, 0xA87FEA27A539E9A5}, // 1e-64\n\t{0x8EEC7F0D19A03AAD, 0xD29FE4B18E88640E}, // 1e-63\n\t{0x1953CF68300424AC, 0x83A3EEEEF9153E89}, // 1e-62\n\t{0x5FA8C3423C052DD7, 0xA48CEAAAB75A8E2B}, // 1e-61\n\t{0x3792F412CB06794D, 0xCDB02555653131B6}, // 1e-60\n\t{0xE2BBD88BBEE40BD0, 0x808E17555F3EBF11}, // 1e-59\n\t{0x5B6ACEAEAE9D0EC4, 0xA0B19D2AB70E6ED6}, // 1e-58\n\t{0xF245825A5A445275, 0xC8DE047564D20A8B}, // 1e-57\n\t{0xEED6E2F0F0D56712, 0xFB158592BE068D2E}, // 1e-56\n\t{0x55464DD69685606B, 0x9CED737BB6C4183D}, // 1e-55\n\t{0xAA97E14C3C26B886, 0xC428D05AA4751E4C}, // 1e-54\n\t{0xD53DD99F4B3066A8, 0xF53304714D9265DF}, // 1e-53\n\t{0xE546A8038EFE4029, 0x993FE2C6D07B7FAB}, // 1e-52\n\t{0xDE98520472BDD033, 0xBF8FDB78849A5F96}, // 1e-51\n\t{0x963E66858F6D4440, 0xEF73D256A5C0F77C}, // 1e-50\n\t{0xDDE7001379A44AA8, 0x95A8637627989AAD}, // 1e-49\n\t{0x5560C018580D5D52, 0xBB127C53B17EC159}, // 1e-48\n\t{0xAAB8F01E6E10B4A6, 0xE9D71B689DDE71AF}, // 1e-47\n\t{0xCAB3961304CA70E8, 0x9226712162AB070D}, // 1e-46\n\t{0x3D607B97C5FD0D22, 0xB6B00D69BB55C8D1}, // 1e-45\n\t{0x8CB89A7DB77C506A, 0xE45C10C42A2B3B05}, // 1e-44\n\t{0x77F3608E92ADB242, 0x8EB98A7A9A5B04E3}, // 1e-43\n\t{0x55F038B237591ED3, 0xB267ED1940F1C61C}, // 1e-42\n\t{0x6B6C46DEC52F6688, 0xDF01E85F912E37A3}, // 1e-41\n\t{0x2323AC4B3B3DA015, 0x8B61313BBABCE2C6}, // 1e-40\n\t{0xABEC975E0A0D081A, 0xAE397D8AA96C1B77}, // 1e-39\n\t{0x96E7BD358C904A21, 0xD9C7DCED53C72255}, // 1e-38\n\t{0x7E50D64177DA2E54, 0x881CEA14545C7575}, // 1e-37\n\t{0xDDE50BD1D5D0B9E9, 0xAA242499697392D2}, // 1e-36\n\t{0x955E4EC64B44E864, 0xD4AD2DBFC3D07787}, // 1e-35\n\t{0xBD5AF13BEF0B113E, 0x84EC3C97DA624AB4}, // 1e-34\n\t{0xECB1AD8AEACDD58E, 0xA6274BBDD0FADD61}, // 1e-33\n\t{0x67DE18EDA5814AF2, 0xCFB11EAD453994BA}, // 1e-32\n\t{0x80EACF948770CED7, 0x81CEB32C4B43FCF4}, // 1e-31\n\t{0xA1258379A94D028D, 0xA2425FF75E14FC31}, // 1e-30\n\t{0x096EE45813A04330, 0xCAD2F7F5359A3B3E}, // 1e-29\n\t{0x8BCA9D6E188853FC, 0xFD87B5F28300CA0D}, // 1e-28\n\t{0x775EA264CF55347D, 0x9E74D1B791E07E48}, // 1e-27\n\t{0x95364AFE032A819D, 0xC612062576589DDA}, // 1e-26\n\t{0x3A83DDBD83F52204, 0xF79687AED3EEC551}, // 1e-25\n\t{0xC4926A9672793542, 0x9ABE14CD44753B52}, // 1e-24\n\t{0x75B7053C0F178293, 0xC16D9A0095928A27}, // 1e-23\n\t{0x5324C68B12DD6338, 0xF1C90080BAF72CB1}, // 1e-22\n\t{0xD3F6FC16EBCA5E03, 0x971DA05074DA7BEE}, // 1e-21\n\t{0x88F4BB1CA6BCF584, 0xBCE5086492111AEA}, // 1e-20\n\t{0x2B31E9E3D06C32E5, 0xEC1E4A7DB69561A5}, // 1e-19\n\t{0x3AFF322E62439FCF, 0x9392EE8E921D5D07}, // 1e-18\n\t{0x09BEFEB9FAD487C2, 0xB877AA3236A4B449}, // 1e-17\n\t{0x4C2EBE687989A9B3, 0xE69594BEC44DE15B}, // 1e-16\n\t{0x0F9D37014BF60A10, 0x901D7CF73AB0ACD9}, // 1e-15\n\t{0x538484C19EF38C94, 0xB424DC35095CD80F}, // 1e-14\n\t{0x2865A5F206B06FB9, 0xE12E13424BB40E13}, // 1e-13\n\t{0xF93F87B7442E45D3, 0x8CBCCC096F5088CB}, // 1e-12\n\t{0xF78F69A51539D748, 0xAFEBFF0BCB24AAFE}, // 1e-11\n\t{0xB573440E5A884D1B, 0xDBE6FECEBDEDD5BE}, // 1e-10\n\t{0x31680A88F8953030, 0x89705F4136B4A597}, // 1e-9\n\t{0xFDC20D2B36BA7C3D, 0xABCC77118461CEFC}, // 1e-8\n\t{0x3D32907604691B4C, 0xD6BF94D5E57A42BC}, // 1e-7\n\t{0xA63F9A49C2C1B10F, 0x8637BD05AF6C69B5}, // 1e-6\n\t{0x0FCF80DC33721D53, 0xA7C5AC471B478423}, // 1e-5\n\t{0xD3C36113404EA4A8, 0xD1B71758E219652B}, // 1e-4\n\t{0x645A1CAC083126E9, 0x83126E978D4FDF3B}, // 1e-3\n\t{0x3D70A3D70A3D70A3, 0xA3D70A3D70A3D70A}, // 1e-2\n\t{0xCCCCCCCCCCCCCCCC, 0xCCCCCCCCCCCCCCCC}, // 1e-1\n\t{0x0000000000000000, 0x8000000000000000}, // 1e0\n\t{0x0000000000000000, 0xA000000000000000}, // 1e1\n\t{0x0000000000000000, 0xC800000000000000}, // 1e2\n\t{0x0000000000000000, 0xFA00000000000000}, // 1e3\n\t{0x0000000000000000, 0x9C40000000000000}, // 1e4\n\t{0x0000000000000000, 0xC350000000000000}, // 1e5\n\t{0x0000000000000000, 0xF424000000000000}, // 1e6\n\t{0x0000000000000000, 0x9896800000000000}, // 1e7\n\t{0x0000000000000000, 0xBEBC200000000000}, // 1e8\n\t{0x0000000000000000, 0xEE6B280000000000}, // 1e9\n\t{0x0000000000000000, 0x9502F90000000000}, // 1e10\n\t{0x0000000000000000, 0xBA43B74000000000}, // 1e11\n\t{0x0000000000000000, 0xE8D4A51000000000}, // 1e12\n\t{0x0000000000000000, 0x9184E72A00000000}, // 1e13\n\t{0x0000000000000000, 0xB5E620F480000000}, // 1e14\n\t{0x0000000000000000, 0xE35FA931A0000000}, // 1e15\n\t{0x0000000000000000, 0x8E1BC9BF04000000}, // 1e16\n\t{0x0000000000000000, 0xB1A2BC2EC5000000}, // 1e17\n\t{0x0000000000000000, 0xDE0B6B3A76400000}, // 1e18\n\t{0x0000000000000000, 0x8AC7230489E80000}, // 1e19\n\t{0x0000000000000000, 0xAD78EBC5AC620000}, // 1e20\n\t{0x0000000000000000, 0xD8D726B7177A8000}, // 1e21\n\t{0x0000000000000000, 0x878678326EAC9000}, // 1e22\n\t{0x0000000000000000, 0xA968163F0A57B400}, // 1e23\n\t{0x0000000000000000, 0xD3C21BCECCEDA100}, // 1e24\n\t{0x0000000000000000, 0x84595161401484A0}, // 1e25\n\t{0x0000000000000000, 0xA56FA5B99019A5C8}, // 1e26\n\t{0x0000000000000000, 0xCECB8F27F4200F3A}, // 1e27\n\t{0x4000000000000000, 0x813F3978F8940984}, // 1e28\n\t{0x5000000000000000, 0xA18F07D736B90BE5}, // 1e29\n\t{0xA400000000000000, 0xC9F2C9CD04674EDE}, // 1e30\n\t{0x4D00000000000000, 0xFC6F7C4045812296}, // 1e31\n\t{0xF020000000000000, 0x9DC5ADA82B70B59D}, // 1e32\n\t{0x6C28000000000000, 0xC5371912364CE305}, // 1e33\n\t{0xC732000000000000, 0xF684DF56C3E01BC6}, // 1e34\n\t{0x3C7F400000000000, 0x9A130B963A6C115C}, // 1e35\n\t{0x4B9F100000000000, 0xC097CE7BC90715B3}, // 1e36\n\t{0x1E86D40000000000, 0xF0BDC21ABB48DB20}, // 1e37\n\t{0x1314448000000000, 0x96769950B50D88F4}, // 1e38\n\t{0x17D955A000000000, 0xBC143FA4E250EB31}, // 1e39\n\t{0x5DCFAB0800000000, 0xEB194F8E1AE525FD}, // 1e40\n\t{0x5AA1CAE500000000, 0x92EFD1B8D0CF37BE}, // 1e41\n\t{0xF14A3D9E40000000, 0xB7ABC627050305AD}, // 1e42\n\t{0x6D9CCD05D0000000, 0xE596B7B0C643C719}, // 1e43\n\t{0xE4820023A2000000, 0x8F7E32CE7BEA5C6F}, // 1e44\n\t{0xDDA2802C8A800000, 0xB35DBF821AE4F38B}, // 1e45\n\t{0xD50B2037AD200000, 0xE0352F62A19E306E}, // 1e46\n\t{0x4526F422CC340000, 0x8C213D9DA502DE45}, // 1e47\n\t{0x9670B12B7F410000, 0xAF298D050E4395D6}, // 1e48\n\t{0x3C0CDD765F114000, 0xDAF3F04651D47B4C}, // 1e49\n\t{0xA5880A69FB6AC800, 0x88D8762BF324CD0F}, // 1e50\n\t{0x8EEA0D047A457A00, 0xAB0E93B6EFEE0053}, // 1e51\n\t{0x72A4904598D6D880, 0xD5D238A4ABE98068}, // 1e52\n\t{0x47A6DA2B7F864750, 0x85A36366EB71F041}, // 1e53\n\t{0x999090B65F67D924, 0xA70C3C40A64E6C51}, // 1e54\n\t{0xFFF4B4E3F741CF6D, 0xD0CF4B50CFE20765}, // 1e55\n\t{0xBFF8F10E7A8921A4, 0x82818F1281ED449F}, // 1e56\n\t{0xAFF72D52192B6A0D, 0xA321F2D7226895C7}, // 1e57\n\t{0x9BF4F8A69F764490, 0xCBEA6F8CEB02BB39}, // 1e58\n\t{0x02F236D04753D5B4, 0xFEE50B7025C36A08}, // 1e59\n\t{0x01D762422C946590, 0x9F4F2726179A2245}, // 1e60\n\t{0x424D3AD2B7B97EF5, 0xC722F0EF9D80AAD6}, // 1e61\n\t{0xD2E0898765A7DEB2, 0xF8EBAD2B84E0D58B}, // 1e62\n\t{0x63CC55F49F88EB2F, 0x9B934C3B330C8577}, // 1e63\n\t{0x3CBF6B71C76B25FB, 0xC2781F49FFCFA6D5}, // 1e64\n\t{0x8BEF464E3945EF7A, 0xF316271C7FC3908A}, // 1e65\n\t{0x97758BF0E3CBB5AC, 0x97EDD871CFDA3A56}, // 1e66\n\t{0x3D52EEED1CBEA317, 0xBDE94E8E43D0C8EC}, // 1e67\n\t{0x4CA7AAA863EE4BDD, 0xED63A231D4C4FB27}, // 1e68\n\t{0x8FE8CAA93E74EF6A, 0x945E455F24FB1CF8}, // 1e69\n\t{0xB3E2FD538E122B44, 0xB975D6B6EE39E436}, // 1e70\n\t{0x60DBBCA87196B616, 0xE7D34C64A9C85D44}, // 1e71\n\t{0xBC8955E946FE31CD, 0x90E40FBEEA1D3A4A}, // 1e72\n\t{0x6BABAB6398BDBE41, 0xB51D13AEA4A488DD}, // 1e73\n\t{0xC696963C7EED2DD1, 0xE264589A4DCDAB14}, // 1e74\n\t{0xFC1E1DE5CF543CA2, 0x8D7EB76070A08AEC}, // 1e75\n\t{0x3B25A55F43294BCB, 0xB0DE65388CC8ADA8}, // 1e76\n\t{0x49EF0EB713F39EBE, 0xDD15FE86AFFAD912}, // 1e77\n\t{0x6E3569326C784337, 0x8A2DBF142DFCC7AB}, // 1e78\n\t{0x49C2C37F07965404, 0xACB92ED9397BF996}, // 1e79\n\t{0xDC33745EC97BE906, 0xD7E77A8F87DAF7FB}, // 1e80\n\t{0x69A028BB3DED71A3, 0x86F0AC99B4E8DAFD}, // 1e81\n\t{0xC40832EA0D68CE0C, 0xA8ACD7C0222311BC}, // 1e82\n\t{0xF50A3FA490C30190, 0xD2D80DB02AABD62B}, // 1e83\n\t{0x792667C6DA79E0FA, 0x83C7088E1AAB65DB}, // 1e84\n\t{0x577001B891185938, 0xA4B8CAB1A1563F52}, // 1e85\n\t{0xED4C0226B55E6F86, 0xCDE6FD5E09ABCF26}, // 1e86\n\t{0x544F8158315B05B4, 0x80B05E5AC60B6178}, // 1e87\n\t{0x696361AE3DB1C721, 0xA0DC75F1778E39D6}, // 1e88\n\t{0x03BC3A19CD1E38E9, 0xC913936DD571C84C}, // 1e89\n\t{0x04AB48A04065C723, 0xFB5878494ACE3A5F}, // 1e90\n\t{0x62EB0D64283F9C76, 0x9D174B2DCEC0E47B}, // 1e91\n\t{0x3BA5D0BD324F8394, 0xC45D1DF942711D9A}, // 1e92\n\t{0xCA8F44EC7EE36479, 0xF5746577930D6500}, // 1e93\n\t{0x7E998B13CF4E1ECB, 0x9968BF6ABBE85F20}, // 1e94\n\t{0x9E3FEDD8C321A67E, 0xBFC2EF456AE276E8}, // 1e95\n\t{0xC5CFE94EF3EA101E, 0xEFB3AB16C59B14A2}, // 1e96\n\t{0xBBA1F1D158724A12, 0x95D04AEE3B80ECE5}, // 1e97\n\t{0x2A8A6E45AE8EDC97, 0xBB445DA9CA61281F}, // 1e98\n\t{0xF52D09D71A3293BD, 0xEA1575143CF97226}, // 1e99\n\t{0x593C2626705F9C56, 0x924D692CA61BE758}, // 1e100\n\t{0x6F8B2FB00C77836C, 0xB6E0C377CFA2E12E}, // 1e101\n\t{0x0B6DFB9C0F956447, 0xE498F455C38B997A}, // 1e102\n\t{0x4724BD4189BD5EAC, 0x8EDF98B59A373FEC}, // 1e103\n\t{0x58EDEC91EC2CB657, 0xB2977EE300C50FE7}, // 1e104\n\t{0x2F2967B66737E3ED, 0xDF3D5E9BC0F653E1}, // 1e105\n\t{0xBD79E0D20082EE74, 0x8B865B215899F46C}, // 1e106\n\t{0xECD8590680A3AA11, 0xAE67F1E9AEC07187}, // 1e107\n\t{0xE80E6F4820CC9495, 0xDA01EE641A708DE9}, // 1e108\n\t{0x3109058D147FDCDD, 0x884134FE908658B2}, // 1e109\n\t{0xBD4B46F0599FD415, 0xAA51823E34A7EEDE}, // 1e110\n\t{0x6C9E18AC7007C91A, 0xD4E5E2CDC1D1EA96}, // 1e111\n\t{0x03E2CF6BC604DDB0, 0x850FADC09923329E}, // 1e112\n\t{0x84DB8346B786151C, 0xA6539930BF6BFF45}, // 1e113\n\t{0xE612641865679A63, 0xCFE87F7CEF46FF16}, // 1e114\n\t{0x4FCB7E8F3F60C07E, 0x81F14FAE158C5F6E}, // 1e115\n\t{0xE3BE5E330F38F09D, 0xA26DA3999AEF7749}, // 1e116\n\t{0x5CADF5BFD3072CC5, 0xCB090C8001AB551C}, // 1e117\n\t{0x73D9732FC7C8F7F6, 0xFDCB4FA002162A63}, // 1e118\n\t{0x2867E7FDDCDD9AFA, 0x9E9F11C4014DDA7E}, // 1e119\n\t{0xB281E1FD541501B8, 0xC646D63501A1511D}, // 1e120\n\t{0x1F225A7CA91A4226, 0xF7D88BC24209A565}, // 1e121\n\t{0x3375788DE9B06958, 0x9AE757596946075F}, // 1e122\n\t{0x0052D6B1641C83AE, 0xC1A12D2FC3978937}, // 1e123\n\t{0xC0678C5DBD23A49A, 0xF209787BB47D6B84}, // 1e124\n\t{0xF840B7BA963646E0, 0x9745EB4D50CE6332}, // 1e125\n\t{0xB650E5A93BC3D898, 0xBD176620A501FBFF}, // 1e126\n\t{0xA3E51F138AB4CEBE, 0xEC5D3FA8CE427AFF}, // 1e127\n\t{0xC66F336C36B10137, 0x93BA47C980E98CDF}, // 1e128\n\t{0xB80B0047445D4184, 0xB8A8D9BBE123F017}, // 1e129\n\t{0xA60DC059157491E5, 0xE6D3102AD96CEC1D}, // 1e130\n\t{0x87C89837AD68DB2F, 0x9043EA1AC7E41392}, // 1e131\n\t{0x29BABE4598C311FB, 0xB454E4A179DD1877}, // 1e132\n\t{0xF4296DD6FEF3D67A, 0xE16A1DC9D8545E94}, // 1e133\n\t{0x1899E4A65F58660C, 0x8CE2529E2734BB1D}, // 1e134\n\t{0x5EC05DCFF72E7F8F, 0xB01AE745B101E9E4}, // 1e135\n\t{0x76707543F4FA1F73, 0xDC21A1171D42645D}, // 1e136\n\t{0x6A06494A791C53A8, 0x899504AE72497EBA}, // 1e137\n\t{0x0487DB9D17636892, 0xABFA45DA0EDBDE69}, // 1e138\n\t{0x45A9D2845D3C42B6, 0xD6F8D7509292D603}, // 1e139\n\t{0x0B8A2392BA45A9B2, 0x865B86925B9BC5C2}, // 1e140\n\t{0x8E6CAC7768D7141E, 0xA7F26836F282B732}, // 1e141\n\t{0x3207D795430CD926, 0xD1EF0244AF2364FF}, // 1e142\n\t{0x7F44E6BD49E807B8, 0x8335616AED761F1F}, // 1e143\n\t{0x5F16206C9C6209A6, 0xA402B9C5A8D3A6E7}, // 1e144\n\t{0x36DBA887C37A8C0F, 0xCD036837130890A1}, // 1e145\n\t{0xC2494954DA2C9789, 0x802221226BE55A64}, // 1e146\n\t{0xF2DB9BAA10B7BD6C, 0xA02AA96B06DEB0FD}, // 1e147\n\t{0x6F92829494E5ACC7, 0xC83553C5C8965D3D}, // 1e148\n\t{0xCB772339BA1F17F9, 0xFA42A8B73ABBF48C}, // 1e149\n\t{0xFF2A760414536EFB, 0x9C69A97284B578D7}, // 1e150\n\t{0xFEF5138519684ABA, 0xC38413CF25E2D70D}, // 1e151\n\t{0x7EB258665FC25D69, 0xF46518C2EF5B8CD1}, // 1e152\n\t{0xEF2F773FFBD97A61, 0x98BF2F79D5993802}, // 1e153\n\t{0xAAFB550FFACFD8FA, 0xBEEEFB584AFF8603}, // 1e154\n\t{0x95BA2A53F983CF38, 0xEEAABA2E5DBF6784}, // 1e155\n\t{0xDD945A747BF26183, 0x952AB45CFA97A0B2}, // 1e156\n\t{0x94F971119AEEF9E4, 0xBA756174393D88DF}, // 1e157\n\t{0x7A37CD5601AAB85D, 0xE912B9D1478CEB17}, // 1e158\n\t{0xAC62E055C10AB33A, 0x91ABB422CCB812EE}, // 1e159\n\t{0x577B986B314D6009, 0xB616A12B7FE617AA}, // 1e160\n\t{0xED5A7E85FDA0B80B, 0xE39C49765FDF9D94}, // 1e161\n\t{0x14588F13BE847307, 0x8E41ADE9FBEBC27D}, // 1e162\n\t{0x596EB2D8AE258FC8, 0xB1D219647AE6B31C}, // 1e163\n\t{0x6FCA5F8ED9AEF3BB, 0xDE469FBD99A05FE3}, // 1e164\n\t{0x25DE7BB9480D5854, 0x8AEC23D680043BEE}, // 1e165\n\t{0xAF561AA79A10AE6A, 0xADA72CCC20054AE9}, // 1e166\n\t{0x1B2BA1518094DA04, 0xD910F7FF28069DA4}, // 1e167\n\t{0x90FB44D2F05D0842, 0x87AA9AFF79042286}, // 1e168\n\t{0x353A1607AC744A53, 0xA99541BF57452B28}, // 1e169\n\t{0x42889B8997915CE8, 0xD3FA922F2D1675F2}, // 1e170\n\t{0x69956135FEBADA11, 0x847C9B5D7C2E09B7}, // 1e171\n\t{0x43FAB9837E699095, 0xA59BC234DB398C25}, // 1e172\n\t{0x94F967E45E03F4BB, 0xCF02B2C21207EF2E}, // 1e173\n\t{0x1D1BE0EEBAC278F5, 0x8161AFB94B44F57D}, // 1e174\n\t{0x6462D92A69731732, 0xA1BA1BA79E1632DC}, // 1e175\n\t{0x7D7B8F7503CFDCFE, 0xCA28A291859BBF93}, // 1e176\n\t{0x5CDA735244C3D43E, 0xFCB2CB35E702AF78}, // 1e177\n\t{0x3A0888136AFA64A7, 0x9DEFBF01B061ADAB}, // 1e178\n\t{0x088AAA1845B8FDD0, 0xC56BAEC21C7A1916}, // 1e179\n\t{0x8AAD549E57273D45, 0xF6C69A72A3989F5B}, // 1e180\n\t{0x36AC54E2F678864B, 0x9A3C2087A63F6399}, // 1e181\n\t{0x84576A1BB416A7DD, 0xC0CB28A98FCF3C7F}, // 1e182\n\t{0x656D44A2A11C51D5, 0xF0FDF2D3F3C30B9F}, // 1e183\n\t{0x9F644AE5A4B1B325, 0x969EB7C47859E743}, // 1e184\n\t{0x873D5D9F0DDE1FEE, 0xBC4665B596706114}, // 1e185\n\t{0xA90CB506D155A7EA, 0xEB57FF22FC0C7959}, // 1e186\n\t{0x09A7F12442D588F2, 0x9316FF75DD87CBD8}, // 1e187\n\t{0x0C11ED6D538AEB2F, 0xB7DCBF5354E9BECE}, // 1e188\n\t{0x8F1668C8A86DA5FA, 0xE5D3EF282A242E81}, // 1e189\n\t{0xF96E017D694487BC, 0x8FA475791A569D10}, // 1e190\n\t{0x37C981DCC395A9AC, 0xB38D92D760EC4455}, // 1e191\n\t{0x85BBE253F47B1417, 0xE070F78D3927556A}, // 1e192\n\t{0x93956D7478CCEC8E, 0x8C469AB843B89562}, // 1e193\n\t{0x387AC8D1970027B2, 0xAF58416654A6BABB}, // 1e194\n\t{0x06997B05FCC0319E, 0xDB2E51BFE9D0696A}, // 1e195\n\t{0x441FECE3BDF81F03, 0x88FCF317F22241E2}, // 1e196\n\t{0xD527E81CAD7626C3, 0xAB3C2FDDEEAAD25A}, // 1e197\n\t{0x8A71E223D8D3B074, 0xD60B3BD56A5586F1}, // 1e198\n\t{0xF6872D5667844E49, 0x85C7056562757456}, // 1e199\n\t{0xB428F8AC016561DB, 0xA738C6BEBB12D16C}, // 1e200\n\t{0xE13336D701BEBA52, 0xD106F86E69D785C7}, // 1e201\n\t{0xECC0024661173473, 0x82A45B450226B39C}, // 1e202\n\t{0x27F002D7F95D0190, 0xA34D721642B06084}, // 1e203\n\t{0x31EC038DF7B441F4, 0xCC20CE9BD35C78A5}, // 1e204\n\t{0x7E67047175A15271, 0xFF290242C83396CE}, // 1e205\n\t{0x0F0062C6E984D386, 0x9F79A169BD203E41}, // 1e206\n\t{0x52C07B78A3E60868, 0xC75809C42C684DD1}, // 1e207\n\t{0xA7709A56CCDF8A82, 0xF92E0C3537826145}, // 1e208\n\t{0x88A66076400BB691, 0x9BBCC7A142B17CCB}, // 1e209\n\t{0x6ACFF893D00EA435, 0xC2ABF989935DDBFE}, // 1e210\n\t{0x0583F6B8C4124D43, 0xF356F7EBF83552FE}, // 1e211\n\t{0xC3727A337A8B704A, 0x98165AF37B2153DE}, // 1e212\n\t{0x744F18C0592E4C5C, 0xBE1BF1B059E9A8D6}, // 1e213\n\t{0x1162DEF06F79DF73, 0xEDA2EE1C7064130C}, // 1e214\n\t{0x8ADDCB5645AC2BA8, 0x9485D4D1C63E8BE7}, // 1e215\n\t{0x6D953E2BD7173692, 0xB9A74A0637CE2EE1}, // 1e216\n\t{0xC8FA8DB6CCDD0437, 0xE8111C87C5C1BA99}, // 1e217\n\t{0x1D9C9892400A22A2, 0x910AB1D4DB9914A0}, // 1e218\n\t{0x2503BEB6D00CAB4B, 0xB54D5E4A127F59C8}, // 1e219\n\t{0x2E44AE64840FD61D, 0xE2A0B5DC971F303A}, // 1e220\n\t{0x5CEAECFED289E5D2, 0x8DA471A9DE737E24}, // 1e221\n\t{0x7425A83E872C5F47, 0xB10D8E1456105DAD}, // 1e222\n\t{0xD12F124E28F77719, 0xDD50F1996B947518}, // 1e223\n\t{0x82BD6B70D99AAA6F, 0x8A5296FFE33CC92F}, // 1e224\n\t{0x636CC64D1001550B, 0xACE73CBFDC0BFB7B}, // 1e225\n\t{0x3C47F7E05401AA4E, 0xD8210BEFD30EFA5A}, // 1e226\n\t{0x65ACFAEC34810A71, 0x8714A775E3E95C78}, // 1e227\n\t{0x7F1839A741A14D0D, 0xA8D9D1535CE3B396}, // 1e228\n\t{0x1EDE48111209A050, 0xD31045A8341CA07C}, // 1e229\n\t{0x934AED0AAB460432, 0x83EA2B892091E44D}, // 1e230\n\t{0xF81DA84D5617853F, 0xA4E4B66B68B65D60}, // 1e231\n\t{0x36251260AB9D668E, 0xCE1DE40642E3F4B9}, // 1e232\n\t{0xC1D72B7C6B426019, 0x80D2AE83E9CE78F3}, // 1e233\n\t{0xB24CF65B8612F81F, 0xA1075A24E4421730}, // 1e234\n\t{0xDEE033F26797B627, 0xC94930AE1D529CFC}, // 1e235\n\t{0x169840EF017DA3B1, 0xFB9B7CD9A4A7443C}, // 1e236\n\t{0x8E1F289560EE864E, 0x9D412E0806E88AA5}, // 1e237\n\t{0xF1A6F2BAB92A27E2, 0xC491798A08A2AD4E}, // 1e238\n\t{0xAE10AF696774B1DB, 0xF5B5D7EC8ACB58A2}, // 1e239\n\t{0xACCA6DA1E0A8EF29, 0x9991A6F3D6BF1765}, // 1e240\n\t{0x17FD090A58D32AF3, 0xBFF610B0CC6EDD3F}, // 1e241\n\t{0xDDFC4B4CEF07F5B0, 0xEFF394DCFF8A948E}, // 1e242\n\t{0x4ABDAF101564F98E, 0x95F83D0A1FB69CD9}, // 1e243\n\t{0x9D6D1AD41ABE37F1, 0xBB764C4CA7A4440F}, // 1e244\n\t{0x84C86189216DC5ED, 0xEA53DF5FD18D5513}, // 1e245\n\t{0x32FD3CF5B4E49BB4, 0x92746B9BE2F8552C}, // 1e246\n\t{0x3FBC8C33221DC2A1, 0xB7118682DBB66A77}, // 1e247\n\t{0x0FABAF3FEAA5334A, 0xE4D5E82392A40515}, // 1e248\n\t{0x29CB4D87F2A7400E, 0x8F05B1163BA6832D}, // 1e249\n\t{0x743E20E9EF511012, 0xB2C71D5BCA9023F8}, // 1e250\n\t{0x914DA9246B255416, 0xDF78E4B2BD342CF6}, // 1e251\n\t{0x1AD089B6C2F7548E, 0x8BAB8EEFB6409C1A}, // 1e252\n\t{0xA184AC2473B529B1, 0xAE9672ABA3D0C320}, // 1e253\n\t{0xC9E5D72D90A2741E, 0xDA3C0F568CC4F3E8}, // 1e254\n\t{0x7E2FA67C7A658892, 0x8865899617FB1871}, // 1e255\n\t{0xDDBB901B98FEEAB7, 0xAA7EEBFB9DF9DE8D}, // 1e256\n\t{0x552A74227F3EA565, 0xD51EA6FA85785631}, // 1e257\n\t{0xD53A88958F87275F, 0x8533285C936B35DE}, // 1e258\n\t{0x8A892ABAF368F137, 0xA67FF273B8460356}, // 1e259\n\t{0x2D2B7569B0432D85, 0xD01FEF10A657842C}, // 1e260\n\t{0x9C3B29620E29FC73, 0x8213F56A67F6B29B}, // 1e261\n\t{0x8349F3BA91B47B8F, 0xA298F2C501F45F42}, // 1e262\n\t{0x241C70A936219A73, 0xCB3F2F7642717713}, // 1e263\n\t{0xED238CD383AA0110, 0xFE0EFB53D30DD4D7}, // 1e264\n\t{0xF4363804324A40AA, 0x9EC95D1463E8A506}, // 1e265\n\t{0xB143C6053EDCD0D5, 0xC67BB4597CE2CE48}, // 1e266\n\t{0xDD94B7868E94050A, 0xF81AA16FDC1B81DA}, // 1e267\n\t{0xCA7CF2B4191C8326, 0x9B10A4E5E9913128}, // 1e268\n\t{0xFD1C2F611F63A3F0, 0xC1D4CE1F63F57D72}, // 1e269\n\t{0xBC633B39673C8CEC, 0xF24A01A73CF2DCCF}, // 1e270\n\t{0xD5BE0503E085D813, 0x976E41088617CA01}, // 1e271\n\t{0x4B2D8644D8A74E18, 0xBD49D14AA79DBC82}, // 1e272\n\t{0xDDF8E7D60ED1219E, 0xEC9C459D51852BA2}, // 1e273\n\t{0xCABB90E5C942B503, 0x93E1AB8252F33B45}, // 1e274\n\t{0x3D6A751F3B936243, 0xB8DA1662E7B00A17}, // 1e275\n\t{0x0CC512670A783AD4, 0xE7109BFBA19C0C9D}, // 1e276\n\t{0x27FB2B80668B24C5, 0x906A617D450187E2}, // 1e277\n\t{0xB1F9F660802DEDF6, 0xB484F9DC9641E9DA}, // 1e278\n\t{0x5E7873F8A0396973, 0xE1A63853BBD26451}, // 1e279\n\t{0xDB0B487B6423E1E8, 0x8D07E33455637EB2}, // 1e280\n\t{0x91CE1A9A3D2CDA62, 0xB049DC016ABC5E5F}, // 1e281\n\t{0x7641A140CC7810FB, 0xDC5C5301C56B75F7}, // 1e282\n\t{0xA9E904C87FCB0A9D, 0x89B9B3E11B6329BA}, // 1e283\n\t{0x546345FA9FBDCD44, 0xAC2820D9623BF429}, // 1e284\n\t{0xA97C177947AD4095, 0xD732290FBACAF133}, // 1e285\n\t{0x49ED8EABCCCC485D, 0x867F59A9D4BED6C0}, // 1e286\n\t{0x5C68F256BFFF5A74, 0xA81F301449EE8C70}, // 1e287\n\t{0x73832EEC6FFF3111, 0xD226FC195C6A2F8C}, // 1e288\n\t{0xC831FD53C5FF7EAB, 0x83585D8FD9C25DB7}, // 1e289\n\t{0xBA3E7CA8B77F5E55, 0xA42E74F3D032F525}, // 1e290\n\t{0x28CE1BD2E55F35EB, 0xCD3A1230C43FB26F}, // 1e291\n\t{0x7980D163CF5B81B3, 0x80444B5E7AA7CF85}, // 1e292\n\t{0xD7E105BCC332621F, 0xA0555E361951C366}, // 1e293\n\t{0x8DD9472BF3FEFAA7, 0xC86AB5C39FA63440}, // 1e294\n\t{0xB14F98F6F0FEB951, 0xFA856334878FC150}, // 1e295\n\t{0x6ED1BF9A569F33D3, 0x9C935E00D4B9D8D2}, // 1e296\n\t{0x0A862F80EC4700C8, 0xC3B8358109E84F07}, // 1e297\n\t{0xCD27BB612758C0FA, 0xF4A642E14C6262C8}, // 1e298\n\t{0x8038D51CB897789C, 0x98E7E9CCCFBD7DBD}, // 1e299\n\t{0xE0470A63E6BD56C3, 0xBF21E44003ACDD2C}, // 1e300\n\t{0x1858CCFCE06CAC74, 0xEEEA5D5004981478}, // 1e301\n\t{0x0F37801E0C43EBC8, 0x95527A5202DF0CCB}, // 1e302\n\t{0xD30560258F54E6BA, 0xBAA718E68396CFFD}, // 1e303\n\t{0x47C6B82EF32A2069, 0xE950DF20247C83FD}, // 1e304\n\t{0x4CDC331D57FA5441, 0x91D28B7416CDD27E}, // 1e305\n\t{0xE0133FE4ADF8E952, 0xB6472E511C81471D}, // 1e306\n\t{0x58180FDDD97723A6, 0xE3D8F9E563A198E5}, // 1e307\n\t{0x570F09EAA7EA7648, 0x8E679C2F5E44FF8F}, // 1e308\n\t{0x2CD2CC6551E513DA, 0xB201833B35D63F73}, // 1e309\n\t{0xF8077F7EA65E58D1, 0xDE81E40A034BCF4F}, // 1e310\n\t{0xFB04AFAF27FAF782, 0x8B112E86420F6191}, // 1e311\n\t{0x79C5DB9AF1F9B563, 0xADD57A27D29339F6}, // 1e312\n\t{0x18375281AE7822BC, 0xD94AD8B1C7380874}, // 1e313\n\t{0x8F2293910D0B15B5, 0x87CEC76F1C830548}, // 1e314\n\t{0xB2EB3875504DDB22, 0xA9C2794AE3A3C69A}, // 1e315\n\t{0x5FA60692A46151EB, 0xD433179D9C8CB841}, // 1e316\n\t{0xDBC7C41BA6BCD333, 0x849FEEC281D7F328}, // 1e317\n\t{0x12B9B522906C0800, 0xA5C7EA73224DEFF3}, // 1e318\n\t{0xD768226B34870A00, 0xCF39E50FEAE16BEF}, // 1e319\n\t{0xE6A1158300D46640, 0x81842F29F2CCE375}, // 1e320\n\t{0x60495AE3C1097FD0, 0xA1E53AF46F801C53}, // 1e321\n\t{0x385BB19CB14BDFC4, 0xCA5E89B18B602368}, // 1e322\n\t{0x46729E03DD9ED7B5, 0xFCF62C1DEE382C42}, // 1e323\n\t{0x6C07A2C26A8346D1, 0x9E19DB92B4E31BA9}, // 1e324\n\t{0xC7098B7305241885, 0xC5A05277621BE293}, // 1e325\n\t{0xB8CBEE4FC66D1EA7, 0xF70867153AA2DB38}, // 1e326\n\t{0x737F74F1DC043328, 0x9A65406D44A5C903}, // 1e327\n\t{0x505F522E53053FF2, 0xC0FE908895CF3B44}, // 1e328\n\t{0x647726B9E7C68FEF, 0xF13E34AABB430A15}, // 1e329\n\t{0x5ECA783430DC19F5, 0x96C6E0EAB509E64D}, // 1e330\n\t{0xB67D16413D132072, 0xBC789925624C5FE0}, // 1e331\n\t{0xE41C5BD18C57E88F, 0xEB96BF6EBADF77D8}, // 1e332\n\t{0x8E91B962F7B6F159, 0x933E37A534CBAAE7}, // 1e333\n\t{0x723627BBB5A4ADB0, 0xB80DC58E81FE95A1}, // 1e334\n\t{0xCEC3B1AAA30DD91C, 0xE61136F2227E3B09}, // 1e335\n\t{0x213A4F0AA5E8A7B1, 0x8FCAC257558EE4E6}, // 1e336\n\t{0xA988E2CD4F62D19D, 0xB3BD72ED2AF29E1F}, // 1e337\n\t{0x93EB1B80A33B8605, 0xE0ACCFA875AF45A7}, // 1e338\n\t{0xBC72F130660533C3, 0x8C6C01C9498D8B88}, // 1e339\n\t{0xEB8FAD7C7F8680B4, 0xAF87023B9BF0EE6A}, // 1e340\n\t{0xA67398DB9F6820E1, 0xDB68C2CA82ED2A05}, // 1e341\n\t{0x88083F8943A1148C, 0x892179BE91D43A43}, // 1e342\n\t{0x6A0A4F6B948959B0, 0xAB69D82E364948D4}, // 1e343\n\t{0x848CE34679ABB01C, 0xD6444E39C3DB9B09}, // 1e344\n\t{0xF2D80E0C0C0B4E11, 0x85EAB0E41A6940E5}, // 1e345\n\t{0x6F8E118F0F0E2195, 0xA7655D1D2103911F}, // 1e346\n\t{0x4B7195F2D2D1A9FB, 0xD13EB46469447567}, // 1e347\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"ASMRWA0dfs1lZ0Rwl+BHfunCnBq0sMsG37oHr9p3L0JLqQVQxNEGMCnGWUOD5xt3zvN62UfAcneq6CZgxq3mSQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372632"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"eisel_lemire","Path":"gno.land/p/demo/json/eisel_lemire","Files":[{"Name":"eisel_lemire.gno","Body":"// Copyright 2020 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage eisel_lemire\n\n// This file implements the Eisel-Lemire ParseFloat algorithm, published in\n// 2020 and discussed extensively at\n// https://nigeltao.github.io/blog/2020/eisel-lemire.html\n//\n// The original C++ implementation is at\n// https://github.com/lemire/fast_double_parser/blob/644bef4306059d3be01a04e77d3cc84b379c596f/include/fast_double_parser.h#L840\n//\n// This Go re-implementation closely follows the C re-implementation at\n// https://github.com/google/wuffs/blob/ba3818cb6b473a2ed0b38ecfc07dbbd3a97e8ae7/internal/cgen/base/floatconv-submodule-code.c#L990\n//\n// Additional testing (on over several million test strings) is done by\n// https://github.com/nigeltao/parse-number-fxx-test-data/blob/5280dcfccf6d0b02a65ae282dad0b6d9de50e039/script/test-go-strconv.go\n\nimport (\n\t\"math\"\n\t\"math/bits\"\n)\n\nconst (\n\tfloat32ExponentBias = 127\n\tfloat64ExponentBias = 1023\n)\n\n// eiselLemire64 parses a floating-point number from its mantissa and exponent representation.\n// This implementation is based on the Eisel-Lemire ParseFloat algorithm, which is efficient\n// and precise for converting strings to floating-point numbers.\n//\n// Arguments:\n// man (uint64): The mantissa part of the floating-point number.\n// exp10 (int): The exponent part, representing the power of 10.\n// neg (bool): Indicates if the number is negative.\n//\n// Returns:\n// f (float64): The parsed floating-point number.\n// ok (bool): Indicates whether the parsing was successful.\n//\n// The function starts by handling special cases, such as zero mantissa.\n// It then checks if the exponent is within the allowed range.\n// After that, it normalizes the mantissa by left-shifting it to fill\n// the leading zeros. This is followed by the main algorithm logic that\n// converts the normalized mantissa and exponent into a 64-bit floating-point number.\n// The function returns this number along with a boolean indicating the success of the operation.\nfunc EiselLemire64(man uint64, exp10 int, neg bool) (f float64, ok bool) {\n\t// The terse comments in this function body refer to sections of the\n\t// https://nigeltao.github.io/blog/2020/eisel-lemire.html blog post.\n\n\t// Exp10 Range.\n\tif man == 0 {\n\t\tif neg {\n\t\t\tf = math.Float64frombits(0x80000000_00000000) // Negative zero.\n\t\t}\n\n\t\treturn f, true\n\t}\n\n\tif exp10 \u003c detailedPowersOfTenMinExp10 || detailedPowersOfTenMaxExp10 \u003c exp10 {\n\t\treturn 0, false\n\t}\n\n\t// Normalization.\n\tclz := bits.LeadingZeros64(man)\n\tman \u003c\u003c= uint(clz)\n\tretExp2 := uint64(217706*exp10\u003e\u003e16+64+float64ExponentBias) - uint64(clz)\n\n\t// Multiplication.\n\txHi, xLo := bits.Mul64(man, detailedPowersOfTen[exp10-detailedPowersOfTenMinExp10][1])\n\n\t// Wider Approximation.\n\tif xHi\u00260x1FF == 0x1FF \u0026\u0026 xLo+man \u003c man {\n\t\tyHi, yLo := bits.Mul64(man, detailedPowersOfTen[exp10-detailedPowersOfTenMinExp10][0])\n\t\tmergedHi, mergedLo := xHi, xLo+yHi\n\t\tif mergedLo \u003c xLo {\n\t\t\tmergedHi++\n\t\t}\n\n\t\tif mergedHi\u00260x1FF == 0x1FF \u0026\u0026 mergedLo+1 == 0 \u0026\u0026 yLo+man \u003c man {\n\t\t\treturn 0, false\n\t\t}\n\n\t\txHi, xLo = mergedHi, mergedLo\n\t}\n\n\t// Shifting to 54 Bits.\n\tmsb := xHi \u003e\u003e 63\n\tretMantissa := xHi \u003e\u003e (msb + 9)\n\tretExp2 -= 1 ^ msb\n\n\t// Half-way Ambiguity.\n\tif xLo == 0 \u0026\u0026 xHi\u00260x1FF == 0 \u0026\u0026 retMantissa\u00263 == 1 {\n\t\treturn 0, false\n\t}\n\n\t// From 54 to 53 Bits.\n\tretMantissa += retMantissa \u0026 1\n\tretMantissa \u003e\u003e= 1\n\tif retMantissa\u003e\u003e53 \u003e 0 {\n\t\tretMantissa \u003e\u003e= 1\n\t\tretExp2 += 1\n\t}\n\n\t// retExp2 is a uint64. Zero or underflow means that we're in subnormal\n\t// float64 space. 0x7FF or above means that we're in Inf/NaN float64 space.\n\t//\n\t// The if block is equivalent to (but has fewer branches than):\n\t//   if retExp2 \u003c= 0 || retExp2 \u003e= 0x7FF { etc }\n\tif retExp2-1 \u003e= 0x7FF-1 {\n\t\treturn 0, false\n\t}\n\n\tretBits := retExp2\u003c\u003c52 | retMantissa\u00260x000FFFFF_FFFFFFFF\n\tif neg {\n\t\tretBits |= 0x80000000_00000000\n\t}\n\n\treturn math.Float64frombits(retBits), true\n}\n\n// detailedPowersOfTen{Min,Max}Exp10 is the power of 10 represented by the\n// first and last rows of detailedPowersOfTen. Both bounds are inclusive.\nconst (\n\tdetailedPowersOfTenMinExp10 = -348\n\tdetailedPowersOfTenMaxExp10 = +347\n)\n\n// detailedPowersOfTen contains 128-bit mantissa approximations (rounded down)\n// to the powers of 10. For example:\n//\n//   - 1e43  (0xE596B7B0_C643C719                   * (2 ** 79))\n//   - 1e43 = (0xE596B7B0_C643C719_6D9CCD05_D0000000 * (2 ** 15))\n//\n// The mantissas are explicitly listed. The exponents are implied by a linear\n// expression with slope 217706.0/65536.0  log(10)/log(2).\n//\n// The table was generated by\n// https://github.com/google/wuffs/blob/ba3818cb6b473a2ed0b38ecfc07dbbd3a97e8ae7/script/print-mpb-powers-of-10.go\nvar detailedPowersOfTen = [...][2]uint64{\n\t{0x1732C869CD60E453, 0xFA8FD5A0081C0288}, // 1e-348\n\t{0x0E7FBD42205C8EB4, 0x9C99E58405118195}, // 1e-347\n\t{0x521FAC92A873B261, 0xC3C05EE50655E1FA}, // 1e-346\n\t{0xE6A797B752909EF9, 0xF4B0769E47EB5A78}, // 1e-345\n\t{0x9028BED2939A635C, 0x98EE4A22ECF3188B}, // 1e-344\n\t{0x7432EE873880FC33, 0xBF29DCABA82FDEAE}, // 1e-343\n\t{0x113FAA2906A13B3F, 0xEEF453D6923BD65A}, // 1e-342\n\t{0x4AC7CA59A424C507, 0x9558B4661B6565F8}, // 1e-341\n\t{0x5D79BCF00D2DF649, 0xBAAEE17FA23EBF76}, // 1e-340\n\t{0xF4D82C2C107973DC, 0xE95A99DF8ACE6F53}, // 1e-339\n\t{0x79071B9B8A4BE869, 0x91D8A02BB6C10594}, // 1e-338\n\t{0x9748E2826CDEE284, 0xB64EC836A47146F9}, // 1e-337\n\t{0xFD1B1B2308169B25, 0xE3E27A444D8D98B7}, // 1e-336\n\t{0xFE30F0F5E50E20F7, 0x8E6D8C6AB0787F72}, // 1e-335\n\t{0xBDBD2D335E51A935, 0xB208EF855C969F4F}, // 1e-334\n\t{0xAD2C788035E61382, 0xDE8B2B66B3BC4723}, // 1e-333\n\t{0x4C3BCB5021AFCC31, 0x8B16FB203055AC76}, // 1e-332\n\t{0xDF4ABE242A1BBF3D, 0xADDCB9E83C6B1793}, // 1e-331\n\t{0xD71D6DAD34A2AF0D, 0xD953E8624B85DD78}, // 1e-330\n\t{0x8672648C40E5AD68, 0x87D4713D6F33AA6B}, // 1e-329\n\t{0x680EFDAF511F18C2, 0xA9C98D8CCB009506}, // 1e-328\n\t{0x0212BD1B2566DEF2, 0xD43BF0EFFDC0BA48}, // 1e-327\n\t{0x014BB630F7604B57, 0x84A57695FE98746D}, // 1e-326\n\t{0x419EA3BD35385E2D, 0xA5CED43B7E3E9188}, // 1e-325\n\t{0x52064CAC828675B9, 0xCF42894A5DCE35EA}, // 1e-324\n\t{0x7343EFEBD1940993, 0x818995CE7AA0E1B2}, // 1e-323\n\t{0x1014EBE6C5F90BF8, 0xA1EBFB4219491A1F}, // 1e-322\n\t{0xD41A26E077774EF6, 0xCA66FA129F9B60A6}, // 1e-321\n\t{0x8920B098955522B4, 0xFD00B897478238D0}, // 1e-320\n\t{0x55B46E5F5D5535B0, 0x9E20735E8CB16382}, // 1e-319\n\t{0xEB2189F734AA831D, 0xC5A890362FDDBC62}, // 1e-318\n\t{0xA5E9EC7501D523E4, 0xF712B443BBD52B7B}, // 1e-317\n\t{0x47B233C92125366E, 0x9A6BB0AA55653B2D}, // 1e-316\n\t{0x999EC0BB696E840A, 0xC1069CD4EABE89F8}, // 1e-315\n\t{0xC00670EA43CA250D, 0xF148440A256E2C76}, // 1e-314\n\t{0x380406926A5E5728, 0x96CD2A865764DBCA}, // 1e-313\n\t{0xC605083704F5ECF2, 0xBC807527ED3E12BC}, // 1e-312\n\t{0xF7864A44C633682E, 0xEBA09271E88D976B}, // 1e-311\n\t{0x7AB3EE6AFBE0211D, 0x93445B8731587EA3}, // 1e-310\n\t{0x5960EA05BAD82964, 0xB8157268FDAE9E4C}, // 1e-309\n\t{0x6FB92487298E33BD, 0xE61ACF033D1A45DF}, // 1e-308\n\t{0xA5D3B6D479F8E056, 0x8FD0C16206306BAB}, // 1e-307\n\t{0x8F48A4899877186C, 0xB3C4F1BA87BC8696}, // 1e-306\n\t{0x331ACDABFE94DE87, 0xE0B62E2929ABA83C}, // 1e-305\n\t{0x9FF0C08B7F1D0B14, 0x8C71DCD9BA0B4925}, // 1e-304\n\t{0x07ECF0AE5EE44DD9, 0xAF8E5410288E1B6F}, // 1e-303\n\t{0xC9E82CD9F69D6150, 0xDB71E91432B1A24A}, // 1e-302\n\t{0xBE311C083A225CD2, 0x892731AC9FAF056E}, // 1e-301\n\t{0x6DBD630A48AAF406, 0xAB70FE17C79AC6CA}, // 1e-300\n\t{0x092CBBCCDAD5B108, 0xD64D3D9DB981787D}, // 1e-299\n\t{0x25BBF56008C58EA5, 0x85F0468293F0EB4E}, // 1e-298\n\t{0xAF2AF2B80AF6F24E, 0xA76C582338ED2621}, // 1e-297\n\t{0x1AF5AF660DB4AEE1, 0xD1476E2C07286FAA}, // 1e-296\n\t{0x50D98D9FC890ED4D, 0x82CCA4DB847945CA}, // 1e-295\n\t{0xE50FF107BAB528A0, 0xA37FCE126597973C}, // 1e-294\n\t{0x1E53ED49A96272C8, 0xCC5FC196FEFD7D0C}, // 1e-293\n\t{0x25E8E89C13BB0F7A, 0xFF77B1FCBEBCDC4F}, // 1e-292\n\t{0x77B191618C54E9AC, 0x9FAACF3DF73609B1}, // 1e-291\n\t{0xD59DF5B9EF6A2417, 0xC795830D75038C1D}, // 1e-290\n\t{0x4B0573286B44AD1D, 0xF97AE3D0D2446F25}, // 1e-289\n\t{0x4EE367F9430AEC32, 0x9BECCE62836AC577}, // 1e-288\n\t{0x229C41F793CDA73F, 0xC2E801FB244576D5}, // 1e-287\n\t{0x6B43527578C1110F, 0xF3A20279ED56D48A}, // 1e-286\n\t{0x830A13896B78AAA9, 0x9845418C345644D6}, // 1e-285\n\t{0x23CC986BC656D553, 0xBE5691EF416BD60C}, // 1e-284\n\t{0x2CBFBE86B7EC8AA8, 0xEDEC366B11C6CB8F}, // 1e-283\n\t{0x7BF7D71432F3D6A9, 0x94B3A202EB1C3F39}, // 1e-282\n\t{0xDAF5CCD93FB0CC53, 0xB9E08A83A5E34F07}, // 1e-281\n\t{0xD1B3400F8F9CFF68, 0xE858AD248F5C22C9}, // 1e-280\n\t{0x23100809B9C21FA1, 0x91376C36D99995BE}, // 1e-279\n\t{0xABD40A0C2832A78A, 0xB58547448FFFFB2D}, // 1e-278\n\t{0x16C90C8F323F516C, 0xE2E69915B3FFF9F9}, // 1e-277\n\t{0xAE3DA7D97F6792E3, 0x8DD01FAD907FFC3B}, // 1e-276\n\t{0x99CD11CFDF41779C, 0xB1442798F49FFB4A}, // 1e-275\n\t{0x40405643D711D583, 0xDD95317F31C7FA1D}, // 1e-274\n\t{0x482835EA666B2572, 0x8A7D3EEF7F1CFC52}, // 1e-273\n\t{0xDA3243650005EECF, 0xAD1C8EAB5EE43B66}, // 1e-272\n\t{0x90BED43E40076A82, 0xD863B256369D4A40}, // 1e-271\n\t{0x5A7744A6E804A291, 0x873E4F75E2224E68}, // 1e-270\n\t{0x711515D0A205CB36, 0xA90DE3535AAAE202}, // 1e-269\n\t{0x0D5A5B44CA873E03, 0xD3515C2831559A83}, // 1e-268\n\t{0xE858790AFE9486C2, 0x8412D9991ED58091}, // 1e-267\n\t{0x626E974DBE39A872, 0xA5178FFF668AE0B6}, // 1e-266\n\t{0xFB0A3D212DC8128F, 0xCE5D73FF402D98E3}, // 1e-265\n\t{0x7CE66634BC9D0B99, 0x80FA687F881C7F8E}, // 1e-264\n\t{0x1C1FFFC1EBC44E80, 0xA139029F6A239F72}, // 1e-263\n\t{0xA327FFB266B56220, 0xC987434744AC874E}, // 1e-262\n\t{0x4BF1FF9F0062BAA8, 0xFBE9141915D7A922}, // 1e-261\n\t{0x6F773FC3603DB4A9, 0x9D71AC8FADA6C9B5}, // 1e-260\n\t{0xCB550FB4384D21D3, 0xC4CE17B399107C22}, // 1e-259\n\t{0x7E2A53A146606A48, 0xF6019DA07F549B2B}, // 1e-258\n\t{0x2EDA7444CBFC426D, 0x99C102844F94E0FB}, // 1e-257\n\t{0xFA911155FEFB5308, 0xC0314325637A1939}, // 1e-256\n\t{0x793555AB7EBA27CA, 0xF03D93EEBC589F88}, // 1e-255\n\t{0x4BC1558B2F3458DE, 0x96267C7535B763B5}, // 1e-254\n\t{0x9EB1AAEDFB016F16, 0xBBB01B9283253CA2}, // 1e-253\n\t{0x465E15A979C1CADC, 0xEA9C227723EE8BCB}, // 1e-252\n\t{0x0BFACD89EC191EC9, 0x92A1958A7675175F}, // 1e-251\n\t{0xCEF980EC671F667B, 0xB749FAED14125D36}, // 1e-250\n\t{0x82B7E12780E7401A, 0xE51C79A85916F484}, // 1e-249\n\t{0xD1B2ECB8B0908810, 0x8F31CC0937AE58D2}, // 1e-248\n\t{0x861FA7E6DCB4AA15, 0xB2FE3F0B8599EF07}, // 1e-247\n\t{0x67A791E093E1D49A, 0xDFBDCECE67006AC9}, // 1e-246\n\t{0xE0C8BB2C5C6D24E0, 0x8BD6A141006042BD}, // 1e-245\n\t{0x58FAE9F773886E18, 0xAECC49914078536D}, // 1e-244\n\t{0xAF39A475506A899E, 0xDA7F5BF590966848}, // 1e-243\n\t{0x6D8406C952429603, 0x888F99797A5E012D}, // 1e-242\n\t{0xC8E5087BA6D33B83, 0xAAB37FD7D8F58178}, // 1e-241\n\t{0xFB1E4A9A90880A64, 0xD5605FCDCF32E1D6}, // 1e-240\n\t{0x5CF2EEA09A55067F, 0x855C3BE0A17FCD26}, // 1e-239\n\t{0xF42FAA48C0EA481E, 0xA6B34AD8C9DFC06F}, // 1e-238\n\t{0xF13B94DAF124DA26, 0xD0601D8EFC57B08B}, // 1e-237\n\t{0x76C53D08D6B70858, 0x823C12795DB6CE57}, // 1e-236\n\t{0x54768C4B0C64CA6E, 0xA2CB1717B52481ED}, // 1e-235\n\t{0xA9942F5DCF7DFD09, 0xCB7DDCDDA26DA268}, // 1e-234\n\t{0xD3F93B35435D7C4C, 0xFE5D54150B090B02}, // 1e-233\n\t{0xC47BC5014A1A6DAF, 0x9EFA548D26E5A6E1}, // 1e-232\n\t{0x359AB6419CA1091B, 0xC6B8E9B0709F109A}, // 1e-231\n\t{0xC30163D203C94B62, 0xF867241C8CC6D4C0}, // 1e-230\n\t{0x79E0DE63425DCF1D, 0x9B407691D7FC44F8}, // 1e-229\n\t{0x985915FC12F542E4, 0xC21094364DFB5636}, // 1e-228\n\t{0x3E6F5B7B17B2939D, 0xF294B943E17A2BC4}, // 1e-227\n\t{0xA705992CEECF9C42, 0x979CF3CA6CEC5B5A}, // 1e-226\n\t{0x50C6FF782A838353, 0xBD8430BD08277231}, // 1e-225\n\t{0xA4F8BF5635246428, 0xECE53CEC4A314EBD}, // 1e-224\n\t{0x871B7795E136BE99, 0x940F4613AE5ED136}, // 1e-223\n\t{0x28E2557B59846E3F, 0xB913179899F68584}, // 1e-222\n\t{0x331AEADA2FE589CF, 0xE757DD7EC07426E5}, // 1e-221\n\t{0x3FF0D2C85DEF7621, 0x9096EA6F3848984F}, // 1e-220\n\t{0x0FED077A756B53A9, 0xB4BCA50B065ABE63}, // 1e-219\n\t{0xD3E8495912C62894, 0xE1EBCE4DC7F16DFB}, // 1e-218\n\t{0x64712DD7ABBBD95C, 0x8D3360F09CF6E4BD}, // 1e-217\n\t{0xBD8D794D96AACFB3, 0xB080392CC4349DEC}, // 1e-216\n\t{0xECF0D7A0FC5583A0, 0xDCA04777F541C567}, // 1e-215\n\t{0xF41686C49DB57244, 0x89E42CAAF9491B60}, // 1e-214\n\t{0x311C2875C522CED5, 0xAC5D37D5B79B6239}, // 1e-213\n\t{0x7D633293366B828B, 0xD77485CB25823AC7}, // 1e-212\n\t{0xAE5DFF9C02033197, 0x86A8D39EF77164BC}, // 1e-211\n\t{0xD9F57F830283FDFC, 0xA8530886B54DBDEB}, // 1e-210\n\t{0xD072DF63C324FD7B, 0xD267CAA862A12D66}, // 1e-209\n\t{0x4247CB9E59F71E6D, 0x8380DEA93DA4BC60}, // 1e-208\n\t{0x52D9BE85F074E608, 0xA46116538D0DEB78}, // 1e-207\n\t{0x67902E276C921F8B, 0xCD795BE870516656}, // 1e-206\n\t{0x00BA1CD8A3DB53B6, 0x806BD9714632DFF6}, // 1e-205\n\t{0x80E8A40ECCD228A4, 0xA086CFCD97BF97F3}, // 1e-204\n\t{0x6122CD128006B2CD, 0xC8A883C0FDAF7DF0}, // 1e-203\n\t{0x796B805720085F81, 0xFAD2A4B13D1B5D6C}, // 1e-202\n\t{0xCBE3303674053BB0, 0x9CC3A6EEC6311A63}, // 1e-201\n\t{0xBEDBFC4411068A9C, 0xC3F490AA77BD60FC}, // 1e-200\n\t{0xEE92FB5515482D44, 0xF4F1B4D515ACB93B}, // 1e-199\n\t{0x751BDD152D4D1C4A, 0x991711052D8BF3C5}, // 1e-198\n\t{0xD262D45A78A0635D, 0xBF5CD54678EEF0B6}, // 1e-197\n\t{0x86FB897116C87C34, 0xEF340A98172AACE4}, // 1e-196\n\t{0xD45D35E6AE3D4DA0, 0x9580869F0E7AAC0E}, // 1e-195\n\t{0x8974836059CCA109, 0xBAE0A846D2195712}, // 1e-194\n\t{0x2BD1A438703FC94B, 0xE998D258869FACD7}, // 1e-193\n\t{0x7B6306A34627DDCF, 0x91FF83775423CC06}, // 1e-192\n\t{0x1A3BC84C17B1D542, 0xB67F6455292CBF08}, // 1e-191\n\t{0x20CABA5F1D9E4A93, 0xE41F3D6A7377EECA}, // 1e-190\n\t{0x547EB47B7282EE9C, 0x8E938662882AF53E}, // 1e-189\n\t{0xE99E619A4F23AA43, 0xB23867FB2A35B28D}, // 1e-188\n\t{0x6405FA00E2EC94D4, 0xDEC681F9F4C31F31}, // 1e-187\n\t{0xDE83BC408DD3DD04, 0x8B3C113C38F9F37E}, // 1e-186\n\t{0x9624AB50B148D445, 0xAE0B158B4738705E}, // 1e-185\n\t{0x3BADD624DD9B0957, 0xD98DDAEE19068C76}, // 1e-184\n\t{0xE54CA5D70A80E5D6, 0x87F8A8D4CFA417C9}, // 1e-183\n\t{0x5E9FCF4CCD211F4C, 0xA9F6D30A038D1DBC}, // 1e-182\n\t{0x7647C3200069671F, 0xD47487CC8470652B}, // 1e-181\n\t{0x29ECD9F40041E073, 0x84C8D4DFD2C63F3B}, // 1e-180\n\t{0xF468107100525890, 0xA5FB0A17C777CF09}, // 1e-179\n\t{0x7182148D4066EEB4, 0xCF79CC9DB955C2CC}, // 1e-178\n\t{0xC6F14CD848405530, 0x81AC1FE293D599BF}, // 1e-177\n\t{0xB8ADA00E5A506A7C, 0xA21727DB38CB002F}, // 1e-176\n\t{0xA6D90811F0E4851C, 0xCA9CF1D206FDC03B}, // 1e-175\n\t{0x908F4A166D1DA663, 0xFD442E4688BD304A}, // 1e-174\n\t{0x9A598E4E043287FE, 0x9E4A9CEC15763E2E}, // 1e-173\n\t{0x40EFF1E1853F29FD, 0xC5DD44271AD3CDBA}, // 1e-172\n\t{0xD12BEE59E68EF47C, 0xF7549530E188C128}, // 1e-171\n\t{0x82BB74F8301958CE, 0x9A94DD3E8CF578B9}, // 1e-170\n\t{0xE36A52363C1FAF01, 0xC13A148E3032D6E7}, // 1e-169\n\t{0xDC44E6C3CB279AC1, 0xF18899B1BC3F8CA1}, // 1e-168\n\t{0x29AB103A5EF8C0B9, 0x96F5600F15A7B7E5}, // 1e-167\n\t{0x7415D448F6B6F0E7, 0xBCB2B812DB11A5DE}, // 1e-166\n\t{0x111B495B3464AD21, 0xEBDF661791D60F56}, // 1e-165\n\t{0xCAB10DD900BEEC34, 0x936B9FCEBB25C995}, // 1e-164\n\t{0x3D5D514F40EEA742, 0xB84687C269EF3BFB}, // 1e-163\n\t{0x0CB4A5A3112A5112, 0xE65829B3046B0AFA}, // 1e-162\n\t{0x47F0E785EABA72AB, 0x8FF71A0FE2C2E6DC}, // 1e-161\n\t{0x59ED216765690F56, 0xB3F4E093DB73A093}, // 1e-160\n\t{0x306869C13EC3532C, 0xE0F218B8D25088B8}, // 1e-159\n\t{0x1E414218C73A13FB, 0x8C974F7383725573}, // 1e-158\n\t{0xE5D1929EF90898FA, 0xAFBD2350644EEACF}, // 1e-157\n\t{0xDF45F746B74ABF39, 0xDBAC6C247D62A583}, // 1e-156\n\t{0x6B8BBA8C328EB783, 0x894BC396CE5DA772}, // 1e-155\n\t{0x066EA92F3F326564, 0xAB9EB47C81F5114F}, // 1e-154\n\t{0xC80A537B0EFEFEBD, 0xD686619BA27255A2}, // 1e-153\n\t{0xBD06742CE95F5F36, 0x8613FD0145877585}, // 1e-152\n\t{0x2C48113823B73704, 0xA798FC4196E952E7}, // 1e-151\n\t{0xF75A15862CA504C5, 0xD17F3B51FCA3A7A0}, // 1e-150\n\t{0x9A984D73DBE722FB, 0x82EF85133DE648C4}, // 1e-149\n\t{0xC13E60D0D2E0EBBA, 0xA3AB66580D5FDAF5}, // 1e-148\n\t{0x318DF905079926A8, 0xCC963FEE10B7D1B3}, // 1e-147\n\t{0xFDF17746497F7052, 0xFFBBCFE994E5C61F}, // 1e-146\n\t{0xFEB6EA8BEDEFA633, 0x9FD561F1FD0F9BD3}, // 1e-145\n\t{0xFE64A52EE96B8FC0, 0xC7CABA6E7C5382C8}, // 1e-144\n\t{0x3DFDCE7AA3C673B0, 0xF9BD690A1B68637B}, // 1e-143\n\t{0x06BEA10CA65C084E, 0x9C1661A651213E2D}, // 1e-142\n\t{0x486E494FCFF30A62, 0xC31BFA0FE5698DB8}, // 1e-141\n\t{0x5A89DBA3C3EFCCFA, 0xF3E2F893DEC3F126}, // 1e-140\n\t{0xF89629465A75E01C, 0x986DDB5C6B3A76B7}, // 1e-139\n\t{0xF6BBB397F1135823, 0xBE89523386091465}, // 1e-138\n\t{0x746AA07DED582E2C, 0xEE2BA6C0678B597F}, // 1e-137\n\t{0xA8C2A44EB4571CDC, 0x94DB483840B717EF}, // 1e-136\n\t{0x92F34D62616CE413, 0xBA121A4650E4DDEB}, // 1e-135\n\t{0x77B020BAF9C81D17, 0xE896A0D7E51E1566}, // 1e-134\n\t{0x0ACE1474DC1D122E, 0x915E2486EF32CD60}, // 1e-133\n\t{0x0D819992132456BA, 0xB5B5ADA8AAFF80B8}, // 1e-132\n\t{0x10E1FFF697ED6C69, 0xE3231912D5BF60E6}, // 1e-131\n\t{0xCA8D3FFA1EF463C1, 0x8DF5EFABC5979C8F}, // 1e-130\n\t{0xBD308FF8A6B17CB2, 0xB1736B96B6FD83B3}, // 1e-129\n\t{0xAC7CB3F6D05DDBDE, 0xDDD0467C64BCE4A0}, // 1e-128\n\t{0x6BCDF07A423AA96B, 0x8AA22C0DBEF60EE4}, // 1e-127\n\t{0x86C16C98D2C953C6, 0xAD4AB7112EB3929D}, // 1e-126\n\t{0xE871C7BF077BA8B7, 0xD89D64D57A607744}, // 1e-125\n\t{0x11471CD764AD4972, 0x87625F056C7C4A8B}, // 1e-124\n\t{0xD598E40D3DD89BCF, 0xA93AF6C6C79B5D2D}, // 1e-123\n\t{0x4AFF1D108D4EC2C3, 0xD389B47879823479}, // 1e-122\n\t{0xCEDF722A585139BA, 0x843610CB4BF160CB}, // 1e-121\n\t{0xC2974EB4EE658828, 0xA54394FE1EEDB8FE}, // 1e-120\n\t{0x733D226229FEEA32, 0xCE947A3DA6A9273E}, // 1e-119\n\t{0x0806357D5A3F525F, 0x811CCC668829B887}, // 1e-118\n\t{0xCA07C2DCB0CF26F7, 0xA163FF802A3426A8}, // 1e-117\n\t{0xFC89B393DD02F0B5, 0xC9BCFF6034C13052}, // 1e-116\n\t{0xBBAC2078D443ACE2, 0xFC2C3F3841F17C67}, // 1e-115\n\t{0xD54B944B84AA4C0D, 0x9D9BA7832936EDC0}, // 1e-114\n\t{0x0A9E795E65D4DF11, 0xC5029163F384A931}, // 1e-113\n\t{0x4D4617B5FF4A16D5, 0xF64335BCF065D37D}, // 1e-112\n\t{0x504BCED1BF8E4E45, 0x99EA0196163FA42E}, // 1e-111\n\t{0xE45EC2862F71E1D6, 0xC06481FB9BCF8D39}, // 1e-110\n\t{0x5D767327BB4E5A4C, 0xF07DA27A82C37088}, // 1e-109\n\t{0x3A6A07F8D510F86F, 0x964E858C91BA2655}, // 1e-108\n\t{0x890489F70A55368B, 0xBBE226EFB628AFEA}, // 1e-107\n\t{0x2B45AC74CCEA842E, 0xEADAB0ABA3B2DBE5}, // 1e-106\n\t{0x3B0B8BC90012929D, 0x92C8AE6B464FC96F}, // 1e-105\n\t{0x09CE6EBB40173744, 0xB77ADA0617E3BBCB}, // 1e-104\n\t{0xCC420A6A101D0515, 0xE55990879DDCAABD}, // 1e-103\n\t{0x9FA946824A12232D, 0x8F57FA54C2A9EAB6}, // 1e-102\n\t{0x47939822DC96ABF9, 0xB32DF8E9F3546564}, // 1e-101\n\t{0x59787E2B93BC56F7, 0xDFF9772470297EBD}, // 1e-100\n\t{0x57EB4EDB3C55B65A, 0x8BFBEA76C619EF36}, // 1e-99\n\t{0xEDE622920B6B23F1, 0xAEFAE51477A06B03}, // 1e-98\n\t{0xE95FAB368E45ECED, 0xDAB99E59958885C4}, // 1e-97\n\t{0x11DBCB0218EBB414, 0x88B402F7FD75539B}, // 1e-96\n\t{0xD652BDC29F26A119, 0xAAE103B5FCD2A881}, // 1e-95\n\t{0x4BE76D3346F0495F, 0xD59944A37C0752A2}, // 1e-94\n\t{0x6F70A4400C562DDB, 0x857FCAE62D8493A5}, // 1e-93\n\t{0xCB4CCD500F6BB952, 0xA6DFBD9FB8E5B88E}, // 1e-92\n\t{0x7E2000A41346A7A7, 0xD097AD07A71F26B2}, // 1e-91\n\t{0x8ED400668C0C28C8, 0x825ECC24C873782F}, // 1e-90\n\t{0x728900802F0F32FA, 0xA2F67F2DFA90563B}, // 1e-89\n\t{0x4F2B40A03AD2FFB9, 0xCBB41EF979346BCA}, // 1e-88\n\t{0xE2F610C84987BFA8, 0xFEA126B7D78186BC}, // 1e-87\n\t{0x0DD9CA7D2DF4D7C9, 0x9F24B832E6B0F436}, // 1e-86\n\t{0x91503D1C79720DBB, 0xC6EDE63FA05D3143}, // 1e-85\n\t{0x75A44C6397CE912A, 0xF8A95FCF88747D94}, // 1e-84\n\t{0xC986AFBE3EE11ABA, 0x9B69DBE1B548CE7C}, // 1e-83\n\t{0xFBE85BADCE996168, 0xC24452DA229B021B}, // 1e-82\n\t{0xFAE27299423FB9C3, 0xF2D56790AB41C2A2}, // 1e-81\n\t{0xDCCD879FC967D41A, 0x97C560BA6B0919A5}, // 1e-80\n\t{0x5400E987BBC1C920, 0xBDB6B8E905CB600F}, // 1e-79\n\t{0x290123E9AAB23B68, 0xED246723473E3813}, // 1e-78\n\t{0xF9A0B6720AAF6521, 0x9436C0760C86E30B}, // 1e-77\n\t{0xF808E40E8D5B3E69, 0xB94470938FA89BCE}, // 1e-76\n\t{0xB60B1D1230B20E04, 0xE7958CB87392C2C2}, // 1e-75\n\t{0xB1C6F22B5E6F48C2, 0x90BD77F3483BB9B9}, // 1e-74\n\t{0x1E38AEB6360B1AF3, 0xB4ECD5F01A4AA828}, // 1e-73\n\t{0x25C6DA63C38DE1B0, 0xE2280B6C20DD5232}, // 1e-72\n\t{0x579C487E5A38AD0E, 0x8D590723948A535F}, // 1e-71\n\t{0x2D835A9DF0C6D851, 0xB0AF48EC79ACE837}, // 1e-70\n\t{0xF8E431456CF88E65, 0xDCDB1B2798182244}, // 1e-69\n\t{0x1B8E9ECB641B58FF, 0x8A08F0F8BF0F156B}, // 1e-68\n\t{0xE272467E3D222F3F, 0xAC8B2D36EED2DAC5}, // 1e-67\n\t{0x5B0ED81DCC6ABB0F, 0xD7ADF884AA879177}, // 1e-66\n\t{0x98E947129FC2B4E9, 0x86CCBB52EA94BAEA}, // 1e-65\n\t{0x3F2398D747B36224, 0xA87FEA27A539E9A5}, // 1e-64\n\t{0x8EEC7F0D19A03AAD, 0xD29FE4B18E88640E}, // 1e-63\n\t{0x1953CF68300424AC, 0x83A3EEEEF9153E89}, // 1e-62\n\t{0x5FA8C3423C052DD7, 0xA48CEAAAB75A8E2B}, // 1e-61\n\t{0x3792F412CB06794D, 0xCDB02555653131B6}, // 1e-60\n\t{0xE2BBD88BBEE40BD0, 0x808E17555F3EBF11}, // 1e-59\n\t{0x5B6ACEAEAE9D0EC4, 0xA0B19D2AB70E6ED6}, // 1e-58\n\t{0xF245825A5A445275, 0xC8DE047564D20A8B}, // 1e-57\n\t{0xEED6E2F0F0D56712, 0xFB158592BE068D2E}, // 1e-56\n\t{0x55464DD69685606B, 0x9CED737BB6C4183D}, // 1e-55\n\t{0xAA97E14C3C26B886, 0xC428D05AA4751E4C}, // 1e-54\n\t{0xD53DD99F4B3066A8, 0xF53304714D9265DF}, // 1e-53\n\t{0xE546A8038EFE4029, 0x993FE2C6D07B7FAB}, // 1e-52\n\t{0xDE98520472BDD033, 0xBF8FDB78849A5F96}, // 1e-51\n\t{0x963E66858F6D4440, 0xEF73D256A5C0F77C}, // 1e-50\n\t{0xDDE7001379A44AA8, 0x95A8637627989AAD}, // 1e-49\n\t{0x5560C018580D5D52, 0xBB127C53B17EC159}, // 1e-48\n\t{0xAAB8F01E6E10B4A6, 0xE9D71B689DDE71AF}, // 1e-47\n\t{0xCAB3961304CA70E8, 0x9226712162AB070D}, // 1e-46\n\t{0x3D607B97C5FD0D22, 0xB6B00D69BB55C8D1}, // 1e-45\n\t{0x8CB89A7DB77C506A, 0xE45C10C42A2B3B05}, // 1e-44\n\t{0x77F3608E92ADB242, 0x8EB98A7A9A5B04E3}, // 1e-43\n\t{0x55F038B237591ED3, 0xB267ED1940F1C61C}, // 1e-42\n\t{0x6B6C46DEC52F6688, 0xDF01E85F912E37A3}, // 1e-41\n\t{0x2323AC4B3B3DA015, 0x8B61313BBABCE2C6}, // 1e-40\n\t{0xABEC975E0A0D081A, 0xAE397D8AA96C1B77}, // 1e-39\n\t{0x96E7BD358C904A21, 0xD9C7DCED53C72255}, // 1e-38\n\t{0x7E50D64177DA2E54, 0x881CEA14545C7575}, // 1e-37\n\t{0xDDE50BD1D5D0B9E9, 0xAA242499697392D2}, // 1e-36\n\t{0x955E4EC64B44E864, 0xD4AD2DBFC3D07787}, // 1e-35\n\t{0xBD5AF13BEF0B113E, 0x84EC3C97DA624AB4}, // 1e-34\n\t{0xECB1AD8AEACDD58E, 0xA6274BBDD0FADD61}, // 1e-33\n\t{0x67DE18EDA5814AF2, 0xCFB11EAD453994BA}, // 1e-32\n\t{0x80EACF948770CED7, 0x81CEB32C4B43FCF4}, // 1e-31\n\t{0xA1258379A94D028D, 0xA2425FF75E14FC31}, // 1e-30\n\t{0x096EE45813A04330, 0xCAD2F7F5359A3B3E}, // 1e-29\n\t{0x8BCA9D6E188853FC, 0xFD87B5F28300CA0D}, // 1e-28\n\t{0x775EA264CF55347D, 0x9E74D1B791E07E48}, // 1e-27\n\t{0x95364AFE032A819D, 0xC612062576589DDA}, // 1e-26\n\t{0x3A83DDBD83F52204, 0xF79687AED3EEC551}, // 1e-25\n\t{0xC4926A9672793542, 0x9ABE14CD44753B52}, // 1e-24\n\t{0x75B7053C0F178293, 0xC16D9A0095928A27}, // 1e-23\n\t{0x5324C68B12DD6338, 0xF1C90080BAF72CB1}, // 1e-22\n\t{0xD3F6FC16EBCA5E03, 0x971DA05074DA7BEE}, // 1e-21\n\t{0x88F4BB1CA6BCF584, 0xBCE5086492111AEA}, // 1e-20\n\t{0x2B31E9E3D06C32E5, 0xEC1E4A7DB69561A5}, // 1e-19\n\t{0x3AFF322E62439FCF, 0x9392EE8E921D5D07}, // 1e-18\n\t{0x09BEFEB9FAD487C2, 0xB877AA3236A4B449}, // 1e-17\n\t{0x4C2EBE687989A9B3, 0xE69594BEC44DE15B}, // 1e-16\n\t{0x0F9D37014BF60A10, 0x901D7CF73AB0ACD9}, // 1e-15\n\t{0x538484C19EF38C94, 0xB424DC35095CD80F}, // 1e-14\n\t{0x2865A5F206B06FB9, 0xE12E13424BB40E13}, // 1e-13\n\t{0xF93F87B7442E45D3, 0x8CBCCC096F5088CB}, // 1e-12\n\t{0xF78F69A51539D748, 0xAFEBFF0BCB24AAFE}, // 1e-11\n\t{0xB573440E5A884D1B, 0xDBE6FECEBDEDD5BE}, // 1e-10\n\t{0x31680A88F8953030, 0x89705F4136B4A597}, // 1e-9\n\t{0xFDC20D2B36BA7C3D, 0xABCC77118461CEFC}, // 1e-8\n\t{0x3D32907604691B4C, 0xD6BF94D5E57A42BC}, // 1e-7\n\t{0xA63F9A49C2C1B10F, 0x8637BD05AF6C69B5}, // 1e-6\n\t{0x0FCF80DC33721D53, 0xA7C5AC471B478423}, // 1e-5\n\t{0xD3C36113404EA4A8, 0xD1B71758E219652B}, // 1e-4\n\t{0x645A1CAC083126E9, 0x83126E978D4FDF3B}, // 1e-3\n\t{0x3D70A3D70A3D70A3, 0xA3D70A3D70A3D70A}, // 1e-2\n\t{0xCCCCCCCCCCCCCCCC, 0xCCCCCCCCCCCCCCCC}, // 1e-1\n\t{0x0000000000000000, 0x8000000000000000}, // 1e0\n\t{0x0000000000000000, 0xA000000000000000}, // 1e1\n\t{0x0000000000000000, 0xC800000000000000}, // 1e2\n\t{0x0000000000000000, 0xFA00000000000000}, // 1e3\n\t{0x0000000000000000, 0x9C40000000000000}, // 1e4\n\t{0x0000000000000000, 0xC350000000000000}, // 1e5\n\t{0x0000000000000000, 0xF424000000000000}, // 1e6\n\t{0x0000000000000000, 0x9896800000000000}, // 1e7\n\t{0x0000000000000000, 0xBEBC200000000000}, // 1e8\n\t{0x0000000000000000, 0xEE6B280000000000}, // 1e9\n\t{0x0000000000000000, 0x9502F90000000000}, // 1e10\n\t{0x0000000000000000, 0xBA43B74000000000}, // 1e11\n\t{0x0000000000000000, 0xE8D4A51000000000}, // 1e12\n\t{0x0000000000000000, 0x9184E72A00000000}, // 1e13\n\t{0x0000000000000000, 0xB5E620F480000000}, // 1e14\n\t{0x0000000000000000, 0xE35FA931A0000000}, // 1e15\n\t{0x0000000000000000, 0x8E1BC9BF04000000}, // 1e16\n\t{0x0000000000000000, 0xB1A2BC2EC5000000}, // 1e17\n\t{0x0000000000000000, 0xDE0B6B3A76400000}, // 1e18\n\t{0x0000000000000000, 0x8AC7230489E80000}, // 1e19\n\t{0x0000000000000000, 0xAD78EBC5AC620000}, // 1e20\n\t{0x0000000000000000, 0xD8D726B7177A8000}, // 1e21\n\t{0x0000000000000000, 0x878678326EAC9000}, // 1e22\n\t{0x0000000000000000, 0xA968163F0A57B400}, // 1e23\n\t{0x0000000000000000, 0xD3C21BCECCEDA100}, // 1e24\n\t{0x0000000000000000, 0x84595161401484A0}, // 1e25\n\t{0x0000000000000000, 0xA56FA5B99019A5C8}, // 1e26\n\t{0x0000000000000000, 0xCECB8F27F4200F3A}, // 1e27\n\t{0x4000000000000000, 0x813F3978F8940984}, // 1e28\n\t{0x5000000000000000, 0xA18F07D736B90BE5}, // 1e29\n\t{0xA400000000000000, 0xC9F2C9CD04674EDE}, // 1e30\n\t{0x4D00000000000000, 0xFC6F7C4045812296}, // 1e31\n\t{0xF020000000000000, 0x9DC5ADA82B70B59D}, // 1e32\n\t{0x6C28000000000000, 0xC5371912364CE305}, // 1e33\n\t{0xC732000000000000, 0xF684DF56C3E01BC6}, // 1e34\n\t{0x3C7F400000000000, 0x9A130B963A6C115C}, // 1e35\n\t{0x4B9F100000000000, 0xC097CE7BC90715B3}, // 1e36\n\t{0x1E86D40000000000, 0xF0BDC21ABB48DB20}, // 1e37\n\t{0x1314448000000000, 0x96769950B50D88F4}, // 1e38\n\t{0x17D955A000000000, 0xBC143FA4E250EB31}, // 1e39\n\t{0x5DCFAB0800000000, 0xEB194F8E1AE525FD}, // 1e40\n\t{0x5AA1CAE500000000, 0x92EFD1B8D0CF37BE}, // 1e41\n\t{0xF14A3D9E40000000, 0xB7ABC627050305AD}, // 1e42\n\t{0x6D9CCD05D0000000, 0xE596B7B0C643C719}, // 1e43\n\t{0xE4820023A2000000, 0x8F7E32CE7BEA5C6F}, // 1e44\n\t{0xDDA2802C8A800000, 0xB35DBF821AE4F38B}, // 1e45\n\t{0xD50B2037AD200000, 0xE0352F62A19E306E}, // 1e46\n\t{0x4526F422CC340000, 0x8C213D9DA502DE45}, // 1e47\n\t{0x9670B12B7F410000, 0xAF298D050E4395D6}, // 1e48\n\t{0x3C0CDD765F114000, 0xDAF3F04651D47B4C}, // 1e49\n\t{0xA5880A69FB6AC800, 0x88D8762BF324CD0F}, // 1e50\n\t{0x8EEA0D047A457A00, 0xAB0E93B6EFEE0053}, // 1e51\n\t{0x72A4904598D6D880, 0xD5D238A4ABE98068}, // 1e52\n\t{0x47A6DA2B7F864750, 0x85A36366EB71F041}, // 1e53\n\t{0x999090B65F67D924, 0xA70C3C40A64E6C51}, // 1e54\n\t{0xFFF4B4E3F741CF6D, 0xD0CF4B50CFE20765}, // 1e55\n\t{0xBFF8F10E7A8921A4, 0x82818F1281ED449F}, // 1e56\n\t{0xAFF72D52192B6A0D, 0xA321F2D7226895C7}, // 1e57\n\t{0x9BF4F8A69F764490, 0xCBEA6F8CEB02BB39}, // 1e58\n\t{0x02F236D04753D5B4, 0xFEE50B7025C36A08}, // 1e59\n\t{0x01D762422C946590, 0x9F4F2726179A2245}, // 1e60\n\t{0x424D3AD2B7B97EF5, 0xC722F0EF9D80AAD6}, // 1e61\n\t{0xD2E0898765A7DEB2, 0xF8EBAD2B84E0D58B}, // 1e62\n\t{0x63CC55F49F88EB2F, 0x9B934C3B330C8577}, // 1e63\n\t{0x3CBF6B71C76B25FB, 0xC2781F49FFCFA6D5}, // 1e64\n\t{0x8BEF464E3945EF7A, 0xF316271C7FC3908A}, // 1e65\n\t{0x97758BF0E3CBB5AC, 0x97EDD871CFDA3A56}, // 1e66\n\t{0x3D52EEED1CBEA317, 0xBDE94E8E43D0C8EC}, // 1e67\n\t{0x4CA7AAA863EE4BDD, 0xED63A231D4C4FB27}, // 1e68\n\t{0x8FE8CAA93E74EF6A, 0x945E455F24FB1CF8}, // 1e69\n\t{0xB3E2FD538E122B44, 0xB975D6B6EE39E436}, // 1e70\n\t{0x60DBBCA87196B616, 0xE7D34C64A9C85D44}, // 1e71\n\t{0xBC8955E946FE31CD, 0x90E40FBEEA1D3A4A}, // 1e72\n\t{0x6BABAB6398BDBE41, 0xB51D13AEA4A488DD}, // 1e73\n\t{0xC696963C7EED2DD1, 0xE264589A4DCDAB14}, // 1e74\n\t{0xFC1E1DE5CF543CA2, 0x8D7EB76070A08AEC}, // 1e75\n\t{0x3B25A55F43294BCB, 0xB0DE65388CC8ADA8}, // 1e76\n\t{0x49EF0EB713F39EBE, 0xDD15FE86AFFAD912}, // 1e77\n\t{0x6E3569326C784337, 0x8A2DBF142DFCC7AB}, // 1e78\n\t{0x49C2C37F07965404, 0xACB92ED9397BF996}, // 1e79\n\t{0xDC33745EC97BE906, 0xD7E77A8F87DAF7FB}, // 1e80\n\t{0x69A028BB3DED71A3, 0x86F0AC99B4E8DAFD}, // 1e81\n\t{0xC40832EA0D68CE0C, 0xA8ACD7C0222311BC}, // 1e82\n\t{0xF50A3FA490C30190, 0xD2D80DB02AABD62B}, // 1e83\n\t{0x792667C6DA79E0FA, 0x83C7088E1AAB65DB}, // 1e84\n\t{0x577001B891185938, 0xA4B8CAB1A1563F52}, // 1e85\n\t{0xED4C0226B55E6F86, 0xCDE6FD5E09ABCF26}, // 1e86\n\t{0x544F8158315B05B4, 0x80B05E5AC60B6178}, // 1e87\n\t{0x696361AE3DB1C721, 0xA0DC75F1778E39D6}, // 1e88\n\t{0x03BC3A19CD1E38E9, 0xC913936DD571C84C}, // 1e89\n\t{0x04AB48A04065C723, 0xFB5878494ACE3A5F}, // 1e90\n\t{0x62EB0D64283F9C76, 0x9D174B2DCEC0E47B}, // 1e91\n\t{0x3BA5D0BD324F8394, 0xC45D1DF942711D9A}, // 1e92\n\t{0xCA8F44EC7EE36479, 0xF5746577930D6500}, // 1e93\n\t{0x7E998B13CF4E1ECB, 0x9968BF6ABBE85F20}, // 1e94\n\t{0x9E3FEDD8C321A67E, 0xBFC2EF456AE276E8}, // 1e95\n\t{0xC5CFE94EF3EA101E, 0xEFB3AB16C59B14A2}, // 1e96\n\t{0xBBA1F1D158724A12, 0x95D04AEE3B80ECE5}, // 1e97\n\t{0x2A8A6E45AE8EDC97, 0xBB445DA9CA61281F}, // 1e98\n\t{0xF52D09D71A3293BD, 0xEA1575143CF97226}, // 1e99\n\t{0x593C2626705F9C56, 0x924D692CA61BE758}, // 1e100\n\t{0x6F8B2FB00C77836C, 0xB6E0C377CFA2E12E}, // 1e101\n\t{0x0B6DFB9C0F956447, 0xE498F455C38B997A}, // 1e102\n\t{0x4724BD4189BD5EAC, 0x8EDF98B59A373FEC}, // 1e103\n\t{0x58EDEC91EC2CB657, 0xB2977EE300C50FE7}, // 1e104\n\t{0x2F2967B66737E3ED, 0xDF3D5E9BC0F653E1}, // 1e105\n\t{0xBD79E0D20082EE74, 0x8B865B215899F46C}, // 1e106\n\t{0xECD8590680A3AA11, 0xAE67F1E9AEC07187}, // 1e107\n\t{0xE80E6F4820CC9495, 0xDA01EE641A708DE9}, // 1e108\n\t{0x3109058D147FDCDD, 0x884134FE908658B2}, // 1e109\n\t{0xBD4B46F0599FD415, 0xAA51823E34A7EEDE}, // 1e110\n\t{0x6C9E18AC7007C91A, 0xD4E5E2CDC1D1EA96}, // 1e111\n\t{0x03E2CF6BC604DDB0, 0x850FADC09923329E}, // 1e112\n\t{0x84DB8346B786151C, 0xA6539930BF6BFF45}, // 1e113\n\t{0xE612641865679A63, 0xCFE87F7CEF46FF16}, // 1e114\n\t{0x4FCB7E8F3F60C07E, 0x81F14FAE158C5F6E}, // 1e115\n\t{0xE3BE5E330F38F09D, 0xA26DA3999AEF7749}, // 1e116\n\t{0x5CADF5BFD3072CC5, 0xCB090C8001AB551C}, // 1e117\n\t{0x73D9732FC7C8F7F6, 0xFDCB4FA002162A63}, // 1e118\n\t{0x2867E7FDDCDD9AFA, 0x9E9F11C4014DDA7E}, // 1e119\n\t{0xB281E1FD541501B8, 0xC646D63501A1511D}, // 1e120\n\t{0x1F225A7CA91A4226, 0xF7D88BC24209A565}, // 1e121\n\t{0x3375788DE9B06958, 0x9AE757596946075F}, // 1e122\n\t{0x0052D6B1641C83AE, 0xC1A12D2FC3978937}, // 1e123\n\t{0xC0678C5DBD23A49A, 0xF209787BB47D6B84}, // 1e124\n\t{0xF840B7BA963646E0, 0x9745EB4D50CE6332}, // 1e125\n\t{0xB650E5A93BC3D898, 0xBD176620A501FBFF}, // 1e126\n\t{0xA3E51F138AB4CEBE, 0xEC5D3FA8CE427AFF}, // 1e127\n\t{0xC66F336C36B10137, 0x93BA47C980E98CDF}, // 1e128\n\t{0xB80B0047445D4184, 0xB8A8D9BBE123F017}, // 1e129\n\t{0xA60DC059157491E5, 0xE6D3102AD96CEC1D}, // 1e130\n\t{0x87C89837AD68DB2F, 0x9043EA1AC7E41392}, // 1e131\n\t{0x29BABE4598C311FB, 0xB454E4A179DD1877}, // 1e132\n\t{0xF4296DD6FEF3D67A, 0xE16A1DC9D8545E94}, // 1e133\n\t{0x1899E4A65F58660C, 0x8CE2529E2734BB1D}, // 1e134\n\t{0x5EC05DCFF72E7F8F, 0xB01AE745B101E9E4}, // 1e135\n\t{0x76707543F4FA1F73, 0xDC21A1171D42645D}, // 1e136\n\t{0x6A06494A791C53A8, 0x899504AE72497EBA}, // 1e137\n\t{0x0487DB9D17636892, 0xABFA45DA0EDBDE69}, // 1e138\n\t{0x45A9D2845D3C42B6, 0xD6F8D7509292D603}, // 1e139\n\t{0x0B8A2392BA45A9B2, 0x865B86925B9BC5C2}, // 1e140\n\t{0x8E6CAC7768D7141E, 0xA7F26836F282B732}, // 1e141\n\t{0x3207D795430CD926, 0xD1EF0244AF2364FF}, // 1e142\n\t{0x7F44E6BD49E807B8, 0x8335616AED761F1F}, // 1e143\n\t{0x5F16206C9C6209A6, 0xA402B9C5A8D3A6E7}, // 1e144\n\t{0x36DBA887C37A8C0F, 0xCD036837130890A1}, // 1e145\n\t{0xC2494954DA2C9789, 0x802221226BE55A64}, // 1e146\n\t{0xF2DB9BAA10B7BD6C, 0xA02AA96B06DEB0FD}, // 1e147\n\t{0x6F92829494E5ACC7, 0xC83553C5C8965D3D}, // 1e148\n\t{0xCB772339BA1F17F9, 0xFA42A8B73ABBF48C}, // 1e149\n\t{0xFF2A760414536EFB, 0x9C69A97284B578D7}, // 1e150\n\t{0xFEF5138519684ABA, 0xC38413CF25E2D70D}, // 1e151\n\t{0x7EB258665FC25D69, 0xF46518C2EF5B8CD1}, // 1e152\n\t{0xEF2F773FFBD97A61, 0x98BF2F79D5993802}, // 1e153\n\t{0xAAFB550FFACFD8FA, 0xBEEEFB584AFF8603}, // 1e154\n\t{0x95BA2A53F983CF38, 0xEEAABA2E5DBF6784}, // 1e155\n\t{0xDD945A747BF26183, 0x952AB45CFA97A0B2}, // 1e156\n\t{0x94F971119AEEF9E4, 0xBA756174393D88DF}, // 1e157\n\t{0x7A37CD5601AAB85D, 0xE912B9D1478CEB17}, // 1e158\n\t{0xAC62E055C10AB33A, 0x91ABB422CCB812EE}, // 1e159\n\t{0x577B986B314D6009, 0xB616A12B7FE617AA}, // 1e160\n\t{0xED5A7E85FDA0B80B, 0xE39C49765FDF9D94}, // 1e161\n\t{0x14588F13BE847307, 0x8E41ADE9FBEBC27D}, // 1e162\n\t{0x596EB2D8AE258FC8, 0xB1D219647AE6B31C}, // 1e163\n\t{0x6FCA5F8ED9AEF3BB, 0xDE469FBD99A05FE3}, // 1e164\n\t{0x25DE7BB9480D5854, 0x8AEC23D680043BEE}, // 1e165\n\t{0xAF561AA79A10AE6A, 0xADA72CCC20054AE9}, // 1e166\n\t{0x1B2BA1518094DA04, 0xD910F7FF28069DA4}, // 1e167\n\t{0x90FB44D2F05D0842, 0x87AA9AFF79042286}, // 1e168\n\t{0x353A1607AC744A53, 0xA99541BF57452B28}, // 1e169\n\t{0x42889B8997915CE8, 0xD3FA922F2D1675F2}, // 1e170\n\t{0x69956135FEBADA11, 0x847C9B5D7C2E09B7}, // 1e171\n\t{0x43FAB9837E699095, 0xA59BC234DB398C25}, // 1e172\n\t{0x94F967E45E03F4BB, 0xCF02B2C21207EF2E}, // 1e173\n\t{0x1D1BE0EEBAC278F5, 0x8161AFB94B44F57D}, // 1e174\n\t{0x6462D92A69731732, 0xA1BA1BA79E1632DC}, // 1e175\n\t{0x7D7B8F7503CFDCFE, 0xCA28A291859BBF93}, // 1e176\n\t{0x5CDA735244C3D43E, 0xFCB2CB35E702AF78}, // 1e177\n\t{0x3A0888136AFA64A7, 0x9DEFBF01B061ADAB}, // 1e178\n\t{0x088AAA1845B8FDD0, 0xC56BAEC21C7A1916}, // 1e179\n\t{0x8AAD549E57273D45, 0xF6C69A72A3989F5B}, // 1e180\n\t{0x36AC54E2F678864B, 0x9A3C2087A63F6399}, // 1e181\n\t{0x84576A1BB416A7DD, 0xC0CB28A98FCF3C7F}, // 1e182\n\t{0x656D44A2A11C51D5, 0xF0FDF2D3F3C30B9F}, // 1e183\n\t{0x9F644AE5A4B1B325, 0x969EB7C47859E743}, // 1e184\n\t{0x873D5D9F0DDE1FEE, 0xBC4665B596706114}, // 1e185\n\t{0xA90CB506D155A7EA, 0xEB57FF22FC0C7959}, // 1e186\n\t{0x09A7F12442D588F2, 0x9316FF75DD87CBD8}, // 1e187\n\t{0x0C11ED6D538AEB2F, 0xB7DCBF5354E9BECE}, // 1e188\n\t{0x8F1668C8A86DA5FA, 0xE5D3EF282A242E81}, // 1e189\n\t{0xF96E017D694487BC, 0x8FA475791A569D10}, // 1e190\n\t{0x37C981DCC395A9AC, 0xB38D92D760EC4455}, // 1e191\n\t{0x85BBE253F47B1417, 0xE070F78D3927556A}, // 1e192\n\t{0x93956D7478CCEC8E, 0x8C469AB843B89562}, // 1e193\n\t{0x387AC8D1970027B2, 0xAF58416654A6BABB}, // 1e194\n\t{0x06997B05FCC0319E, 0xDB2E51BFE9D0696A}, // 1e195\n\t{0x441FECE3BDF81F03, 0x88FCF317F22241E2}, // 1e196\n\t{0xD527E81CAD7626C3, 0xAB3C2FDDEEAAD25A}, // 1e197\n\t{0x8A71E223D8D3B074, 0xD60B3BD56A5586F1}, // 1e198\n\t{0xF6872D5667844E49, 0x85C7056562757456}, // 1e199\n\t{0xB428F8AC016561DB, 0xA738C6BEBB12D16C}, // 1e200\n\t{0xE13336D701BEBA52, 0xD106F86E69D785C7}, // 1e201\n\t{0xECC0024661173473, 0x82A45B450226B39C}, // 1e202\n\t{0x27F002D7F95D0190, 0xA34D721642B06084}, // 1e203\n\t{0x31EC038DF7B441F4, 0xCC20CE9BD35C78A5}, // 1e204\n\t{0x7E67047175A15271, 0xFF290242C83396CE}, // 1e205\n\t{0x0F0062C6E984D386, 0x9F79A169BD203E41}, // 1e206\n\t{0x52C07B78A3E60868, 0xC75809C42C684DD1}, // 1e207\n\t{0xA7709A56CCDF8A82, 0xF92E0C3537826145}, // 1e208\n\t{0x88A66076400BB691, 0x9BBCC7A142B17CCB}, // 1e209\n\t{0x6ACFF893D00EA435, 0xC2ABF989935DDBFE}, // 1e210\n\t{0x0583F6B8C4124D43, 0xF356F7EBF83552FE}, // 1e211\n\t{0xC3727A337A8B704A, 0x98165AF37B2153DE}, // 1e212\n\t{0x744F18C0592E4C5C, 0xBE1BF1B059E9A8D6}, // 1e213\n\t{0x1162DEF06F79DF73, 0xEDA2EE1C7064130C}, // 1e214\n\t{0x8ADDCB5645AC2BA8, 0x9485D4D1C63E8BE7}, // 1e215\n\t{0x6D953E2BD7173692, 0xB9A74A0637CE2EE1}, // 1e216\n\t{0xC8FA8DB6CCDD0437, 0xE8111C87C5C1BA99}, // 1e217\n\t{0x1D9C9892400A22A2, 0x910AB1D4DB9914A0}, // 1e218\n\t{0x2503BEB6D00CAB4B, 0xB54D5E4A127F59C8}, // 1e219\n\t{0x2E44AE64840FD61D, 0xE2A0B5DC971F303A}, // 1e220\n\t{0x5CEAECFED289E5D2, 0x8DA471A9DE737E24}, // 1e221\n\t{0x7425A83E872C5F47, 0xB10D8E1456105DAD}, // 1e222\n\t{0xD12F124E28F77719, 0xDD50F1996B947518}, // 1e223\n\t{0x82BD6B70D99AAA6F, 0x8A5296FFE33CC92F}, // 1e224\n\t{0x636CC64D1001550B, 0xACE73CBFDC0BFB7B}, // 1e225\n\t{0x3C47F7E05401AA4E, 0xD8210BEFD30EFA5A}, // 1e226\n\t{0x65ACFAEC34810A71, 0x8714A775E3E95C78}, // 1e227\n\t{0x7F1839A741A14D0D, 0xA8D9D1535CE3B396}, // 1e228\n\t{0x1EDE48111209A050, 0xD31045A8341CA07C}, // 1e229\n\t{0x934AED0AAB460432, 0x83EA2B892091E44D}, // 1e230\n\t{0xF81DA84D5617853F, 0xA4E4B66B68B65D60}, // 1e231\n\t{0x36251260AB9D668E, 0xCE1DE40642E3F4B9}, // 1e232\n\t{0xC1D72B7C6B426019, 0x80D2AE83E9CE78F3}, // 1e233\n\t{0xB24CF65B8612F81F, 0xA1075A24E4421730}, // 1e234\n\t{0xDEE033F26797B627, 0xC94930AE1D529CFC}, // 1e235\n\t{0x169840EF017DA3B1, 0xFB9B7CD9A4A7443C}, // 1e236\n\t{0x8E1F289560EE864E, 0x9D412E0806E88AA5}, // 1e237\n\t{0xF1A6F2BAB92A27E2, 0xC491798A08A2AD4E}, // 1e238\n\t{0xAE10AF696774B1DB, 0xF5B5D7EC8ACB58A2}, // 1e239\n\t{0xACCA6DA1E0A8EF29, 0x9991A6F3D6BF1765}, // 1e240\n\t{0x17FD090A58D32AF3, 0xBFF610B0CC6EDD3F}, // 1e241\n\t{0xDDFC4B4CEF07F5B0, 0xEFF394DCFF8A948E}, // 1e242\n\t{0x4ABDAF101564F98E, 0x95F83D0A1FB69CD9}, // 1e243\n\t{0x9D6D1AD41ABE37F1, 0xBB764C4CA7A4440F}, // 1e244\n\t{0x84C86189216DC5ED, 0xEA53DF5FD18D5513}, // 1e245\n\t{0x32FD3CF5B4E49BB4, 0x92746B9BE2F8552C}, // 1e246\n\t{0x3FBC8C33221DC2A1, 0xB7118682DBB66A77}, // 1e247\n\t{0x0FABAF3FEAA5334A, 0xE4D5E82392A40515}, // 1e248\n\t{0x29CB4D87F2A7400E, 0x8F05B1163BA6832D}, // 1e249\n\t{0x743E20E9EF511012, 0xB2C71D5BCA9023F8}, // 1e250\n\t{0x914DA9246B255416, 0xDF78E4B2BD342CF6}, // 1e251\n\t{0x1AD089B6C2F7548E, 0x8BAB8EEFB6409C1A}, // 1e252\n\t{0xA184AC2473B529B1, 0xAE9672ABA3D0C320}, // 1e253\n\t{0xC9E5D72D90A2741E, 0xDA3C0F568CC4F3E8}, // 1e254\n\t{0x7E2FA67C7A658892, 0x8865899617FB1871}, // 1e255\n\t{0xDDBB901B98FEEAB7, 0xAA7EEBFB9DF9DE8D}, // 1e256\n\t{0x552A74227F3EA565, 0xD51EA6FA85785631}, // 1e257\n\t{0xD53A88958F87275F, 0x8533285C936B35DE}, // 1e258\n\t{0x8A892ABAF368F137, 0xA67FF273B8460356}, // 1e259\n\t{0x2D2B7569B0432D85, 0xD01FEF10A657842C}, // 1e260\n\t{0x9C3B29620E29FC73, 0x8213F56A67F6B29B}, // 1e261\n\t{0x8349F3BA91B47B8F, 0xA298F2C501F45F42}, // 1e262\n\t{0x241C70A936219A73, 0xCB3F2F7642717713}, // 1e263\n\t{0xED238CD383AA0110, 0xFE0EFB53D30DD4D7}, // 1e264\n\t{0xF4363804324A40AA, 0x9EC95D1463E8A506}, // 1e265\n\t{0xB143C6053EDCD0D5, 0xC67BB4597CE2CE48}, // 1e266\n\t{0xDD94B7868E94050A, 0xF81AA16FDC1B81DA}, // 1e267\n\t{0xCA7CF2B4191C8326, 0x9B10A4E5E9913128}, // 1e268\n\t{0xFD1C2F611F63A3F0, 0xC1D4CE1F63F57D72}, // 1e269\n\t{0xBC633B39673C8CEC, 0xF24A01A73CF2DCCF}, // 1e270\n\t{0xD5BE0503E085D813, 0x976E41088617CA01}, // 1e271\n\t{0x4B2D8644D8A74E18, 0xBD49D14AA79DBC82}, // 1e272\n\t{0xDDF8E7D60ED1219E, 0xEC9C459D51852BA2}, // 1e273\n\t{0xCABB90E5C942B503, 0x93E1AB8252F33B45}, // 1e274\n\t{0x3D6A751F3B936243, 0xB8DA1662E7B00A17}, // 1e275\n\t{0x0CC512670A783AD4, 0xE7109BFBA19C0C9D}, // 1e276\n\t{0x27FB2B80668B24C5, 0x906A617D450187E2}, // 1e277\n\t{0xB1F9F660802DEDF6, 0xB484F9DC9641E9DA}, // 1e278\n\t{0x5E7873F8A0396973, 0xE1A63853BBD26451}, // 1e279\n\t{0xDB0B487B6423E1E8, 0x8D07E33455637EB2}, // 1e280\n\t{0x91CE1A9A3D2CDA62, 0xB049DC016ABC5E5F}, // 1e281\n\t{0x7641A140CC7810FB, 0xDC5C5301C56B75F7}, // 1e282\n\t{0xA9E904C87FCB0A9D, 0x89B9B3E11B6329BA}, // 1e283\n\t{0x546345FA9FBDCD44, 0xAC2820D9623BF429}, // 1e284\n\t{0xA97C177947AD4095, 0xD732290FBACAF133}, // 1e285\n\t{0x49ED8EABCCCC485D, 0x867F59A9D4BED6C0}, // 1e286\n\t{0x5C68F256BFFF5A74, 0xA81F301449EE8C70}, // 1e287\n\t{0x73832EEC6FFF3111, 0xD226FC195C6A2F8C}, // 1e288\n\t{0xC831FD53C5FF7EAB, 0x83585D8FD9C25DB7}, // 1e289\n\t{0xBA3E7CA8B77F5E55, 0xA42E74F3D032F525}, // 1e290\n\t{0x28CE1BD2E55F35EB, 0xCD3A1230C43FB26F}, // 1e291\n\t{0x7980D163CF5B81B3, 0x80444B5E7AA7CF85}, // 1e292\n\t{0xD7E105BCC332621F, 0xA0555E361951C366}, // 1e293\n\t{0x8DD9472BF3FEFAA7, 0xC86AB5C39FA63440}, // 1e294\n\t{0xB14F98F6F0FEB951, 0xFA856334878FC150}, // 1e295\n\t{0x6ED1BF9A569F33D3, 0x9C935E00D4B9D8D2}, // 1e296\n\t{0x0A862F80EC4700C8, 0xC3B8358109E84F07}, // 1e297\n\t{0xCD27BB612758C0FA, 0xF4A642E14C6262C8}, // 1e298\n\t{0x8038D51CB897789C, 0x98E7E9CCCFBD7DBD}, // 1e299\n\t{0xE0470A63E6BD56C3, 0xBF21E44003ACDD2C}, // 1e300\n\t{0x1858CCFCE06CAC74, 0xEEEA5D5004981478}, // 1e301\n\t{0x0F37801E0C43EBC8, 0x95527A5202DF0CCB}, // 1e302\n\t{0xD30560258F54E6BA, 0xBAA718E68396CFFD}, // 1e303\n\t{0x47C6B82EF32A2069, 0xE950DF20247C83FD}, // 1e304\n\t{0x4CDC331D57FA5441, 0x91D28B7416CDD27E}, // 1e305\n\t{0xE0133FE4ADF8E952, 0xB6472E511C81471D}, // 1e306\n\t{0x58180FDDD97723A6, 0xE3D8F9E563A198E5}, // 1e307\n\t{0x570F09EAA7EA7648, 0x8E679C2F5E44FF8F}, // 1e308\n\t{0x2CD2CC6551E513DA, 0xB201833B35D63F73}, // 1e309\n\t{0xF8077F7EA65E58D1, 0xDE81E40A034BCF4F}, // 1e310\n\t{0xFB04AFAF27FAF782, 0x8B112E86420F6191}, // 1e311\n\t{0x79C5DB9AF1F9B563, 0xADD57A27D29339F6}, // 1e312\n\t{0x18375281AE7822BC, 0xD94AD8B1C7380874}, // 1e313\n\t{0x8F2293910D0B15B5, 0x87CEC76F1C830548}, // 1e314\n\t{0xB2EB3875504DDB22, 0xA9C2794AE3A3C69A}, // 1e315\n\t{0x5FA60692A46151EB, 0xD433179D9C8CB841}, // 1e316\n\t{0xDBC7C41BA6BCD333, 0x849FEEC281D7F328}, // 1e317\n\t{0x12B9B522906C0800, 0xA5C7EA73224DEFF3}, // 1e318\n\t{0xD768226B34870A00, 0xCF39E50FEAE16BEF}, // 1e319\n\t{0xE6A1158300D46640, 0x81842F29F2CCE375}, // 1e320\n\t{0x60495AE3C1097FD0, 0xA1E53AF46F801C53}, // 1e321\n\t{0x385BB19CB14BDFC4, 0xCA5E89B18B602368}, // 1e322\n\t{0x46729E03DD9ED7B5, 0xFCF62C1DEE382C42}, // 1e323\n\t{0x6C07A2C26A8346D1, 0x9E19DB92B4E31BA9}, // 1e324\n\t{0xC7098B7305241885, 0xC5A05277621BE293}, // 1e325\n\t{0xB8CBEE4FC66D1EA7, 0xF70867153AA2DB38}, // 1e326\n\t{0x737F74F1DC043328, 0x9A65406D44A5C903}, // 1e327\n\t{0x505F522E53053FF2, 0xC0FE908895CF3B44}, // 1e328\n\t{0x647726B9E7C68FEF, 0xF13E34AABB430A15}, // 1e329\n\t{0x5ECA783430DC19F5, 0x96C6E0EAB509E64D}, // 1e330\n\t{0xB67D16413D132072, 0xBC789925624C5FE0}, // 1e331\n\t{0xE41C5BD18C57E88F, 0xEB96BF6EBADF77D8}, // 1e332\n\t{0x8E91B962F7B6F159, 0x933E37A534CBAAE7}, // 1e333\n\t{0x723627BBB5A4ADB0, 0xB80DC58E81FE95A1}, // 1e334\n\t{0xCEC3B1AAA30DD91C, 0xE61136F2227E3B09}, // 1e335\n\t{0x213A4F0AA5E8A7B1, 0x8FCAC257558EE4E6}, // 1e336\n\t{0xA988E2CD4F62D19D, 0xB3BD72ED2AF29E1F}, // 1e337\n\t{0x93EB1B80A33B8605, 0xE0ACCFA875AF45A7}, // 1e338\n\t{0xBC72F130660533C3, 0x8C6C01C9498D8B88}, // 1e339\n\t{0xEB8FAD7C7F8680B4, 0xAF87023B9BF0EE6A}, // 1e340\n\t{0xA67398DB9F6820E1, 0xDB68C2CA82ED2A05}, // 1e341\n\t{0x88083F8943A1148C, 0x892179BE91D43A43}, // 1e342\n\t{0x6A0A4F6B948959B0, 0xAB69D82E364948D4}, // 1e343\n\t{0x848CE34679ABB01C, 0xD6444E39C3DB9B09}, // 1e344\n\t{0xF2D80E0C0C0B4E11, 0x85EAB0E41A6940E5}, // 1e345\n\t{0x6F8E118F0F0E2195, 0xA7655D1D2103911F}, // 1e346\n\t{0x4B7195F2D2D1A9FB, 0xD13EB46469447567}, // 1e347\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"4QvsYCEViqsSbHbC3nzrC00Lkcqn6IcoQpH3wcR6GSxtZ0OfTCYdm0Cnkb3ljEcOYt/C5xv48JIeeg/twNelmQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372634"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8","package":{"Name":"cryptopunkstar","Path":"gno.land/r/youtubers/cryptopunkstar","Files":[{"Name":"package.gno","Body":"package youtube\n\nfunc Cryptopunkstar(path string) string [\n  return \"@cryptopunkstar on Youtube !\"\n]\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsfGYP4d45M3jSq3Cs02mX9XC3pIVzEkSG91ZXpsKZ2s"},"signature":"r7zgUCp0zDgK2hvpMsqZzGPdzZIWPvmRvdlIN5cJUDNwV+Zs+SuytKxpRKyd9NUs3MSrmQfKtxEIe9Xu35Wmrw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372639"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"41SQM4QGx8R7qIoyeUpGB4iNyK5Cyjf7aqgLQ3zrK7AEcLcT2P1BEZi/64dX32iF7afwLtG+/TXDtxwXv27FBA=="}],"memo":""},"blockNum":"372641"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"HRQxXCNLQpAedszcDQr5gYViSMgNzL8ymTF9drH5me49/f6eLhs4dPnQBSS31oFBp2IuUS/pLNsAD6XTqI1O2g=="}],"memo":""},"blockNum":"372643"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"18b4Tfc08fO3E+yiAtrL6xOVLYb6qPw7V/Lm9gy0XHwExtIQEQUF79lz/uyHJlRBJlQb+SE+spxhp8qRblkYtg=="}],"memo":""},"blockNum":"372645"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8","package":{"Name":"cryptopunkstar","Path":"gno.land/r/youtubers/cryptopunkstar","Files":[{"Name":"package.gno","Body":"package youtube\n\nfunc Render(path string) string [\n  return \"@cryptopunkstar on Youtube !\"\n]\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsfGYP4d45M3jSq3Cs02mX9XC3pIVzEkSG91ZXpsKZ2s"},"signature":"u4wILA5wzLPH9/i22DbMdTCd0HufcIA/3d5ouioohLgG3Sto0uOt58Ct3Nz/RmoQw+LEpGej1/JIgpovC97/tg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372647"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"QFBKiRN/kieh5UH8xdbtpReZjYWpY7BCtLbkC6L09twXC4E3h54aOudLXdaSl6VDEkE8GNnSu6pbqo4b6uVgHQ=="}],"memo":""},"blockNum":"372649"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8","package":{"Name":"cryptopunkstar","Path":"gno.land/r/youtubers/cryptopunkstar","Files":[{"Name":"package.gno","Body":"package youtube\n\nfunc Render(path string) string {\n  return \"Youtube Cryptopunkstar airdrop!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsfGYP4d45M3jSq3Cs02mX9XC3pIVzEkSG91ZXpsKZ2s"},"signature":"HHkwuV/sKdItRqxr8qL2QvXkBYxqPRKA5D2C6ENU9a1oYwT4w9DXrJDwPFHeOvy9Ni7kBq2pgVIBwRsgJfACIQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372651"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8","package":{"Name":"youtube","Path":"gno.land/r/youtubers/youtube","Files":[{"Name":"package.gno","Body":"package youtube\n\nfunc Render(path string) string {\n  return \"Youtube Cryptopunkstar airdrop!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsfGYP4d45M3jSq3Cs02mX9XC3pIVzEkSG91ZXpsKZ2s"},"signature":"AB0im//XvAr3L5yGFpsZXQkWlYyA9gvZcWjODarfnSBkjLOjM9JYI3G6W7rAHqOUKur8x2QTNOmuOcoXJvDV/A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372654"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"8ydYhs9IWo8LIqJyBuAlRNBHZcD7WdbGeZe4vDeANGxK9YMA8vTJXYRJTBdrPx1i6PkbzrM7HJqXAFvjSQnwyw=="}],"memo":""},"blockNum":"372658"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"4fsCJEqjqc5iIQJJ45CWjmJ3CEXKkwwj/aVaq041KV8uhS/aAcT6O1XWbFTNxLptSLBaLv1Qn5bMl1c1TaSf0g=="}],"memo":""},"blockNum":"372661"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"HvWZ8x/GDtPJXUcuV7t5ZjUZoUNpCltHQov/m+LqkvVjlXJXh1jcbWlpbja+511ifBS2cpPW2lr7eY+zpbQtaA=="}],"memo":""},"blockNum":"372664"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"s+y7Z9gFziO6Pwpl1VXwNVUdckGmGOuYLGyN5fsmkTI5IZPRJ2wcaJ9BoeUuR1nHqs5XSiwkqVVZi1fWCofQtg=="}],"memo":""},"blockNum":"372680"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"DKq4boWXpcp0Y9+w0lCTDhyFDTjYdI5T+29WTUisJWEdWidaDdZLAFfVsltSA5M15IJsLI+1AqfTtOzJRFuEAA=="}],"memo":""},"blockNum":"372682"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"Y5yAIItQwOJAelv5fNNisQf3YGGOLaQzAp9RAnMyRDdHf7S2VOE06948qyTxTpAsG7y/9dx4zfwDD6XYVHYcHw=="}],"memo":""},"blockNum":"372685"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"GC9CmR/1QPK24GJ7lC+Q9mmUuKq8nBkkvhe4ErMpBVIyLMWbr5ffEjmBo4rzmDMuIi4Bq3i1n39XHHDLrthzEw=="}],"memo":""},"blockNum":"372687"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Yya5dye1VHx7xcVPHEpQayXoDjcTMSSi9KEXwOTfZqEp1mx2GZpL/eUpDXcYom6fPb8zn4XJHroiwvR9S1LvCg=="}],"memo":""},"blockNum":"372691"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"6iye0C6GWF5b12EBHMq9YtVZ6JjPhEn7DSFVdapMgkNlZZMGNmqmpWjnBTyyLDRtHw0AurftDPo1qr95pxK+EQ=="}],"memo":""},"blockNum":"372693"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"IZq/XpPIlkqeQ5p24Z4MjAkG30qvIUy2tdQw4dj464E7h0Z8rRQ04JgTLQPMg/i0OljTBSN69u17OyjPOuPXyg=="}],"memo":""},"blockNum":"372696"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"ItjDosPPF8ni4ZP1s8ty96hjyNzVM5uL6sQHCAkutxB5hLQmEocyWgZOyw/ZtI0FoeQg8SdqrZqhfkHlUG48Iw=="}],"memo":""},"blockNum":"372698"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"sBRNOSSJIggfMYPK9vN/Ll1ubzdkf/9r0k2MwWDAiv0y0AeinxCYAqx/hvD+H2Tq+KOPtHvvjoLClgXpIIf3pw=="}],"memo":""},"blockNum":"372700"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"ADsNZyY7fBM6OcBBJEMXUBCt7rRNhUcmuD/ho5jkxPIDgK8F7n5HWhrf+bexPYY8418E+jSbutLM4k+nf7zZ8A=="}],"memo":""},"blockNum":"372702"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"JGlAmnqK2ra21E9ynJGkhu1Et0aTv7HCVluixwa56p16AslW/ObT0lUENQcmA04A4/nTXUKydwN+sUOy5nL27g=="}],"memo":""},"blockNum":"372704"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"r5S6eakh7FUam5arS8jT0eiolIQa6At7i3x4VyD6ygJPFSbO0ZsbL4MbF/Kljp6V0ulzG3LBXSxZScPlrKrc+Q=="}],"memo":""},"blockNum":"372706"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"BmsdBdCr5Qj6KrnvKNtJycsXHSjFM+fOfBfb+V38jkdKD3nmkfgAft1vP6krTPpd45zAVFHKsfPgni5BB8T+/g=="}],"memo":""},"blockNum":"372708"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1h63xr9dx0xluhya9zhvqkytmktuuk4t9ylrq4e","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"0goO2vF9I0++6bRosT7zQycx3hP3cIqtSt8NZFKIUbV9QMHIBqg+rHtWz1L31D/xZ/nR0WcwrzMC9X8vly9b4A=="}],"memo":""},"blockNum":"372712"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"XAE87qJ7dZSlZoaAoMBWSXbahj/jfqjBTJCoIoqG3L9FcNNcqSOdd+RgdJ/1ufadw+7BaJlfqtSm30eFDBDT0Q=="}],"memo":""},"blockNum":"372722"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"kR8pVd2QP8flPjarkFPiEeCAIRzRB+ChKB2RixKiGWUP7VRSMYLDlfgBH7duWWQSqIa0DTCtLBJ0XDwPsYyKkQ=="}],"memo":""},"blockNum":"372724"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"TUAg8tX9V6apivurJ8zbckUQftmxbDrXcMv/n0z+NPcOFfgtVHBWPUB245nrllo7uPfNhtirpCIg1r5OfBQ5aw=="}],"memo":""},"blockNum":"372726"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"HPWBHTJYpGBWZqwEuVkHQSGhrvcoj8KHpfxU4oEaroRB/IN/Fihnyft/Ou6zuIWyDfMx3Ar1mJ1nNGBWvbDQNw=="}],"memo":""},"blockNum":"372729"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc","package":{"Name":"cps","Path":"gno.land/r/demo2/cps","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"cps.gno","Body":"package cps\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tcps   *grc20.AdminToken\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\n)\n\nfunc init() {\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\n\tcps.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\n}\n\n// method proxies as public functions.\n\n// getters.\n\nfunc TotalSupply() uint64 {\n\treturn cps.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := cps.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\n// setters.\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcps.Transfer(caller, to.Resolve(), amount)\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcps.Approve(caller, spender.Resolve(), amount)\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n}\n\n// faucet.\n\nfunc Faucet() {\n\t// FIXME: add limits?\n\t// FIXME: add payment in gnot?\n\tcaller := std.GetOrigCaller()\n\tcps.Mint(caller, 1000*10000) // 1k\n}\n\n// administration.\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tcps.Mint(address.Resolve(), amount)\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tcps.Burn(address.Resolve(), amount)\n}\n\n// render le rendu\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn cps.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n// secure access for admin :)\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+WyZfLauc8sAfiJkG+DSCcDpwMjhob0R9mS75B92vx2"},"signature":"Vmc+U7TV6dJAV9x/ZowgSnMisjuzj8c5/nMt4UupzLFtbuzvdLCGB87i2JxTO9DgceI5tCDulKsyCpcKPPNxzA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372731"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"5t+dZDTPybpYKt2vx3vN6OIlkxw7HF5eIRRFSh84c7AF9TX4aoDTIW0sEsKwv9Ts0tZcf1cgOvz99t1aZ6xe5A=="}],"memo":""},"blockNum":"372733"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1uf8u5jf2m9l80g0zsfq7tufl3qufqc4393jtkl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"PemRMV4k2Uh6XZ2K972RLe9iLdskwr+XCgAhaV7IaBZm3z4PpSV5QeitVhH+Kdy9pz2lA/FQOfkAW+uEWElw9Q=="}],"memo":""},"blockNum":"372735"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1uf8u5jf2m9l80g0zsfq7tufl3qufqc4393jtkl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"KCF+IIpqiOEUEOXa/g0jpXah6AIaIaDSEHmU2sWDaAUPMaJyFU7SLn47WYgC99a6blCTSNpy2vLR9/3Bjjk6rg=="}],"memo":""},"blockNum":"372737"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1uf8u5jf2m9l80g0zsfq7tufl3qufqc4393jtkl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"SAPmEnYMXN/kHlNVREeN8f07CigxES3WnnCRucIcwUBSuWafUkQwAZcyRSCalZxyH4ZTigojGJRbucAr7BClDw=="}],"memo":""},"blockNum":"372739"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc","package":{"Name":"cps","Path":"gno.land/r/cryptopunkstar/cps","Files":[{"Name":"cps.gno","Body":"package cps\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tcps   *grc20.AdminToken\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\n)\n\nfunc init() {\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\n\tcps.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\n}\n\n// method proxies as public functions.\n\n// getters.\n\nfunc TotalSupply() uint64 {\n\treturn cps.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := cps.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\n// setters.\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcps.Transfer(caller, to.Resolve(), amount)\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcps.Approve(caller, spender.Resolve(), amount)\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n}\n\n// faucet.\n\nfunc Faucet() {\n\t// FIXME: add limits?\n\t// FIXME: add payment in gnot?\n\tcaller := std.GetOrigCaller()\n\tcps.Mint(caller, 1000*10000) // 1k\n}\n\n// administration.\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tcps.Mint(address.Resolve(), amount)\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tcps.Burn(address.Resolve(), amount)\n}\n\n// render le rendu\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn cps.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n// secure access for admin :)\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+WyZfLauc8sAfiJkG+DSCcDpwMjhob0R9mS75B92vx2"},"signature":"87MtuCGqLgMqkq36Cu8fM/0QbYQ8nYhTnpoa2snlQGV9LEMQ3UsJj8KNzIpAJkvoXITpMfxjBn35oyh/yRyM5w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372742"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"gi00V+tqDQjHSK/8e/BCBGsftWptsbNyvsOURafnCecGaEGqNRieT9Y8vy79BLnLISGom0OYobrU9lBJ2ysB0A=="}],"memo":""},"blockNum":"372749"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"gP1mivZYecbbpBCj72MFPmApX3XgXTy9qWoy1DudFu4x+fSffshZ559SndMjrZqtbCZ7eUi6jmxSR+iG95ALsA=="}],"memo":""},"blockNum":"372752"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1uf8u5jf2m9l80g0zsfq7tufl3qufqc4393jtkl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"I2FJic8ZUE2B8Bw/nxQSciSuO6+KFxi9knD0FuKcKCNl+KkoW486xg2iF0cxWknqbBPeVR/HipfoViWHZxE4Yg=="}],"memo":""},"blockNum":"372754"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1uf8u5jf2m9l80g0zsfq7tufl3qufqc4393jtkl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"4yJlfMIJfZ30AkfqtDyfWAulOc7pRLRoyl4TeFsIW3J6PbzV9QywdhUk6647v3XxRd96I7m2QrzTyfsJgi3RZg=="}],"memo":""},"blockNum":"372756"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"3gxBXmAT6JbEkTLl81/IV/2aOtgb/ZdyCWYiZRHzIDB+R+Q2rNx7PNH6aoPsWMLnZtzOuW4n1J4ylWNCTl+C2Q=="}],"memo":""},"blockNum":"372759"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"H4cJZH3hq3Qk3pb/g/zUHXi+i4iqs+TyxuR7R7FnWPZzQpU3obU6FcPonQKQ30rYciIM2TSn+nvoVsNz1kZmCw=="}],"memo":""},"blockNum":"372761"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"i/9ww6mvVnm5SF5Kg1rYOYlrPjtFMltvwZ3UA1j9Splori369jY7qDJLbyRja0iiL3ik+j9+XAEEOBGwYIAbyA=="}],"memo":""},"blockNum":"372763"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Twk3JV6WR/vAxKTOZFsnTB46X5YWoEShhUrF3e4vChEAuMkmVXLBTO8lWtAUjLJ2hyrpkaU0XzRWPFAqIGm2vw=="}],"memo":""},"blockNum":"372769"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"tmSee2A3FiOq4aG5b5fjMRAMIdt2E1yEil40y7RiQCVXp+Jq1QMYN6HKjxXVyRaClCV4oo8axwrRGUJIIxz7Fg=="}],"memo":""},"blockNum":"372773"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1uf8u5jf2m9l80g0zsfq7tufl3qufqc4393jtkl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"96sQYvTii054GYyrYgX/+T802qlkGXw6Qq/buQEgo/R27CIjjqk6x7uwWtO4hPoqhqlsDGcrPI/Q/zvwYl+j+Q=="}],"memo":""},"blockNum":"372775"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"o4G9D1hkWsinc11dUQnhO+Yjjo45fM9msPX0ipBa6oB31JRqFeAFpNrAjkyZwFcrhLCnXh1Uf52wiqo2KZ0yCw=="}],"memo":""},"blockNum":"372778"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"NxE+3QeSJEoHxAumxo2+I+1DzZfHrq+DXoLPJmFrwVkdtJMgILJXeMLdLmAqdDNC/yonXNIWlWFcweDjVq5JUA=="}],"memo":""},"blockNum":"372780"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"l6HMKmNuNEGgB5Ws41YNLLfK4SIvKJsK0bRVWtM0l+Ato/GH6kvHSS8WiJoVRGioVQNv0ncjB52QwPVOzLDruw=="}],"memo":""},"blockNum":"372785"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"iUzU2JIbqunAcMSyRa7VU3EXSztu6nHFYSU7ncRQYgxtp2tsiCbc9E8fSs+CRNNb4FMhW1g7WumKnYw7h7aLsA=="}],"memo":""},"blockNum":"372787"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"kwPeLfqAqxyKI5+bLZodluvi5H/tnxeLrMMtwNoYC2Vx/jTlEeS/yO/gAaWZ6lnytwv33omP9gI8P+5OXYmMZg=="}],"memo":""},"blockNum":"372791"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Z4Pb0kBISxaZKB5veSBOhI02M37obgic7lRRJ7xKcNhluyClOgWYUtn1OimV8JEOnd33ri75LCW+ZCFNEz3lzA=="}],"memo":""},"blockNum":"372802"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9","package":{"Name":"occ","Path":"gno.land/r/test2/occ","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"},{"Name":"occ.gno","Body":"package occ\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tocc   *grc20.AdminToken\r\n\tadmin std.Address = \"g1egm3vnlyejjpdem764jmmanwqdunggfjhwte79\" // TODO: helper to change admin\r\n)\r\ng1egm3vnlyejjpdem764jmmanwqdunggfjhwte79\r\nfunc init() {\r\n\tocc = grc20.NewAdminToken(\"Cryptopunkstar\", \"occ\", 4)\r\n\tocc.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tocc.Mint(\"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn occ.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := occ.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := occ.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn occ.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := occ.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3Z7lP+LaLsbriIstwGgkAF/+w14ik3fo/Mx9+5XhY5S"},"signature":"Q+uWe1if8k41WOyqJ9NAdq+wkFiV4FN4kj2jUlYfcccdHNK2T70iRa5bVmET8PtJuHxma2GO1dyYhZrzkHKzcQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372806"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9","package":{"Name":"occ","Path":"gno.land/r/test2/occ","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"},{"Name":"occ.gno","Body":"package occ\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tocc   *grc20.AdminToken\r\n\tadmin std.Address = \"g1egm3vnlyejjpdem764jmmanwqdunggfjhwte79\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tocc = grc20.NewAdminToken(\"Cryptopunkstar\", \"occ\", 4)\r\n\tocc.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tocc.Mint(\"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn occ.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := occ.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := occ.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn occ.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := occ.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3Z7lP+LaLsbriIstwGgkAF/+w14ik3fo/Mx9+5XhY5S"},"signature":"ZAOe7JS4cFfcfKOXp598gYc4KSFgZmYT6MAGXIH6WvQ3RW4PlAavHyy7PD4lOkDZdV02O93oBtQFdoeTUvR4mw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372809"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1nyjd90gz36q6vjm8qwslg2v38ma8su6cz3jryv","package":{"Name":"cry","Path":"gno.land/r/cry/cry","Files":[{"Name":"package.gno","Body":"package cry\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tcry   *grc20.AdminToken\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\n)\n\nfunc init() {\n\tcry = grc20.NewAdminToken(\"Cryptopunkstar\", \"cry\", 4)\n\tcry.Mint(admin, 1000000*100000)                                    // @administrator (1M)\n\tcry.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\n}\n\n// method proxies as public functions.\n\n// getters.\n\nfunc TotalSupply() uint64 {\n\treturn cry.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := cry.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := cry.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\n// setters.\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcry.Transfer(caller, to.Resolve(), amount)\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcry.Approve(caller, spender.Resolve(), amount)\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcry.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n}\n\n// faucet.\n\nfunc Faucet() {\n\t// FIXME: add limits?\n\t// FIXME: add payment in gnot?\n\tcaller := std.GetOrigCaller()\n\tcry.Mint(caller, 1000*10000) // 1k\n}\n\n// administration.\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tcry.Mint(address.Resolve(), amount)\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tcry.Burn(address.Resolve(), amount)\n}\n\n// render le rendu\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn cry.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := cry.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n// secure access for admin :)\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"},{"Name":"cry.gno","Body":"package cry\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcry   *grc20.AdminToken\r\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcry = grc20.NewAdminToken(\"Cryptopunkstar\", \"cry\", 4)\r\n\tcry.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcry.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cry.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cry.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cry.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cry.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cry.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7PgP3bKSbI1FvmBOIOPcBUoFdEOhQaLQBNB6llDv9Cn"},"signature":"5R9xZnUjeCW8G2n49FQxDyvwkOSv0mSZcHThh6CdLzw6/9XnedfkVQoXhM61ycKAcA2gb96D6oVb9p/HOk1JdQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372813"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1nyjd90gz36q6vjm8qwslg2v38ma8su6cz3jryv","package":{"Name":"cry","Path":"gno.land/r/cry/cry","Files":[{"Name":"package.gno","Body":"package cry\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tcry   *grc20.AdminToken\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\n)\n\nfunc init() {\n\tcry = grc20.NewAdminToken(\"Cryptopunkstar\", \"cry\", 4)\n\tcry.Mint(admin, 1000000*100000)                                    // @administrator (1M)\n\tcry.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\n}\n\n// method proxies as public functions.\n\n// getters.\n\nfunc TotalSupply() uint64 {\n\treturn cry.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := cry.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := cry.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\n// setters.\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcry.Transfer(caller, to.Resolve(), amount)\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcry.Approve(caller, spender.Resolve(), amount)\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tcry.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n}\n\n// faucet.\n\nfunc Faucet() {\n\t// FIXME: add limits?\n\t// FIXME: add payment in gnot?\n\tcaller := std.GetOrigCaller()\n\tcry.Mint(caller, 1000*10000) // 1k\n}\n\n// administration.\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tcry.Mint(address.Resolve(), amount)\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tcry.Burn(address.Resolve(), amount)\n}\n\n// render le rendu\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn cry.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := cry.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n// secure access for admin :)\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}"},{"Name":"cry.gno","Body":"package cry\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcry   *grc20.AdminToken\r\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcry = grc20.NewAdminToken(\"Cryptopunkstar\", \"cry\", 4)\r\n\tcry.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcry.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cry.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cry.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cry.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cry.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cry.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7PgP3bKSbI1FvmBOIOPcBUoFdEOhQaLQBNB6llDv9Cn"},"signature":"1oMdz5j+qZotRfyETWOT7ZIYimDokr7J0TToNQLjey4li2XJ4UR1mcoc+I9USdEnsZfaiqoBbSxzVWbgtUe2Nw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372815"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9","package":{"Name":"occ","Path":"gno.land/r/test2/occ","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"},{"Name":"occ.gno","Body":"package occ\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tocc   *grc20.AdminToken\r\n\tadmin std.Address = \"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tocc = grc20.NewAdminToken(\"Cryptopunkstar\", \"occ\", 4)\r\n\tocc.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tocc.Mint(\"g1egm3vnlyejjpdem764jmmanwqdunggfjhwte79\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn occ.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := occ.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := occ.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn occ.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := occ.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3Z7lP+LaLsbriIstwGgkAF/+w14ik3fo/Mx9+5XhY5S"},"signature":"9m25cU9G660ETCYcJiEy2atcpxj/jPSsUio6eJ/ZdqNvneTGbUZhUhRQAJoahA9uOjzawsF3g7HbuFZ1Ta7tCw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372817"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1nyjd90gz36q6vjm8qwslg2v38ma8su6cz3jryv","package":{"Name":"cry","Path":"gno.land/p/cry/cry","Files":[{"Name":"cry.gno","Body":"package cry\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcry   *grc20.AdminToken\r\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcry = grc20.NewAdminToken(\"Cryptopunkstar\", \"cry\", 4)\r\n\tcry.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcry.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cry.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cry.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cry.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cry.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cry.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7PgP3bKSbI1FvmBOIOPcBUoFdEOhQaLQBNB6llDv9Cn"},"signature":"1FE7Zzp7sc0sRJIbMM2is236J1wIMF5O3rAP4PWj7mo/0Aa/J9cSnVkbAEJZXD9Ie3MeWTQzGhT1QLEzolGQ/w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372819"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1nyjd90gz36q6vjm8qwslg2v38ma8su6cz3jryv","package":{"Name":"cry2","Path":"gno.land/r/cry/cry2","Files":[{"Name":"cry.gno","Body":"package cry\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcry   *grc20.AdminToken\r\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcry = grc20.NewAdminToken(\"Cryptopunkstar\", \"cry\", 4)\r\n\tcry.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcry.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cry.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cry.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cry.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cry.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cry.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7PgP3bKSbI1FvmBOIOPcBUoFdEOhQaLQBNB6llDv9Cn"},"signature":"0uqnRkVG1Cja/xc7wjlArufus8e4K8DY7H28UzELZCpvkZhUqdJi8rmvwRX+Z6LZrly3tdqD/B6wYhb2iRbpIA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372821"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1nyjd90gz36q6vjm8qwslg2v38ma8su6cz3jryv","package":{"Name":"cry2","Path":"gno.land/p/cry2/cry2","Files":[{"Name":"cry.gno","Body":"package cry\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcry   *grc20.AdminToken\r\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcry = grc20.NewAdminToken(\"Cryptopunkstar\", \"cry\", 4)\r\n\tcry.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcry.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cry.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cry.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cry.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cry.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cry.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7PgP3bKSbI1FvmBOIOPcBUoFdEOhQaLQBNB6llDv9Cn"},"signature":"swXS93Qz1xHKNBAtc3mQx711ntHvn7al0ZuZNY7FcQgP5hWa8WsaZNwCrnMJX/3kgOn0+7ZZKQFMq3Q8wAPYJw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372823"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1nyjd90gz36q6vjm8qwslg2v38ma8su6cz3jryv","package":{"Name":"cry2","Path":"gno.land/p/cry/cry2","Files":[{"Name":"cry.gno","Body":"package cry\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcry   *grc20.AdminToken\r\n\tadmin std.Address = \"g1p9ap4pqc74uwek9zqk0kxx9wq90ljpyz9av6lc\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcry = grc20.NewAdminToken(\"Cryptopunkstar\", \"cry\", 4)\r\n\tcry.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcry.Mint(\"g1f748xee7gpwldyrz4xea3nk6hw24lfya49fus8\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cry.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cry.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cry.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcry.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcry.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cry.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cry.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7PgP3bKSbI1FvmBOIOPcBUoFdEOhQaLQBNB6llDv9Cn"},"signature":"VVsEgMBo1s5vp4ypJ3DCUUZP5N3ONPbdeaWz1rMqvPBJFu7H7cyJewE/fZyqUrGXYfpTDxFmYzCScoT9cv1+Bg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372825"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1nyjd90gz36q6vjm8qwslg2v38ma8su6cz3jryv","send":"","pkg_path":"gno.land/r/demo/faucet","func":"Faucet","args":["g1nyjd90gz36q6vjm8qwslg2v38ma8su6cz3jryv"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7PgP3bKSbI1FvmBOIOPcBUoFdEOhQaLQBNB6llDv9Cn"},"signature":"FFjriHSBS/BfH3jyovN+JSf3Ib5KHpgBIsCbJsaW/mcYZ1fk0wPgi9tNvyJpq1awC+Hx0FTQmAZjRNWSa9T+5Q=="}],"memo":""},"blockNum":"372827"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9","package":{"Name":"occ","Path":"gno.land/r/test2/occ","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"},{"Name":"occ.gno","Body":"package occ\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tocc   *grc20.AdminToken\r\n\tadmin std.Address = \"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tocc = grc20.NewAdminToken(\"occifloc\", \"occ\", 4)\r\n\tocc.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tocc.Mint(\"g1egm3vnlyejjpdem764jmmanwqdunggfjhwte79\", 100000*100000) // @steefun (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn occ.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := occ.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := occ.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn occ.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := occ.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3Z7lP+LaLsbriIstwGgkAF/+w14ik3fo/Mx9+5XhY5S"},"signature":"mkyCWukp35Bne483e7OlVZrbcMOUx0MAKGRmZKzUdGgLbV44L67w/mMS2LlxvCEclwN66IuQnzaRlr7ViSj/8w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372830"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9","package":{"Name":"occ","Path":"gno.land/r/test2/occ","Files":[{"Name":"occ.gno","Body":"package occ\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tocc   *grc20.AdminToken\r\n\tadmin std.Address = \"g1pgr5hyw69q0slyczjv2w5xx0x25337y7pjhzq9\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tocc = grc20.NewAdminToken(\"occifloc\", \"occ\", 4)\r\n\tocc.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tocc.Mint(\"g1egm3vnlyejjpdem764jmmanwqdunggfjhwte79\", 100000*100000) // @steefun (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn occ.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := occ.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := occ.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tocc.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tocc.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn occ.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := occ.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3Z7lP+LaLsbriIstwGgkAF/+w14ik3fo/Mx9+5XhY5S"},"signature":"XuFH7tQoxeHvau+VXzJlbBBtf/UJFkfHBOGWZyWxuIYpKB+xlmYs/ORSQ/F+1RQ0p85jexA/rz8fkm39syWAzQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372832"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"WOXcj6qrNGmgnSKtVIXLa6LceET0yXABpKeTiLe1XlZc7ZXUWveuoDe+EjsWJsmGQqISukZKToe00uZBxvvfWg=="}],"memo":""},"blockNum":"372887"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"VeDSFdVBHs5NHy4YrUWxGc0yo9rXnoc8XmqE6qY8h0IUnK64z1yqSmfGDuJABuR+fYVGTuks50uQEoFK8zjFgQ=="}],"memo":""},"blockNum":"372899"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","package":{"Name":"wakrypto","Path":"gno.land/r/demo/wakrypto","Files":[{"Name":"package.gno","Body":"package wakrypto\n\nfunc Render(path string) string {\n  return \"wakrypto!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ap94HPqivN3o8yHLT8O5i9lrVnAaQVtJxq8LdfTrn0YJ"},"signature":"V54SyoFSTI0QooxK38SkXnwjHX8aBqi52WTtBWxyTv4r18TiCsAn9zhl9FMFPk7w5fWrXVhJ/LAPPVROx08Phg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"372901"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"E8gZGp10BLUce6Ve5kuPWQjFPMrWMHWFsE6uPkxPS3ElOEhrl8ivpWQUJrAR1fXPi574emospZHB0V2Rpn1wrA=="}],"memo":""},"blockNum":"372945"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uf8u5jf2m9l80g0zsfq7tufl3qufqc4393jtkl","send":"","pkg_path":"gno.land/r/test10/poll","func":"Render","args":[""]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AitYIWT3az4Jx3hGzTapJ6hyalJ6EYgqQCpYoe7Gx2Sw"},"signature":"jeOCfoQGBk62XFfGCY7jU6OfvQZ1JFlnMsVBYEZSnU8lhPzU5mOCDk3oj0buDFmhyAMHtUBKhNnVjEMTsKCxhQ=="}],"memo":"Called through gno.studio"},"blockNum":"373032"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1mkw4gwfpa0qktgzp64m5hxqywj38utxrq5udm3","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"4TvaVIUGxv7tNEUt1ww8Fp0QEA/4q5OtRbiI1zzjFYluiVt0t77qWTW3m6W8EgjqeAsbtkfD2l9mY+XtMlWEIQ=="}],"memo":""},"blockNum":"373132"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1pxnhuy4864wg5eqyd7h0myxfn0z6qqpzpgyqts","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"UYTDPU4VhR8x8FvvqcXmKKRrEQNFu1H+XS5NrxoZI/5qERtK+IRtKmg+vaGFlvJVZZNeicSsr24uMdXcGqXpAg=="}],"memo":""},"blockNum":"373141"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1wnk77fuxp622hquyc97zgks00gcaj4xj4ygh7r","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"bYfN7OzahR9ZNVMKhz8OqGRwU7EarF3fpMa/9khE11AGObmRF7gvK6lZ5Ic6hKQGCoYIqnoqAxq8QJgMh7vuFA=="}],"memo":""},"blockNum":"373181"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"dAr3YpU1prmSSVrNBgcZUV++iEOG/1fUMu3rV58XGAo22HgKVjvs6HgdELXnmVlwUZpGIj+/a/S/uDHvGr7oiw=="}],"memo":""},"blockNum":"373220"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"H34KCqiwieqcBIQ5wACnJbuck0w+895Z8gcb8CsxLYdFD1hsTaZyPfDdL+NQKbgQyJOJrEhQlqajQYNJOxulNg=="}],"memo":""},"blockNum":"373225"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"hC/mkjiiLARo9IQ5p9oUTvj+aRA/FF/oFPeHsBVgngZqDrbrEisf6jfqHkOg2vP1PQ8mvTrxNUtnUtwOxrfKrA=="}],"memo":""},"blockNum":"373228"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"LEfcAlH1tDShKat11/WiA4uruvujmoYnqQBxf+5ViVoyN7EaDplme3/v2gIwpKvdP8zI0SFTr1XWygzk1MvL5Q=="}],"memo":""},"blockNum":"373230"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"J5wqrnw9QvdxZSzY2ZKXy30OZ2jLQCnoOlZgBX/CzxhayWiwxjIebYdrSkZU6TEOC5riq5jdAkzBvJ9OtF3whg=="}],"memo":""},"blockNum":"373232"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"5bW0Rluj7D8ira+hNmzmrTL1BN5mUMg2yNiLomNZrXRpyaN5HfSrGXX8R0FwwlybBoUlVankEue0XvKB1UiNUg=="}],"memo":""},"blockNum":"373234"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"iV5hH4qJbCE9mPS33PcPKwE+s8T16a/leaJWPB8gvx4ZoWOZKUx+4g3ikzM4s1/h3oDYkK5lTlo9zduQe56dLg=="}],"memo":""},"blockNum":"373237"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"HDEUXJ7Xqg0QDPyrmn5lZvANnw+VQpZBDXWs7sM1lBVtEhpGyrbROwe7VmhRH98uZr+F6d7Gsu9bZsXmVaschQ=="}],"memo":""},"blockNum":"373239"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"qYHBi7bMNhDTImJUYYU22Sc8T6CCyud/sWiVwpOoRH9ZoCn3WcCtPd4bUGupX8FXGK18N6S4O8ctA8kOedaYFg=="}],"memo":""},"blockNum":"373241"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"gkCIW2qCkVbxIm4lw1oxfbWNSTDPoE1oQpjsHZ4OAjMPrkBY7HYI8x+rBNtrEg9QNTq51GqLp7Y84vzWahXOlQ=="}],"memo":""},"blockNum":"373243"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"JzFsnM7WCvCh3rWlGoXvT/sPMhoMpFWnh0lhBA46OYw2r+3fuG6iNQD6p/xSw1fXGYxCIY3z5GFY7S6Km1EnDg=="}],"memo":""},"blockNum":"373245"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"3FHM9phAQaVTmWJYPwVz3vYOwg6CfNbUIHxzy2whaq5XSzY5nfz4qTOcV7/qiQ12Or+W5FJ5rf0TYRdKWw08wA=="}],"memo":""},"blockNum":"373248"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1nueflqclwc7894s6qrlh5cen9uveme9hu5kqaz","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"7ooplkCg5bTtt1K6EOIaGx7hb8n1SUIeyRhNdEy3JzQF9huoaTn19c7l95FJxDv7mNMocdtTisRI1Y7olY9vug=="}],"memo":""},"blockNum":"373253"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1nueflqclwc7894s6qrlh5cen9uveme9hu5kqaz","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"SbaqXSrgWpu8PX/qVxHw+1kozQmkUrZGB2LgjGKyVPNAksw+b0XuKehP23tJW9w4dK4F4b0+3fp8HFb3dS8r8g=="}],"memo":""},"blockNum":"373258"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1nueflqclwc7894s6qrlh5cen9uveme9hu5kqaz","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"pGtYmOjGIZ6zJE1JBbJTSLkj8+0fLYeu1F4tn42hZ85iaO4NjN85fiSm9+zw7VR7JFd9XV4b+sdxdLcaoFAJQg=="}],"memo":""},"blockNum":"373260"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1nueflqclwc7894s6qrlh5cen9uveme9hu5kqaz","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"XF+UnN1QHczv8CDLRXTTGWzGtOlrRCqez9y7/DmEMuQKrVnWrWJ9JN2PvPhE7zv5OO9ddCTsEO5hss6Tl0rLHg=="}],"memo":""},"blockNum":"373262"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1nueflqclwc7894s6qrlh5cen9uveme9hu5kqaz","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"BERhuctfCqPSwQzB5VkLo1ahfvbuhW+Ha1AF4kjMOW8OZ+FVbYr+GVJ4Va33GOplCqd3AqyvND0CASguEFnXGA=="}],"memo":""},"blockNum":"373264"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1nueflqclwc7894s6qrlh5cen9uveme9hu5kqaz","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"u4tLbGHQ1bsT8P6eKIAoQkwrcBwehvp9ruPzGrjxlncw3n7naE76qDxz0xJqW/DPr0MenMAtw1jRkTP1bpAX+g=="}],"memo":""},"blockNum":"373266"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1nueflqclwc7894s6qrlh5cen9uveme9hu5kqaz","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"sTGSjMVC/oayrFCUZ2TsskjbWlkgbKcGGJFlQyL5yHNCM/18vlzi/9dNkYTKFZccL/kDWxQL6YxofqOoiCRsjg=="}],"memo":""},"blockNum":"373268"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"5oELK74kLaCSKo2DlQK7Muw39bFaF2jkmDkSM6y4S8drlYIhXhH4R7vXonIlLjVRaV4N268puFFvIOWzmoUtOw=="}],"memo":""},"blockNum":"373273"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g15gf7qdnvczcc95v6r6d9vxxd64u6nl37cj648y","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"c/n1tYmSAGe/jpb/LQVxOMYMRI0R3YXi0rwCWnOpg7VoYoq9rPg4TgJ+bAOA9onF4HsUvRp2j1QHZn5NTvbFlQ=="}],"memo":""},"blockNum":"373275"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"IBvbopYNmcW9yca8+sMNJnlM7gb9+3FHbOB2fRtCS78/h+QmpGKg4LUK+zQLnH5PTqy8LMeaGakhafE90Yih7w=="}],"memo":""},"blockNum":"373277"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"x5gQZA0Pa8webGziS4/qgguid4aNj5u+1fmIDCj95G5i6XYrIePGPup+zb4hloBSU3dh9KFXEtPZbd5jDvo0Ew=="}],"memo":""},"blockNum":"373279"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"zyVQ3rxoJQVka+nJhl+++JB+ttPviOWcBdKrqsfxDoVjA60zFQfyVoErogyPMXouPvcyrSTl6Hh/8D7COoh+qA=="}],"memo":""},"blockNum":"373281"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"2M1My0xTs9isG9YvbnDA+zvC0scjq1Tdt8y9GfAeipNiDk0As0wmqHqMdgJ6ZSFhvikhS7xbizxHs38eb8dUIQ=="}],"memo":""},"blockNum":"373283"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Y+xNErM+zL4rOE8WyLSDqtA2jwvRQ/v8P7p7QRj4B2Q8BuEPCRnHathKy69Sf9TPSXREN5GNnNNnetMW2VTjHA=="}],"memo":""},"blockNum":"373286"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"1gBf4Jq5E88MhtCjSxx2EigN9g49M9bnRLaSUyUtwbNfHAWomRdnbUeVI0O6Cr5O8Ct3L28F2jCkyGLs73DVEg=="}],"memo":""},"blockNum":"373290"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"jP/mxuvOqgoChtx4iyZESycYDojUaSSsTQqNmmJO8JoaMM9QrOkI1l3j0VaZl89iEIvoRc7gxhWnQSwaZ53Iuw=="}],"memo":""},"blockNum":"373292"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"mM/sgLFLoPirA0F9V5j/PIU+NOuVvifXkDQxgAcSDz1yLgrmZ+AMZTlZ8+NVYfZFeoI/oGGvQ7DT5Y86Viv0Dg=="}],"memo":""},"blockNum":"373297"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"/JUmUfyyNtYzuDJH66yczuDad60X8lNUDJO3Gd+zAQcopCE0Rl7CNol+WzC8Xp52EsrjT0ZSfI9nxLp6XECYoQ=="}],"memo":""},"blockNum":"373299"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"OdP1cLCZpVsXNvzJQTEJxEnpcpaBj8P9GPUw4urhn6RP7Qi1Yfd6OGAdO+t6HuMRD3zfZYaaPC2G1b4J/frNSg=="}],"memo":""},"blockNum":"373301"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"EX+6qzRBfdNYO4VJXBXnVofiyUhejFvFvuB1hjs6gcF69Gk2OB4v/BIWeUAH0g5e6/39frNw8cHNEVd0WmH2dw=="}],"memo":""},"blockNum":"373310"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"f9ukjwlQfRoDICyFt0wCKjFHMjRZ4KIabHyfZdYNfFlBvdbswXV/ra2RiXc0htO8Ybt20VZTKIMDd4ShMbHbZw=="}],"memo":""},"blockNum":"373312"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"t+aIMyPljThhncyvAlAnhrpAJVxkg5oYNbLBu5NyMyENZmnwyGvK6ChtkkMzbRlVk77bbKVKToTAHBAW53GIOA=="}],"memo":""},"blockNum":"373314"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"eUcKygDY4jxxCwcZjM4uJ2WdSI2xvwBznGUurzr9VOIxb5alv0q01k/2Dt0HUM9qzeGclnKgQr04vZuFbpFjdg=="}],"memo":""},"blockNum":"373316"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15gf7qdnvczcc95v6r6d9vxxd64u6nl37cj648y","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"dT8CnxVVihCXsmXuBk5uwP8zh39IV0wMNi27A3pi1at+W7FiGX2iSzvzeJrpeMNO11gY49bg6x+VBq5yN++OVw=="}],"memo":""},"blockNum":"373318"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15gf7qdnvczcc95v6r6d9vxxd64u6nl37cj648y","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"bNmgLfTpo0yekylxsd9FGyfeB6nc9CjV58d/n2QR/vhfRnQg4CzbyZ/SOukO99JBi52SkyWj1OobN4C9YskAPQ=="}],"memo":""},"blockNum":"373320"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15gf7qdnvczcc95v6r6d9vxxd64u6nl37cj648y","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"72kcGQ7UAsBcGhn5bsiQ+lxy+8sOPpUFwBiwMz8Tn5Q910DXw6dPW/aZ4Aw4zwN1hn+o7no1RhenGoImpoitZA=="}],"memo":""},"blockNum":"373322"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15gf7qdnvczcc95v6r6d9vxxd64u6nl37cj648y","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"sX2u36ZYNJ7R1z3wpdqNHsrr4801zyIPb0WAdWIkUAhKSqy7v4Dhdm5BDMsY//GX8JeG7YYJRXZSDUJcdjRHRg=="}],"memo":""},"blockNum":"373324"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g12w28y8g6feadunkl6wv7w2e8yjnal0j3p9dxhw","package":{"Name":"obkos","Path":"gno.land/r/kestar/obkos","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuB8BNOWimpiFHaYn9DH45izPbiVxvZVbADaTft4iDD9"},"signature":"BRkhP3gadkUDIQOXwD6wpOCkWOQooFmh4s/51mQBfOx0ygTTSU7J2+SFciz9lDS+Qa9t+gvdKKWnv1MJ+b6wBA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373328"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"JzIj0xcZj0lXFLB3KrTbrvQKJdbsPwc2fXCi7VKuOsts9cW328PmYEcbgZxqVYttgf5Sci4K2zWqj2I0CBbwlQ=="}],"memo":""},"blockNum":"373330"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"iv288SXocZwhDPVW356YHimIk+uM/KpBk39g84vMMdRqLdQnJfs4FBKa7HMkbTTJk841jeI2nULUMJMitCEFDA=="}],"memo":""},"blockNum":"373332"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"nZwnjsjh6FEKTrLC1BK34+wSlcDspmP6wllSka5QKh5yAr+lJIzrGX1DDwtOvfJKKTv05aCEqwx1s2oiVow+7A=="}],"memo":""},"blockNum":"373334"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"RtuhD/7E6ZDq4EhNH4vd4eNpBjO8I4SQ5c1cXob8mhgSE34436eyl/hmejWoTk7qBVUFHWJeRkqeOeqSpYVk5g=="}],"memo":""},"blockNum":"373335"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"ThA+zvob4upf0/In/2TKtwO0xoxf1D1JsVkBSuur6DRYkUEGHVo26PvedHPHaAr3kVx0fwp4cmjo/DFS4NoMvA=="}],"memo":""},"blockNum":"373337"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17zumnvtv34mpzcva2n7jnux9jnq9kdau7km580","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"LtKFhoSLmCc5jCmh7R/hlQosq4jH6bABFz0e6SQFXcEJNejCqnlYsLXOWt7QvrICbxnzG5X6ikHXo+KrlPDMiw=="}],"memo":""},"blockNum":"373339"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"ROrU7HyeoX2VETaZKEoyh9QWMIby2Z9v6YAZ0YGsJegFx8MHBYKWpcN6zOftL5zWrdw1QZovILXufqvuKEJPRg=="}],"memo":""},"blockNum":"373365"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"poll","Path":"gno.land/r/hellotest/poll","Files":[{"Name":"package.gno","Body":"package poll\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tChoiceNone             Choice = 0x0\n\tChoiceSinceInception   Choice = 0x1\n\tChoiceOneOrTwoYearsAgo Choice = 0x2\n\tChoiceThisYear         Choice = 0x4\n\tChoiceThisMonth        Choice = 0x8\n)\n\nvar answerLabels = map[Choice]string{\n\tChoiceThisMonth:        \"This month\",\n\tChoiceThisYear:         \"This year\",\n\tChoiceOneOrTwoYearsAgo: \"1-2 years ago\",\n\tChoiceSinceInception:   \"Since its inception\",\n}\n\nvar (\n\trealmURL string\n\tadmin    std.Address\n\tpoll     = Poll{\n\t\tQuestion:  \"When did you first learn about Gno.land?\",\n\t\tVotingURL: \"https://gno.studio/connect/gno.land/r/gnoyourdate/poll?network=test3\u0026tab=functions#Vote\",\n\t\tAnswers: []Answer{\n\t\t\t{Choice: ChoiceThisMonth},\n\t\t\t{Choice: ChoiceThisYear},\n\t\t\t{Choice: ChoiceOneOrTwoYearsAgo},\n\t\t\t{Choice: ChoiceSinceInception},\n\t\t},\n\t}\n)\n\nfunc init() {\n\trealmURL = \"https://test3.gno.land\" + strings.TrimPrefix(std.CurrentRealmPath(), \"gno.land\")\n\tadmin = std.GetOrigCaller()\n}\n\ntype (\n\t// Choice defines a type for poll choices.\n\tChoice byte\n\n\t// Poll tracks the number of votes for a set of pre defined answers.\n\tPoll struct {\n\t\tQuestion     string\n\t\tVotingURL    string\n\t\tAnswers      []Answer\n\t\tParticipants []std.Address // TODO: Use AVL tree for better search performance?\n\t\tEnded        bool\n\t}\n\n\t// Answer contains the number of votes for a poll choice.\n\tAnswer struct {\n\t\tChoice Choice\n\t\tCount  uint\n\t}\n)\n\n// String returns the choice as a string.\nfunc (c Choice) String() string {\n\treturn strconv.Itoa(int(c))\n}\n\n// GetCount returns the number of votes submitted for a poll choice.\nfunc (p Poll) GetCount(c Choice) uint {\n\tfor _, a := range p.Answers {\n\t\tif a.Choice == c {\n\t\t\treturn a.Count\n\t\t}\n\t}\n\treturn 0\n}\n\n// HasVoted checks if an address already submitted a vote.\nfunc (p Poll) HasVoted(addr std.Address) bool {\n\tfor _, a := range p.Participants {\n\t\tif a == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Vote submits a vote for one of the poll choices.\n//\n// Only one of the choices should be selected to consider the vote as valid.\n// The answer you choose should be selected as True (Yes) making sure that all other options are selected as False (No).\n//\n// When did you first learn about Gno.land?\n// - This month\n// - This year\n// - 1-2 years ago\n// - Since its inception\nfunc Vote(thisMonth, thisYear, oneOrTwoYearsAgo, sinceInception bool) string {\n\tassertPollIsActive()\n\n\tchoice := mustCreateChoiceFromVoteArgs(thisMonth, thisYear, oneOrTwoYearsAgo, sinceInception)\n\tcaller := std.GetOrigCaller()\n\tassertFirstVote(caller)\n\n\tfor i, a := range poll.Answers {\n\t\tif a.Choice == choice {\n\t\t\tpoll.Answers[i].Count++\n\t\t\tpoll.Participants = append(poll.Participants, caller)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn ufmt.Sprintf(\n\t\t`You have successfully voted yes on \"%s\" you can check out the result at %s`,\n\t\tanswerLabels[choice],\n\t\trealmURL,\n\t)\n}\n\n// Render returns a Markdown string with the poll details.\nfunc Render(string) string {\n\tvar buf strings.Builder\n\n\tbuf.WriteString(ufmt.Sprintf(\"## Poll: %s\\n\", poll.Question))\n\n\tif poll.Ended {\n\t\tbuf.WriteString(\"The poll has ended\\n\")\n\t} else {\n\t\tbuf.WriteString(\n\t\t\tufmt.Sprintf(\"You can participate in the poll by [submitting your vote](%s)\\n\", poll.VotingURL),\n\t\t)\n\t}\n\n\tbuf.WriteString(\"### Answers:\\n\")\n\tfor _, c := range [4]Choice{ChoiceThisMonth, ChoiceThisYear, ChoiceOneOrTwoYearsAgo, ChoiceSinceInception} {\n\t\tbuf.WriteString(\n\t\t\tufmt.Sprintf(\"- %s: %d vote(s)\\n\", answerLabels[c], poll.GetCount(c)),\n\t\t)\n\t}\n\n\tbuf.WriteString(\n\t\tufmt.Sprintf(\"\\nThe total number of answers is **%d**\", len(poll.Participants)),\n\t)\n\n\treturn buf.String()\n}\n\n// EndPoll ends the poll to stop receiving new votes.\nfunc EndPoll() string {\n\tassertCallerIsAdmin()\n\tassertPollIsActive()\n\n\tpoll.Ended = true\n\treturn \"Poll ended successfully\"\n}\n\n// GetAdmin returns the address of the Realm admin account.\nfunc GetAdmin() string {\n\treturn admin.String()\n}\n\nfunc mustCreateChoiceFromVoteArgs(voteArgs ...bool) Choice {\n\tvar c Choice\n\tfor _, arg := range voteArgs {\n\t\tc \u003c\u003c= 1 // shift left\n\t\tif arg {\n\t\t\tc |= 1 // last bit on\n\t\t}\n\t}\n\n\tswitch c {\n\tcase ChoiceThisMonth, ChoiceThisYear, ChoiceOneOrTwoYearsAgo, ChoiceSinceInception:\n\t\treturn c\n\tcase ChoiceNone:\n\t\tpanic(\n\t\t\t\"No choice has been selected, you should submit a vote for one of the answers.\\n\" +\n\t\t\t\t\"Only one of the choices should be selected to consider the vote as valid.\",\n\t\t)\n\tdefault:\n\t\tpanic(\n\t\t\t\"Multiple choices has been selected, you should submit a vote for only one answer.\\n\" +\n\t\t\t\t\"The answer you choose should be selected as True (Yes) making sure that all other options are selected as False (No).\",\n\t\t)\n\t}\n}\n\nfunc assertPollIsActive() {\n\tif poll.Ended {\n\t\tpanic(\"Poll has ended\")\n\t}\n}\n\nfunc assertFirstVote(addr std.Address) {\n\tfor _, a := range poll.Participants {\n\t\tif a == addr {\n\t\t\tpanic(\"This address already voted\")\n\t\t}\n\t}\n}\n\nfunc assertCallerIsAdmin() {\n\tif admin != std.GetOrigCaller() {\n\t\tpanic(\"Forbidden\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"ByGLAWB7ly0aJvghK2mkYdZWoHSow0CX4Hnkl7kN8rEg052kgZ20EosZghBJ3c87PWXznVsFyo8F4C1RwZ11xQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373367"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"poll","Path":"gno.land/r/hellotest/poll","Files":[{"Name":"package.gno","Body":"package poll\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tChoiceNone             Choice = 0x0\n\tChoiceSinceInception   Choice = 0x1\n\tChoiceOneOrTwoYearsAgo Choice = 0x2\n\tChoiceThisYear         Choice = 0x4\n\tChoiceThisMonth        Choice = 0x8\n)\n\nvar answerLabels = map[Choice]string{\n\tChoiceThisMonth:        \"This month\",\n\tChoiceThisYear:         \"This year\",\n\tChoiceOneOrTwoYearsAgo: \"1-2 years ago\",\n\tChoiceSinceInception:   \"Since its inception\",\n}\n\nvar (\n\trealmURL string\n\tadmin    std.Address\n\tpoll     = Poll{\n\t\tQuestion:  \"When did you first learn about Gno.land?\",\n\t\tVotingURL: \"https://gno.studio/connect/gno.land/r/gnoyourdate/poll?network=test3\u0026tab=functions#Vote\",\n\t\tAnswers: []Answer{\n\t\t\t{Choice: ChoiceThisMonth},\n\t\t\t{Choice: ChoiceThisYear},\n\t\t\t{Choice: ChoiceOneOrTwoYearsAgo},\n\t\t\t{Choice: ChoiceSinceInception},\n\t\t},\n\t}\n)\n\nfunc init() {\n\trealmURL = \"https://test3.gno.land\" + strings.TrimPrefix(std.CurrentRealmPath(), \"gno.land\")\n\tadmin = \"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9\"\n}\n\ntype (\n\t// Choice defines a type for poll choices.\n\tChoice byte\n\n\t// Poll tracks the number of votes for a set of pre defined answers.\n\tPoll struct {\n\t\tQuestion     string\n\t\tVotingURL    string\n\t\tAnswers      []Answer\n\t\tParticipants []std.Address // TODO: Use AVL tree for better search performance?\n\t\tEnded        bool\n\t}\n\n\t// Answer contains the number of votes for a poll choice.\n\tAnswer struct {\n\t\tChoice Choice\n\t\tCount  uint\n\t}\n)\n\n// String returns the choice as a string.\nfunc (c Choice) String() string {\n\treturn strconv.Itoa(int(c))\n}\n\n// GetCount returns the number of votes submitted for a poll choice.\nfunc (p Poll) GetCount(c Choice) uint {\n\tfor _, a := range p.Answers {\n\t\tif a.Choice == c {\n\t\t\treturn a.Count\n\t\t}\n\t}\n\treturn 0\n}\n\n// HasVoted checks if an address already submitted a vote.\nfunc (p Poll) HasVoted(addr std.Address) bool {\n\tfor _, a := range p.Participants {\n\t\tif a == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Vote submits a vote for one of the poll choices.\n//\n// Only one of the choices should be selected to consider the vote as valid.\n// The answer you choose should be selected as True (Yes) making sure that all other options are selected as False (No).\n//\n// When did you first learn about Gno.land?\n// - This month\n// - This year\n// - 1-2 years ago\n// - Since its inception\nfunc Vote(thisMonth, thisYear, oneOrTwoYearsAgo, sinceInception bool) string {\n\tassertPollIsActive()\n\n\tchoice := mustCreateChoiceFromVoteArgs(thisMonth, thisYear, oneOrTwoYearsAgo, sinceInception)\n\tcaller := std.GetOrigCaller()\n\tassertFirstVote(caller)\n\n\tfor i, a := range poll.Answers {\n\t\tif a.Choice == choice {\n\t\t\tpoll.Answers[i].Count++\n\t\t\tpoll.Participants = append(poll.Participants, caller)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn ufmt.Sprintf(\n\t\t`You have successfully voted yes on \"%s\" you can check out the result at %s`,\n\t\tanswerLabels[choice],\n\t\trealmURL,\n\t)\n}\n\n// Render returns a Markdown string with the poll details.\nfunc Render(string) string {\n\tvar buf strings.Builder\n\n\tbuf.WriteString(ufmt.Sprintf(\"## Poll: %s\\n\", poll.Question))\n\n\tif poll.Ended {\n\t\tbuf.WriteString(\"The poll has ended\\n\")\n\t} else {\n\t\tbuf.WriteString(\n\t\t\tufmt.Sprintf(\"You can participate in the poll by [submitting your vote](%s)\\n\", poll.VotingURL),\n\t\t)\n\t}\n\n\tbuf.WriteString(\"### Answers:\\n\")\n\tfor _, c := range [4]Choice{ChoiceThisMonth, ChoiceThisYear, ChoiceOneOrTwoYearsAgo, ChoiceSinceInception} {\n\t\tbuf.WriteString(\n\t\t\tufmt.Sprintf(\"- %s: %d vote(s)\\n\", answerLabels[c], poll.GetCount(c)),\n\t\t)\n\t}\n\n\tbuf.WriteString(\n\t\tufmt.Sprintf(\"\\nThe total number of answers is **%d**\", len(poll.Participants)),\n\t)\n\n\treturn buf.String()\n}\n\n// EndPoll ends the poll to stop receiving new votes.\nfunc EndPoll() string {\n\tassertCallerIsAdmin()\n\tassertPollIsActive()\n\n\tpoll.Ended = true\n\treturn \"Poll ended successfully\"\n}\n\n// GetAdmin returns the address of the Realm admin account.\nfunc GetAdmin() string {\n\treturn admin.String()\n}\n\nfunc mustCreateChoiceFromVoteArgs(voteArgs ...bool) Choice {\n\tvar c Choice\n\tfor _, arg := range voteArgs {\n\t\tc \u003c\u003c= 1 // shift left\n\t\tif arg {\n\t\t\tc |= 1 // last bit on\n\t\t}\n\t}\n\n\tswitch c {\n\tcase ChoiceThisMonth, ChoiceThisYear, ChoiceOneOrTwoYearsAgo, ChoiceSinceInception:\n\t\treturn c\n\tcase ChoiceNone:\n\t\tpanic(\n\t\t\t\"No choice has been selected, you should submit a vote for one of the answers.\\n\" +\n\t\t\t\t\"Only one of the choices should be selected to consider the vote as valid.\",\n\t\t)\n\tdefault:\n\t\tpanic(\n\t\t\t\"Multiple choices has been selected, you should submit a vote for only one answer.\\n\" +\n\t\t\t\t\"The answer you choose should be selected as True (Yes) making sure that all other options are selected as False (No).\",\n\t\t)\n\t}\n}\n\nfunc assertPollIsActive() {\n\tif poll.Ended {\n\t\tpanic(\"Poll has ended\")\n\t}\n}\n\nfunc assertFirstVote(addr std.Address) {\n\tfor _, a := range poll.Participants {\n\t\tif a == addr {\n\t\t\tpanic(\"This address already voted\")\n\t\t}\n\t}\n}\n\nfunc assertCallerIsAdmin() {\n\tif admin != std.GetOrigCaller() {\n\t\tpanic(\"Forbidden\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"QgRQr4nF6CEIf15i1QoZYfPHYDJCz3Mmpw1EsT8KAz0LsHr6Mx/KpgmI9JVQ52NqCW+VvXdtGvo0mj7xlz0QrQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373370"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"4Aj2f5zojQuKYSNZiLEqzpA+uNbzpteXt1jmosA14eoPYd7NJF6rGC1SJiK6tXs+pjiqhW8ms+EI9OO/iCiwZw=="}],"memo":""},"blockNum":"373372"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","send":"","pkg_path":"gno.land/r/hellotest/poll","func":"GetAdmin","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"pXru9xpKdklOxII6wf9NSh66/HqMDScr+Tm1ro835r8K8iiu1s+3QOz0kDOMV3QDP7+YjqlzkjnoOXLZO1Y0vw=="}],"memo":"Called through gno.studio"},"blockNum":"373375"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"1lJ5xT/t+PcG4dPBMOObqmAs95fhWwUB8NCfGtkOsig8nTihACjFvkSfrZ6kKZdSndY4HBJB4kvV3YCvnXKejg=="}],"memo":""},"blockNum":"373376"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"JkjM/Tf1MNlFBeFFIHe4qIcrKGWKaqakbtvWpLpWUiBkUGZtT2xhoiUCsB1U7oe54Ve57WBeW0r0x/s/QKejdg=="}],"memo":""},"blockNum":"373380"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"ARSR7L2GB/jV0gnp+zL2YzQrr2OtymX6Syag0lEIlAgpumqUSFbUO015R94hAdoStXEcUOnIuS3qbglSLP/SHQ=="}],"memo":""},"blockNum":"373382"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"f7PCnzW5MyQAEEDPR6Ha3Ax5mM5AceKJaUD3eP1d0s1ITaalnBUE9EPAxGxCEyPWRVEv9UmCioBwnc6BxomFeA=="}],"memo":""},"blockNum":"373384"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"pG+QNjBIvPxhVEla7dgxH01mpF9C/79P8Od90gdLIesWaA6kA0gwCB7ehYJZk+0THJCzPyT7seXWTBnJDnnwJA=="}],"memo":""},"blockNum":"373386"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"H/82XGnh/hr0FzA0uA4Hhtmnc+A6N7ijgqhdLJkmWgIgHrldKJ5mqFO5a09F98PNAyDFzbodQVXaHBR8TWdoHQ=="}],"memo":""},"blockNum":"373388"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"gM/0EtwAPEiyr5I1NFnm49Cl0JM50r9+er6PJGZF3fUK/QIFWD9NS1LCJkdrVEDZpSg6BFePcXDNLOEJO+pimg=="}],"memo":""},"blockNum":"373393"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"nH+IlJ3Olxdo04cy6xLJG0T99UM94aUamgUhCPe78WdeNr1PxgDLaPKqgOSHMfsmhaN/BLo5o8GSelWZaBVO7Q=="}],"memo":""},"blockNum":"373395"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"UANlfRH8oOmKmQH1P27H3Ku2u3t2RIll7u29YKhLPKNz/8fs8QO9JoxYy5d7/lm6czdnPGxLddGlLXaAsqyhSw=="}],"memo":""},"blockNum":"373397"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"bXkc4P99HrDC4eQzuWjY8aKyP7wSpaZXWzVYxmcCubtpeA4drDYY9dwd24MQiwxyN197LbbfsNoWGD78MNOB1g=="}],"memo":""},"blockNum":"373399"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"v1","Path":"gno.land/r/hello12/v1","Files":[{"Name":"package.gno","Body":"package v1\n\nimport (\n\t\"gno.land/p/demo/ufmt\"\n\t\"std\"\n)\n\nvar (\n\tadmin std.Address\n)\n\nfunc init() {\n\tadmin = std.GetOrigCaller()\n}\n\nfunc AmIAdmin() string {\n\tactor := std.GetOrigCaller()\n\treturn ufmt.Sprintf(\"Admin: %s\\nCaller: %s\\nIsAdmin: %t\", actor == admin)\n}\n\nfunc Render(path string) string {\n\treturn AmIAdmin()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/x1unix/whoami/v1\n\nrequire (\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"2Ts2qLQLZdYTlG+TuSSLLvrg/PFcQoBgJfS6TD0A384Ma/VLcDdjNlztaX6rkXKuEiCxQt4cdBDAcCOh/MsXFg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373401"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"poll","Path":"gno.land/r/hello17/poll","Files":[{"Name":"package.gno","Body":"package poll\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tChoiceNone             Choice = 0x0\n\tChoiceSinceInception   Choice = 0x1\n\tChoiceOneOrTwoYearsAgo Choice = 0x2\n\tChoiceThisYear         Choice = 0x4\n\tChoiceThisMonth        Choice = 0x8\n)\n\nvar answerLabels = map[Choice]string{\n\tChoiceThisMonth:        \"This month\",\n\tChoiceThisYear:         \"This year\",\n\tChoiceOneOrTwoYearsAgo: \"1-2 years ago\",\n\tChoiceSinceInception:   \"Since its inception\",\n}\n\nvar (\n\trealmURL string\n\tadmin    std.Address\n\tpoll     = Poll{\n\t\tQuestion:  \"When did you first learn about Gno.land?\",\n\t\tVotingURL: \"https://gno.studio/connect/gno.land/r/gnoyourdate/poll?network=test3\u0026tab=functions#Vote\",\n\t\tAnswers: []Answer{\n\t\t\t{Choice: ChoiceThisMonth},\n\t\t\t{Choice: ChoiceThisYear},\n\t\t\t{Choice: ChoiceOneOrTwoYearsAgo},\n\t\t\t{Choice: ChoiceSinceInception},\n\t\t},\n\t}\n)\n\nfunc init() {\n\trealmURL = \"https://test3.gno.land\" + strings.TrimPrefix(std.CurrentRealmPath(), \"gno.land\")\n\tadmin = \"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9\"\n}\n\ntype (\n\t// Choice defines a type for poll choices.\n\tChoice byte\n\n\t// Poll tracks the number of votes for a set of pre defined answers.\n\tPoll struct {\n\t\tQuestion     string\n\t\tVotingURL    string\n\t\tAnswers      []Answer\n\t\tParticipants []std.Address // TODO: Use AVL tree for better search performance?\n\t\tEnded        bool\n\t}\n\n\t// Answer contains the number of votes for a poll choice.\n\tAnswer struct {\n\t\tChoice Choice\n\t\tCount  uint\n\t}\n)\n\n// String returns the choice as a string.\nfunc (c Choice) String() string {\n\treturn strconv.Itoa(int(c))\n}\n\n// GetCount returns the number of votes submitted for a poll choice.\nfunc (p Poll) GetCount(c Choice) uint {\n\tfor _, a := range p.Answers {\n\t\tif a.Choice == c {\n\t\t\treturn a.Count\n\t\t}\n\t}\n\treturn 0\n}\n\n// HasVoted checks if an address already submitted a vote.\nfunc (p Poll) HasVoted(addr std.Address) bool {\n\tfor _, a := range p.Participants {\n\t\tif a == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Vote submits a vote for one of the poll choices.\n//\n// Only one of the choices should be selected to consider the vote as valid.\n// The answer you choose should be selected as True (Yes) making sure that all other options are selected as False (No).\n//\n// When did you first learn about Gno.land?\n// - This month\n// - This year\n// - 1-2 years ago\n// - Since its inception\nfunc Vote(thisMonth, thisYear, oneOrTwoYearsAgo, sinceInception bool) string {\n\tassertPollIsActive()\n\n\tchoice := mustCreateChoiceFromVoteArgs(thisMonth, thisYear, oneOrTwoYearsAgo, sinceInception)\n\tcaller := std.GetOrigCaller()\n\tassertFirstVote(caller)\n\n\tfor i, a := range poll.Answers {\n\t\tif a.Choice == choice {\n\t\t\tpoll.Answers[i].Count++\n\t\t\tpoll.Participants = append(poll.Participants, caller)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn ufmt.Sprintf(\n\t\t`You have successfully voted yes on \"%s\" you can check out the result at %s`,\n\t\tanswerLabels[choice],\n\t\trealmURL,\n\t)\n}\n\n// Render returns a Markdown string with the poll details.\nfunc Render(string) string {\n\tvar buf strings.Builder\n\n\tbuf.WriteString(ufmt.Sprintf(\"## Poll: %s\\n\", poll.Question))\n\n\tif poll.Ended {\n\t\tbuf.WriteString(\"The poll has ended\\n\")\n\t} else {\n\t\tbuf.WriteString(\n\t\t\tufmt.Sprintf(\"You can participate in the poll by [submitting your vote](%s)\\n\", poll.VotingURL),\n\t\t)\n\t}\n\n\tbuf.WriteString(\"### Answers:\\n\")\n\tfor _, c := range [4]Choice{ChoiceThisMonth, ChoiceThisYear, ChoiceOneOrTwoYearsAgo, ChoiceSinceInception} {\n\t\tbuf.WriteString(\n\t\t\tufmt.Sprintf(\"- %s: %d vote(s)\\n\", answerLabels[c], poll.GetCount(c)),\n\t\t)\n\t}\n\n\tbuf.WriteString(\n\t\tufmt.Sprintf(\"\\nThe total number of answers is **%d**\", len(poll.Participants)),\n\t)\n\n\treturn buf.String()\n}\n\n// EndPoll ends the poll to stop receiving new votes.\nfunc EndPoll() string {\n\tassertCallerIsAdmin()\n\tassertPollIsActive()\n\n\tpoll.Ended = true\n\treturn \"Poll ended successfully\"\n}\n\n// GetAdmin returns the address of the Realm admin account.\nfunc GetAdmin() string {\n\treturn admin.String()\n}\n\nfunc mustCreateChoiceFromVoteArgs(voteArgs ...bool) Choice {\n\tvar c Choice\n\tfor _, arg := range voteArgs {\n\t\tc \u003c\u003c= 1 // shift left\n\t\tif arg {\n\t\t\tc |= 1 // last bit on\n\t\t}\n\t}\n\n\tswitch c {\n\tcase ChoiceThisMonth, ChoiceThisYear, ChoiceOneOrTwoYearsAgo, ChoiceSinceInception:\n\t\treturn c\n\tcase ChoiceNone:\n\t\tpanic(\n\t\t\t\"No choice has been selected, you should submit a vote for one of the answers.\\n\" +\n\t\t\t\t\"Only one of the choices should be selected to consider the vote as valid.\",\n\t\t)\n\tdefault:\n\t\tpanic(\n\t\t\t\"Multiple choices has been selected, you should submit a vote for only one answer.\\n\" +\n\t\t\t\t\"The answer you choose should be selected as True (Yes) making sure that all other options are selected as False (No).\",\n\t\t)\n\t}\n}\n\nfunc assertPollIsActive() {\n\tif poll.Ended {\n\t\tpanic(\"Poll has ended\")\n\t}\n}\n\nfunc assertFirstVote(addr std.Address) {\n\tfor _, a := range poll.Participants {\n\t\tif a == addr {\n\t\t\tpanic(\"This address already voted\")\n\t\t}\n\t}\n}\n\nfunc assertCallerIsAdmin() {\n\tif admin != std.GetOrigCaller() {\n\t\tpanic(\"Forbidden\")\n\t}\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"ULyPtDuEyoGD1GzoYw1hwhloodd06qtaN8RbuqmoFnkDD9EjjnAjwKbpk5cIZRCKAX2BCfzcN97pskz8mucSyg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373404"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"JpInhBPRvq4wygeSXBa49Vu9cAPoxtHYLfztYKcYDkwb+1q0j1Z9r4kwsxknU2JpvHyrSJNtLMK+u06IJIUzlA=="}],"memo":""},"blockNum":"373406"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"UkveJBadexZ2KufUw4i+D5Jj+ub7pzudI4l3vJMJ5EVFT0VgrnuhJwSdX0DXtL/0ozPy4lMQUlInjUjFddvsjw=="}],"memo":""},"blockNum":"373408"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"AMja+Zr/qGWW++vH2/vJb7YY1IXVDejw5x/rGixN2JBXPTtrNHmHt02y0eU7km3WX/k+rXkJTTTp1cuZYQwqZA=="}],"memo":""},"blockNum":"373410"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"giOVlE7P6gRlAvgTdmTIaZIwujOU2Qe+VmxngkXp+EVuibgaMswFk9EIydYzV8uKmSxHqkbCrDjHFBoN3w8iCA=="}],"memo":""},"blockNum":"373412"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"059oyv5LmEJkXuXvn4uC9cxGC7ZXERRt7ADey/mYQfExFaHA66TCmKWnzRByNtTdwy5C/Ug2z+T3D5EZ0QPkDQ=="}],"memo":""},"blockNum":"373414"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"KQh+j2DnAWySh5KFFJGzNVJrYJxYYUbmRKdJUzxF+AktDCA4i4RCQfdEHbMKdubA7w0TfylBgEwNMznK4TDqdw=="}],"memo":""},"blockNum":"373416"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"fb6rY6lR+O5y5HmoO5aEzfdPaq0om2WYUGJ2mVPFxrQ2nPmQxZHXtlsa5ceflVLdCSjipH/pofLl3PNB9y8+Ug=="}],"memo":""},"blockNum":"373420"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"df8yJBAHgHVWfwWrN1WfdaFs0i10gFbW7F+aLc5ixz5GQl2mKE2lmUK7rFe77jPK8tSm7YxYupU2FOG40ix5Vw=="}],"memo":""},"blockNum":"373422"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"YaOM0/nNEMIWwWVBQONrBkdsLnVtSCkKJf+TP0DDKawTc+5clxw7cBM6PjjO/t1uqrZ+qKKI/bRNXL9TSSP5Xg=="}],"memo":""},"blockNum":"373424"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"oL9/y43tbAuOcodXoPVO6QCO9yu8/d+9J8EPeC2g2HQTgi4osoqNqgxadd7fV1STi4BgmERPtVX3SkR0ZTei4Q=="}],"memo":""},"blockNum":"373426"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"wtnIzX92LgBFA/noQgifLckTBlEZ3ouKepilDhAa9MMRgKoV9TkMNCLXaGB21IAEXPoe5O2j1E3EWxtT7BR72w=="}],"memo":""},"blockNum":"373428"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"o8D5q1kGX1mMvQu1YyQkGCAa7qL/I+yWLrumUJQ2xZ0tUyMHxJ6t8Ap4kkWMVdkKF5FJZ55/Qr8gUkzfwktIQQ=="}],"memo":""},"blockNum":"373430"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"KL7OSWG7WYQGn6v1E4679nw0eUGk+qhSkQIuLjEj9wlv0pR9M/yR6LNgPEmudMwVy4FdE5qYZFGzVgaX/xw5cg=="}],"memo":""},"blockNum":"373432"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"YNSRbxcZ0fxIW/jj8NgBI08SoXVt2nyLfpI4snTTgxwiXK5L//sEcYzL0CFk+jPvnFXwqo1fryroGXh0LrBqHg=="}],"memo":""},"blockNum":"373434"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"ls1CbPmVYtnuT5TFShqJ1gCnk69LeLDoRGOvTE2iU/cnQBcE4uSchF5gHEDCMrczAcWwhA5b3VzG2FYKWb4L4w=="}],"memo":""},"blockNum":"373436"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"1HZkzDakHCtU6DqsiDmf9pLtPOKTJusUlqw3Ea43bUoyuhKxWTe2vSPH1jDe4HWQbdSbyfkxd4EMatK4EFkFVg=="}],"memo":""},"blockNum":"373438"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"0G4b0w7PlydkDd4DGxvT2y/+E+hzJZ3wuwgsch37U91pbRI1jjBL5gJfbFzLyHdePHUrYe5yz86fJok3xeHCuw=="}],"memo":""},"blockNum":"373440"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"TQ8kToxwT9tIRJC+eZ7sxzeFrQHVzL7E4/mDUad2kfJOzy1ZB7b2c2o6Wjn3OsUXPn4soqE6cRksd9hzrACyVw=="}],"memo":""},"blockNum":"373442"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"m2bnMHB3/QsA7k86wwFzxhT/Og2KJJeLYNuxfRqSbvNIroi/cZWetOAsP9MLqpvUCiV7BB1EPO4XcMKeYMvEYw=="}],"memo":""},"blockNum":"373444"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"IE5Sn+04fzI+2NY3r5szZ79luoGsKZXxmGDtk2YYdoY9jkEnRzsZByt+XdJesWx2Tq3CDStczk8WWF+hc8CbNw=="}],"memo":""},"blockNum":"373446"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"CYYsWtPYqs+GpO8V+xjZ/g1NaDaqXPu3LsgNRR5+WnNjnrQqUdI+9Mm3i7NZJ2MoF6fpU0zOAnS7MiZh11XpYA=="}],"memo":""},"blockNum":"373448"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"udw8een1j7q7bkica4GCtEsI0SIb1hiiUfEz9QOGBYpjSYCwi/S7KxtSuu5rwuBNNC78KUv+j7GDiut+qMMYqA=="}],"memo":""},"blockNum":"373450"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1q6jrp203fq0239pv38sdq3y3urvd6vt5azacpv","send":"","pkg_path":"gno.land/r/gnoland/faucet","func":"Transfer","args":["g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","350000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Axv4T12NC9y+rRIbPLAlcMlHxmjOGUAqA6pWRfiju7GT"},"signature":"rpqKi2IBKBOGBYx8YriuEsBTs0riGwXIU1Q9VVPyjXh27h4FAmeHUIS0PnSLoRS8SQtP8ZkCPRpDjrAWc2+K8A=="}],"memo":""},"blockNum":"373452"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v1","Path":"gno.land/r/x1unix/whoami/v1","Files":[{"Name":"package.gno","Body":"package v1\n\nimport (\n\t\"gno.land/p/demo/ufmt\"\n\t\"std\"\n)\n\nvar (\n\tadmin std.Address = \"\"\n)\n\nfunc init() {\n\tadmin = std.GetOrigCaller()\n}\n\nfunc AmIAdmin() string {\n\tactor := std.GetOrigCaller()\n\treturn ufmt.Sprintf(\"Admin: %s\\nCaller: %s\\nIsAdmin: %t\", actor == admin)\n}\n\nfunc Render(path string) string {\n\treturn AmIAdmin()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/x1unix/whoami/v1\n\nrequire (\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"jWT9kiWZb7rkh2aW6CVRyw/N+JRB/4a1ycd6JSc5T05heVBTt549oWBI/TpF71B/zKNW6ZlOHurfOX3aukt2ew=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373454"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"cWtrzRLYTfoDlvz40+gUizQ8ee2Lca5yHh7FCS7V6cJ66bQ6MrT4S8UXyEUYFd7BKINjH172xZRFhy92drpg2g=="}],"memo":""},"blockNum":"373456"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"hello","Path":"gno.land/r/cc/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"ClBQ1EhvX4u9B/NixoF6wk9Bv7gmEprXLqNwNBrNDpJPzdjO+mm0I8klZ5ExcLYfkXTMEZnG229vQmrfkDSsog=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373458"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v1","Path":"gno.land/r/x1unix/whoami/v1","Files":[{"Name":"package.gno","Body":"package v1\n\nimport (\n\t\"gno.land/p/demo/ufmt\"\n\t\"std\"\n)\n\nvar (\n\tadmin std.Address = \"\"\n)\n\nfunc init() {\n\tadmin = \"\"\n}\n\nfunc AmIAdmin() string {\n\tactor := std.GetOrigCaller()\n\treturn ufmt.Sprintf(\"Admin: %s\\nCaller: %s\\nIsAdmin: %t\", actor == admin)\n}\n\nfunc Render(path string) string {\n\treturn AmIAdmin()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/x1unix/whoami/v1\n\nrequire (\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"6E0FPRN+Y3wfQY0wywKg+6/f2wf4lYbskxaMT8fS1WMw9SzJvkncmb9JsOcf0JGNyy328OeWGQ8iIHrFcr4kbw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373460"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","send":"","pkg_path":"gno.land/r/hellotest/poll","func":"Vote","args":["false","true","false","false"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"K4T4DGGBQbf0JP0hGyyeV/kUTkl+9tZ0yCbas4Lox+RsPBhTK8ORa/1p0Fdggj3P4rsU0cxM7HsgvpsrnFfIJA=="}],"memo":"Called through gno.studio"},"blockNum":"373463"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v3","Path":"gno.land/r/x1unix/feedback/v3","Files":[{"Name":"package.gno","Body":"package v3\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}"},{"Name":"gno.mod","Body":"module gno.land/r/x1unix/feedback/v3\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"IztrbQhkgg4Ydb9BVT3AZzCcaL238e37TUo/LFkzpSZSz/k/+YXEpJm5k+OlkYz6im8QJld+joWRMTOEl7FLYA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373481"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v10","Path":"gno.land/r/x1unix/feedback/v10","Files":[{"Name":"package.gno","Body":"package v10\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}"},{"Name":"gno.mod","Body":"module gno.land/r/x1unix/feedback/v10\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"7rOKEBBE+tnLlN8ueyCHjVQJLFSGMtPugvbbfl/7b6dbkgHaFEhs/f3r1YTDZrvJrTFVIp5bM94RLGPDh/y3LQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373483"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v1","Path":"gno.land/r/sdm/feedback/v1","Files":[{"Name":"package.gno","Body":"package v1\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/feedback/v1\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"zktQYnMos7zdk1iV/+d8Jct/2brkgY9GWnpZ93cHub8txTAfdueEjSAmhsWTkVk4T4AGqYhipUvrM32ovzwvxQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373485"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v1","func":"SubmitFeedback","args":["test"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"PXpoiEQ73RmBRK3sDdCmMcPpsmW8I8EoHDRUVJOZzdEWG2WENyyjjdlxm9WlJerl3USFzxWZ1dCoo5FrgfrGwA=="}],"memo":"Called through gno.studio"},"blockNum":"373487"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v1","func":"RespondToFeedback","args":["1","reply"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"Ygr82dkD30wxD2kgZhMniGt6nCEaeDYQ5BCpEQTGOFZYFv/H/f5x8PGEPlDzMVI2MC8FAzXLDPXs6N5T28Br+g=="}],"memo":"Called through gno.studio"},"blockNum":"373489"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"aWReD0Z37m76flUgspiu8gjl8UrnDlhemGix5VWdLGU120a9CJkBQqoLu/G9AZDAy/By7VXoEk2SEhiQk6FHcw=="}],"memo":""},"blockNum":"373491"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v1","func":"RespondToFeedback","args":["1","twat"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"skwjiIGTMgr7m++7oFEQO3IWz/DXmcBsTNNgOkGgjVkgZWzOTuQSDBDMmPSV6QlA3yw8GvvLkkGIdwu6giLSWA=="}],"memo":"Called through gno.studio"},"blockNum":"373493"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v1","func":"AddModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"ZrfYOV/xYSmAVBfsg+qjfTriZtH7eZkd1Vzw2dErHJA4KvgPzk/vnr1YmzFVXUM/aKHNczdbgb18KtHdyjnsdQ=="}],"memo":"Called through gno.studio"},"blockNum":"373495"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v2","Path":"gno.land/r/sdm/feedback/v2","Files":[{"Name":"package.gno","Body":"package v2\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/feedback/v2\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"p2xujPiKpmr9ktvgUnXJfvweB+akeGYodk0yj5qhke4D/E4a3Ks/h1ZrdyheWfy67EAMm6I0EOUpPZ4MOHGL5g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373498"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"SubmitFeedback","args":["test?"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"7qagMUmJ74h8RDabDoBiruKoeOsBBtQB337sb6BSikw9o2f6qXvB89m6JJZGck8W5VZc5b7Sy/BPeYAR/LFaYg=="}],"memo":"Called through gno.studio"},"blockNum":"373500"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"RespondToFeedback","args":["1","qqqqq"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"klslpdDusZvEjAsymre7rsnv0QZvsJzN69rm36IP1EYxosHeVH14jgk6ZDeXdidQxw4m3np6/2+Z/NOis/Qy/g=="}],"memo":"Called through gno.studio"},"blockNum":"373502"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"AddModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"mSmfdlnPO58RTaKKHXQIdzuiIrqnO+PUgcDqzQ8U21BP4FPoKsct1z9+38vT6VpS5GUy0C+kfCQzXehHks0jOg=="}],"memo":"Called through gno.studio"},"blockNum":"373504"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"RemoveModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"LKusjuIlDlwET46cNpH696wnh0oSSGhPphI0MZ9UVN0XvnELPXBQs8bqV6PbFn4M6BEUXdUMgcGFBVOqZTzj/w=="}],"memo":"Called through gno.studio"},"blockNum":"373506"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"AddModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"5n+UXgjbQg4TWN6ur88Ey3a3zhK8XurQdZVWjxI6QyBOXy9B7rNAYlqn71TTNhmAyecz94zO8Y5la7WSLMD9qA=="}],"memo":"Called through gno.studio"},"blockNum":"373508"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"RespondToFeedback","args":["1","wat?"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"NdKLfLz4wLuaKk6dG+5hWIOH1r3yv+STnAfl0orrmI1b189zw6ZgOOh3I/dVBeWCbvYUAzbvDVCQgf4VeauBIQ=="}],"memo":"Called through gno.studio"},"blockNum":"373510"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"Render","args":[""]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"HSX9IdL2S2DXPVZe/X6f0IaAtmNQvl5DYbouo7WQBEFsct3EDFs1TCaUOILMmnqWmHOftVQELbSn0Hccm5ZktA=="}],"memo":"Called through gno.studio"},"blockNum":"373512"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"AddModerator","args":["asdasdasdasd"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"Ncp3TKXkcKKK08PD08QrbCJ7FcHUIkOYhpQEtW7pqDApnvyARFI9j+X0u7n5poCPO0XPfl+uOtj3uj30l1BkRg=="}],"memo":"Called through gno.studio"},"blockNum":"373515"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"RemoveModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"HnM6b1nPbt1ehwU6RVFn59cN36733IuoEulsGJBMVbdHP+2AnCIO42RKE8j0gnFmcup2VOi3pJ3zv+tb9s3Jxg=="}],"memo":"Called through gno.studio"},"blockNum":"373517"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v2","func":"RemoveModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"x4obmHdD1NEB6qJmTY5zJI5CJhhXw/UCqZz1CkCtSypFvFLKOq8Pkxf72VUsTv8EA+oox/dnaoRLjPJzs3O06w=="}],"memo":"Called through gno.studio"},"blockNum":"373519"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v3","Path":"gno.land/r/sdm/feedback/v3","Files":[{"Name":"package.gno","Body":"package v3\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tif !addr.IsValid() {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tif !addr.IsValid() {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/feedback/v3\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"es0D2BK/1d7tVzmMLx4Fof4btHD07Dp54Pyx4J/eZXgYoyTK11ZP/RmD1ggetIGpEUJFdLUL7kiywMZIgtitdQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373526"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v3","Path":"gno.land/r/sdm/feedback/v3","Files":[{"Name":"package.gno","Body":"package v3\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/feedback/v3\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"hFKp3//ZC7n9XHQ4Ai+UYpIN17BAyeNG3G3RAOYqV4VAt3uglbE2l0asRlrXWiovgPuWNyMBeL3vhlUrx0SykA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373530"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"SubmitFeedback","args":["1"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"jukXph78N3qVGq+n0506G4iMHZuAvx20q0b4mYRjBUx9w0N6rYvCC524D6j6Y+drt0vVJIKN2L071pzYOi+xmw=="}],"memo":"Called through gno.studio"},"blockNum":"373533"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"isHMjrjK1n1wUZPCjqSIk5ee8pNNM1671p3PK4J+SXsSuCPuvh1KLD98Xwk1EuEDJjNE74s/zrrJK4x6l0ykWg=="}],"memo":"Called through gno.studio"},"blockNum":"373535"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g18h9ggekrl6ym9n7t3ye8ah58vm44v25nhugz62","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Qoit9MIoJXGBLqUSAUxKbr7kqhwOUwpweRQ2EeSk5+MkqgsG5PmRB1hLiPpVD0kOx8J+gpo1aM/AHvIkTEDpdQ=="}],"memo":""},"blockNum":"373537"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"rxecz1E6LPP1zY71ihxeSrf3vEWxUkM2Uw2+fnpVc5Qpx0sX4LPHjlssnODFregjQ7FpNwiwv/yxF8hn1WPXeA=="}],"memo":"Called through gno.studio"},"blockNum":"373539"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g18h9ggekrl6ym9n7t3ye8ah58vm44v25nhugz62","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"nYVRgOSKr87QiCFQV1P7qCmevTE8mpoJbkBD9eE90lgPMeQzXjWkfWKbJzhZMVpjOocLSz/mEK+wDYiLotcXtQ=="}],"memo":""},"blockNum":"373541"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"AddModerator","args":["aaaaaa"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"eAZTQAAcgU1oXgvOOIXGqMORhO4HkIAQGPI6s5b7AvZxQyk6geXi0kXLrvHEeyvQdYtYAJCmE8t1afJOZGB6kg=="}],"memo":"Called through gno.studio"},"blockNum":"373543"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"AddModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"UehG1tr3FK3IBiuV7oQ+ZLpZdB2cab5F903h1RRgY4cZe/ZZGtWwvtNEcVz0BczNpxMIR5F026MEoChXwlZKdg=="}],"memo":"Called through gno.studio"},"blockNum":"373545"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"wsJVDW2+oP8uvJxPEVOrcMWXv1LU4SJYk/BQqguifZkX0bZNaIPUDKbRFvAXI2ma7QzINt9PX+KDbdPaSRi8cA=="}],"memo":"Called through gno.studio"},"blockNum":"373547"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g18h9ggekrl6ym9n7t3ye8ah58vm44v25nhugz62","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Ez4OzQ7L+UcQljBnu3QR1FEDf8rkd3ak4P1XZMpd3bQM0Nzj/3v+OzPpQfmiG99zpoGl7EE4v/ULrW0nQcaZPw=="}],"memo":""},"blockNum":"373549"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"KiskzWLzruxr3pKtOrVAmFezQpL+kC4I5zNrHFJHq8k1UysDkSsFJRb99V5JtnMU/9sQ5ElL5djsNBmGHTTp8Q=="}],"memo":""},"blockNum":"373551"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"RemoveModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0f"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"dMKBKQj0fkr9WeG/IUZyidXedJwq/O5CZkW1YXWIXZscZuBHbeUxN7lu8ybz/Alwwyo2wqlLhv78pR3AVgNLHg=="}],"memo":"Called through gno.studio"},"blockNum":"373553"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"RemoveModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"KBxF6MCViBellIbROMHGYuJLZQn/4fj5g9dv59MW0N5a3jpmHH5HLhZsyAwDTCr0L/PCS6OulFsWc/2A+mySWg=="}],"memo":"Called through gno.studio"},"blockNum":"373555"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"RemoveModerator","args":["g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"NA1lF265dnWAsDyInOL5znu+hYRKHhc+mQHanwiwaRoNJ39yoytw0182xQHDTSXxkOwppdeglrTx6Oxjsh2oUQ=="}],"memo":"Called through gno.studio"},"blockNum":"373557"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fdk37llu9sfu9mdupmzjx34v2nrrdnk2757e0j","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmPvFPM2RBSwYBtGZFUaTlIxSgHAZ+s2TXUiGG37/FcC"},"signature":"2dqldZw5p/pbI6vC5AHOsVy0IKYyluZqv4MiPE+Bp/kguNCH4SsYO5wDpmIQA2oWXlaPIE91/RGCbWkvyGw+Ew=="}],"memo":"Called through gno.studio"},"blockNum":"373559"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g18h9ggekrl6ym9n7t3ye8ah58vm44v25nhugz62","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"qVUUtg/OSywBGW6uvbVlMzqZ3X90aZRmoUErQCtXV9QebiGX2LArX1muKVlJBvFPOiuPaFLIFavHzUADdXGsSw=="}],"memo":""},"blockNum":"373561"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g18h9ggekrl6ym9n7t3ye8ah58vm44v25nhugz62","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"0BuB3L1w4+EpRGb8UGN1TbwsAoPqDWNL/p79ajLZvPRDSZu0pslbUnYUi/CBZGVOde+bhRo6TTQhCkYHpoO/2g=="}],"memo":""},"blockNum":"373564"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g18h9ggekrl6ym9n7t3ye8ah58vm44v25nhugz62","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"n02P7y82EwUstVwIvDc95FxSZnhaVI3UpCOdCVBso+osZufdVQC0JqkBB8PyrBRvbOJKFEFfo4NlXxPXyp+B7w=="}],"memo":""},"blockNum":"373566"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"AddModerator","args":["g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"Mrr/M2BINuaq4rqRQVurtxteQ7O4rmAeWNrzgz6sLrIiGbTgKjWAjLS72AnueZcLVvIjCqoPlPVNYT5qN8slhw=="}],"memo":"Called through gno.studio"},"blockNum":"373573"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"N3sgmc2N5WzQF1G4QI4JiZP8JRoGBPG83T+H7UwbGO5oebNhRr0Au+Qv+1sRAU5l/WwV8CZx48uG8Owkv/GoFw=="}],"memo":"Called through gno.studio"},"blockNum":"373575"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"96KBUJpbn1jTL0eMquhLm6zuXfvLZqSCtQx35M6Xr01UShaOHS+vJqWqW0iFGne+/NOI/QFAd3J0NPYYoPpClw=="}],"memo":""},"blockNum":"373580"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v3","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"Si14E8CzXz1WEuyFHCEvcfOnDqykPXzIuISfODL/WcVIwMgfuFTMgaQhr5I91YW4f07Z6Tsu+Mhw4/1v2DWz1Q=="}],"memo":"Called through gno.studio"},"blockNum":"373583"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Y+qUEYtfYey4N3nPraKj/P3JcBzTJFP3wW8BUaC5IPBEaMl90ANOYnBuGfu3aK9xL1PSwrJhvS9UJHwzgoybDg=="}],"memo":""},"blockNum":"373585"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"YPRnD4MeMhpbfY8bxw7Rgrfx5HsV23mkjPPH0juONg86RdMx6ZUhCl7mATTWqS1izoNuEIR73JCyyH3erGvkjg=="}],"memo":""},"blockNum":"373587"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"tSAD+uV4wiGmLEtsoyYXgHb9vP6SlvI2j/CoD5cMlxkc+9ARpTkU1RtANqIQOhYscqdhWwJGgSBWVA39SQVD+w=="}],"memo":""},"blockNum":"373589"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"vFIuNBmEYAauqkn4XrXpDOMLx6K2HpYoEePz1B0ZIt9YhBI9neFuSEKens8EpOf5Co9z0a+4Q7DP+Vx4KcdNPg=="}],"memo":""},"blockNum":"373591"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"v5","Path":"gno.land/r/sdm/feedback/v5","Files":[{"Name":"package.gno","Body":"package v5\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(path string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/feedback/v5\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"SsTBOje9a/1cab/JkE3TNBN6T/ZBTzYkBFgnWjwTsV1IlZYxkhyDc+X8Djrm6rAM/1ZtipDvI76OFRX4A/SXKA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373596"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v5","func":"SubmitFeedback","args":["111111"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"/6PzUL2TRkwkrPiFRmBR68KrvndZTILXTDn1ESGUbPRQwmXtAFOBjePPSJVDwoCuyU6bO4JPM7c5orv3GGCwgQ=="}],"memo":"Called through gno.studio"},"blockNum":"373598"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/feedback/v5","func":"Render","args":[""]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"2sqRjHNbcs4tNh7zt7RlNr0qiBtTK78db5BluBcNxahmnt/usnvYvbLImvXczZVKBDXyQYcVXiT4Eo9w4CLC1A=="}],"memo":"Called through gno.studio"},"blockNum":"373600"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"feedbacktest","Path":"gno.land/r/sdm/feedbacktest","Files":[{"Name":"package.gno","Body":"package feedbacktest\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(path string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/feedbacktest\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"7gmPdJIHCop/SPipM9WICdAysKOn/9r0RmMjLpCNNBQd2NP8IY8hrPTljBe3dObrYqZRmSpZdB5ZYTbDPO7BbA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373603"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"feedback","Path":"gno.land/r/sdm/v1/feedback","Files":[{"Name":"package.gno","Body":"package feedback\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(path string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/v1/feedback/\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"MISbu5hwB988HGNX66GAKqHkgn+ZAUH+P6QiMTj2fw0B0+ccE/UHujLZr389mY7Y80f3hqcBseD+g5lAztiRSA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373606"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"feedback","Path":"gno.land/r/sdm/vodka/feedback","Files":[{"Name":"package.gno","Body":"package feedback\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(path string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/vodka/feedback/\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"HUWEBFwC1nBqPRWXRfZrg1j9uoXnWxMX991kSJ1H/Od5LgwkH5lHEQiENz9OG61nfQ6dZRE14wkTDjmUnFl2TA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373608"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"feedback_1","Path":"gno.land/r/sdm/feedback_1","Files":[{"Name":"package.gno","Body":"package feedback_1\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(path string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/feedback_1/\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"vPtCyJgwJ5NYjYuxXJ2u5j9oRHQ1L9SbsUtoIOGoy+R05eX0OmipBDLvEIsGa58EGr/ejt/QQgSsIA4/cGPifQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373611"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"KbO30UsJyj/IaBYAz2EbQ3YvyiRxzLizp/EukVPog8E+kL/5XB1IchNyCWCdblYyHJN7beLM4sOVbw48IkjgJQ=="}],"memo":""},"blockNum":"373613"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"xZoXnHyw2j3kyE4OsbQcBbGNg+ABxpf40rSpVTmH07BW92NypZ6NaDEAU6EXF37gDNIo0v34I4sbx3/Ahec0Rg=="}],"memo":""},"blockNum":"373615"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"O96QkppM6Ga6kdrVeUSSUrVu+bu5zT9wukdBUIycOOt4+JTTHNOn3vtCyXbMspB6dyCoSO3GNj/VVRYp6qotSA=="}],"memo":""},"blockNum":"373619"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"+HiHSrozfgaUn0baM69PVJUWqhTv2dyG8LQb23Jy35V95K8v8PKuAo2yfaaeFlx7rH5WTu0Yzsik1A8uc0O2TA=="}],"memo":""},"blockNum":"373621"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"423zLqS2gRhxzHrD1+SnddkZCtzmDdZgl7qwc6/uLyUgnWMJqcTPXW69ir7J/T7r5kNVe9GtKiBgDtoOV7Ubaw=="}],"memo":""},"blockNum":"373623"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"GO7fbpZ7MCIyAVmpO/lZlX4K7b6U5SxOK0phbIn/HWNd7NTXCL9t96dn4eZsOVRD1/ptEbxWrLfThVj8qzj/xw=="}],"memo":""},"blockNum":"373625"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"somedudefeedbacktest_1","Path":"gno.land/r/sdm/somedudefeedbacktest_1","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_1\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockFeedback locks the realm, preventing further feedback submissions.\nfunc LockFeedback() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockFeedback unlocks the realm, allowing further feedback submissions.\nfunc UnlockFeedback() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(path string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_1\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"jUxas+e//ZyYAgB9ANK+m7jQmlq5svocR2W0+r1adb9TIgiwuHduflwbDOIuT2xRCZRu0NDfAZpDcqEyTlU2yw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373628"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Ni3XKWJZkYyj9Chk+JxATIWnxTQEksFVe+HLfJxvJt8lyX74BSaNcMluf8xMQ2QajyaUwBo8TCOHXfNEu/r7aA=="}],"memo":""},"blockNum":"373630"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"FON8h7aL0CwusQyyaycFBE9wNzK8TlnoVYLmE/0DZOszeonxy/xPXPHhQ6L+Nz+m7UT2EPnX6edafgYTJVdFUA=="}],"memo":"Called through gno.studio"},"blockNum":"373632"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"9qLIzw77vcL12RSuyHGfUFfo571Q4f5UakOJl5hjIP5w9nsK1B36Em7vJPsNh7RS5wt41A/1KET9a/6xo7p+zw=="}],"memo":"Called through gno.studio"},"blockNum":"373635"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"auM6zs4hBMxsveVXuDp+EXP0k5f/+onUg3ouXgJDl+o++vfyLgHarApiVtQBuHxLVH+Ws9g+s3HeWtCSky1J7A=="}],"memo":""},"blockNum":"373638"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"aD0AMcDkXHsdL+u4QHOC39IHTNPxhJfpYhSKwMhktXt8Ae/8LPIugHr+5IbvuIcSbSZ7TeDZtyTCIxXPNRJ/0g=="}],"memo":""},"blockNum":"373640"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmDuuTgSMdrhG49g2OdOaaPx5L91eIcZySaYLTyfs2K+"},"signature":"Xn/tUuloGXZ3ahvQ+nBW0sKYwv8UMUEmZdBX2l+nXCwSRPdDHeQ8/UHCE5Ir676TLIc8sOKw/GJC5hmcd52zFQ=="}],"memo":"Called through gno.studio"},"blockNum":"373642"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"AddModerator","args":["g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmDuuTgSMdrhG49g2OdOaaPx5L91eIcZySaYLTyfs2K+"},"signature":"kMshatZMXDmLdIVFxioAdKw10/GKqaXbGBnIrTZiCdwmORNy1Djh2+F9TdCDra3bOWeSJGipk3/H25SUpQc9xA=="}],"memo":"Called through gno.studio"},"blockNum":"373644"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"SubmitFeedback","args":["ajksfddsjkldasjkl;dfsaadfsadfjskl;adfjskl;adfjskl;"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"rQ8kPapZFETl5PcCGu8PVLphKmVTNo2lUdLJ3Li8UX1IFfd+Zp6s3vg/ykd2BB5249xFDVEmhrpXA7L8Ps1ZPA=="}],"memo":"Called through gno.studio"},"blockNum":"373646"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"5rWxWcbZOrJJq/SCcn1yam2+LhMVZp8Iu6vki9Kia2V7l3FOWVD4n6lXPjQjkOS7DUlEHT3kh/GON1l7TdUn9g=="}],"memo":"Called through gno.studio"},"blockNum":"373648"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"RespondToFeedback","args":["1","response?"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"eGrDJL8wST+Yi5nTVg2Hd6v3EIAddjcyV+dG/A0WN1QeYlx0O9eGZxohzXV1UaSxYcOZXhl/3+1xE9wEpO+LHw=="}],"memo":"Called through gno.studio"},"blockNum":"373650"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"BanFeedback","args":["1"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"545aY+7Of9Az8pOL0HSmfNAeGN0i5iKzRtRdIPshUldckdIoUx4gR0Cp5fdBLj/uUloH5ESiezJYs0u2s/Jhrg=="}],"memo":"Called through gno.studio"},"blockNum":"373652"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"LockFeedback","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmDuuTgSMdrhG49g2OdOaaPx5L91eIcZySaYLTyfs2K+"},"signature":"IKobW95vSdFzX+ZshtkYlXnsJXR0Eb91m1C5FeydsecsM7kR6O4i2z9tWaJymbPCVgPqRdMRY2UMHtZnrx8DoQ=="}],"memo":"Called through gno.studio"},"blockNum":"373654"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_1","func":"SubmitFeedback","args":["11111111"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"2BVurCV8ojXQCUgvmU6FCGafmY8TIIqMBAcEuB4gaRdZ85vgylTwaGo3XVTcP/743KfQEF/X6CRBRo6TmLu+rw=="}],"memo":"Called through gno.studio"},"blockNum":"373656"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"koCfXtAMxtna3ruv8/AbMZSiS3kKc4SeO2nyYlS8Wdp8XWFoDVaCBuPKpqg7fPlKKUgJTDg/VML8IVZ7RADcLQ=="}],"memo":""},"blockNum":"373658"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"VX1PxYejT/grkRUqYkIebmOcm/7jyzDu1gIDWUPNUe0Mf1svl4suL2wDAWd/+eOUeqBnC8MRMMx5sB9sjamF8g=="}],"memo":""},"blockNum":"373661"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","package":{"Name":"wakrim","Path":"gno.land/r/demo/wakrim","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"wkm.gno","Body":"package wkm\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\twkm   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\twkm = grc20.NewAdminToken(\"wakrim\", \"wkm\", 4)\r\n\twkm.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\twkm.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @wakrim (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn wkm.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := wkm.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := wkm.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn wkm.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := wkm.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ap94HPqivN3o8yHLT8O5i9lrVnAaQVtJxq8LdfTrn0YJ"},"signature":"4U7eFSCv8+1xntT1QerD1wkd/psGQkQtsbRgnOgbC9ks+i9Tyr/0oqcBtR+jlrnuDvF6WeL6VbabhR4lmds2gw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373663"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","package":{"Name":"wakrim","Path":"gno.land/r/demo/wakrim","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"wkm.gno","Body":"package wkm\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\twkm   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\twkm = grc20.NewAdminToken(\"wakrim\", \"wkm\", 4)\r\n\twkm.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\twkm.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @wakrim (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn wkm.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := wkm.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := wkm.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn wkm.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := wkm.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ap94HPqivN3o8yHLT8O5i9lrVnAaQVtJxq8LdfTrn0YJ"},"signature":"5Kvr882hd0dhRzw0bIj1xu6+y5oCgePdfsKH5Rn9JDw/69Y74Yvk4W2jFOUw7TUWJV+bA+QXs5DiE/t+a1CjVQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373665"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"somedudefeedbacktest_2","Path":"gno.land/r/sdm/somedudefeedbacktest_2","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_2\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tif isLocked {\n\t\tsb.WriteString(\"\u003e Realm is locked.\\n\")\n\t}\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_2\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"PVzXGYdNlcF1//HGZ25QggbcApduFFYxMHUtkVTwOIZHJArCY4pCnFE+ZguiUySwvRFz6vBJNZjpjAIlXE7e2A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373668"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"somedudefeedbacktest_3","Path":"gno.land/r/sdm/somedudefeedbacktest_3","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_3\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID    = 1\n\tisLocked  = false\n\tfeedbacks = []Feedback{}\n\tmodAddrs  = []std.Address{}\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockRealm locks the realm, preventing further feedback submissions.\nfunc LockRealm() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockRealm unlocks the realm, allowing further feedback submissions.\nfunc UnlockRealm() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", id)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tif isLocked {\n\t\tsb.WriteString(\"\u003e Realm is locked.\\n\")\n\t}\n\tfor _, fb := range feedbacks {\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_3\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"zu7dEtGXnJVFTfpsfGj1+6Fci3vCKRsgylOMI0sGyCd2Oe/JuS3+IOgsO6ewMtpaeyy42mi+6DSiSqsQmADvdg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373670"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","package":{"Name":"wkm","Path":"gno.land/r/demo/wkm","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"wkm.gno","Body":"package wkm\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\twkm   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\twkm = grc20.NewAdminToken(\"wakrim\", \"wkm\", 4)\r\n\twkm.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\twkm.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @wakrim (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn wkm.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := wkm.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := wkm.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn wkm.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := wkm.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ap94HPqivN3o8yHLT8O5i9lrVnAaQVtJxq8LdfTrn0YJ"},"signature":"8j1KXWSkwU8OF8QCP2Q9gRWnTcaiZU5C01RcVyuMkhYhHOGWxyIySxigZuKXuwpFoW0xO9AYdRwtVLrFaniZ5g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373672"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_3","func":"LockRealm","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmDuuTgSMdrhG49g2OdOaaPx5L91eIcZySaYLTyfs2K+"},"signature":"gJyq11Jufg70YcULufswIBb6aVEC17IVBzYD8i/y6XFslfWSLtlXDQpiPEd4ErQfzklkmnI1bpVk7ntYFaevDA=="}],"memo":"Called through gno.studio"},"blockNum":"373674"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw","package":{"Name":"wkm","Path":"gno.land/r/demo/wkm","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"wkm.gno","Body":"package wkm\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\twkm   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\twkm = grc20.NewAdminToken(\"wakrim\", \"wkm\", 4)\r\n\twkm.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\twkm.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @wakrim (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn wkm.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := wkm.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := wkm.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn wkm.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := wkm.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ap94HPqivN3o8yHLT8O5i9lrVnAaQVtJxq8LdfTrn0YJ"},"signature":"2t+jkQ5q5P5iutfjKjEVATITu4Vjm4hpyNAHhhtgAbZD76pM2trka5xcaBQdQLbEFNfRZhQQQnZX2bsrl4J8Fw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373677"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_3","func":"SubmitFeedback","args":["aaaaa"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"z1ls13SK7qu+v9oj35tMxScDuAAXf5OrRMovE51R9e9ANrYsjsCt6QTXsVNg7zhFiJQ/z4lix6WYk3Zya/Zrag=="}],"memo":"Called through gno.studio"},"blockNum":"373679"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_3","func":"UnlockRealm","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmDuuTgSMdrhG49g2OdOaaPx5L91eIcZySaYLTyfs2K+"},"signature":"aHgS2fC1r8ziPBY7cwG8orrUvSffqR44R2mc704ffWZ9BkRr4DqjfmZNOANx4B7YJ/5FjMfqhSIwQ4Zj9A/oxQ=="}],"memo":"Called through gno.studio"},"blockNum":"373681"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_3","func":"SubmitFeedback","args":["\u003cscript\u003ealert(\"asdasd\");\u003c/script\u003e"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"1gwjQlr2pbV3Ssjwr5cybnDCMFUW+lY6m/HWz631TUpZnRke+Ay5Q5C/Kcw8lnbVof/2lcgy8xTnVrCbXoAldw=="}],"memo":"Called through gno.studio"},"blockNum":"373683"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0","package":{"Name":"wkm","Path":"gno.land/r/demo/wkm","Files":[{"Name":"package.gno","Body":"package wakrypto\n\nfunc Render(path string) string {\n  return \"wakrypto!\"\n}\n"},{"Name":"wkm.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj25BEMdES3Xjgu3tntiE7dXQR0JIyYR9/YWamQML7Lo"},"signature":"VDqhvmDYhtbee5CsvuYPJ6cnJ0VmNo/ghb+UPpthnU11o93VsklTvSVQMbLAlOI/KMdtou8mYWRVygzzB3Mn8w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373695"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0","package":{"Name":"wkm","Path":"gno.land/r/demo/wkm","Files":[{"Name":"package.gno","Body":"package wakrypto\n\nfunc Render(path string) string {\n  return \"wakrypto!\"\n}\n"},{"Name":"wkm.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"},{"Name":"cps.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj25BEMdES3Xjgu3tntiE7dXQR0JIyYR9/YWamQML7Lo"},"signature":"biP32IFaC5urj9ijMgkvX0xogNVgDFA83XCp3yk0VaJn+3IqjeaLTkjjxjAaPqNUSAm0rlx8RMFpLBqBZcLr/A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373698"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0","package":{"Name":"cps","Path":"gno.land/r/demo/cps","Files":[{"Name":"package.gno","Body":"package wakrypto\n\nfunc Render(path string) string {\n  return \"wakrypto!\"\n}\n"},{"Name":"wkm.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"},{"Name":"cps.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj25BEMdES3Xjgu3tntiE7dXQR0JIyYR9/YWamQML7Lo"},"signature":"J0jL4mCk7JeTIDIMOGdNAqfIG/DORQU64w+zAaFfBlsjffg0h4aqacKtxgH1F3ydv0vx+pbuqf5SEqBMDSAngg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373700"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0","package":{"Name":"cps","Path":"gno.land/r/demo/cps","Files":[{"Name":"package.gno","Body":"package wakrypto\n\nfunc Render(path string) string {\n  return \"wakrypto!\"\n}\n"},{"Name":"wkm.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"},{"Name":"cps.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj25BEMdES3Xjgu3tntiE7dXQR0JIyYR9/YWamQML7Lo"},"signature":"A3+TzIJoMMI/e2CgVKHyxU76KK9l7Gi3NjFOEfC4/MoJUze8paAGOqWsShhkPAhmnVm2PjrJGlUFUVgsAIt0ng=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373703"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0","package":{"Name":"x","Path":"gno.land/r/demo/x","Files":[{"Name":"package.gno","Body":"package wakrypto\n\nfunc Render(path string) string {\n  return \"wakrypto!\"\n}\n"},{"Name":"wkm.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"},{"Name":"cps.gno","Body":"package cps\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tcps   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\tcps = grc20.NewAdminToken(\"Cryptopunkstar\", \"CPS\", 4)\r\n\tcps.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\tcps.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @cryptopunkstar (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn cps.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := cps.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := cps.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tcps.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn cps.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := cps.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj25BEMdES3Xjgu3tntiE7dXQR0JIyYR9/YWamQML7Lo"},"signature":"UuKbJE7sOIY4whO9VNLC3/ZV1LZ2EpDFvyfoW/xkTYMLL8C6r90UcI592+W6d/Y5WAzpbA6TckV+waLtAigqnA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373705"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0","package":{"Name":"x","Path":"gno.land/r/demo/x","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"wkm.gno","Body":"package wkm\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\twkm   *grc20.AdminToken\r\n\tadmin std.Address = \"g16crksxhg97q7w6jkr2yc7ahyvyvw339asjxrtw\" // TODO: helper to change admin\r\n)\r\n\r\nfunc init() {\r\n\twkm = grc20.NewAdminToken(\"wakrim\", \"wkm\", 4)\r\n\twkm.Mint(admin, 1000000*100000)                                    // @administrator (1M)\r\n\twkm.Mint(\"g13tsxsyvzt6qqvgm2eprmqk3q4s6ctwvndxt4x0\", 100000*100000) // @wakrim (100k)\r\n}\r\n\r\n// method proxies as public functions.\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn wkm.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := wkm.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := wkm.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\twkm.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\tcps.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\twkm.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render le rendu\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn wkm.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := wkm.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n// secure access for admin :)\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj25BEMdES3Xjgu3tntiE7dXQR0JIyYR9/YWamQML7Lo"},"signature":"+EOYYgkCYS2QbQTziLBi8XQTnUY4Q69FErUdpoRUrK1F3+qxK7E91l9PPV1Zc5zi9xZOFzoxZPU0ObaTljs2kA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373708"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"somedudefeedbacktest_4","Path":"gno.land/r/sdm/somedudefeedbacktest_4","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_4\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr     = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n\n\tpkgPath          = \"r/sdm/somedudefeedbacktest_4\"\n\trealmViewPath    = \"https://test3.gno.land/\" + pkgPath\n\tfeedbackFormPath = \"https://gno.studio/connect/view/gno.land/\" + realmViewPath + \"?network=test3#SubmitFeedback\"\n)\n\nvar (\n\tnextID            = 1\n\tisLocked          = false\n\tfeedbacks         = []Feedback{}\n\tmodAddrs          = []std.Address{}\n\tmigratedRealmPath = \"\"\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockRealm locks the realm, preventing further feedback submissions.\nfunc LockRealm() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockRealm unlocks the realm, allowing further feedback submissions.\nfunc UnlockRealm() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully. See all feedback at %s\", realmViewPath)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// MarkRealmDeprecated marks realm as deprecated, locks feedback recording and shows a new realm path at page.\nfunc MarkRealmDeprecated(newPath string) {\n\tnewPath = strings.TrimSpace(newPath)\n\tif newPath == \"\" {\n\t\tpanic(\"New path is empty\")\n\t}\n\n\tisLocked = true\n\tmigratedRealmPath = newPath\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := \u0026strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tif isLocked {\n\t\tsb.WriteString(\"\u003e Realm is locked.\\n\")\n\n\t\tif migratedRealmPath != \"\" {\n\t\t\tsb.WriteString(\"\u003e Realm is moved to \")\n\t\t\twriteHyperlink(sb, migratedRealmPath, migratedRealmPath)\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t} else {\n\t\twriteHyperlink(sb, \" Click here to submit your feedback \", feedbackFormPath)\n\t\tsb.WriteString(\"\\n\")\n\t}\n\n\tfor i := len(feedbacks) - 1; i \u003e= 0; i-- {\n\t\tfb := feedbacks[i]\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tif len(feedbacks) == 0 {\n\t\tsb.WriteString(\"*No Feedback*\\n\")\n\t}\n\n\treturn sb.String()\n}"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_4\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"jK4OHrO2J+i8nAy0XMj579TxZ/cPK9/g+QTc7X0gKItJe94MmC1iQwSVDHkNp3PLWdZV8L5slPcuj9BZPfzvTg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373719"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"somedudefeedbacktest_4","Path":"gno.land/r/sdm/somedudefeedbacktest_4","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_4\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr     = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n\n\tpkgPath          = \"r/sdm/somedudefeedbacktest_4\"\n\trealmViewPath    = \"https://test3.gno.land/\" + pkgPath\n\tfeedbackFormPath = \"https://gno.studio/connect/view/gno.land/\" + realmViewPath + \"?network=test3#SubmitFeedback\"\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID            = 1\n\tisLocked          = false\n\tfeedbacks         = []Feedback{}\n\tmodAddrs          = []std.Address{}\n\tmigratedRealmPath = \"\"\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockRealm locks the realm, preventing further feedback submissions.\nfunc LockRealm() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockRealm unlocks the realm, allowing further feedback submissions.\nfunc UnlockRealm() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully. See all feedback at %s\", realmViewPath)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// MarkRealmDeprecated marks realm as deprecated, locks feedback recording and shows a new realm path at page.\nfunc MarkRealmDeprecated(newPath string) {\n\tnewPath = strings.TrimSpace(newPath)\n\tif newPath == \"\" {\n\t\tpanic(\"New path is empty\")\n\t}\n\n\tisLocked = true\n\tmigratedRealmPath = newPath\n}\n\nfunc writeHyperlink(w *strings.Builder, label, url string) {\n\tw.WriteString(\"[\")\n\tw.WriteString(label)\n\tw.WriteString(\"](\")\n\tw.WriteString(url)\n\tw.WriteString(\")\")\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := \u0026strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tif isLocked {\n\t\tsb.WriteString(\"\u003e Realm is locked.\\n\")\n\n\t\tif migratedRealmPath != \"\" {\n\t\t\tsb.WriteString(\"\u003e Realm is moved to \")\n\t\t\twriteHyperlink(sb, migratedRealmPath, migratedRealmPath)\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t} else {\n\t\twriteHyperlink(sb, \" Click here to submit your feedback \", feedbackFormPath)\n\t\tsb.WriteString(\"\\n\")\n\t}\n\n\tfor i := len(feedbacks) - 1; i \u003e= 0; i-- {\n\t\tfb := feedbacks[i]\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tif len(feedbacks) == 0 {\n\t\tsb.WriteString(\"*No Feedback*\\n\")\n\t}\n\n\treturn sb.String()\n}"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_4\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"hNdBtcnuTrtKG0/jCLlVIX8pT0B0099hltijA/GdPhg/gsxGz5k7rIo4gLjfk9GK8HvpHDkuiCU4IyEYK8UEmA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373721"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"somedudefeedbacktest_5","Path":"gno.land/r/sdm/somedudefeedbacktest_5","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_5\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr     = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n\n\tpkgPath          = \"r/sdm/somedudefeedbacktest_5\"\n\trealmViewPath    = \"https://test3.gno.land/\" + pkgPath\n\tfeedbackFormPath = \"https://gno.studio/connect/view/gno.land/\" + realmViewPath + \"?network=test3#SubmitFeedback\"\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID            = 1\n\tisLocked          = false\n\tfeedbacks         = []Feedback{}\n\tmodAddrs          = []std.Address{}\n\tmigratedRealmPath = \"\"\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockRealm locks the realm, preventing further feedback submissions.\nfunc LockRealm() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockRealm unlocks the realm, allowing further feedback submissions.\nfunc UnlockRealm() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully. See all feedback at %s\", realmViewPath)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// MarkRealmDeprecated marks realm as deprecated, locks feedback recording and shows a new realm path at page.\nfunc MarkRealmDeprecated(newPath string) {\n\tnewPath = strings.TrimSpace(newPath)\n\tif newPath == \"\" {\n\t\tpanic(\"New path is empty\")\n\t}\n\n\tisLocked = true\n\tmigratedRealmPath = newPath\n}\n\nfunc writeHyperlink(w *strings.Builder, label, url string) {\n\tw.WriteString(\"[\")\n\tw.WriteString(label)\n\tw.WriteString(\"](\")\n\tw.WriteString(url)\n\tw.WriteString(\")\")\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := \u0026strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tif isLocked {\n\t\tsb.WriteString(\"\u003e Realm is locked.\\n\")\n\n\t\tif migratedRealmPath != \"\" {\n\t\t\tsb.WriteString(\"\u003e Realm is moved to \")\n\t\t\twriteHyperlink(sb, migratedRealmPath, migratedRealmPath)\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t} else {\n\t\twriteHyperlink(sb, \" Click here to submit your feedback \", feedbackFormPath)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tfor i := len(feedbacks) - 1; i \u003e= 0; i-- {\n\t\tfb := feedbacks[i]\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tif len(feedbacks) == 0 {\n\t\tsb.WriteString(\"*No Feedback*\\n\")\n\t}\n\n\treturn sb.String()\n}"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_4\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"WYo4QgbN9ViSxXvpUkup8didmvyu9KfkQ8vI2t54j1oFrYijlb/rxWRKH0XX++GkJm2evzDS5DEzMLY9roiLEA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373723"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"somedudefeedbacktest_6","Path":"gno.land/r/sdm/somedudefeedbacktest_6","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_6\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr     = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n\n\tpkgPath          = \"r/sdm/somedudefeedbacktest_6\"\n\trealmViewPath    = \"https://test3.gno.land/\" + pkgPath\n\tfeedbackFormPath = \"https://gno.studio/connect/view/gno.land/\" + pkgPath + \"?network=test3#SubmitFeedback\"\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID            = 1\n\tisLocked          = false\n\tfeedbacks         = []Feedback{}\n\tmodAddrs          = []std.Address{}\n\tmigratedRealmPath = \"\"\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockRealm locks the realm, preventing further feedback submissions.\nfunc LockRealm() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockRealm unlocks the realm, allowing further feedback submissions.\nfunc UnlockRealm() string {\n\tassertIsOwner()\n\tisLocked = false\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully. See all feedback at %s\", realmViewPath)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// MarkRealmDeprecated marks realm as deprecated, locks feedback recording and shows a new realm path at page.\nfunc MarkRealmDeprecated(newPath string) {\n\tnewPath = strings.TrimSpace(newPath)\n\tif newPath == \"\" {\n\t\tpanic(\"New path is empty\")\n\t}\n\n\tisLocked = true\n\tmigratedRealmPath = newPath\n}\n\nfunc writeHyperlink(w *strings.Builder, label, url string) {\n\tw.WriteString(\"[\")\n\tw.WriteString(label)\n\tw.WriteString(\"](\")\n\tw.WriteString(url)\n\tw.WriteString(\")\")\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := \u0026strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\tif isLocked {\n\t\tsb.WriteString(\"\u003e Realm is locked.\\n\")\n\n\t\tif migratedRealmPath != \"\" {\n\t\t\tsb.WriteString(\"\u003e Realm is moved to \")\n\t\t\twriteHyperlink(sb, migratedRealmPath, migratedRealmPath)\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t} else {\n\t\twriteHyperlink(sb, \" Click here to submit your feedback \", feedbackFormPath)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tfor i := len(feedbacks) - 1; i \u003e= 0; i-- {\n\t\tfb := feedbacks[i]\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tif len(feedbacks) == 0 {\n\t\tsb.WriteString(\"*No Feedback*\\n\")\n\t}\n\n\treturn sb.String()\n}"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_4\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"dUVaZJC1FNVBCvxI2gGUSJuPha4WXq4+LORwMZS5B2gjMIzCBJjqqAGrv5mRAj5I5yPlzxqf+tzugkCq8lhkiA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373726"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_6","func":"SubmitFeedback","args":["aaaaa"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"XApNNzP5Kq/iA0XvhH7OGVo0shJd3W+vWRhtG1k3VbBeBzrxuq4nLyo5Z6c4Lnxpm/FwTB9WD7oubj7dzvVEIw=="}],"memo":"Called through gno.studio"},"blockNum":"373728"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_6","func":"SubmitFeedback","args":["aaaaaaaaaaaa"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"2CwkWNARvlQfciwVGfxn4jqH6oxMM9lr4LcWNn/lRdp2zkfVO+s9ILjuEGb5vbJkGEnYba9+6+esFQx1T7cxxA=="}],"memo":"Called through gno.studio"},"blockNum":"373730"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_6","func":"LockRealm","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmDuuTgSMdrhG49g2OdOaaPx5L91eIcZySaYLTyfs2K+"},"signature":"llKLoPsae0GWh5b9Y/hsa35DE/RrDLuWRwQOgmafhagvimN4JQZ01YP8GQI4ad/IrmDnV6HmSv4m62KuzuD7PA=="}],"memo":"Called through gno.studio"},"blockNum":"373733"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_6","func":"MarkRealmDeprecated","args":["https://google.com"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmDuuTgSMdrhG49g2OdOaaPx5L91eIcZySaYLTyfs2K+"},"signature":"QPx2MC2MotzTYjAiIy0soAWFVyeBQnd3olp2dcTYYSNrWX7ycQ1Vg85n+iYhFxaLkFdt2kAUjgm3iXJSKJmXhw=="}],"memo":"Called through gno.studio"},"blockNum":"373735"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","package":{"Name":"somedudefeedbacktest_7","Path":"gno.land/r/sdm/somedudefeedbacktest_7","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_7\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr     = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n\n\tpkgPath          = \"r/sdm/somedudefeedbacktest_7\"\n\trealmViewPath    = \"https://test3.gno.land/\" + pkgPath\n\tfeedbackFormPath = \"https://gno.studio/connect/view/gno.land/\" + pkgPath + \"?network=test3#SubmitFeedback\"\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID            = 1\n\tisLocked          = false\n\tfeedbacks         = []Feedback{}\n\tmodAddrs          = []std.Address{}\n\tmigratedRealmPath = \"\"\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockRealm locks the realm, preventing further feedback submissions.\nfunc LockRealm() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockRealm unlocks the realm, allowing further feedback submissions.\nfunc UnlockRealm() string {\n\tassertIsOwner()\n\tisLocked = false\n\tmigratedRealmPath = \"\"\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully. See all feedback at %s\", realmViewPath)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// MarkRealmDeprecated marks realm as deprecated, locks feedback recording and shows a new realm path at page.\nfunc MarkRealmDeprecated(newPath string) {\n\tnewPath = strings.TrimSpace(newPath)\n\tif newPath == \"\" {\n\t\tpanic(\"New path is empty\")\n\t}\n\n\tisLocked = true\n\tmigratedRealmPath = newPath\n}\n\nfunc writeHyperlink(w *strings.Builder, label, url string) {\n\tw.WriteString(\"[\")\n\tw.WriteString(label)\n\tw.WriteString(\"](\")\n\tw.WriteString(url)\n\tw.WriteString(\")\")\n}\n\n\nfunc renderRealmDisclaimer(w *strings.Builder) {\n\tif !isLocked {\n\t\treturn\n\t}\n\n\tw.WriteString(`\u003cp style=\"padding: .75rem 1.25rem; border: 1px solid #FFEEBA; background-color: #FFF3CD; color: #856404; border-radius: .25rem\"\u003eRealm is locked.`)\n\tif migratedRealmPath != \"\" {\n\t\tw.WriteString(` Realm is moved to \u003ca href=\"`)\n\t\tw.WriteString(migratedRealmPath)\n\t\tw.WriteString(`\"\u003e`)\n\t\tw.WriteString(migratedRealmPath)\n\t\tw.WriteString(\"\u003c/a\u003e\")\n\t}\n\tw.WriteString(\"\u003c/p\u003e\\n\\n\")\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := \u0026strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\n\trenderRealmDisclaimer(sb)\n\tif !isLocked {\n\t\twriteHyperlink(sb, \" Click here to submit your feedback \", feedbackFormPath)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tfor i := len(feedbacks) - 1; i \u003e= 0; i-- {\n\t\tfb := feedbacks[i]\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tif len(feedbacks) == 0 {\n\t\tsb.WriteString(\"*No Feedback*\\n\\n\")\n\t}\n\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_4\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"XFMoFu6xbYMlcb4Q5KtaN0cFGsgqbuudOg5RMtcUnAoHtgPheAtQz26D8SrY8zBesbCkdTBmOCOM1rFekAtmfQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373750"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_7","func":"SubmitFeedback","args":["asd"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"4XkAUJ6ggdZcxyuQgV96zedbuEoT7m9GX7BPCuPZwOMQ+fVH3RVlwpt6VtN3Z320CB3LnUntJQth7CYv2/cY+w=="}],"memo":"Called through gno.studio"},"blockNum":"373752"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_7","func":"MarkRealmDeprecated","args":["asdasd"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"UJn3V3R5a1FLIYgFFS3NXbcI3tO2ABCFHjt9ZjNGB5QNRFXcoaWxQyrsjFbQnhUeQLBqJnCIlUooiEDJkzKwrw=="}],"memo":"Called through gno.studio"},"blockNum":"373754"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_7","func":"MarkRealmDeprecated","args":["https://google.com"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"qjcBTEqLnPivA2aDe+G1Sg83acXrvM+w3NknqMKUuCgMlPFjnomnSQHyVWN9+CWLWmPOUT4UOeq+BNmlweqBkA=="}],"memo":"Called through gno.studio"},"blockNum":"373756"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_7","func":"BanFeedback","args":["2"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"Ap3WSp24YTe6u81s7W01diPJ4K45au2aiegCmNxapFY7+g3axMqOR3IybaVOvPuMisbGFCHjcRU//KNEEZsOCQ=="}],"memo":"Called through gno.studio"},"blockNum":"373758"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","package":{"Name":"somedudefeedbacktest_8","Path":"gno.land/r/sdm/somedudefeedbacktest_8","Files":[{"Name":"package.gno","Body":"package somedudefeedbacktest_8\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr     = std.Address(\"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd\")\n\n\tpkgPath          = \"r/sdm/somedudefeedbacktest_8\"\n\trealmViewPath    = \"https://test3.gno.land/\" + pkgPath\n\tfeedbackFormPath = \"https://gno.studio/connect/view/gno.land/\" + pkgPath + \"?network=test3#SubmitFeedback\"\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID            = 1\n\tisLocked          = false\n\tfeedbacks         = []Feedback{}\n\tmodAddrs          = []std.Address{}\n\tmigratedRealmPath = \"\"\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockRealm locks the realm, preventing further feedback submissions.\nfunc LockRealm() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockRealm unlocks the realm, allowing further feedback submissions.\nfunc UnlockRealm() string {\n\tassertIsOwner()\n\tisLocked = false\n\tmigratedRealmPath = \"\"\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully. See all feedback at %s\", realmViewPath)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// MarkRealmDeprecated marks realm as deprecated, locks feedback recording and shows a new realm path at page.\nfunc MarkRealmDeprecated(newPath string) {\n\tassertIsOwner()\n\tnewPath = strings.TrimSpace(newPath)\n\tif newPath == \"\" {\n\t\tpanic(\"New path is empty\")\n\t}\n\n\tisLocked = true\n\tmigratedRealmPath = newPath\n}\n\nfunc writeHyperlink(w *strings.Builder, label, url string) {\n\tw.WriteString(\"[\")\n\tw.WriteString(label)\n\tw.WriteString(\"](\")\n\tw.WriteString(url)\n\tw.WriteString(\")\")\n}\n\n\nfunc renderRealmDisclaimer(w *strings.Builder) {\n\tif !isLocked {\n\t\treturn\n\t}\n\n\tw.WriteString(`\u003cp style=\"padding: .75rem 1.25rem; border: 1px solid #FFEEBA; background-color: #FFF3CD; color: #856404; border-radius: .25rem\"\u003eRealm is locked.`)\n\tif migratedRealmPath != \"\" {\n\t\tw.WriteString(` Realm is moved to \u003ca href=\"`)\n\t\tw.WriteString(migratedRealmPath)\n\t\tw.WriteString(`\"\u003e`)\n\t\tw.WriteString(migratedRealmPath)\n\t\tw.WriteString(\"\u003c/a\u003e\")\n\t}\n\tw.WriteString(\"\u003c/p\u003e\\n\\n\")\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := \u0026strings.Builder{}\n\tsb.WriteString(\"# Feedback Collection\\n\")\n\n\trenderRealmDisclaimer(sb)\n\tif !isLocked {\n\t\twriteHyperlink(sb, \" Click here to submit your feedback \", feedbackFormPath)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tfor i := len(feedbacks) - 1; i \u003e= 0; i-- {\n\t\tfb := feedbacks[i]\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tif len(feedbacks) == 0 {\n\t\tsb.WriteString(\"*No Feedback*\\n\\n\")\n\t}\n\n\treturn sb.String()\n}\n"},{"Name":"gno.mod","Body":"module gno.land/r/sdm/somedudefeedbacktest_8\n\nrequire (\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"y+iEA/dMIkOlAjscJti15sE6Jeq2DaRaJyHbCxeZE3x1qKmw3XMI/uX7Tes1E0xnWAHuF9zqCO0wwX3wTjsZ3g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373762"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_8","func":"MarkRealmDeprecated","args":["sdf"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"tXPL5IaQPbw7ZRPEkyf4NKRW3sqn9y3PH+tsElDzv3FHOIBcYs4R+9qpnehTSuAGfehOtIEsZ7/lvA9WuX4exA=="}],"memo":"Called through gno.studio"},"blockNum":"373764"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_8","func":"BanFeedback","args":["1"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"sMoZFGJBH4r3eIVQTDxiD1ay8UZLAkIJwkhV39RvIENoN43xN2Mce158uWX6hNPg9cx9fqGDd9GC3Jp18wD/7Q=="}],"memo":"Called through gno.studio"},"blockNum":"373766"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_8","func":"SubmitFeedback","args":["1111111"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"tDs8ktvou/Wtz2j9Jc2+C+iVgobwPnFjirwUiihn+jgEcmHCCTFrI5kzE9L8/JJzwovpnWEU89LuQ+BoourHbQ=="}],"memo":"Called through gno.studio"},"blockNum":"373768"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_8","func":"BanFeedback","args":["1"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"TIIxTAmHXcURgsOFrRtBP/NDDBgX0UDAvX3ncoiI2cw58iaChC+ld9jHdIf6Kk4eXQsYOprm8mzx5OSIxpNStA=="}],"memo":"Called through gno.studio"},"blockNum":"373770"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_8","func":"MarkRealmDeprecated","args":["javascript:alert(\"lol\")"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"ksB36Vxxn8tP7A/2Xg4dm3C0E4Y6Tm46su4dAcodh7Ia480SXycLx0DdreOHUlTky8eDcSleICJIWzQz+sHdBA=="}],"memo":"Called through gno.studio"},"blockNum":"373772"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/sdm/somedudefeedbacktest_8","func":"MarkRealmDeprecated","args":["//google.com"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"GEZHtvTic4J9HSrAKvdaNIw1j1JVbkGSIVNiz/QWLzxtQ1d+yonZfaeUnBsOsp3t6yXK2sETewe9rDj0pG7tww=="}],"memo":"Called through gno.studio"},"blockNum":"373774"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu","package":{"Name":"feedback_v1","Path":"gno.land/r/gnostudio/feedback_v1","Files":[{"Name":"package.gno","Body":"package feedback_v1\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tmaxCharsCount = 256\n\tnotFoundIndex = -1\n\n\t// ownerAddr is wallet address of realm admin.\n\townerAddr = std.Address(\"g1rdld2ay4c3r3eghk563sz6ne79mmplcl8zatuu\")\n\n\tpkgPath          = \"r/gnostudio/feedback_v1\"\n\trealmViewPath    = \"https://test3.gno.land/\" + pkgPath\n\tfeedbackFormPath = \"https://gno.studio/connect/view/gno.land/\" + pkgPath + \"?network=test3#SubmitFeedback\"\n)\n\nvar (\n\t// HTML escaping.\n\thtmlQuot = []byte(\"\u0026#34;\") // shorter than \"\u0026quot;\"\n\thtmlApos = []byte(\"\u0026#39;\") // shorter than \"\u0026apos;\" and apos was not in HTML until HTML5\n\thtmlAmp  = []byte(\"\u0026amp;\")\n\thtmlLt   = []byte(\"\u0026lt;\")\n\thtmlGt   = []byte(\"\u0026gt;\")\n\thtmlNull = []byte(\"\\uFFFD\")\n)\n\ntype Feedback struct {\n\tID        int\n\tUser      std.Address\n\tContent   string\n\tResponse  string\n\tCreatedAt time.Time\n\tRespondAt time.Time\n}\n\nvar (\n\tnextID            = 1\n\tisLocked          = false\n\tfeedbacks         = []Feedback{}\n\tmodAddrs          = []std.Address{}\n\tmigratedRealmPath = \"\"\n)\n\nfunc stripHtml(input string) string {\n\t// Copy from Go's `template.HTMLEscape`.\n\t// See: $GOROOT/src/text/template/funcs.go\n\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(input, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn input\n\t}\n\n\tb := []byte(input)\n\tw := strings.Builder{}\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\n\tw.Write(b[last:])\n\treturn w.String()\n}\n\nfunc findFeedback(id int) (int, bool) {\n\t// TODO: use avl and seqid when will move to test4\n\tfor i := range feedbacks {\n\t\tif feedbacks[i].ID == id {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn notFoundIndex, false\n}\n\nfunc findModerator(addr std.Address) int {\n\tfor i, modAddr := range modAddrs {\n\t\tif modAddr == addr {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn notFoundIndex\n}\n\nfunc assertAddrValid(addr std.Address) {\n\t// std.Address.IsValid() not available on test3\n\t_, _, ok := std.DecodeBech32(addr)\n\tif !ok {\n\t\tpanic(\"Invalid wallet address\")\n\t}\n}\n\n// assertIsModerator checks whether a current caller is owner or a moderator.\nfunc assertIsModerator() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr || findModerator(actorId) != notFoundIndex\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertIsOwner checks whether a current caller is a realm owner.\nfunc assertIsOwner() {\n\tactorId := std.GetOrigCaller()\n\tisAllowed := actorId == ownerAddr\n\tif !isAllowed {\n\t\tpanic(\"Access Denied\")\n\t}\n}\n\n// assertNotLocked interrupts execution if realm is locked.\nfunc assertNotLocked() {\n\tif isLocked {\n\t\tpanic(\"Realm is locked\")\n\t}\n}\n\n// LockRealm locks the realm, preventing further feedback submissions.\nfunc LockRealm() string {\n\tassertIsOwner()\n\tisLocked = true\n\treturn \"Locked\"\n}\n\n// UnlockRealm unlocks the realm, allowing further feedback submissions.\nfunc UnlockRealm() string {\n\tassertIsOwner()\n\tisLocked = false\n\tmigratedRealmPath = \"\"\n\treturn \"Unlocked\"\n}\n\n// SubmitFeedback allows users to submit their feedback about GnoStudio.\nfunc SubmitFeedback(message string) string {\n\tassertNotLocked()\n\n\tmessage = strings.TrimSpace(message)\n\tif message == \"\" {\n\t\tpanic(\"Message can't be empty\")\n\t}\n\n\tif len(message) \u003e maxCharsCount {\n\t\tpanic(\"Message is too long\")\n\t}\n\n\tid := nextID\n\tfeedbacks = append(feedbacks, Feedback{\n\t\tID:        id,\n\t\tUser:      std.GetOrigCaller(),\n\t\tContent:   stripHtml(message),\n\t\tCreatedAt: time.Now(),\n\t})\n\n\tnextID++\n\treturn ufmt.Sprintf(\"Feedback submitted successfully. See all feedback at %s\", realmViewPath)\n}\n\n// BanFeedback used by moderation team to remove feedbacks which violate code of conduct.\nfunc BanFeedback(feedbackID int) string {\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\t// Still keep the record but remove a harmful message.\n\tfeedbacks[i].Content = \"\"\n\treturn \"Feedback was removed by a moderator\"\n}\n\n// RespondToFeedback allows any moderator or realm owner to leave a response to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n\tassertNotLocked()\n\tassertIsModerator()\n\n\ti, ok := findFeedback(feedbackID)\n\tif !ok {\n\t\tpanic(\"Feedback not found\")\n\t}\n\n\tfeedback := feedbacks[i]\n\tif feedback.Response != \"\" {\n\t\tpanic(\"Feedback already has a response\")\n\t}\n\n\tresponse = strings.TrimSpace(response)\n\tif response == \"\" {\n\t\tpanic(\"Response can't be empty\")\n\t}\n\n\tif len(response) \u003e maxCharsCount {\n\t\tpanic(\"Response is too long\")\n\t}\n\n\tfeedback.RespondAt = time.Now()\n\tfeedback.Response = stripHtml(response)\n\tfeedbacks[i] = feedback\n\n\treturn \"Response recorded successfully\"\n}\n\n// GetRole returns a role name of a caller (admin, moderator or guest).\nfunc GetRole() string {\n\tactorId := std.GetOrigCaller()\n\tif actorId == ownerAddr {\n\t\treturn \"admin\"\n\t}\n\n\tif i := findModerator(actorId); i != notFoundIndex {\n\t\treturn \"moderator\"\n\t}\n\n\treturn \"guest\"\n}\n\n// AddModerator adds a new wallet address to a list of moderators.\nfunc AddModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i != notFoundIndex {\n\t\tpanic(\"Entry already exists\")\n\t}\n\n\tmodAddrs = append(modAddrs, addr)\n\treturn \"Success\"\n}\n\n// RemoveModerator removes a wallet address from a list of moderators.\nfunc RemoveModerator(addr std.Address) string {\n\tassertIsOwner()\n\tassertAddrValid(addr)\n\n\ti := findModerator(addr)\n\tif i == notFoundIndex {\n\t\tpanic(\"Entry not found\")\n\t}\n\n\tmodAddrs = append(modAddrs[:i], modAddrs[i+1:]...)\n\treturn \"Success\"\n}\n\n// MarkRealmDeprecated marks realm as deprecated, locks feedback recording and shows a new realm path at page.\nfunc MarkRealmDeprecated(newPath string) {\n\tassertIsOwner()\n\tnewPath = strings.TrimSpace(newPath)\n\tif newPath == \"\" {\n\t\tpanic(\"New path is empty\")\n\t}\n\n\tisLocked = true\n\tmigratedRealmPath = newPath\n}\n\nfunc writeHyperlink(w *strings.Builder, label, url string) {\n\tw.WriteString(\"[\")\n\tw.WriteString(label)\n\tw.WriteString(\"](\")\n\tw.WriteString(url)\n\tw.WriteString(\")\")\n}\n\nfunc renderRealmDisclaimer(w *strings.Builder) {\n\tif !isLocked {\n\t\treturn\n\t}\n\n\tw.WriteString(`\u003cp style=\"padding: .75rem 1.25rem; border: 1px solid #FFEEBA; background-color: #FFF3CD; color: #856404; border-radius: .25rem\"\u003eRealm is locked.`)\n\tif migratedRealmPath != \"\" {\n\t\tw.WriteString(` Realm is moved to \u003ca href=\"`)\n\t\tw.WriteString(migratedRealmPath)\n\t\tw.WriteString(`\"\u003e`)\n\t\tw.WriteString(migratedRealmPath)\n\t\tw.WriteString(\"\u003c/a\u003e\")\n\t}\n\tw.WriteString(\"\u003c/p\u003e\\n\\n\")\n}\n\n// Render displays all feedback and responses.\nfunc Render(_ string) string {\n\tsb := \u0026strings.Builder{}\n\tsb.WriteString(\"# Gno Studio Feedback Collection\\n\")\n\n\trenderRealmDisclaimer(sb)\n\tif !isLocked {\n\t\twriteHyperlink(sb, \" Click here to submit your feedback \", feedbackFormPath)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tfor i := len(feedbacks) - 1; i \u003e= 0; i-- {\n\t\tfb := feedbacks[i]\n\t\tsb.WriteString(ufmt.Sprintf(\"## Feedback #%d\\n\", fb.ID))\n\t\tsb.WriteString(ufmt.Sprintf(\"From `%s` at %s\\n\\n\", fb.User, fb.CreatedAt.Format(time.RFC1123)))\n\t\tif fb.Content == \"\" {\n\t\t\tsb.WriteString(\"*Feedback was removed by a moderator*\")\n\t\t} else {\n\t\t\tsb.WriteString(fb.Content)\n\t\t}\n\t\tsb.WriteString(\"\\n\\n\")\n\n\t\tif fb.Response == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsb.WriteString(\"### Response\\n\")\n\t\tsb.WriteString(ufmt.Sprintf(\"At %s\\n\\n\", fb.RespondAt.Format(time.RFC1123)))\n\t\tsb.WriteString(fb.Response)\n\t\tsb.WriteString(\"\\n\\n\")\n\t}\n\n\tif len(feedbacks) == 0 {\n\t\tsb.WriteString(\"*No Feedback*\\n\\n\")\n\t}\n\n\treturn sb.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AmDuuTgSMdrhG49g2OdOaaPx5L91eIcZySaYLTyfs2K+"},"signature":"hbqiHPvIFGm2cOAlp5kjz6WpTelcbHYjD1P0ht22aWFimku8obmulRa7StsX7k1XYhzZXpwjATrHCfFmMnEUgg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"373782"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/gnostudio/feedback_v1","func":"GetRole","args":null}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"mwAuFEYgysFtpAaEcK8+pvuEbRD7Hb0xwUdiaYEfo5NXSMrXEoA88B+bXyYB9pt7BQ3iDPhXjKGMFrFPgypHKQ=="}],"memo":"Called through gno.studio"},"blockNum":"373797"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"7EI4u4C37GZuZWrkanrTB1lbB41hazRUcRlq9NYsxyBtRP/LLc+iziS/MP35tPCevJa1x++xMAjNCKKRuJZREA=="}],"memo":""},"blockNum":"373888"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"j/ROkBcV44ZfbYoVcwovkRLSRMnbwztiLscT1wDlD6kNc4ig7BLxs+GWd57esFbVN30qIOjp11WFmDRXykPecQ=="}],"memo":""},"blockNum":"373890"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"INDhIXdwgwO92dwBcI333i+fEKoYkfVQ/jz3NZZFnqp257d8T3gPsfQUB0KfeXOK4FFOOwSxmm7dUTD4Oh/+jg=="}],"memo":""},"blockNum":"373893"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"oObkQlJDmp1SAq6kwaR052n9XddqGpoBlDI+URz/OG4EMAEzgeIsL7czlTf9y5TB2SRL5bj71WcIHg23wdpvAQ=="}],"memo":""},"blockNum":"373904"}
