{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"1000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"jJpbBtWuwpNlaQTv/fvDwfdydIiZ+PGX367GbFaYy3VWvytFFhqCs4KvVkV6naybr0X/83u/H8GCNaqUnJqDTg=="}],"memo":""},"blockNum":"299486"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"hello","Path":"gno.land/r/demo/tt3/hello","Files":[{"Name":"hello.gno","Body":"package hello\n\nfunc Render(name string) string {\n\treturn \"Hello \" + name\n}"}]},"deposit":""}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"FwOuomJHaSRFNI0ZixFYUGXacu9VK9B3CVqPtlO14WkO6ofC7945A9M2FBhtj64WH3FkGs3XrQxZJ+/POeBS0A=="}],"memo":""},"blockNum":"299489"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","1"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"mraKKBU+DiXXU48PfvKxnRkl3p5vgFtguW0GSH0xKl4tkMpiNAo5VA8nJXhfMPyCelQHJ4nyqc1Dn9boYj9plQ=="}],"memo":""},"blockNum":"299492"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1tt3whq2tdcqh2mtd4yjv6dlct73vvamxrftw6v","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"FiDxGqYsSf7efPESQl8iRKR9qhF7SCLJS86guw3nrGNu8kmIny/ybfnR4p0PSsRMaz2WgubcYgDHv6Sov1AbFQ=="}],"memo":""},"blockNum":"299496"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tt3whq2tdcqh2mtd4yjv6dlct73vvamxrftw6v","package":{"Name":"yayy","Path":"gno.land/r/demo/yayy","Files":[{"Name":"package.gno","Body":"package yayy\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6Q3ERX6FiG92+U7SdyZGDU7t5E7ZTFGKr3pyTcUPX86"},"signature":"AaB4NggcvlQKTgBJ+0Y5iOFSnjnXZU8UTMLnOTCswDFRNFkp4nyaAHVwsFiV+6Vwp3uifLyEVQXo/1XNBEwh+A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"299498"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1tt3whq2tdcqh2mtd4yjv6dlct73vvamxrftw6v","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"4yDiXEgw5OM4XAgkrqF+E6RTusPB6tH/qvykYKANVJU+lThBgCYiPnjnpqdn+pqaPT14vpSasQSRDbY/hHhWoQ=="}],"memo":""},"blockNum":"299501"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tt3whq2tdcqh2mtd4yjv6dlct73vvamxrftw6v","package":{"Name":"yummyyum","Path":"gno.land/r/demo/yummyyum","Files":[{"Name":"package.gno","Body":"package yummyyum\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6Q3ERX6FiG92+U7SdyZGDU7t5E7ZTFGKr3pyTcUPX86"},"signature":"PXF7/C2teRdDpAuKzrmNZ811UwFuTuwiH9raZdxKowIdWZcg8bUJ25yD0Lr0kBJ8hhAYgTLrVVKS/bvCX2Iy/w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"299503"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1s4lvedlmr7j6zzh0qm0njgm8wqaks6jn902dmw","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"nkBxAUKcTFFd6+txtYadQU5StGiuaCDefHIvsDFLSy16HRumSekUZNTynNlaO07IkYQ/Q9IsBLkM/RQMhpgjCg=="}],"memo":""},"blockNum":"299662"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1frvde3cwzpmkmcsgh6wfcc099k7xt838qtdk6w","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"tzXzGRYqttEawhnlZw/U76RuOza0y2d6j4/TowKsbKRLGr9YDjUScb8btSHJSmMbM9TuclcSQ/wnLr+s/1b5gg=="}],"memo":""},"blockNum":"299664"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1f2gy53gjx46l8njpxum48e79s9ehlzq5vzsgkk","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"vSvGvSWUOlJ2hipbiBJlxNJj4Qfkx5/rS7EnOf5iQXlHhe/cvSqmFRBUSx3keHuZ/9fwHKmYaUUiFj79Froyyg=="}],"memo":""},"blockNum":"299666"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g13z8g3fttsj86j0ul40eym30gcvzc8hvsqpjylv","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"U8x51f6KxLLg/bDykzA8H6OxWH6XMIF37IO4+rOBeroVA9B3wR8rz0MBc7Lv1mkPAFm7FKF4hfVRdw9kkD3FeQ=="}],"memo":""},"blockNum":"299668"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1wxar2cfqg9y0455x4vqhmqrc8fhv8mzmtzrt8m","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"o+kuRyjtcg7UI93Om2pVyZnz2eeqOatnCyc3PKrZcYIgRfZPm0fd9ZFRjzzF7DcMCx94FlWdAvPKXz+2UTwNcQ=="}],"memo":""},"blockNum":"299670"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1f2gy53gjx46l8njpxum48e79s9ehlzq5vzsgkk","to_address":"g1frvde3cwzpmkmcsgh6wfcc099k7xt838qtdk6w","amount":"309900000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AyWRILG6PZy1uT/LIOq0SxphkqWG3vzAiMEyWxvxSTM4"},"signature":"jQ7SkENMeFdT8sOr/sthAZmpaHZBANl66zBfh4KDqTNsAzDgDsWo8cFcxQfEXEODCoU/Sgqm9nYtYklLlvfYTQ=="}],"memo":""},"blockNum":"299672"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"kNQGuTVU3tS8/wjlizUCScWMJInM0j8fLp7wsJS5bk057hZUEAmXtMrVPb0U/YPIOjh8yKi9yyJUQePDVydbmw=="}],"memo":""},"blockNum":"299929"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","package":{"Name":"hello11156","Path":"gno.land/r/hello11156/hello11156","Files":[{"Name":"package.gno","Body":"package hello11156\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgRVZeBhCNiXMgeopMseJTFgTUwWKdw1TibC+g1lyO3E"},"signature":"tl+0UHJX2xtavUOeGECkzN7zL7sKeUOC9RuAMOtJChFFMY7U3KErFsnHCwFSMldo+qe0g4AUV6mVi5/f2iqpFw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"299931"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"grc20token","Path":"gno.land/r/grc20token/grc20token","Files":[{"Name":"package.gno","Body":"package users\n\nimport (\n\t\"regexp\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/users\"\n)\n\n//----------------------------------------\n// State\n\nvar (\n\tadmin      std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\"\n\tname2User  avl.Tree                    // Name -\u003e *users.User\n\taddr2User  avl.Tree                    // std.Address -\u003e *users.User\n\tinvites    avl.Tree                    // string(inviter+\":\"+invited) -\u003e true\n\tcounter    int                         // user id counter\n\tminFee     int64       = 200 * 1000000 // minimum gnot must be paid to register.\n\tmaxFeeMult int64       = 10            // maximum multiples of minFee accepted.\n)\n\n//----------------------------------------\n// Top-level functions\n\nfunc Register(inviter std.Address, name string, profile string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert invited or paid.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\tsentCoins := std.GetOrigSend()\n\tminCoin := std.Coin{\"ugnot\", minFee}\n\tif inviter == \"\" {\n\t\t// banker := std.GetBanker(std.BankerTypeOrigSend)\n\t\tif len(sentCoins) == 1 \u0026\u0026 sentCoins[0].IsGTE(minCoin) {\n\t\t\tif sentCoins[0].Amount \u003e minFee*maxFeeMult {\n\t\t\t\tpanic(\"payment must not be greater than \" + strconv.Itoa(int(minFee*maxFeeMult)))\n\t\t\t} else {\n\t\t\t\t// ok\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(\"payment must not be less than \" + strconv.Itoa(int(minFee)))\n\t\t}\n\t} else {\n\t\tinvitekey := inviter.String() + \":\" + caller.String()\n\t\t_, ok := invites.Get(invitekey)\n\t\tif !ok {\n\t\t\tpanic(\"invalid invitation\")\n\t\t}\n\t\tinvites.Remove(invitekey)\n\t}\n\t// assert not already registered.\n\t_, ok := name2User.Get(name)\n\tif ok {\n\t\tpanic(\"name already registered\")\n\t}\n\t_, ok = addr2User.Get(caller.String())\n\tif ok {\n\t\tpanic(\"address already registered\")\n\t}\n\t// assert name is valid.\n\tif !reName.MatchString(name) {\n\t\tpanic(\"invalid name: \" + name + \" (must be at least 6 characters, lowercase alphanumeric with underscore)\")\n\t}\n\t// remainder of fees go toward invites.\n\tinvites := int(0)\n\tif len(sentCoins) == 1 {\n\t\tif sentCoins[0].Denom == \"ugnot\" \u0026\u0026 sentCoins[0].Amount \u003e= minFee {\n\t\t\tinvites = int(sentCoins[0].Amount / minFee)\n\t\t\tif inviter == \"\" \u0026\u0026 invites \u003e 0 {\n\t\t\t\tinvites -= 1\n\t\t\t}\n\t\t}\n\t}\n\t// register.\n\tcounter++\n\tuser := \u0026users.User{\n\t\tAddress: caller,\n\t\tName:    name,\n\t\tProfile: profile,\n\t\tNumber:  counter,\n\t\tInvites: invites,\n\t\tInviter: inviter,\n\t}\n\tname2User.Set(name, user)\n\taddr2User.Set(caller.String(), user)\n}\n\nfunc Invite(invitee string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// get caller/inviter.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\tlines := strings.Split(invitee, \"\\n\")\n\tif caller == admin {\n\t\t// nothing to do, all good\n\t} else {\n\t\t// ensure has invites.\n\t\tuserI, ok := addr2User.Get(caller.String())\n\t\tif !ok {\n\t\t\tpanic(\"user unknown\")\n\t\t}\n\t\tuser := userI.(*users.User)\n\t\tif user.Invites \u003c= 0 {\n\t\t\tpanic(\"user has no invite tokens\")\n\t\t}\n\t\tuser.Invites -= len(lines)\n\t\tif user.Invites \u003c 0 {\n\t\t\tpanic(\"user has insufficient invite tokens\")\n\t\t}\n\t}\n\t// for each line...\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue // file bodies have a trailing newline.\n\t\t} else if strings.HasPrefix(line, `//`) {\n\t\t\tcontinue // comment\n\t\t}\n\t\t// record invite.\n\t\tinvitekey := string(caller) + \":\" + string(line)\n\t\tinvites.Set(invitekey, true)\n\t}\n}\n\nfunc GrantInvites(invites string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// for each line...\n\tlines := strings.Split(invites, \"\\n\")\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue // file bodies have a trailing newline.\n\t\t} else if strings.HasPrefix(line, `//`) {\n\t\t\tcontinue // comment\n\t\t}\n\t\t// parse name and invites.\n\t\tvar name string\n\t\tvar invites int\n\t\tparts := strings.Split(line, \":\")\n\t\tif len(parts) == 1 { // short for :1.\n\t\t\tname = parts[0]\n\t\t\tinvites = 1\n\t\t} else if len(parts) == 2 {\n\t\t\tname = parts[0]\n\t\t\tinvites_, err := strconv.Atoi(parts[1])\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tinvites = int(invites_)\n\t\t} else {\n\t\t\tpanic(\"should not happen\")\n\t\t}\n\t\t// give invites.\n\t\tuserI, ok := name2User.Get(name)\n\t\tif !ok {\n\t\t\t// maybe address.\n\t\t\tuserI, ok = addr2User.Get(name)\n\t\t\tif !ok {\n\t\t\t\tpanic(\"invalid user \" + name)\n\t\t\t}\n\t\t}\n\t\tuser := userI.(*users.User)\n\t\tuser.Invites += invites\n\t}\n}\n\n// Any leftover fees go toward invitations.\nfunc SetMinFee(newMinFee int64) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin caller.\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// update global variables.\n\tminFee = newMinFee\n}\n\n// This helps prevent fat finger accidents.\nfunc SetMaxFeeMultiple(newMaxFeeMult int64) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin caller.\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// update global variables.\n\tmaxFeeMult = newMaxFeeMult\n}\n\n//----------------------------------------\n// Exposed public functions\n\nfunc GetUserByName(name string) *users.User {\n\tuserI, ok := name2User.Get(name)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn userI.(*users.User)\n}\n\nfunc GetUserByAddress(addr std.Address) *users.User {\n\tuserI, ok := addr2User.Get(addr.String())\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn userI.(*users.User)\n}\n\n// unlike GetUserByName, input must be \"@\" prefixed for names.\nfunc GetUserByAddressOrName(input users.AddressOrName) *users.User {\n\tname, isName := input.GetName()\n\tif isName {\n\t\treturn GetUserByName(name)\n\t}\n\treturn GetUserByAddress(std.Address(input))\n}\n\nfunc Resolve(input users.AddressOrName) std.Address {\n\tname, isName := input.GetName()\n\tif !isName {\n\t\treturn std.Address(input) // TODO check validity\n\t}\n\tuser := GetUserByName(name)\n\treturn user.Address\n}\n\n//----------------------------------------\n// Constants\n\n// NOTE: name length must be clearly distinguishable from a bech32 address.\nvar reName = regexp.MustCompile(`^[a-z]+[_a-z0-9]{5,16}$`)\n\n//----------------------------------------\n// Render main page\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t} else if len(path) \u003e= 38 { // 39? 40?\n\t\tif path[:2] != \"g1\" {\n\t\t\treturn \"invalid address \" + path\n\t\t}\n\t\tuser := GetUserByAddress(std.Address(path))\n\t\tif user == nil {\n\t\t\t// TODO: display basic information about account.\n\t\t\treturn \"unknown address \" + path\n\t\t}\n\t\treturn user.Render()\n\t} else {\n\t\tuser := GetUserByName(path)\n\t\tif user == nil {\n\t\t\treturn \"unknown username \" + path\n\t\t}\n\t\treturn user.Render()\n\t}\n}\n\nfunc renderHome() string {\n\tdoc := \"\"\n\tname2User.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tuser := value.(*users.User)\n\t\tdoc += \" * [\" + user.Name + \"](/r/demo/users:\" + user.Name + \")\\n\"\n\t\treturn false\n\t})\n\treturn doc\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"KZhEMUvm0kADNii3raLa7VfLJmqWcKB5Zke9a1c6OC89d4zTikn/xMT08vZHdubDKMR+kr/3kYM/H7YvddW/gA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300051"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"mytoken","Path":"gno.land/r/grc20token/mytoken","Files":[{"Name":"package.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"CMFzqEqi3CwrzgXve8jxxFVCuhyJBvdVh03t2oCEl9E2Gtrlx5DFt0WTEQhDGYdyMLbpC1gLPuD7gxrzCk9Vug=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300059"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"mytoken","Path":"gno.land/r/grc20token/mytoken","Files":[{"Name":"package.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"iSsvs3Xaq7azdI4gM0GXCXjqe2unngt7n6si+jPVQjJhsbdP5FXshP6iAL84qQ/CNjcNDmbSCFBL5w7Ylbsq5Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300064"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"mytoken","Path":"gno.land/r/grc20token/mytoken","Files":[{"Name":"package.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"diDWNPJSjJVEI3NRxdsDkwrL2a3STpGRivCzAyUhMNATkOGPt+BfAHLQZhvSwanq7QUKQO6Qooq8xkXbykViwQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300066"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"mytoken","Path":"gno.land/r/grc20token/mytoken","Files":[{"Name":"package.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n  \"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"+amhW0kwFkffRJT0Xwqm6OuHXq+cLk46tbA95kfT6ew9dUe3FT0ymSwkmEFgV1qrKVmvDFK7q7CSGH+lJjyB+w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300068"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"mytoken","Path":"gno.land/r/grc20token/mytoken","Files":[{"Name":"package.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n  \"strings\"\n  \"ufmt\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"Y+a2juyF8RNml/fglXv1G/JDkAwyCCcNTxnKD8DyVQwBaMWXKb4dhTOnLLrUoSK/r11sX7x4Vt5PP8gp5a9ZSA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300072"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"mytoken","Path":"gno.land/r/grc20token/mytoken","Files":[{"Name":"package.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n  \"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n  \"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"j96rWc+pDj9ZmRRnsRUw8KX4Ia8ANWvCj3FSejR6C8AXaQE4e+FJl7UsDLvW5bEUO2/sw8EdAwnmU53dk/Qykw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300074"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/demo/kazai","func":"BalanceOf","args":["g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"b0+gJonrXXKg+uIp1qTDQXqPsVG848mxIEXl5Rwdsy9R2q+ayg96qxVT5Wyqp0E+wU1lZRjAtFsQ8i4Y0txKYQ=="}],"memo":""},"blockNum":"300105"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/grc20token/mytoken","func":"BalanceOf","args":["g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"QC3zhID/DudqsflxKyawPFMGaLQxhTr1G0aA9hB1RzlB5SbxZcjIek1RzR3NuRTyl2ZNgXIl6jzzvSngUpd9tg=="}],"memo":""},"blockNum":"300118"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea","package":{"Name":"kazainft","Path":"gno.land/r/nft/kazainft","Files":[{"Name":"kazainft.gno","Body":"package kazainft\n\nimport (\n    \"std\"\n\n    \"gno.land/p/demo/grc/grc721\"\n    \"gno.land/r/demo/users\"\n)\n\nvar (\n    admin std.Address = \"g1v664qx78zhv2edtx6ypdylfpafrqjz8g2rlaea\"\n    kazainft = grc721.NewBasicNFT(\"kazainft\", \"KNFT\")\n)\n\nfunc init() {\n    mintNNFT(admin, 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n    count := my.TokenCount()\n    for i := count; i \u003c count+n; i++ {\n        tid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n        kazainft.Mint(owner, tid)\n    }\n}\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n    balance, err := kazainft.BalanceOf(user.Resolve())\n    if err != nil {\n        panic(err)\n    }\n\n    return balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n    owner, err := kazainft.OwnerOf(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n    return kazainft.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n    addr, err := kazainft.GetApproved(tid)\n    if err != nil {\n        panic(err)\n    }\n\n    return addr\n}\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.Approve(user.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n    err := kazainft.SetApprovalForAll(user.Resolve(), approved)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n    err := kazainft.TransferFrom(from.Resolve(), to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Mint(to.Resolve(), tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Burn(tid grc721.TokenID) {\n    caller := std.PrevRealm().Addr()\n    assertIsAdmin(caller)\n    err := kazainft.Burn(tid)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc Render(path string) string {\n    switch {\n    case path == \"\":\n        return kazainft.RenderHome()\n    default:\n        return \"404\\n\"\n    }\n}\n\nfunc assertIsAdmin(address std.Address) {\n    if address != admin {\n        panic(\"restricted access\")\n    }\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"An36kfJTFLYv6qJ18qs3TguyUwiALNgLeCPHsZjzhSdI"},"signature":"25RTgICQBtGSQzYk2whorW3e9+hcgZoqeg/knTPMUWwlhDZEWkPdz57ZT2yOxbvmzzKSLlMesy9jcnETt23HMQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300164"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/grc20token/mytoken","func":"BalanceOf","args":["g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"2mAJSazsuO/uL0r7gpzJhcHq+IfNABEO2ljHg60Hl85O8K+oF48/IMG41xYAwFnPHddu7byBaf8OWc0msD6YNA=="}],"memo":""},"blockNum":"300224"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/grc20token/mytoken","func":"TotalSupply","args":null}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"+YKCZcj97v+RVkbY9Aqf9qAQy4IpSrBOnzM497cqhIcVCeTh2BEfpCtMqAOGdXVoC/JrMIkNEtqGOD0ASda64Q=="}],"memo":""},"blockNum":"300226"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/grc20token/mytoken","func":"Mint","args":["g1enpvuf7yukrs7h4hgsqcu3jqygw7pjmad3k2tm","10"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"O7pnon2YIUWXJ7pkx0cmEvG7/A8rQ11ZkZK9xNBgiA1rDObVjxeEcFlu9xBaEPFz0TgUuJ1qEiRVljJoyNA+Qw=="}],"memo":""},"blockNum":"300229"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"myNFTtoken","Path":"gno.land/r/grc721token/myNFTtoken","Files":[{"Name":"package.gno","Body":"package myNFTtoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\t// provision the token's name and symbol\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := my.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"3CCuXwuH860Sn4L6S7lpWMfEw7kYFGzRyTW+AYrn9rJtgYaNb+9iWKV6+uJX1LAWGk2OORELWe2cOn75z6b8Jg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300237"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"myNFTtoken","Path":"gno.land/r/myNFTtoken/myNFTtoken","Files":[{"Name":"package.gno","Body":"package myNFTtoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\t// provision the token's name and symbol\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := my.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"MDaefuIDsD0J7ddBK6wTV+8r4xS9iZbl2gALl88nDLZ+UkfDp6SP2nKBLSaMvQ7ciuFZqZ3MnjvgxPlluacdCA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300239"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"malekNFTtoken","Path":"gno.land/r/malekNFTtoken/malekNFTtoken","Files":[{"Name":"package.gno","Body":"package malekNFTtoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\t// provision the token's name and symbol\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := my.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"IJlwKhLLgxhyGjkMW6zTvhdDzLzGAc2bYuogpW/FG5dQoSl8nuw7hM3Z1iOpIPOnJjzbthaOnwOoxJIXs8zfdQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300242"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"malekNFTtoken","Path":"gno.land/r/malekNFT/malekNFTtoken","Files":[{"Name":"package.gno","Body":"package malekNFTtoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\t// provision the token's name and symbol\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := my.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"fHyL9x9fPKc6Sc4bHs4o8wTHvsZACa9uRyPSCUZF8JYfaCtiydOLGWIsxLxbJ6CXLaWRD0chmKAaFDDrV1pfKw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300244"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"maleknfttoken","Path":"gno.land/r/maleknft/maleknfttoken","Files":[{"Name":"package.gno","Body":"package maleknfttoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\t// provision the token's name and symbol\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := my.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"qhZVEkS9fzwjitYKVC1u4PosG8LBLR/hlTSN825jOQMeNH4g81rH1hu9mpFepjyp1pP8TLA6Izoz+i57SSRSLg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300248"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"maleknft","Path":"gno.land/r/maleknft/maleknft","Files":[{"Name":"package.gno","Body":"package maleknfttoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n  \"gno.land/r/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\t// provision the token's name and symbol\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := my.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"3dM6OgHvzMSeT838Nyhyg89ErykU5lCWFqboc6/Bu/Yj+gDuEC2PBHxLmO9+JnQEr+TXjUxoq3N1opdfSZ+2CQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300250"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10ahumypepd2qcrau7kahv8q78f7jcdns5tn54a","package":{"Name":"maleknfttoken","Path":"gno.land/r/maleknft/maleknfttoken","Files":[{"Name":"package.gno","Body":"package maleknfttoken\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n  \"gno.land/r/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\t// provision the token's name and symbol\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (supply = 10)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := my.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AidlxNTtkl1dDNCgxrSNVJKYWZdC9yrixvgSAP6U6WYX"},"signature":"kNAyj+fuw4RRJDvcvvaAsuJ1xzJtWLjc/QirZb73YjliRNV9ltdW4WrmE/gguxWj+2iygOohR+IrHFbkIlX+Jg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300252"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"counter","Path":"gno.land/r/leon/counter","Files":[{"Name":"package.gno","Body":"package counter\n\nimport (\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar count int\n\nfunc Increment() {\n\tcount++\n}\n\nfunc Decrement() {\n\tcount--\n}\n\nfunc Render(_ string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\n// How to: Deploy using Gno Playground"},{"Name":"package_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCounter_Increment(t *testing.T) {\n\t// Reset the value\n\tcount = 0\n\n\t// Verify the initial value is 0\n\tif count != 0 {\n\t\tt.Fatalf(\"initial value != 0\")\n\t}\n\n\t// Increment the value\n\tIncrement()\n\n\t// Verify the initial value is 1\n\tif count != 1 {\n\t\tt.Fatalf(\"initial value != 1\")\n\t}\n}\n\nfunc TestCounter_Decrement(t *testing.T) {\n\t// Reset the value\n\tcount = 0\n\n\t// Verify the initial value is 0\n\tif count != 0 {\n\t\tt.Fatalf(\"initial value != 0\")\n\t}\n\n\t// Decrement the value\n\tDecrement()\n\n\t// Verify the initial value is 1\n\tif count != -1 {\n\t\tt.Fatalf(\"initial value != -1\")\n\t}\n}\n\nfunc TestCounter_Render(t *testing.T) {\n\t// Reset the value\n\tcount = 0\n\n\t// Verify the Render output\n\tif Render(\"\") != \"Count: 0\" {\n\t\tt.Fatalf(\"invalid Render value\")\n\t}\n}\n\n// How to: Deploy using Gno Playground"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"/B4jspnRqK6fRUUrzK74Vb49CzDZ1dG9a2SDUzCl/G8MaBXb2w6XIJi2O+2y/sx5BnP5ydoVocg0d+COUCbpFQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300798"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g130qplr2dny02smprqcypk4t9fd3ahnjuf08yax","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"8kS6mkHrKUtkbp1zZGKdbctcjvQXZ1liXeBxgEqAgIohJo58SA99BzSpeGF33Zsx7NIajv0SzEWDbfnSGQH6Ww=="}],"memo":""},"blockNum":"300814"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"poll","Path":"gno.land/r/leon/poll","Files":[{"Name":"package.gno","Body":"package poll\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// Main struct\ntype Poll struct {\n\ttitle       string\n\tdescription string\n\tdeadline    int64     // block height\n\tvoters      *avl.Tree // addr -\u003e yes / no (bool)\n}\n\n// Getters\nfunc (p Poll) Title() string {\n\treturn p.title\n}\n\nfunc (p Poll) Description() string {\n\treturn p.description\n}\n\nfunc (p Poll) Deadline() int64 {\n\treturn p.deadline\n}\n\nfunc (p Poll) Voters() *avl.Tree {\n\treturn p.voters\n}\n\n// Poll instance constructor\nfunc NewPoll(title, description string, deadline int64) *Poll {\n\treturn \u0026Poll{\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tdeadline:    deadline,\n\t\tvoters:      avl.NewTree(),\n\t}\n}\n\n// Vote Votes for a user\nfunc (p *Poll) Vote(voter std.Address, vote bool) {\n\tp.Voters().Set(voter.String(), vote)\n}\n\n// HasVoted vote: yes - true, no - false\nfunc (p *Poll) HasVoted(address std.Address) (bool, bool) {\n\tvote, exists := p.Voters().Get(address.String())\n\tif exists {\n\t\treturn true, vote.(bool)\n\t}\n\treturn false, false\n}\n\n// VoteCount Returns the number of yay \u0026 nay votes\nfunc (p Poll) VoteCount() (int, int) {\n\tvar yay int\n\n\tp.Voters().Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tvote := value.(bool)\n\t\tif vote == true {\n\t\t\tyay = yay + 1\n\t\t}\n\t})\n\treturn yay, p.Voters().Size() - yay\n}\n// How to: Write Simple Dapp"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"1MAc4pkmG82BLuBUWPbWiZJG//8N6kyV0G8PQtkPY1EG8kQSpb43D8iMnmHy/dC1n4efVK7Zy2NmNAoCP1Ym7Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300844"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"poll","Path":"gno.land/r/leon/poll","Files":[{"Name":"package.gno","Body":"package poll\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/leons/avl\"\n)\n\n// Main struct\ntype Poll struct {\n\ttitle       string\n\tdescription string\n\tdeadline    int64     // block height\n\tvoters      *avl.Tree // addr -\u003e yes / no (bool)\n}\n\n// Getters\nfunc (p Poll) Title() string {\n\treturn p.title\n}\n\nfunc (p Poll) Description() string {\n\treturn p.description\n}\n\nfunc (p Poll) Deadline() int64 {\n\treturn p.deadline\n}\n\nfunc (p Poll) Voters() *avl.Tree {\n\treturn p.voters\n}\n\n// Poll instance constructor\nfunc NewPoll(title, description string, deadline int64) *Poll {\n\treturn \u0026Poll{\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tdeadline:    deadline,\n\t\tvoters:      avl.NewTree(),\n\t}\n}\n\n// Vote Votes for a user\nfunc (p *Poll) Vote(voter std.Address, vote bool) {\n\tp.Voters().Set(voter.String(), vote)\n}\n\n// HasVoted vote: yes - true, no - false\nfunc (p *Poll) HasVoted(address std.Address) (bool, bool) {\n\tvote, exists := p.Voters().Get(address.String())\n\tif exists {\n\t\treturn true, vote.(bool)\n\t}\n\treturn false, false\n}\n\n// VoteCount Returns the number of yay \u0026 nay votes\nfunc (p Poll) VoteCount() (int, int) {\n\tvar yay int\n\n\tp.Voters().Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tvote := value.(bool)\n\t\tif vote == true {\n\t\t\tyay = yay + 1\n\t\t}\n\t})\n\treturn yay, p.Voters().Size() - yay\n}\n// How to: Write Simple Dapp"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"fQnzbhRJ/+5wz1tc4BT6RLpJH7SNpRDGwcYGyqIYddMLG9Zxh8G2A0rws1ItRwdkF7PntNKtBUv8NCCpQ/Jd5Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300846"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"poll","Path":"gno.land/r/leon/poll","Files":[{"Name":"package.gno","Body":"package poll\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/leon/avl\"\n)\n\n// Main struct\ntype Poll struct {\n\ttitle       string\n\tdescription string\n\tdeadline    int64     // block height\n\tvoters      *avl.Tree // addr -\u003e yes / no (bool)\n}\n\n// Getters\nfunc (p Poll) Title() string {\n\treturn p.title\n}\n\nfunc (p Poll) Description() string {\n\treturn p.description\n}\n\nfunc (p Poll) Deadline() int64 {\n\treturn p.deadline\n}\n\nfunc (p Poll) Voters() *avl.Tree {\n\treturn p.voters\n}\n\n// Poll instance constructor\nfunc NewPoll(title, description string, deadline int64) *Poll {\n\treturn \u0026Poll{\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tdeadline:    deadline,\n\t\tvoters:      avl.NewTree(),\n\t}\n}\n\n// Vote Votes for a user\nfunc (p *Poll) Vote(voter std.Address, vote bool) {\n\tp.Voters().Set(voter.String(), vote)\n}\n\n// HasVoted vote: yes - true, no - false\nfunc (p *Poll) HasVoted(address std.Address) (bool, bool) {\n\tvote, exists := p.Voters().Get(address.String())\n\tif exists {\n\t\treturn true, vote.(bool)\n\t}\n\treturn false, false\n}\n\n// VoteCount Returns the number of yay \u0026 nay votes\nfunc (p Poll) VoteCount() (int, int) {\n\tvar yay int\n\n\tp.Voters().Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tvote := value.(bool)\n\t\tif vote == true {\n\t\t\tyay = yay + 1\n\t\t}\n\t})\n\treturn yay, p.Voters().Size() - yay\n}\n// How to: Write Simple Dapp"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"uRYK9EvJNfNCNt9/wVUSL2r0INUpVky7cnN/GgIcOIVwLfj1pV6uua2+Uc2lvLcX/TTWsKua/5VS/8UH5S00gw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300848"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"poll","Path":"gno.land/r/leon/poll","Files":[{"Name":"package.gno","Body":"package poll\n\nimport (\n\t\"std\"\n\n\t// Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/leon/poll\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// state variables\nvar (\n\tpolls         *avl.Tree // id -\u003e Poll\n\tpollIDCounter seqid.ID\n)\n\nfunc init() {\n\tpolls = avl.NewTree()\n}\n\n// NewPoll - Creates a new Poll instance\nfunc NewPoll(title, description string, deadline int64) string {\n\t// get block height\n\tif deadline \u003c= std.GetHeight() {\n\t\tpanic(\"deadline has to be in the future\")\n\t}\n\n\t// Generate int\n\tid := pollIDCounter.Next().String()\n\tp := poll.NewPoll(title, description, deadline)\n\n\t// add new poll in avl tree\n\tpolls.Set(id, p)\n\n\treturn ufmt.Sprintf(\"Successfully created poll #%s!\", id)\n}\n\n// Vote - vote for a specific Poll\n// yes - true, no - false\nfunc Vote(id string, vote bool) string {\n\t// get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// get specific Poll from AVL tree\n\tpollRaw, exists := polls.Get(id)\n\n\tif !exists {\n\t\tpanic(\"poll with specified doesn't exist\")\n\t}\n\n\t// cast Poll into proper format\n\tpoll, _ := pollRaw.(*poll.Poll)\n\n\tvoted, _ := poll.HasVoted(txSender)\n\tif voted {\n\t\tpanic(\"you've already voted!\")\n\t}\n\n\tif poll.Deadline() \u003c= std.GetHeight() {\n\t\tpanic(\"voting for this poll is closed\")\n\t}\n\n\t// record vote\n\tpoll.Vote(txSender, vote)\n\n\t// update Poll in tree\n\tpolls.Set(id, poll)\n\n\tif vote == true {\n\t\treturn ufmt.Sprintf(\"Successfully voted YAY for poll #%s!\", id)\n\t}\n\treturn ufmt.Sprintf(\"Successfully voted NAY for poll #%s!\", id)\n}\n\nfunc Render(path string) string {\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Polls!\\n\\n\")\n\n\tif polls.Size() == 0 {\n\t\tb.WriteString(\"### No active polls currently!\")\n\t\treturn b.String()\n\t}\n\tpolls.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Poll struct\n\t\tp := value.(*poll.Poll)\n\t\tddl := p.Deadline()\n\n\t\tyay, nay := p.VoteCount()\n\t\tyayPercent := 0\n\t\tnayPercent := 0\n\n\t\tif yay+nay != 0 {\n\t\t\tyayPercent = yay * 100 / (yay + nay)\n\t\t\tnayPercent = nay * 100 / (yay + nay)\n\t\t}\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Poll #%s: %s\\n\",\n\t\t\t\tkey, // poll ID\n\t\t\t\tp.Title(),\n\t\t\t),\n\t\t)\n\n\t\tdropdown := \"\u003cdetails\u003e\\n\u003csummary\u003ePoll details\u003c/summary\u003e\u003cbr\u003e\"\n\n\t\tb.WriteString(dropdown + \"Description: \" + p.Description())\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eVoting until block: %d\u003cbr\u003eCurrent vote count: %d\",\n\t\t\t\tp.Deadline(),\n\t\t\t\tp.Voters().Size()),\n\t\t)\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eYAY votes: %d (%d%%)\", yay, yayPercent),\n\t\t)\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eNAY votes: %d (%d%%)\u003c/details\u003e\", nay, nayPercent),\n\t\t)\n\n\t\tdropdown = \"\u003cbr\u003e\u003cdetails\u003e\\n\u003csummary\u003eVote details\u003c/summary\u003e\"\n\t\tb.WriteString(dropdown)\n\n\t\tp.Voters().Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t\tvoter := key\n\t\t\tvote := value.(bool)\n\n\t\t\tif vote == true {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted YAY!\", voter),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted NAY!\", voter),\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\n\t\tb.WriteString(\"\u003c/details\u003e\\n\\n\")\n\t\treturn false\n\t})\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"azUrFlAHy/357NI6tUltG8NBcDKW0Sh+gx1Jmsb9YZw0AuWRSuyPnOlvkdkKND2nlmYj10WvNdhcehyuSJXP5g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300852"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"pollr","Path":"gno.land/r/leon/pollr","Files":[{"Name":"package.gno","Body":"package poll\n\nimport (\n\t\"std\"\n\n\t// Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/leon/poll\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// state variables\nvar (\n\tpolls         *avl.Tree // id -\u003e Poll\n\tpollIDCounter seqid.ID\n)\n\nfunc init() {\n\tpolls = avl.NewTree()\n}\n\n// NewPoll - Creates a new Poll instance\nfunc NewPoll(title, description string, deadline int64) string {\n\t// get block height\n\tif deadline \u003c= std.GetHeight() {\n\t\tpanic(\"deadline has to be in the future\")\n\t}\n\n\t// Generate int\n\tid := pollIDCounter.Next().String()\n\tp := poll.NewPoll(title, description, deadline)\n\n\t// add new poll in avl tree\n\tpolls.Set(id, p)\n\n\treturn ufmt.Sprintf(\"Successfully created poll #%s!\", id)\n}\n\n// Vote - vote for a specific Poll\n// yes - true, no - false\nfunc Vote(id string, vote bool) string {\n\t// get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// get specific Poll from AVL tree\n\tpollRaw, exists := polls.Get(id)\n\n\tif !exists {\n\t\tpanic(\"poll with specified doesn't exist\")\n\t}\n\n\t// cast Poll into proper format\n\tpoll, _ := pollRaw.(*poll.Poll)\n\n\tvoted, _ := poll.HasVoted(txSender)\n\tif voted {\n\t\tpanic(\"you've already voted!\")\n\t}\n\n\tif poll.Deadline() \u003c= std.GetHeight() {\n\t\tpanic(\"voting for this poll is closed\")\n\t}\n\n\t// record vote\n\tpoll.Vote(txSender, vote)\n\n\t// update Poll in tree\n\tpolls.Set(id, poll)\n\n\tif vote == true {\n\t\treturn ufmt.Sprintf(\"Successfully voted YAY for poll #%s!\", id)\n\t}\n\treturn ufmt.Sprintf(\"Successfully voted NAY for poll #%s!\", id)\n}\n\nfunc Render(path string) string {\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Polls!\\n\\n\")\n\n\tif polls.Size() == 0 {\n\t\tb.WriteString(\"### No active polls currently!\")\n\t\treturn b.String()\n\t}\n\tpolls.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Poll struct\n\t\tp := value.(*poll.Poll)\n\t\tddl := p.Deadline()\n\n\t\tyay, nay := p.VoteCount()\n\t\tyayPercent := 0\n\t\tnayPercent := 0\n\n\t\tif yay+nay != 0 {\n\t\t\tyayPercent = yay * 100 / (yay + nay)\n\t\t\tnayPercent = nay * 100 / (yay + nay)\n\t\t}\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Poll #%s: %s\\n\",\n\t\t\t\tkey, // poll ID\n\t\t\t\tp.Title(),\n\t\t\t),\n\t\t)\n\n\t\tdropdown := \"\u003cdetails\u003e\\n\u003csummary\u003ePoll details\u003c/summary\u003e\u003cbr\u003e\"\n\n\t\tb.WriteString(dropdown + \"Description: \" + p.Description())\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eVoting until block: %d\u003cbr\u003eCurrent vote count: %d\",\n\t\t\t\tp.Deadline(),\n\t\t\t\tp.Voters().Size()),\n\t\t)\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eYAY votes: %d (%d%%)\", yay, yayPercent),\n\t\t)\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eNAY votes: %d (%d%%)\u003c/details\u003e\", nay, nayPercent),\n\t\t)\n\n\t\tdropdown = \"\u003cbr\u003e\u003cdetails\u003e\\n\u003csummary\u003eVote details\u003c/summary\u003e\"\n\t\tb.WriteString(dropdown)\n\n\t\tp.Voters().Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t\tvoter := key\n\t\t\tvote := value.(bool)\n\n\t\t\tif vote == true {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted YAY!\", voter),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted NAY!\", voter),\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\n\t\tb.WriteString(\"\u003c/details\u003e\\n\\n\")\n\t\treturn false\n\t})\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"UTo1Qyetj5utXvPoQFiv5dR2FT6MHnjK/WFqqqHCB3QVrZXj9qvCAOGfzOx+e3whaXh9WzFTrjUCUUK/+Ri7TA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300854"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"pollr","Path":"gno.land/r/leon/pollr","Files":[{"Name":"package.gno","Body":"package pollr\n\nimport (\n\t\"std\"\n\n\t// Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/p/leon/poll\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// state variables\nvar (\n\tpolls         *avl.Tree // id -\u003e Poll\n\tpollIDCounter seqid.ID\n)\n\nfunc init() {\n\tpolls = avl.NewTree()\n}\n\n// NewPoll - Creates a new Poll instance\nfunc NewPoll(title, description string, deadline int64) string {\n\t// get block height\n\tif deadline \u003c= std.GetHeight() {\n\t\tpanic(\"deadline has to be in the future\")\n\t}\n\n\t// Generate int\n\tid := pollIDCounter.Next().String()\n\tp := poll.NewPoll(title, description, deadline)\n\n\t// add new poll in avl tree\n\tpolls.Set(id, p)\n\n\treturn ufmt.Sprintf(\"Successfully created poll #%s!\", id)\n}\n\n// Vote - vote for a specific Poll\n// yes - true, no - false\nfunc Vote(id string, vote bool) string {\n\t// get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// get specific Poll from AVL tree\n\tpollRaw, exists := polls.Get(id)\n\n\tif !exists {\n\t\tpanic(\"poll with specified doesn't exist\")\n\t}\n\n\t// cast Poll into proper format\n\tpoll, _ := pollRaw.(*poll.Poll)\n\n\tvoted, _ := poll.HasVoted(txSender)\n\tif voted {\n\t\tpanic(\"you've already voted!\")\n\t}\n\n\tif poll.Deadline() \u003c= std.GetHeight() {\n\t\tpanic(\"voting for this poll is closed\")\n\t}\n\n\t// record vote\n\tpoll.Vote(txSender, vote)\n\n\t// update Poll in tree\n\tpolls.Set(id, poll)\n\n\tif vote == true {\n\t\treturn ufmt.Sprintf(\"Successfully voted YAY for poll #%s!\", id)\n\t}\n\treturn ufmt.Sprintf(\"Successfully voted NAY for poll #%s!\", id)\n}\n\nfunc Render(path string) string {\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Polls!\\n\\n\")\n\n\tif polls.Size() == 0 {\n\t\tb.WriteString(\"### No active polls currently!\")\n\t\treturn b.String()\n\t}\n\tpolls.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Poll struct\n\t\tp := value.(*poll.Poll)\n\t\tddl := p.Deadline()\n\n\t\tyay, nay := p.VoteCount()\n\t\tyayPercent := 0\n\t\tnayPercent := 0\n\n\t\tif yay+nay != 0 {\n\t\t\tyayPercent = yay * 100 / (yay + nay)\n\t\t\tnayPercent = nay * 100 / (yay + nay)\n\t\t}\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Poll #%s: %s\\n\",\n\t\t\t\tkey, // poll ID\n\t\t\t\tp.Title(),\n\t\t\t),\n\t\t)\n\n\t\tdropdown := \"\u003cdetails\u003e\\n\u003csummary\u003ePoll details\u003c/summary\u003e\u003cbr\u003e\"\n\n\t\tb.WriteString(dropdown + \"Description: \" + p.Description())\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eVoting until block: %d\u003cbr\u003eCurrent vote count: %d\",\n\t\t\t\tp.Deadline(),\n\t\t\t\tp.Voters().Size()),\n\t\t)\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eYAY votes: %d (%d%%)\", yay, yayPercent),\n\t\t)\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eNAY votes: %d (%d%%)\u003c/details\u003e\", nay, nayPercent),\n\t\t)\n\n\t\tdropdown = \"\u003cbr\u003e\u003cdetails\u003e\\n\u003csummary\u003eVote details\u003c/summary\u003e\"\n\t\tb.WriteString(dropdown)\n\n\t\tp.Voters().Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t\tvoter := key\n\t\t\tvote := value.(bool)\n\n\t\t\tif vote == true {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted YAY!\", voter),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted NAY!\", voter),\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\n\t\tb.WriteString(\"\u003c/details\u003e\\n\\n\")\n\t\treturn false\n\t})\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"tJrLjryL2rcE23sqg7Nv4otPNvd1Xgf0BFMKWOzd5gc1ZNuy8hCPXWsSKS+aJetImHpbWyIa9DC/wGnwHN8Rzg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300856"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","package":{"Name":"pollr","Path":"gno.land/r/leon/pollr","Files":[{"Name":"package.gno","Body":"package pollr\n\nimport (\n\t\"std\"\n\n\t// Package found on gno.land/p/demo/avl on test3 is outdated.\n    // On the path below you can find the newest version of the package, matching the one found in the monorepo.\n    // Versioning for Gno packages is under development.\n\t\"gno.land/p/leon/avl\"\n\t\"gno.land/r/leon/poll\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// state variables\nvar (\n\tpolls         *avl.Tree // id -\u003e Poll\n\tpollIDCounter seqid.ID\n)\n\nfunc init() {\n\tpolls = avl.NewTree()\n}\n\n// NewPoll - Creates a new Poll instance\nfunc NewPoll(title, description string, deadline int64) string {\n\t// get block height\n\tif deadline \u003c= std.GetHeight() {\n\t\tpanic(\"deadline has to be in the future\")\n\t}\n\n\t// Generate int\n\tid := pollIDCounter.Next().String()\n\tp := poll.NewPoll(title, description, deadline)\n\n\t// add new poll in avl tree\n\tpolls.Set(id, p)\n\n\treturn ufmt.Sprintf(\"Successfully created poll #%s!\", id)\n}\n\n// Vote - vote for a specific Poll\n// yes - true, no - false\nfunc Vote(id string, vote bool) string {\n\t// get txSender\n\ttxSender := std.GetOrigCaller()\n\n\t// get specific Poll from AVL tree\n\tpollRaw, exists := polls.Get(id)\n\n\tif !exists {\n\t\tpanic(\"poll with specified doesn't exist\")\n\t}\n\n\t// cast Poll into proper format\n\tpoll, _ := pollRaw.(*poll.Poll)\n\n\tvoted, _ := poll.HasVoted(txSender)\n\tif voted {\n\t\tpanic(\"you've already voted!\")\n\t}\n\n\tif poll.Deadline() \u003c= std.GetHeight() {\n\t\tpanic(\"voting for this poll is closed\")\n\t}\n\n\t// record vote\n\tpoll.Vote(txSender, vote)\n\n\t// update Poll in tree\n\tpolls.Set(id, poll)\n\n\tif vote == true {\n\t\treturn ufmt.Sprintf(\"Successfully voted YAY for poll #%s!\", id)\n\t}\n\treturn ufmt.Sprintf(\"Successfully voted NAY for poll #%s!\", id)\n}\n\nfunc Render(path string) string {\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Polls!\\n\\n\")\n\n\tif polls.Size() == 0 {\n\t\tb.WriteString(\"### No active polls currently!\")\n\t\treturn b.String()\n\t}\n\tpolls.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Poll struct\n\t\tp := value.(*poll.Poll)\n\t\tddl := p.Deadline()\n\n\t\tyay, nay := p.VoteCount()\n\t\tyayPercent := 0\n\t\tnayPercent := 0\n\n\t\tif yay+nay != 0 {\n\t\t\tyayPercent = yay * 100 / (yay + nay)\n\t\t\tnayPercent = nay * 100 / (yay + nay)\n\t\t}\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Poll #%s: %s\\n\",\n\t\t\t\tkey, // poll ID\n\t\t\t\tp.Title(),\n\t\t\t),\n\t\t)\n\n\t\tdropdown := \"\u003cdetails\u003e\\n\u003csummary\u003ePoll details\u003c/summary\u003e\u003cbr\u003e\"\n\n\t\tb.WriteString(dropdown + \"Description: \" + p.Description())\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eVoting until block: %d\u003cbr\u003eCurrent vote count: %d\",\n\t\t\t\tp.Deadline(),\n\t\t\t\tp.Voters().Size()),\n\t\t)\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eYAY votes: %d (%d%%)\", yay, yayPercent),\n\t\t)\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eNAY votes: %d (%d%%)\u003c/details\u003e\", nay, nayPercent),\n\t\t)\n\n\t\tdropdown = \"\u003cbr\u003e\u003cdetails\u003e\\n\u003csummary\u003eVote details\u003c/summary\u003e\"\n\t\tb.WriteString(dropdown)\n\n\t\tp.Voters().Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t\tvoter := key\n\t\t\tvote := value.(bool)\n\n\t\t\tif vote == true {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted YAY!\", voter),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted NAY!\", voter),\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\n\t\tb.WriteString(\"\u003c/details\u003e\\n\\n\")\n\t\treturn false\n\t})\n\treturn b.String()\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"MdU/+0Gnqx2sSSnELqNcPV5NwFaNusmll2xQl1gEeHhMiCGsUE/paLq7loZTZTCjRrW49wkfLGxYWWw+Z1XeVg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"300858"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1wvjfeck8vu66v0vruj6y32v4qy9l9vjchzwzuy","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"1XK+RzLQRb2P8DgLwFiZ3FaOQ4nCCnH6NnHyJY3VJg5WaaQq/vK+FTrevI7p/jmNFarZRd76V/8tSLAf3YGRQQ=="}],"memo":""},"blockNum":"300927"}
