{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","package":{"Name":"gnosocial","Path":"gno.land/r/michelle22/gnosocial","Files":[{"Name":"gnosocial.gno","Body":"package gnosocial\r\n\r\nimport (\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"std\"\r\n\t\"strings\"\r\n\t\"time\"\r\n)\r\n\r\ntype Post struct {\r\n\tAuthor  std.Address\r\n\tContent string\r\n\tTime    time.Time\r\n}\r\n\r\ntype DirectMessage struct {\r\n\tSender   std.Address\r\n\tReceiver std.Address\r\n\tContent  string\r\n\tTime     time.Time\r\n}\r\n\r\nvar posts []Post\r\nvar directMessages []DirectMessage\r\n\r\n// ... (rest of the code)\r\n// Post your thoughts.\r\n//\r\n// Enter a post below, and then press the `Call` button.\r\n//\r\n// The post will be recorded along with your address for everyone else to read.\r\nfunc CreatePost(content string) {\r\n\tnewPost := Post{\r\n\t\tAuthor:  std.GetOrigCaller(),\r\n\t\tContent: content,\r\n\t\tTime:    time.Now(),\r\n\t}\r\n\tposts = append(posts, newPost)\r\n}\r\n\r\n// Talk with someone else! Enter their address, and the message that you want\r\n// to send to them below, and then press the `Call` button.\r\nfunc SendDirectMessage(receiver std.Address, content string) {\r\n\tnewDM := DirectMessage{\r\n\t\tSender:   std.GetOrigCaller(),\r\n\t\tReceiver: receiver,\r\n\t\tContent:  content,\r\n\t\tTime:     time.Now(),\r\n\t}\r\n\tdirectMessages = append(directMessages, newDM)\r\n}\r\n\r\n// Call this to see all of the current posts.\r\nfunc RenderPosts() string {\r\n\tvar output strings.Builder\r\n\toutput.WriteString(\"# All Posts\")\r\n\tfor _, post := range posts {\r\n\t\toutput.WriteString(ufmt.Sprintf(\"* %s @ %s: %s\", post.Time.String(), post.Author, post.Content))\r\n\t}\r\n\treturn output.String()\r\n}\r\n\r\n// Call this to see your messages.\r\nfunc RenderDMs() string {\r\n\tvar output strings.Builder\r\n\tcaller := std.GetOrigCaller()\r\n\r\n\tif caller == \"\" {\r\n\t\toutput.WriteString(\"* All Direct Messages\")\r\n\t} else {\r\n\t\toutput.WriteString(\"* Your Direct Messages\")\r\n\t}\r\n\r\n\tfor _, dm := range directMessages {\r\n\t\tif caller == \"\" || dm.Sender == caller || dm.Receiver == caller {\r\n\t\t\toutput.WriteString(ufmt.Sprintf(\"* From: %s to: %s @ %s: %s\", dm.Sender, dm.Receiver, dm.Time.String(), dm.Content))\r\n\t\t}\r\n\t}\r\n\treturn output.String()\r\n}\r\n\r\n// Calling Render() with `/posts` will return an HTML string with all of the current posts.\r\n// Calling Render() with `/dms` will return an HTML string with all of the current direct messages.\r\nfunc Render(path string) string {\r\n\tcommand := \"\"\r\n\tif idx := strings.Index(path, \"/\"); idx \u003e= 0 {\r\n\t\tcommand = path[idx+1:]\r\n\t}\r\n\r\n\tswitch command {\r\n\tcase \"posts\":\r\n\t\treturn RenderPosts()\r\n\tcase \"dms\":\r\n\t\treturn RenderDMs()\r\n\tdefault:\r\n\t\treturn \"Welcome to GnoSocial! Use /posts to view all posts or /dms to view your messages.\"\r\n\t}\r\n}\r\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"w4ut0NAgh2G+xcdZt/cBOeBROd3jyexWOy6zgLIhvew2xRdUsrz8jQi8zIwdCI2uFO3bvCq5bgYyV7M6q6t5hw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"475587"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1tgnfu08qu54xyew5296jy22e0fa24j0u4u9xk9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"orp4Ck1tEZQ9qNFCPHkCwik7roNegvqYP10YdmXYAMluC3JtkZ6VHicf0T2s7hynGb/prKJvNrGz598XggQhjg=="}],"memo":""},"blockNum":"476015"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1tgnfu08qu54xyew5296jy22e0fa24j0u4u9xk9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"8nwxUyYdq950krAoyfUxX3BEl6vJlqgFDMNI03s/YmcsW5G/efrm4rgxmyrmm7MzCpMOhsL2HS2+SENSWsu+Hw=="}],"memo":""},"blockNum":"476019"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1tgnfu08qu54xyew5296jy22e0fa24j0u4u9xk9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"xMUgHCrk4XXmUl6oSNih4YL6TwWa2vj8Gwd1ehvOFJ4GUfQ4gHFnWJmgKxW2fxyGyVDwLVJdf99VaOBn+ZWxfg=="}],"memo":""},"blockNum":"476021"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1tgnfu08qu54xyew5296jy22e0fa24j0u4u9xk9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"bT5jMIXDbpUGxIHvpIL9Pb2m2TGeoTIHuiJPS0b7GTQJTy0Y9orFRXTM87I6jFBkL9RytnZLYzMJmnG+scdXhg=="}],"memo":""},"blockNum":"476027"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g176py0kpfzcm0aghmyz06flyrepsvv422fmcgcc","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"pYVOYTQM7Avj7JGi5mFv0VLyFC7FG3ajeNXsXy92oNNIjW2WW5odqn3/yDJQ5W78HS5SBfDA93LxOyf1OKTL/Q=="}],"memo":""},"blockNum":"476151"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"hY7k5X/f4znDy3z31fCksChErhv++x2yGaknoFP8a+NYKB2vT1Bpa1y4GqANEeANIJNmiy2gbRRQWTHmNvu2tw=="}],"memo":""},"blockNum":"476173"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"dCQ6b3sIRvxk0/Mvt4iUWRs6b/UBXgUY3JckEOqlMwFIMOT8Wuu0hERQbMquY8zrWjJBLWhn22OLaG2q+eocCg=="}],"memo":""},"blockNum":"476181"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"M1zCTFz+GfDIfFrvHXnUKPJexNp9J2S37hu0V+rTcewMqmXZ/xAu83y2kbBB+U1lzEBPevFo+g1H8BfD39iIXg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476186"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/ez/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"jkCqri7IvOU8twZC2WMKxfEjUCqQL+iIqN4THmtCS2YN6hsnyxXDAwj7MTpkA038QaWGJCw31xz5MgLPz+ItUg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476188"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n  RegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"zeUw1lbmKzDzIAvECcXJjNocNXK8fwhouEw0HrnJ6MpE0/gnZiFU3M4eL3TYCNkb8rW2RYknOSs4bxsH2/6CJA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476190"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"hYFN0loUii6NDTAg06H0Jwsj5bBdHx91AuH6nhRgYrI9QJxUOxsZg1cJGHdLa7yx7IHK96P0DLB6O5mr4CzmQg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476194"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/test666/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"6y2Bb8BgM8+GgK2YItJBJwGfOsquBRefdMmozO6bEfJ4ZyoV9jhrTUuZ1kVWpsTFQzUb1OjvRKKXqkhPNKObwA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476198"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/test666/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"AL+COa+gE7e0Hok58KD16vBa0lMZswt+vL/nFu5L0qs2rRXkCFeO4XA7UvxwGrXC1lgvV16tpMiHfF88JWUQzw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476204"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g176py0kpfzcm0aghmyz06flyrepsvv422fmcgcc","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"UiLV1eNyGo9/Fzpkkg6D15au4cPiS+YkKpuBUpQpD/hcBYT3GHk6f5EtUwksVnCNxqRj/Xg1JQtWlpOTp93qzQ=="}],"memo":""},"blockNum":"476208"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"hello.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"},{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"49oV+bxfTv06bu5B9BUvhwGxtGHqoinDG7wvBB0kKbIlV8CVi2FZ3ibA6SEN5d/5H3+GnkYhZj7Nrh325sfJ9Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476210"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"hello.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"},{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"raffle.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"Cs608F7nuVWM/mw8TG5cymax9rLZBLJCPlg6PLcnZn5jGyl/2hu/usbvj7/pwCZcKneokNA+9vGwjfWetqDcOA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476212"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"hello","Path":"gno.land/r/gc24/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"raffle.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"q5McIO/Wl18GhoVbzNXEUkmp6+Xi8LwBs1WYhjwTee13YsciTtChENsNcyKM9Tgd1ZuIFS0CYs7DQF8SanX+uw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476214"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g176py0kpfzcm0aghmyz06flyrepsvv422fmcgcc","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"f5Qbs4wQR9TZ9EhvSZ3QG21j6JGvhYYGg3u2VcP2a5dCDISje1GEya/+sFaijmpFVRZ2xccms772q+K/xNBxGQ=="}],"memo":""},"blockNum":"476216"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"raffle.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"QCdjydWxTGhlq0NhxpEw6VBBL9SWFTfkECwSPuTPBe1CXHXt/ygpQB896CSka/tdcpmluDfBlzo9gfRA8atmRg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476218"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"raffle.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"+KrcPIDDWxwLRGzyrgbFLL8qE6bPGnuJNKnJ8zz4JhhvhtDiJjOXgi844oeKzeGzMX4r6oMc0ZND9wR9QcPUvQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476221"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"raffle.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"/QkGsQ33VYpHWG8Dhk6VXeQdPJfomAyvslka20ionkNXklsMr1apwugq62aP85wV4gf/4TOI+RicGBy5aA/Wug=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476223"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"raffle.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n\n\tRegisterCode(\"uUmQetH0c7\")\n\tRegisterUsername(\"edgarzapeka\")\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"E/MaMUyGOzJSVaMBYEp8pUxJgWy2LAxTt91DMHrzO68gXQmNOecTdEO+DEQQ+Xa7YjUimZHeygl46NVq2Go4xA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476226"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1l39m49fg30s9trgrcpf848vema5mfy2lt2texn","package":{"Name":"hello","Path":"gno.land/r/gc24/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AjoRGXLrlwqKw5I1ChZu4+RFwJ9J6+b+WlLRMuzNGlvD"},"signature":"8fMdixrElBg1W7HQGDk94Lr/M2zjj/RQ3aBL+Kq9MyJFsggE3w4tbUpItv0BPKFY3JfCnEiN/STa4yS00IPSUQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476230"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1vjzrzlckdk8n30ns32tz7qqw9dyzeagf7xtskp","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"24VcIjZrEhP/gNzvyWFFGXa6ZKwMidXYgvMEuNUql+sIST6WlGylLqGmf8uVeiqH0XgOb0VyaZpy2Y1Xokk/lw=="}],"memo":""},"blockNum":"476240"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"L70CzS8T7dKyJ/1Z8/IJFCYVMK5GvZQxXt3ZNjLmfvsxSsBaexEQNLRdjlxIWGpmMOqrWBqVFgIHw5aR4hPn8g=="}],"memo":""},"blockNum":"476263"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Hmso0PsrOk+azJJa1hifPhokbHCmyTxfXqGE2Ik7CrFtyOc6q4vATn4fzOp4DoYrpTwjgAuWaeYkEPZLZJ5o+g=="}],"memo":""},"blockNum":"476283"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"package.gno","Body":"package hello\n\nimport (\n    \"https://gno.land/r/gc24/raffle\"\n)\n\nfunc init() {\n  raffle.RegisterUsername(\"james-prysm\")\n}\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6eEE7NDGyiPlgKPe0V36gtE5KRzwleLF3PvAFYdoBkY"},"signature":"DPbBL5emNiX4hnPR0L1J0jHOesXR2agczUgzVBjOQOR1oW6oPZP56FTEBpeUrg1hCRq47nRxbpIQUNAwMfXK1Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476285"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n    \"https://gno.land/r/gc24/raffle\"\n)\n\nfunc init() {\n  raffle.RegisterUsername(\"james-prysm\")\n}\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6eEE7NDGyiPlgKPe0V36gtE5KRzwleLF3PvAFYdoBkY"},"signature":"GeH57VBox5O48+rwwV1zwhSMWCZzmcjdjgmVjOtDY78mcmEHKn/+BXtffk2F+/tuJ7j9ej5cWYSswoYBt/sJvg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476288"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nfunc init() {\n  RegisterUsername(\"james-prysm\")\n}\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6eEE7NDGyiPlgKPe0V36gtE5KRzwleLF3PvAFYdoBkY"},"signature":"p5piXBMBjUAawnjMx7Gpwb9cFc71EaWt+wn6kpaZ1dlxemuNujjfy2W2MzTTopAfoDN1s1tXhtD4ZfLLxkqdvg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476290"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EntryData is the main struct that contains all data on raffle entries\ntype EntryData struct {\n\ttxorigin   std.Address\n\tcaller     std.Realm\n\traffleCode string\n\tcodeHash   string\n\tghUsername string\n}\n\n// Top-level variables are automatically persisted to storage\nvar (\n\to                *ownable.Ownable    // admin of the raffle realm\n\tpartialEntries   []*EntryData        // keeps registered partialEntries\n\tcompleteEntries  []*EntryData        // keeps complete registrations: valid code + gh username\n\tcodeHashes       []string            // valid code hashes\n\tregisteredHashes map[string]struct{} // tracks if a code has been registered before\n\twinner1, winner2 *EntryData          // storing raffle winners\n\tnumReg           int\n\trandSource       *rand.Rand\n)\n\n// Nothing to see here, just some constants, move on :)\nconst (\n\tcodeLength = 10\n\tamtOfCodes = 300\n)\n\n// Hello! This is where you register your raffle code!\n// Calling RegisterCode is the first step for entering the raffle.\n// It allows you to register a specific raffle code and connect your address to it.\n// RegisterCode only be called via other code; you should figure out a way to do it.\nfunc RegisterCode(code string) string {\n\tif code == \"\" \u0026\u0026 len(code) != codeLength {\n\t\tpanic(\"invalid code: \" + code)\n\t}\n\n\tcaller := std.PrevRealm()     // save realm used to call\n\torigin := std.GetOrigCaller() // save deployer of realm\n\n\t// Deny non-code entries\n\tif caller.IsUser() {\n\t\tpanic(\"denied; can only be called from within code\")\n\t}\n\n\t// Get sha256 of code\n\thash := sha256.Sum256([]byte(code))\n\thashString := hex.EncodeToString(hash[:])\n\n\t// Check if code has already been registered\n\tif _, ok := registeredHashes[hashString]; ok {\n\t\tpanic(\"code already registered: \" + code)\n\t}\n\n\t// Check if the gopher has already registered another raffle code\n\tif originExists(origin) {\n\t\tpanic(\"you cannot register more than one code!\")\n\t}\n\n\t// Try to find the hash in the official hash list\n\tvar found bool\n\tfor _, ch := range codeHashes {\n\t\tif ch == hashString {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tpanic(\"specified code is not a valid raffle code: \" + code)\n\t}\n\n\tentry := \u0026EntryData{\n\t\ttxorigin:   origin,\n\t\tcaller:     caller,\n\t\traffleCode: code,\n\t\tcodeHash:   hashString,\n\t\tghUsername: \"\",\n\t}\n\n\t// Save to hash tracker\n\tregisteredHashes[hashString] = struct{}{}\n\n\t// Save raffle entry\n\tpartialEntries = append(partialEntries, entry)\n\n\treturn ufmt.Sprintf(\"Successfully registered raffle code!\\n%s\\nRegister your username to complete your raffle entry.\", entry.String())\n}\n\n// Somewhat similar to Go, init() executes upon deployment of your code.\n// Hint: maybe you can use init() in your code to execute RegisterCode() upon deployment via play.gno.land?\nfunc init() {\n\t// Set admin address\n\to = ownable.NewWithAddress(\"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5\")\n\n\tpartialEntries = make([]*EntryData, 0)\n\tcompleteEntries = make([]*EntryData, 0)\n\tregisteredHashes = make(map[string]struct{})\n\tcodeHashes = make([]string, 300)\n}\n\n// RegisterUsername registers a GitHub username to an already existing entry\n// Hint: you can call this function just like you did with RegisterCode(), or via gno.studio/connect :)\n// If you use Connect, make sure you're on the Portal Loop network, and you've navigated to the correct path!\nfunc RegisterUsername(username string) string {\n\tif username == \"\" {\n\t\tpanic(\"invalid username: \" + username)\n\t}\n\n\torigin := std.GetOrigCaller()\n\n\tfor _, entry := range partialEntries {\n\t\tif entry.txorigin == origin { // this will check if you're using the same address as when registering the raffle code ;)\n\t\t\tif entry.ghUsername != \"\" {\n\t\t\t\tpanic(\"you cannot register your username twice!\")\n\t\t\t}\n\n\t\t\tentry.ghUsername = username\n\t\t\tcompleteEntries = append(completeEntries, entry)\n\t\t\tnumReg += 1\n\t\t\treturn ufmt.Sprintf(\"successfully registered %s for address %s\", username, entry.txorigin)\n\t\t}\n\t}\n\n\tpanic(\"could not find entry for caller address; did you register your raffle code yet?\")\n}\n\n// Admin stuff\n\nfunc PickWinner1() string {\n\to.AssertCallerIsOwner()\n\twinner1 = pickWinner()\n\n\treturn winner1.ghUsername\n}\n\nfunc PickWinner2() string {\n\to.AssertCallerIsOwner()\n\twinner2 = pickWinner()\n\n\treturn winner2.ghUsername\n}\n\nfunc UploadCodeHashes(delimCodes string) {\n\to.AssertCallerIsOwner()\n\n\ttokens := strings.Split(delimCodes, \",\")\n\n\tif len(tokens) != amtOfCodes {\n\t\tpanic(ufmt.Sprintf(\"invalid amount of codes; wanted %d got %d\", amtOfCodes, len(tokens)))\n\t}\n\n\tcopy(codeHashes, tokens)\n}\n\nfunc UploadRandomness(x, y uint64) {\n\to.AssertCallerIsOwner()\n\n\trandSource = rand.New(rand.NewPCG(x, y))\n}\n\n// Rendering\n\nfunc Render(_ string) string {\n\toutput := \"# Raffle - GopherCon US 2024\\n\\n\"\n\n\toutput += renderStats()\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += renderWinners()\n\t}\n\n\toutput += RenderGuide()\n\n\treturn output\n}\n\nfunc renderStats() string {\n\toutput := \"\"\n\n\toutput += \"### Raffle Stats\\n\\n\"\n\n\toutput += `\u003cdiv class=\"columns-3\"\u003e`\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest codes\n\toutput += renderLatestCodesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest codes\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Latest usernames\n\toutput += renderLatestUsernamesWidget(5)\n\toutput += `\u003c/div\u003e` // close Latest usernames\n\n\toutput += `\u003cdiv class=\"column\"\u003e` // Chances\n\toutput += renderChances()\n\toutput += `\u003c/div\u003e` // close Chances\n\n\toutput += `\u003c/div\u003e` // close columns-3\n\n\toutput += \"\\n\\n\"\n\toutput += \"---\" // close section\n\n\toutput += \"\\n\"\n\n\treturn output\n}\n\nfunc renderChances() string {\n\toutput := \"\\n\\n#### Chances\\n\\n\"\n\n\toutput += ufmt.Sprintf(\"- Users in the raffle: %d\\n\\n\", numReg)\n\n\tif numReg \u003e 0 {\n\t\toutput += ufmt.Sprintf(\"- Chance of winning: 2:%d\\n\\n\", numReg)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestCodesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest codes\\n\\n\"\n\tpeNum := len(partialEntries)\n\n\tif peNum == 0 {\n\t\toutput += \"No codes registered yet.\"\n\t\treturn output\n\t}\n\n\tif peNum \u003c amt {\n\t\tamt = peNum\n\t}\n\n\tfor i := peNum - 1; i \u003e= peNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", partialEntries[i].raffleCode)\n\t}\n\n\treturn output\n}\n\nfunc renderLatestUsernamesWidget(amt int) string {\n\toutput := \"\\n\\n#### Latest usernames\\n\\n\"\n\tceNum := len(completeEntries)\n\n\tif winner1 != nil || winner2 != nil {\n\t\toutput += \"Winners are chosen!\"\n\t\treturn output\n\t}\n\n\tif ceNum == 0 {\n\t\toutput += \"No usernames registered yet.\"\n\t\treturn output\n\t}\n\n\tif ceNum \u003c amt {\n\t\tamt = ceNum\n\t}\n\n\tfor i := ceNum - 1; i \u003e= ceNum-amt; i-- {\n\t\toutput += ufmt.Sprintf(\"- `%s`\\n\\n\", completeEntries[i].ghUsername)\n\t}\n\n\treturn output\n}\n\nfunc renderWinners() string {\n\toutput := \"\\n\\n# Winners\\n\\n\"\n\n\tif winner1 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 1: `@%s`\\n\\n\", winner1.ghUsername)\n\t}\n\n\tif winner2 != nil {\n\t\toutput += ufmt.Sprintf(\"### Winner 2: `@%s`\\n\\n\", winner2.ghUsername)\n\t}\n\n\toutput += \"## Congratulations! Come to the booth and show us your GitHub account!\\n\\n\"\n\n\toutput += \"---\\n\\n\"\n\n\treturn output\n}\n\n// Helpers\n\nfunc (entry *EntryData) String() string {\n\treturn ufmt.Sprintf(\"Address: %s\\nRealm Path: %s\\nCode: %s\\nHash: %s\\nGitHub username: %s\\n\",\n\t\tentry.txorigin.String(),\n\t\tentry.caller.PkgPath(),\n\t\tentry.raffleCode,\n\t\tentry.codeHash,\n\t\tentry.ghUsername,\n\t)\n}\n\nfunc pickWinner() *EntryData {\n\tif len(completeEntries) == 0 {\n\t\tpanic(\"No complete entries yet!\")\n\t}\n\tif randSource == nil {\n\t\tpanic(\"No randomness source yet!\")\n\t}\n\n\tr := rand.New(randSource)\n\twinnerIndex := r.IntN(len(completeEntries))\n\twinner := completeEntries[winnerIndex]\n\n\t// remove winner from entry list\n\tcompleteEntries = append(completeEntries[:winnerIndex], completeEntries[winnerIndex+1:]...)\n\n\treturn winner\n}\n\nfunc CheckHashUpload() int {\n\treturn len(codeHashes)\n}\n\nfunc originExists(origin std.Address) bool {\n\tfor _, e := range partialEntries {\n\t\tif e.txorigin == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6eEE7NDGyiPlgKPe0V36gtE5KRzwleLF3PvAFYdoBkY"},"signature":"4jUOb9W+C77G+xjgi5L806VAF3g3pfq1c8Do2iFmi5gbBkh3XAhucTE7ouXSBDRmeh4Tcy+hXOcRakOBwsTZHg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476296"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"KWyqBEG26TeI4Sr4MY4puYk8BAtrbj55TFLaMaJIEOQzqJFhpei84LUuZ9pYpnH9RStP2qHpYxqQI78B1iXQAQ=="}],"memo":""},"blockNum":"476300"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","package":{"Name":"raffle","Path":"gno.land/r/gc24/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nfunc init() {\n RegisterCode(\"4QS2FT6hSu\")\n}\n\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6eEE7NDGyiPlgKPe0V36gtE5KRzwleLF3PvAFYdoBkY"},"signature":"KXYCoGN9cDmhvyQ/bN9A7Ifzf9/X25tHjj7bb202/JwK+hfxdmsQKsW58cluqDj7jz2ikZWFDJhh0aq0uK3TKw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476307"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"al2S8KSpXn1W1DQjt+2y7hLDmNR45LC1dhQ7vLy4lcxqtmbpM6GeXyfMDMntlomQZpT8Jlu9BVgkPnVxu79rdw=="}],"memo":""},"blockNum":"476311"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"pNB64bs/4PebgJV7vgdmKPZs4lIo5f2wtaApcTNnp79qIyvlPMEaRlTlWPIp7bNnoBHbmML2EUCOIxk1/baRSg=="}],"memo":""},"blockNum":"476313"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"UnpQRE31YJTXFJs4f2aInMXcVrQwyAGLKlCLh2I9z4VzUvwlIoMZgO4TbQUFnUdcy3Mmi6x9NZfCRGzYNzPKKw=="}],"memo":""},"blockNum":"476320"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"5gK4nHTltWp/lpm8pW9TttXjO660W1uJSdSeC9ykQ90xQKRfI7B9MC0J5S81brWmqhP2gRQQxTexTDpwIbvKdg=="}],"memo":""},"blockNum":"476325"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1z0nhhy5c85cn2eqhu7m67sv8dqw4aqpy5knp7p","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"hBgA+pdhM7iGT/ucB2U5fE8iTyy695EnuVVG+aVvhS4yBfXGsXa2PaT9kYUCnlFZdMeaZVfPmPdblSO8Rq7ymA=="}],"memo":""},"blockNum":"476327"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1c2e8d9pehttcge60zkwr5vfd5sxy8ss94mt7s0","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"h1+SULJ+6vYaiPAlr1fUkVxdAplix6n/zaDuMnWnaNtbY5e0gBBe1REDNEUBGzkk0I7R+sqvcUta0aqbEzCydw=="}],"memo":""},"blockNum":"476376"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1jdky3gfkpzg8zdgjsh6k45qdmwqjznqktqr73c","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"wAYrdSo5NQvemjt23ub7Lxu3RILclbIrHWdzZsOMWBtLKStTpRVF4H6CN0o4NZz7IF+4tq0Cc3vn8OcO/8Jz0Q=="}],"memo":""},"blockNum":"476382"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1jdky3gfkpzg8zdgjsh6k45qdmwqjznqktqr73c","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"jglzm3z7FJn01tUeoQsbFvXWTTi3lujDqcrE4RiCpEpbTshe23y/flzm0JnN5ZGrxcchRC64x1msiDDgerGTeg=="}],"memo":""},"blockNum":"476385"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1jdky3gfkpzg8zdgjsh6k45qdmwqjznqktqr73c","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"tGLXki17eqt2Tw6YQ+ogGU88CbR4I8w9fRI97pgK1N1k6GZewvrUMqudHl8YNr39/b+sReW+o/oooRSuTomJLQ=="}],"memo":""},"blockNum":"476388"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1jdky3gfkpzg8zdgjsh6k45qdmwqjznqktqr73c","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"blByCU4DfKciWmsODRyJ4mfkj7Hxr0i1yJbaeAMP/IA88OAfhUNV0LkJKrI+8l0wdeS+PqFwwLyNnw8w6nrskg=="}],"memo":""},"blockNum":"476392"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1jdky3gfkpzg8zdgjsh6k45qdmwqjznqktqr73c","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"c9M9LZKMPyoUmR7sj54EPQagxHitanPOmpg6E/jdKHYBf6SF4w2Mx7LEP2ONfBLs9kDUV5sY7m/LjJVWbU4/BA=="}],"memo":""},"blockNum":"476394"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1jdky3gfkpzg8zdgjsh6k45qdmwqjznqktqr73c","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Ks5Ght80tmK2k6KjYJfxQxoxMAdZjDez7azJk+qQ86QO1Gaz1O6igEzx0h/D6Bx9HXpxhRRB4+/9dzKJyHWf3Q=="}],"memo":""},"blockNum":"476396"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ly494qhk5ler6erzqp7rksv539g48w4dtjwwf","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Tiro03iXv23hSYMtuHhmWXxAD5d+tfeIodgjVtnVyW57tk9D3f3sBqTdpr2IdRdZfyGqa5Mn0oGXjVb/7/aZGg=="}],"memo":""},"blockNum":"476406"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ly494qhk5ler6erzqp7rksv539g48w4dtjwwf","package":{"Name":"raffle","Path":"gno.land/r/gc24/soypat/raffle","Files":[{"Name":"package.gno","Body":"package hello\n\nimport (\n  \"gno.land/r/gc24/raffle\"\n)\n\nconst (\n  code = \"CyH0GyhYsx\"\n  user = \"soypat\"  \n)\n\nfunc init() {\n  // keyboard's mine c:\n  raffle.RegisterCode(code)\n  raffle.RegisterUsername(user)\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A17z/bUHo9UC2xHoBmsyZ2rvfxtu5H4KIlFTgSzYGiHQ"},"signature":"zmcmBUadpg9R0Tv60UVua3/XXrX6ejvd+EJ4BofAZ/MtFDas1OF0lnEedQXsoc/44HG47guVbWR4S5n1FUvWjw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476408"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ly494qhk5ler6erzqp7rksv539g48w4dtjwwf","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"E+qL1rSpAZXRKsg1jKuvjNH1jH8u7X5Tt2YV3JUKEucmCZ24KbmL+8cIU3W64HrFTTgAMdiG5DDEjjaEvOZ1LA=="}],"memo":""},"blockNum":"476410"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15ly494qhk5ler6erzqp7rksv539g48w4dtjwwf","package":{"Name":"raffle","Path":"gno.land/r/gc24/soypat/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport (\n  \"gno.land/r/gc24/raffle\"\n)\n\nconst (\n  code = \"CyH0GyhYsx\"\n  user = \"soypat\"  \n)\n\nfunc init() {\n  // keyboard's mine c:\n  raffle.RegisterCode(code)\n  raffle.RegisterUsername(user)\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A17z/bUHo9UC2xHoBmsyZ2rvfxtu5H4KIlFTgSzYGiHQ"},"signature":"W65jzjn5mFkqf0s9Gn7wc7rWpaTOJODz8PTvNXjcKbEn+xnr9SotujMHkUsUQUaRppqJivRo5b0shatx9EP2YQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476412"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g15ly494qhk5ler6erzqp7rksv539g48w4dtjwwf","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"FIbudfn9eaYtCB4g2KR7Fk/gT04C94JSn0VxhoH0ObcykgFzbk64nn+Yph+A2wfsGf6AuJbTarx0f91VV81ZPw=="}],"memo":""},"blockNum":"476416"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1tgnfu08qu54xyew5296jy22e0fa24j0u4u9xk9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"YGqSv+hdAQs92R2HVXiyx5rqX+OMDktpKt7YBSfrwFYfhNqkc8LoldPy52T56O46MxaTfC+mQ9D2V+VZxJDO4Q=="}],"memo":""},"blockNum":"476434"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1lrnsh8vhpx043y0496gvaf0x5a4jug5r05qcan","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"w0hK9QhFDrR25SvQAVGw4evSKagGr+M2KsMGTUgHOPxaYNRfVvIhEHHzKpVHSZrtUgfHlUD69GgtI1XDkqrnig=="}],"memo":""},"blockNum":"476438"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1lrnsh8vhpx043y0496gvaf0x5a4jug5r05qcan","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"XT6uZdnfWg0gYqTULmFkNRooL1KjE/yqTQ9BULxSmVAGHo+DrM5d7N03JkXL1nv7xJPkTcc8QcEs1uD4JnPQrw=="}],"memo":""},"blockNum":"476443"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1lrnsh8vhpx043y0496gvaf0x5a4jug5r05qcan","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"fMX7TcPIo2ZkPb4EscGjuYfFIOXbiJ0MM9QMDlHsjRVPNIEXYgQlf5MM8zJpI4WGe0WxAWuwKiLekJYReyzPpQ=="}],"memo":""},"blockNum":"476447"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1lrnsh8vhpx043y0496gvaf0x5a4jug5r05qcan","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"D7mjUI2VOM+GGvnWAkHqdsBabi8tcUfQG1g7ITEZUY19QVbQHbORCmiQDzDIbQDyu1KJb7KRwe2HSyeBmnguhw=="}],"memo":""},"blockNum":"476449"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1lrnsh8vhpx043y0496gvaf0x5a4jug5r05qcan","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"3eR9W1XPi1jeL5Jj3QsVbIBrdo6qF7sW4Zu/RmdBaX1gRodJxmYggTaXEiUcmrXmVg42wzj6CeHinQH2lM7Vog=="}],"memo":""},"blockNum":"476451"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1lrnsh8vhpx043y0496gvaf0x5a4jug5r05qcan","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"6nfp5mOPCL124fIfdmKtiGD8zbCb0FOumZzT3QUa4yRvggVB0bcYIfjd/IipTrMWf7ksCegdLkD/7aoyxA24jw=="}],"memo":""},"blockNum":"476454"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1lrnsh8vhpx043y0496gvaf0x5a4jug5r05qcan","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"VT3pI0rc2ouvAT2KP+j6fTfFN6/Vt0kQ4RGEKk6qBTJ8bhmrremdSVALHx3klAbNMonXR1NMFYDm1g09MGI3Kw=="}],"memo":""},"blockNum":"476456"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1lrnsh8vhpx043y0496gvaf0x5a4jug5r05qcan","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"R+rdseI5u89pE4niBmtOu7gvunL1rNQk8r6Xa5h2CtBa6V8Z0iP64Psxb5S/NcNjH3H47nOMchHX70Yb16jntg=="}],"memo":""},"blockNum":"476458"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1c2e8d9pehttcge60zkwr5vfd5sxy8ss94mt7s0","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"4NwyALnaWaQqsN1GciCdz/SL42nD7b260Cq3wzvfQ5wIl1KF/kW88YNsh8LmHnJJEVpBZj1ey1AjsyqN7otuDA=="}],"memo":""},"blockNum":"476484"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1c2e8d9pehttcge60zkwr5vfd5sxy8ss94mt7s0","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"meLKpzjLxnziI+1odGDvHkx5eIMMR1XvW9CijhKMRehc1b+7/5GeH7crFcwXjbhSa4gw90/GAvDbNGt928nnRg=="}],"memo":""},"blockNum":"476486"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1c2e8d9pehttcge60zkwr5vfd5sxy8ss94mt7s0","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"yCjB56QYrpuC3fGeYmImZpj71iE6K8e4SXxJS05caWNTESAZmeHqVAY1E/9VvJ6GMZqLTp9ARa89rRFyOizoMg=="}],"memo":""},"blockNum":"476488"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1c2e8d9pehttcge60zkwr5vfd5sxy8ss94mt7s0","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"Wj/GCRWeXnJAVjoR3jlTmqBnAhs5cRFLuVIYlWsNGDNVG29OsZ8AKOzUZF+6nw5kGG+PxUs2gNaPUL1CMaG2ng=="}],"memo":""},"blockNum":"476490"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1c2e8d9pehttcge60zkwr5vfd5sxy8ss94mt7s0","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"70SC2iOYwrx/VOZL2H1kvVRkJ++8oRQ6ahxZyb/u7WcUlOKObsWfaWxMmLGKaTwlPnRgYDyiSdS1yAAEm/BKxQ=="}],"memo":""},"blockNum":"476496"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1c2e8d9pehttcge60zkwr5vfd5sxy8ss94mt7s0","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"i14G62nViTQjDkaGVfYrULyD1vJLfXLO/h7ATseoWBxrzSFDm255O0YmI50yHRC0fWqFR+kzrXh4jhQQlsASZA=="}],"memo":""},"blockNum":"476498"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1dqkzgdmnueeleduhfs29tlrac2uzqdplt65qxn","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"fSqk+7vX4R1/2GvChvV+z9ddRchO8c98Cyaa1kcFIKQil5tvlUzICOiasxvB9MbfTM+rcvEHLgEiZXKT+BZArw=="}],"memo":""},"blockNum":"476521"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1arpyfgln4nn360x0y27andyvec7kz9ylyzwyss","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"vwz3GLJuBBSv9bqz5yZX/masp+My6KlSKP8O+DObcp01u+rK/F+F3JMSpZ4hpWUmhGoMCzgii8Zer9dVUK+GJA=="}],"memo":""},"blockNum":"476539"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1dqkzgdmnueeleduhfs29tlrac2uzqdplt65qxn","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"H+q8xNII+cYMRpkXs3T0tut+l/Atm6RwnHjtuIqME39FWaPRTcrGUTGbZrI159fnrLE3bUh3yrS1ymll8QvF+Q=="}],"memo":""},"blockNum":"476544"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dqkzgdmnueeleduhfs29tlrac2uzqdplt65qxn","package":{"Name":"raffle","Path":"gno.land/r/vershun/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nvar output string\n\nfunc init() {\n  output += RegisterCode(\"N2GpwjdQbp\")\n  output += RegisterUsername(\"vershun\")\n}\n\nfunc Render(path string) string {\n  return output\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Azv5CWC8iMFcUIBftvgjx06Ix2TPLsFOH4xCsvDvT/rf"},"signature":"V7FoQEtsrXGATOUiYih5SOcueDSJk1oqT4XijGnxGUlI4otmpN9UZvmiCEC8no5Q1j70fX6iHT1Q1/EwjkOagA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476546"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"9KwZhWZLhUEMiXPIlqTpg8adPZ8lJ5jPylyQha3wHWx1RVYJLiqt+6ICqcX1f4Zh1khgV3voTKcGv9+zCo+RSw=="}],"memo":""},"blockNum":"476549"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","to_address":"g1kpptltmd8jmwq5et5udh3ld8qq4ksqm9kj0vs4","amount":"5000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"vLK5b+naR8YjsBZFoKazUKBPA/NwRTMrPbIL6o0de+Y+CS1gWMz2ri7I0UOwr8u1NblYQNJ55qmayseMh3cgHQ=="}],"memo":""},"blockNum":"476551"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dqkzgdmnueeleduhfs29tlrac2uzqdplt65qxn","package":{"Name":"raffle","Path":"gno.land/r/vershun/raffle","Files":[{"Name":"package.gno","Body":"package raffle\n\nimport \"gno.land/r/gc24/raffle\"\n\nvar output string\n\nfunc init() {\n  output += raffle.RegisterCode(\"N2GpwjdQbp\")\n  output += raffle.RegisterUsername(\"vershun\")\n}\n\nfunc Render(path string) string {\n  return output\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Azv5CWC8iMFcUIBftvgjx06Ix2TPLsFOH4xCsvDvT/rf"},"signature":"vlDescjw41dOTxWiJlQMs5GMfcRojeWCGXno/Iw4788oPTJnMNWT8mWbbQ+K+Hq74GLHdBRQKNht1gZbALL32Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"476554"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1dqkzgdmnueeleduhfs29tlrac2uzqdplt65qxn","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"y6450fKluXbWIr4fnQtHpUmIHmRP94JyyrVX/o00iF8pChW7e3JOVPXic87vILqJqCVXWP+qcNZBYH8gcnZLdg=="}],"memo":""},"blockNum":"476559"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1dqkzgdmnueeleduhfs29tlrac2uzqdplt65qxn","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"clIHtTmy/wiPxEpkp+jgT15dAnj+Sedwjsbde6J8FlMG6uF7DC2oaCo7jY5zZJu9McNoM0uaU0KrogvXlXLNXA=="}],"memo":""},"blockNum":"476561"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1arpyfgln4nn360x0y27andyvec7kz9ylyzwyss","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"WbQJ96+XDdnUyhzTM1E13WHF0eth1teFpkYUBxoIqgYY0Yrr3Y47K8GLNYN0MdOsUmV7mBMIUM1G/ElYc+nrow=="}],"memo":""},"blockNum":"476567"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1arpyfgln4nn360x0y27andyvec7kz9ylyzwyss","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"t9THVdVOeDR0Bxcdo0mhZGn4zCC215eNn3ww0vvbouAjCOmuT11mJOKBhKWePK2e9MBPTPJ8PdRUSJV9A1WPoA=="}],"memo":""},"blockNum":"476569"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1arpyfgln4nn360x0y27andyvec7kz9ylyzwyss","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"lwT76YzebMWIezPHVRYcfiQ00lVJsLarupfUDt1cKo0jioFh1/ywXJt59zlvFI5UZPhRrQTiKX2ILYkSoUI6Ug=="}],"memo":""},"blockNum":"476571"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1arpyfgln4nn360x0y27andyvec7kz9ylyzwyss","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"IBNv4sWPUMRVMMWZ6crVHB8gs/xXW7+ZDzmlcMmSu9toi46PRqf+VsXMKoYj/2PLaPgotcZhV8BxKa03Im3YsQ=="}],"memo":""},"blockNum":"476573"}
