{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"AdvanceProposals","args":null}],"fee":{"gas_wanted":"11000000","gas_fee":"1200000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"0FBG1Zugyi+dWVoSVmWHxocrXLyKWKYFH7mBJ7yaKVIIsXktsrb+9fdVBsvmArOOWjvH+zvvbY6nZY7dKyQpbw=="}],"memo":""},"metadata":{"timestamp":"1734513828"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"AdvanceProposals","args":null}],"fee":{"gas_wanted":"12000000","gas_fee":"1200000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"a2EZg4ui4CNPD5GKXzPte97hVkKeOOUkR7z1aUKUVYphFxGgOPyR3wImFBDe+VwtM7qu0SGOof7Uej/SZQKo4w=="}],"memo":""},"metadata":{"timestamp":"1734513858"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"AdvanceProposals","args":null}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"PF5O9ZLN52uPVDnG2ff0Lfi/F8XENGfbkEmybZ4GoxgyDr5ikhhzQI6B0omaAzfvnpQ8NgDSMeS6AZfd9Xd5/A=="}],"memo":""},"metadata":{"timestamp":"1734514135"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"3IC1C6RVTddFqcHQ9Gtx+3KYyx/GuMY82tC2JZPJhi8rrevzrKKhU+bXffcEsL6EvP/J+ZW4Bcqmw2juujPKRg=="}],"memo":""},"metadata":{"timestamp":"1734523771"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"KkPFi8XiwYKiVVEpMBLY9iQ+KvYOTrsS8sKSRreYl7sbTlb48p60gBDlkCsFtQQIhZmA3T4hB5UkhAK2YKQ/Vw=="}],"memo":""},"metadata":{"timestamp":"1734523786"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/space/v1rc1","func":"CreateNews","args":["Blockchain Testnet Launched: Test4 Now Live","https://gno.land/r/gnoland/blog:p/test4-live","gno.land blog, testnets"]}],"fee":{"gas_wanted":"10000000","gas_fee":"9783795ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"ubq+Vy1c+fbxsJGQRZYCbmhWI04rxBAT/PmI6PC3qyFO5wKTfjqMGx15XWBdqwKY4B/qAfn9CSLYVh4usEQpYQ=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734523851"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/space/v1rc1","func":"SubmitEditorsModificationProposal","args":["Add news editors","A proposal to add two new editors to the News section on Space","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5 (ecodev)\ng1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun (Dev)\ng125t352u4pmdrr57emc4pe04y40sknr5ztng5mt (devrel)",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"9783795ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"AHTokKPnqbYmhxSiLbVqQiksnEY10xIfombmsfw7syVkenGUtWF4Ck+InKu7pYQ81BODK3alRDTrF/qbt5kiAw=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734524600"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"LSLSBQ04HZvaWBJP/qlVhsN4UUAzcNRFiQ2/0JnH+2Anns+SLUpa/6uk9nIMESEXblnd+THlC1kjvt2kQSFH1g=="}],"memo":""},"metadata":{"timestamp":"1734620332"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1qsfyuwvcxxlduzzp4nts8u7cjw9y2r0d32ynrv","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"MXZnTR7lDozdrTJHWrm1tOQpBrcSVOZuOh4ucELyj3tdxHml/Uh014LlPOxZB5ccfJGiOD8zGOAwnl/BIH3Gbg=="}],"memo":""},"metadata":{"timestamp":"1734563331"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"6geFQkysBYFCAGMmeg3wQOepvOAjco7uDV2fR2qI4yoIXoPMveR5dPDEsyIbuk6njD9UMSQgZG/FhM6WEseokA=="}],"memo":""},"metadata":{"timestamp":"1734574117"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1xnvftgfz9atd7uw2wfvtlmnvyxdps8hlf3whtp","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"ZezWXdCdm6K91yi+bvt6iA3ZFkLO6eCVO4EfTFFp5BJXiGBfRONJ7hjXPmyV88Sgn/+eQsi4ZsPKOaEg+OEy/w=="}],"memo":""},"metadata":{"timestamp":"1734563316"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g14kdg0zn97xms3eza5xh6lcycmwm4zjksg4peum","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"HLzC3RfgchnE637AqSXa89NnjO30HFKRL5zhjWKAUCUuR4IJFj1oE47kY1jm4IfJpWGbj1gJR1N0Iibip68JTw=="}],"memo":""},"metadata":{"timestamp":"1734560213"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g14v5etks3h4sma95sksf9pczyfcmce70pet9f6q","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"3azR4Z/bOOcVmzoTNc2sJW9BKrgNSPP4aIu7YSiNG/gL2UUbSou7nw3KiwOPt7BUcJ6NcSZN4DBOgamNYwPcCg=="}],"memo":""},"metadata":{"timestamp":"1734579078"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"3IC1C6RVTddFqcHQ9Gtx+3KYyx/GuMY82tC2JZPJhi8rrevzrKKhU+bXffcEsL6EvP/J+ZW4Bcqmw2juujPKRg=="}],"memo":""},"metadata":{"timestamp":"1734531839"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"KkPFi8XiwYKiVVEpMBLY9iQ+KvYOTrsS8sKSRreYl7sbTlb48p60gBDlkCsFtQQIhZmA3T4hB5UkhAK2YKQ/Vw=="}],"memo":""},"metadata":{"timestamp":"1734531854"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"XEYUqFao4GQnXcU3ZR1YxfYwTeKuYCdkr7H4haVtaegWuEn9PJhDDQZpTH0LDFcDweafB5Lcq/qGJxJINg7N4Q=="}],"memo":""},"metadata":{"timestamp":"1734531874"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"fBYdIZyMvx0Wfc0RWxmDuNOqloZWy1m3zI8ctNoUFiBvZr81jDi03QRBszUwLVnlpDUllnPLRya8MVa+kMflJA=="}],"memo":""},"metadata":{"timestamp":"1734533295"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"gP9hw2xuhhIk/2aa93QheJqoEr8r9gn1mcgXL0PlDMsCQjoLQ3PJzbnfGqEV9eK1GpRfidGlbFxFlp+XbZwADw=="}],"memo":""},"metadata":{"timestamp":"1734533275"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"2rmsEXC14gD6Zw1UI94awgNr+Y21MUqm+8Z6gnyTles/1YpBBfgB+FRVZXbELy/xrBCiDOx8wzR4vjtyFLEKxg=="}],"memo":""},"metadata":{"timestamp":"1734620172"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"2z13fgD91xTinH5YUirwe+ZA++D99ZZWSWaIcddr/8kGCaXJMFUYpbx1sGPCOnW9yAylsh4AUeaJfo7PrnYjSQ=="}],"memo":""},"metadata":{"timestamp":"1734620292"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"9wB+RzAJSRmVFZXa3dGN4lROMBwVsS6vDJHy5XRH1ABj22Mhs++C7dl/yJRBUqehUB1mWkA19w65NeU6hpRgdQ=="}],"memo":""},"metadata":{"timestamp":"1734624861"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"NkCaT6r7ojwjPtcFYBq0RpyliLAfCjokRcTnVQDuRkIy1OLgonz3UFxYyOljYDVPRyDDkxa/ReCvAV1KaE4r8g=="}],"memo":""},"metadata":{"timestamp":"1734619820"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"Y/5aFYWe8g7JM480F0hy1pfgNwao4iutfKsv63ZuGL04BD56HfyU7dO/Eb8oCl1ryLHYy3zpdmpq4Ai0GFYXeQ=="}],"memo":""},"metadata":{"timestamp":"1734620312"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"eM3Cl9tzcXnb+yNNaR00LIQOv3ph3mYj+Y0IT0jQZIBJMV+UdPZAI+yOyqTgleITZPKIGTTYVvndTUHIehM0tw=="}],"memo":""},"metadata":{"timestamp":"1734619805"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"o59NEEif1/QF0kSLDR9qG0XlVycMtzlRhStg89G5Bbt9Pwcvfq8GvGt9hV5dOZr8U29aVaGNjMDV3cBOOs3Pfw=="}],"memo":""},"metadata":{"timestamp":"1734620327"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"avl","path":"gno.land/p/demo/avl","files":[{"name":"node.gno","body":"package avl\n\n//----------------------------------------\n// Node\n\n// Node represents a node in an AVL tree.\ntype Node struct {\n\tkey       string      // key is the unique identifier for the node.\n\tvalue     interface{} // value is the data stored in the node.\n\theight    int8        // height is the height of the node in the tree.\n\tsize      int         // size is the number of nodes in the subtree rooted at this node.\n\tleftNode  *Node       // leftNode is the left child of the node.\n\trightNode *Node       // rightNode is the right child of the node.\n}\n\n// NewNode creates a new node with the given key and value.\nfunc NewNode(key string, value interface{}) *Node {\n\treturn \u0026Node{\n\t\tkey:    key,\n\t\tvalue:  value,\n\t\theight: 0,\n\t\tsize:   1,\n\t}\n}\n\n// Size returns the size of the subtree rooted at the node.\nfunc (node *Node) Size() int {\n\tif node == nil {\n\t\treturn 0\n\t}\n\treturn node.size\n}\n\n// IsLeaf checks if the node is a leaf node (has no children).\nfunc (node *Node) IsLeaf() bool {\n\treturn node.height == 0\n}\n\n// Key returns the key of the node.\nfunc (node *Node) Key() string {\n\treturn node.key\n}\n\n// Value returns the value of the node.\nfunc (node *Node) Value() interface{} {\n\treturn node.value\n}\n\n// _copy creates a copy of the node (excluding value).\nfunc (node *Node) _copy() *Node {\n\tif node.height == 0 {\n\t\tpanic(\"Why are you copying a value node?\")\n\t}\n\treturn \u0026Node{\n\t\tkey:       node.key,\n\t\theight:    node.height,\n\t\tsize:      node.size,\n\t\tleftNode:  node.leftNode,\n\t\trightNode: node.rightNode,\n\t}\n}\n\n// Has checks if a node with the given key exists in the subtree rooted at the node.\nfunc (node *Node) Has(key string) (has bool) {\n\tif node == nil {\n\t\treturn false\n\t}\n\tif node.key == key {\n\t\treturn true\n\t}\n\tif node.height == 0 {\n\t\treturn false\n\t}\n\tif key \u003c node.key {\n\t\treturn node.getLeftNode().Has(key)\n\t}\n\treturn node.getRightNode().Has(key)\n}\n\n// Get searches for a node with the given key in the subtree rooted at the node\n// and returns its index, value, and whether it exists.\nfunc (node *Node) Get(key string) (index int, value interface{}, exists bool) {\n\tif node == nil {\n\t\treturn 0, nil, false\n\t}\n\n\tif node.height == 0 {\n\t\tif node.key == key {\n\t\t\treturn 0, node.value, true\n\t\t}\n\t\tif node.key \u003c key {\n\t\t\treturn 1, nil, false\n\t\t}\n\t\treturn 0, nil, false\n\t}\n\n\tif key \u003c node.key {\n\t\treturn node.getLeftNode().Get(key)\n\t}\n\n\trightNode := node.getRightNode()\n\tindex, value, exists = rightNode.Get(key)\n\tindex += node.size - rightNode.size\n\treturn index, value, exists\n}\n\n// GetByIndex retrieves the key-value pair of the node at the given index\n// in the subtree rooted at the node.\nfunc (node *Node) GetByIndex(index int) (key string, value interface{}) {\n\tif node.height == 0 {\n\t\tif index == 0 {\n\t\t\treturn node.key, node.value\n\t\t}\n\t\tpanic(\"GetByIndex asked for invalid index\")\n\t}\n\t// TODO: could improve this by storing the sizes\n\tleftNode := node.getLeftNode()\n\tif index \u003c leftNode.size {\n\t\treturn leftNode.GetByIndex(index)\n\t}\n\treturn node.getRightNode().GetByIndex(index - leftNode.size)\n}\n\n// Set inserts a new node with the given key-value pair into the subtree rooted at the node,\n// and returns the new root of the subtree and whether an existing node was updated.\n//\n// XXX consider a better way to do this... perhaps split Node from Node.\nfunc (node *Node) Set(key string, value interface{}) (newSelf *Node, updated bool) {\n\tif node == nil {\n\t\treturn NewNode(key, value), false\n\t}\n\n\tif node.height == 0 {\n\t\treturn node.setLeaf(key, value)\n\t}\n\n\tnode = node._copy()\n\tif key \u003c node.key {\n\t\tnode.leftNode, updated = node.getLeftNode().Set(key, value)\n\t} else {\n\t\tnode.rightNode, updated = node.getRightNode().Set(key, value)\n\t}\n\n\tif updated {\n\t\treturn node, updated\n\t}\n\n\tnode.calcHeightAndSize()\n\treturn node.balance(), updated\n}\n\n// setLeaf inserts a new leaf node with the given key-value pair into the subtree rooted at the node,\n// and returns the new root of the subtree and whether an existing node was updated.\nfunc (node *Node) setLeaf(key string, value interface{}) (newSelf *Node, updated bool) {\n\tif key == node.key {\n\t\treturn NewNode(key, value), true\n\t}\n\n\tif key \u003c node.key {\n\t\treturn \u0026Node{\n\t\t\tkey:       node.key,\n\t\t\theight:    1,\n\t\t\tsize:      2,\n\t\t\tleftNode:  NewNode(key, value),\n\t\t\trightNode: node,\n\t\t}, false\n\t}\n\n\treturn \u0026Node{\n\t\tkey:       key,\n\t\theight:    1,\n\t\tsize:      2,\n\t\tleftNode:  node,\n\t\trightNode: NewNode(key, value),\n\t}, false\n}\n\n// Remove deletes the node with the given key from the subtree rooted at the node.\n// returns the new root of the subtree, the new leftmost leaf key (if changed),\n// the removed value and the removal was successful.\nfunc (node *Node) Remove(key string) (\n\tnewNode *Node, newKey string, value interface{}, removed bool,\n) {\n\tif node == nil {\n\t\treturn nil, \"\", nil, false\n\t}\n\tif node.height == 0 {\n\t\tif key == node.key {\n\t\t\treturn nil, \"\", node.value, true\n\t\t}\n\t\treturn node, \"\", nil, false\n\t}\n\tif key \u003c node.key {\n\t\tvar newLeftNode *Node\n\t\tnewLeftNode, newKey, value, removed = node.getLeftNode().Remove(key)\n\t\tif !removed {\n\t\t\treturn node, \"\", value, false\n\t\t}\n\t\tif newLeftNode == nil { // left node held value, was removed\n\t\t\treturn node.rightNode, node.key, value, true\n\t\t}\n\t\tnode = node._copy()\n\t\tnode.leftNode = newLeftNode\n\t\tnode.calcHeightAndSize()\n\t\tnode = node.balance()\n\t\treturn node, newKey, value, true\n\t}\n\n\tvar newRightNode *Node\n\tnewRightNode, newKey, value, removed = node.getRightNode().Remove(key)\n\tif !removed {\n\t\treturn node, \"\", value, false\n\t}\n\tif newRightNode == nil { // right node held value, was removed\n\t\treturn node.leftNode, \"\", value, true\n\t}\n\tnode = node._copy()\n\tnode.rightNode = newRightNode\n\tif newKey != \"\" {\n\t\tnode.key = newKey\n\t}\n\tnode.calcHeightAndSize()\n\tnode = node.balance()\n\treturn node, \"\", value, true\n}\n\n// getLeftNode returns the left child of the node.\nfunc (node *Node) getLeftNode() *Node {\n\treturn node.leftNode\n}\n\n// getRightNode returns the right child of the node.\nfunc (node *Node) getRightNode() *Node {\n\treturn node.rightNode\n}\n\n// rotateRight performs a right rotation on the node and returns the new root.\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateRight() *Node {\n\tnode = node._copy()\n\tl := node.getLeftNode()\n\t_l := l._copy()\n\n\t_lrCached := _l.rightNode\n\t_l.rightNode = node\n\tnode.leftNode = _lrCached\n\n\tnode.calcHeightAndSize()\n\t_l.calcHeightAndSize()\n\n\treturn _l\n}\n\n// rotateLeft performs a left rotation on the node and returns the new root.\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateLeft() *Node {\n\tnode = node._copy()\n\tr := node.getRightNode()\n\t_r := r._copy()\n\n\t_rlCached := _r.leftNode\n\t_r.leftNode = node\n\tnode.rightNode = _rlCached\n\n\tnode.calcHeightAndSize()\n\t_r.calcHeightAndSize()\n\n\treturn _r\n}\n\n// calcHeightAndSize updates the height and size of the node based on its children.\n// NOTE: mutates height and size\nfunc (node *Node) calcHeightAndSize() {\n\tnode.height = maxInt8(node.getLeftNode().height, node.getRightNode().height) + 1\n\tnode.size = node.getLeftNode().size + node.getRightNode().size\n}\n\n// calcBalance calculates the balance factor of the node.\nfunc (node *Node) calcBalance() int {\n\treturn int(node.getLeftNode().height) - int(node.getRightNode().height)\n}\n\n// balance balances the subtree rooted at the node and returns the new root.\n// NOTE: assumes that node can be modified\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) balance() (newSelf *Node) {\n\tbalance := node.calcBalance()\n\tif balance \u003e= -1 {\n\t\treturn node\n\t}\n\tif balance \u003e 1 {\n\t\tif node.getLeftNode().calcBalance() \u003e= 0 {\n\t\t\t// Left Left Case\n\t\t\treturn node.rotateRight()\n\t\t}\n\t\t// Left Right Case\n\t\tleft := node.getLeftNode()\n\t\tnode.leftNode = left.rotateLeft()\n\t\treturn node.rotateRight()\n\t}\n\n\tif node.getRightNode().calcBalance() \u003c= 0 {\n\t\t// Right Right Case\n\t\treturn node.rotateLeft()\n\t}\n\n\t// Right Left Case\n\tright := node.getRightNode()\n\tnode.rightNode = right.rotateRight()\n\treturn node.rotateLeft()\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) Iterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, true, true, cb)\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) ReverseIterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, false, true, cb)\n}\n\n// TraverseInRange traverses all nodes, including inner nodes.\n// Start is inclusive and end is exclusive when ascending,\n// Start and end are inclusive when descending.\n// Empty start and empty end denote no start and no end.\n// If leavesOnly is true, only visit leaf nodes.\n// NOTE: To simulate an exclusive reverse traversal,\n// just append 0x00 to start.\nfunc (node *Node) TraverseInRange(start, end string, ascending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\tafterStart := (start == \"\" || start \u003c node.key)\n\tstartOrAfter := (start == \"\" || start \u003c= node.key)\n\tbeforeEnd := false\n\tif ascending {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c end)\n\t} else {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c= end)\n\t}\n\n\t// Run callback per inner/leaf node.\n\tstop := false\n\tif (!node.IsLeaf() \u0026\u0026 !leavesOnly) ||\n\t\t(node.IsLeaf() \u0026\u0026 startOrAfter \u0026\u0026 beforeEnd) {\n\t\tstop = cb(node)\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t}\n\tif node.IsLeaf() {\n\t\treturn stop\n\t}\n\n\tif ascending {\n\t\t// check lower nodes, then higher\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t} else {\n\t\t// check the higher nodes first\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t}\n\n\treturn stop\n}\n\n// TraverseByOffset traverses all nodes, including inner nodes.\n// A limit of math.MaxInt means no limit.\nfunc (node *Node) TraverseByOffset(offset, limit int, descending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\n\t// fast paths. these happen only if TraverseByOffset is called directly on a leaf.\n\tif limit \u003c= 0 || offset \u003e= node.size {\n\t\treturn false\n\t}\n\tif node.IsLeaf() {\n\t\tif offset \u003e 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn cb(node)\n\t}\n\n\t// go to the actual recursive function.\n\treturn node.traverseByOffset(offset, limit, descending, leavesOnly, cb)\n}\n\n// TraverseByOffset traverses the subtree rooted at the node by offset and limit,\n// in either ascending or descending order, and applies the callback function to each traversed node.\n// If leavesOnly is true, only leaf nodes are visited.\nfunc (node *Node) traverseByOffset(offset, limit int, descending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\t// caller guarantees: offset \u003c node.size; limit \u003e 0.\n\tif !leavesOnly {\n\t\tif cb(node) {\n\t\t\treturn true\n\t\t}\n\t}\n\tfirst, second := node.getLeftNode(), node.getRightNode()\n\tif descending {\n\t\tfirst, second = second, first\n\t}\n\tif first.IsLeaf() {\n\t\t// either run or skip, based on offset\n\t\tif offset \u003e 0 {\n\t\t\toffset--\n\t\t} else {\n\t\t\tcb(first)\n\t\t\tlimit--\n\t\t\tif limit \u003c= 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// possible cases:\n\t\t// 1 the offset given skips the first node entirely\n\t\t// 2 the offset skips none or part of the first node, but the limit requires some of the second node.\n\t\t// 3 the offset skips none or part of the first node, and the limit stops our search on the first node.\n\t\tif offset \u003e= first.size {\n\t\t\toffset -= first.size // 1\n\t\t} else {\n\t\t\tif first.traverseByOffset(offset, limit, descending, leavesOnly, cb) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// number of leaves which could actually be called from inside\n\t\t\tdelta := first.size - offset\n\t\t\toffset = 0\n\t\t\tif delta \u003e= limit {\n\t\t\t\treturn true // 3\n\t\t\t}\n\t\t\tlimit -= delta // 2\n\t\t}\n\t}\n\n\t// because of the caller guarantees and the way we handle the first node,\n\t// at this point we know that limit \u003e 0 and there must be some values in\n\t// this second node that we include.\n\n\t// =\u003e if the second node is a leaf, it has to be included.\n\tif second.IsLeaf() {\n\t\treturn cb(second)\n\t}\n\t// =\u003e if it is not a leaf, it will still be enough to recursively call this\n\t// function with the updated offset and limit\n\treturn second.traverseByOffset(offset, limit, descending, leavesOnly, cb)\n}\n\n// Only used in testing...\nfunc (node *Node) lmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getLeftNode().lmd()\n}\n\n// Only used in testing...\nfunc (node *Node) rmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getRightNode().rmd()\n}\n\nfunc maxInt8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"},{"name":"node_test.gno","body":"package avl\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestTraverseByOffset(t *testing.T) {\n\tconst testStrings = `Alfa\nAlfred\nAlpha\nAlphabet\nBeta\nBeth\nBook\nBrowser`\n\ttt := []struct {\n\t\tname string\n\t\tdesc bool\n\t}{\n\t\t{\"ascending\", false},\n\t\t{\"descending\", true},\n\t}\n\n\tfor _, tt := range tt {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tsl := strings.Split(testStrings, \"\\n\")\n\n\t\t\t// sort a first time in the order opposite to how we'll be traversing\n\t\t\t// the tree, to ensure that we are not just iterating through with\n\t\t\t// insertion order.\n\t\t\tsort.Strings(sl)\n\t\t\tif !tt.desc {\n\t\t\t\treverseSlice(sl)\n\t\t\t}\n\n\t\t\tr := NewNode(sl[0], nil)\n\t\t\tfor _, v := range sl[1:] {\n\t\t\t\tr, _ = r.Set(v, nil)\n\t\t\t}\n\n\t\t\t// then sort sl in the order we'll be traversing it, so that we can\n\t\t\t// compare the result with sl.\n\t\t\treverseSlice(sl)\n\n\t\t\tvar result []string\n\t\t\tfor i := 0; i \u003c len(sl); i++ {\n\t\t\t\tr.TraverseByOffset(i, 1, tt.desc, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif !slicesEqual(sl, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", sl, result)\n\t\t\t}\n\n\t\t\tfor l := 2; l \u003c= len(sl); l++ {\n\t\t\t\t// \"slices\"\n\t\t\t\tfor i := 0; i \u003c= len(sl); i++ {\n\t\t\t\t\tmax := i + l\n\t\t\t\t\tif max \u003e len(sl) {\n\t\t\t\t\t\tmax = len(sl)\n\t\t\t\t\t}\n\t\t\t\t\texp := sl[i:max]\n\t\t\t\t\tactual := []string{}\n\n\t\t\t\t\tr.TraverseByOffset(i, l, tt.desc, true, func(tr *Node) bool {\n\t\t\t\t\t\tactual = append(actual, tr.Key())\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\tif !slicesEqual(exp, actual) {\n\t\t\t\t\t\tt.Errorf(\"want %v got %v\", exp, actual)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHas(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\thasKey   string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\t\"has key in non-empty tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"B\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in non-empty tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"has key in single-node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t\"A\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in single-node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t\"B\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in empty tree\",\n\t\t\t[]string{},\n\t\t\t\"A\",\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tresult := tree.Has(tt.hasKey)\n\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinput        []string\n\t\tgetKey       string\n\t\texpectIdx    int\n\t\texpectVal    interface{}\n\t\texpectExists bool\n\t}{\n\t\t{\n\t\t\t\"get existing key\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"B\",\n\t\t\t1,\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"get non-existent key (smaller)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"@\",\n\t\t\t0,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get non-existent key (larger)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\t5,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get from empty tree\",\n\t\t\t[]string{},\n\t\t\t\"A\",\n\t\t\t0,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tidx, val, exists := tree.Get(tt.getKey)\n\n\t\t\tif idx != tt.expectIdx {\n\t\t\t\tt.Errorf(\"Expected index %d, got %d\", tt.expectIdx, idx)\n\t\t\t}\n\n\t\t\tif val != tt.expectVal {\n\t\t\t\tt.Errorf(\"Expected value %v, got %v\", tt.expectVal, val)\n\t\t\t}\n\n\t\t\tif exists != tt.expectExists {\n\t\t\t\tt.Errorf(\"Expected exists %t, got %t\", tt.expectExists, exists)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetByIndex(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       []string\n\t\tidx         int\n\t\texpectKey   string\n\t\texpectVal   interface{}\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\t\"get by valid index\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t2,\n\t\t\t\"C\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by valid index (smallest)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t0,\n\t\t\t\"A\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by valid index (largest)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t4,\n\t\t\t\"E\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by invalid index (negative)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t-1,\n\t\t\t\"\",\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"get by invalid index (out of range)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t5,\n\t\t\t\"\",\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected a panic but didn't get one\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tkey, val := tree.GetByIndex(tt.idx)\n\n\t\t\tif !tt.expectPanic {\n\t\t\t\tif key != tt.expectKey {\n\t\t\t\t\tt.Errorf(\"Expected key %s, got %s\", tt.expectKey, key)\n\t\t\t\t}\n\n\t\t\t\tif val != tt.expectVal {\n\t\t\t\t\tt.Errorf(\"Expected value %v, got %v\", tt.expectVal, val)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRemove(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinput     []string\n\t\tremoveKey string\n\t\texpected  []string\n\t}{\n\t\t{\n\t\t\t\"remove leaf node\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"D\"},\n\t\t\t\"B\",\n\t\t\t[]string{\"A\", \"C\", \"D\"},\n\t\t},\n\t\t{\n\t\t\t\"remove node with one child\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"D\"},\n\t\t\t\"A\",\n\t\t\t[]string{\"B\", \"C\", \"D\"},\n\t\t},\n\t\t{\n\t\t\t\"remove node with two children\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"C\",\n\t\t\t[]string{\"A\", \"B\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"remove root node\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"C\",\n\t\t\t[]string{\"A\", \"B\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"remove non-existent key\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\ttree, _, _, _ = tree.Remove(tt.removeKey)\n\n\t\t\tresult := make([]string, 0)\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTraverse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"empty tree\",\n\t\t\t[]string{},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"single node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t[]string{\"A\"},\n\t\t},\n\t\t{\n\t\t\t\"small tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"large tree\",\n\t\t\t[]string{\"H\", \"D\", \"L\", \"B\", \"F\", \"J\", \"N\", \"A\", \"C\", \"E\", \"G\", \"I\", \"K\", \"M\", \"O\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tt.Run(\"iterate\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"ReverseIterate\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\ttree.ReverseIterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\texpected := make([]string, len(tt.expected))\n\t\t\t\tcopy(expected, tt.expected)\n\t\t\t\tfor i, j := 0, len(expected)-1; i \u003c j; i, j = i+1, j-1 {\n\t\t\t\t\texpected[i], expected[j] = expected[j], expected[i]\n\t\t\t\t}\n\t\t\t\tif !slicesEqual(expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", expected, result)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"TraverseInRange\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\tstart, end := \"C\", \"M\"\n\t\t\t\ttree.TraverseInRange(start, end, true, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\texpected := make([]string, 0)\n\t\t\t\tfor _, key := range tt.expected {\n\t\t\t\t\tif key \u003e= start \u0026\u0026 key \u003c end {\n\t\t\t\t\t\texpected = append(expected, key)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !slicesEqual(expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", expected, result)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRotateWhenHeightDiffers(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"right rotation when left subtree is higher\",\n\t\t\t[]string{\"E\", \"C\", \"A\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"E\", \"D\"},\n\t\t},\n\t\t{\n\t\t\t\"left rotation when right subtree is higher\",\n\t\t\t[]string{\"A\", \"C\", \"E\", \"D\", \"F\"},\n\t\t\t[]string{\"A\", \"C\", \"D\", \"E\", \"F\"},\n\t\t},\n\t\t{\n\t\t\t\"left-right rotation\",\n\t\t\t[]string{\"E\", \"A\", \"C\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"E\", \"D\"},\n\t\t},\n\t\t{\n\t\t\t\"right-left rotation\",\n\t\t\t[]string{\"A\", \"E\", \"C\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"E\", \"D\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\t// perform rotation or balance\n\t\t\ttree = tree.balance()\n\n\t\t\t// check tree structure\n\t\t\tvar result []string\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRotateAndBalance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"right rotation\",\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"left rotation\",\n\t\t\t[]string{\"E\", \"D\", \"C\", \"B\", \"A\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"left-right rotation\",\n\t\t\t[]string{\"C\", \"A\", \"E\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"right-left rotation\",\n\t\t\t[]string{\"C\", \"E\", \"A\", \"D\", \"B\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\ttree = tree.balance()\n\n\t\t\tvar result []string\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc slicesEqual(w1, w2 []string) bool {\n\tif len(w1) != len(w2) {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c len(w1); i++ {\n\t\tif w1[0] != w2[0] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc maxint8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc reverseSlice(ss []string) {\n\tfor i := 0; i \u003c len(ss)/2; i++ {\n\t\tj := len(ss) - 1 - i\n\t\tss[i], ss[j] = ss[j], ss[i]\n\t}\n}\n"},{"name":"tree.gno","body":"package avl\n\ntype ITree interface {\n\t// read operations\n\n\tSize() int\n\tHas(key string) bool\n\tGet(key string) (value interface{}, exists bool)\n\tGetByIndex(index int) (key string, value interface{})\n\tIterate(start, end string, cb IterCbFn) bool\n\tReverseIterate(start, end string, cb IterCbFn) bool\n\tIterateByOffset(offset int, count int, cb IterCbFn) bool\n\tReverseIterateByOffset(offset int, count int, cb IterCbFn) bool\n\n\t// write operations\n\n\tSet(key string, value interface{}) (updated bool)\n\tRemove(key string) (value interface{}, removed bool)\n}\n\ntype IterCbFn func(key string, value interface{}) bool\n\n//----------------------------------------\n// Tree\n\n// The zero struct can be used as an empty tree.\ntype Tree struct {\n\tnode *Node\n}\n\n// NewTree creates a new empty AVL tree.\nfunc NewTree() *Tree {\n\treturn \u0026Tree{\n\t\tnode: nil,\n\t}\n}\n\n// Size returns the number of key-value pair in the tree.\nfunc (tree *Tree) Size() int {\n\treturn tree.node.Size()\n}\n\n// Has checks whether a key exists in the tree.\n// It returns true if the key exists, otherwise false.\nfunc (tree *Tree) Has(key string) (has bool) {\n\treturn tree.node.Has(key)\n}\n\n// Get retrieves the value associated with the given key.\n// It returns the value and a boolean indicating whether the key exists.\nfunc (tree *Tree) Get(key string) (value interface{}, exists bool) {\n\t_, value, exists = tree.node.Get(key)\n\treturn\n}\n\n// GetByIndex retrieves the key-value pair at the specified index in the tree.\n// It returns the key and value at the given index.\nfunc (tree *Tree) GetByIndex(index int) (key string, value interface{}) {\n\treturn tree.node.GetByIndex(index)\n}\n\n// Set inserts a key-value pair into the tree.\n// If the key already exists, the value will be updated.\n// It returns a boolean indicating whether the key was newly inserted or updated.\nfunc (tree *Tree) Set(key string, value interface{}) (updated bool) {\n\tnewnode, updated := tree.node.Set(key, value)\n\ttree.node = newnode\n\treturn updated\n}\n\n// Remove removes a key-value pair from the tree.\n// It returns the removed value and a boolean indicating whether the key was found and removed.\nfunc (tree *Tree) Remove(key string) (value interface{}, removed bool) {\n\tnewnode, _, value, removed := tree.node.Remove(key)\n\ttree.node = newnode\n\treturn value, removed\n}\n\n// Iterate performs an in-order traversal of the tree within the specified key range.\n// It calls the provided callback function for each key-value pair encountered.\n// If the callback returns true, the iteration is stopped.\nfunc (tree *Tree) Iterate(start, end string, cb IterCbFn) bool {\n\treturn tree.node.TraverseInRange(start, end, true, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// ReverseIterate performs a reverse in-order traversal of the tree within the specified key range.\n// It calls the provided callback function for each key-value pair encountered.\n// If the callback returns true, the iteration is stopped.\nfunc (tree *Tree) ReverseIterate(start, end string, cb IterCbFn) bool {\n\treturn tree.node.TraverseInRange(start, end, false, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// IterateByOffset performs an in-order traversal of the tree starting from the specified offset.\n// It calls the provided callback function for each key-value pair encountered, up to the specified count.\n// If the callback returns true, the iteration is stopped.\nfunc (tree *Tree) IterateByOffset(offset int, count int, cb IterCbFn) bool {\n\treturn tree.node.TraverseByOffset(offset, count, true, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// ReverseIterateByOffset performs a reverse in-order traversal of the tree starting from the specified offset.\n// It calls the provided callback function for each key-value pair encountered, up to the specified count.\n// If the callback returns true, the iteration is stopped.\nfunc (tree *Tree) ReverseIterateByOffset(offset int, count int, cb IterCbFn) bool {\n\treturn tree.node.TraverseByOffset(offset, count, false, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// Verify that Tree implements TreeInterface\nvar _ ITree = (*Tree)(nil)\n"},{"name":"tree_test.gno","body":"package avl\n\nimport \"testing\"\n\nfunc TestNewTree(t *testing.T) {\n\ttree := NewTree()\n\tif tree.node != nil {\n\t\tt.Error(\"Expected tree.node to be nil\")\n\t}\n}\n\nfunc TestTreeSize(t *testing.T) {\n\ttree := NewTree()\n\tif tree.Size() != 0 {\n\t\tt.Error(\"Expected empty tree size to be 0\")\n\t}\n\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\tif tree.Size() != 2 {\n\t\tt.Error(\"Expected tree size to be 2\")\n\t}\n}\n\nfunc TestTreeHas(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\n\tif !tree.Has(\"key1\") {\n\t\tt.Error(\"Expected tree to have key1\")\n\t}\n\n\tif tree.Has(\"key2\") {\n\t\tt.Error(\"Expected tree to not have key2\")\n\t}\n}\n\nfunc TestTreeGet(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\n\tvalue, exists := tree.Get(\"key1\")\n\tif !exists || value != \"value1\" {\n\t\tt.Error(\"Expected Get to return value1 and true\")\n\t}\n\n\t_, exists = tree.Get(\"key2\")\n\tif exists {\n\t\tt.Error(\"Expected Get to return false for non-existent key\")\n\t}\n}\n\nfunc TestTreeGetByIndex(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\n\tkey, value := tree.GetByIndex(0)\n\tif key != \"key1\" || value != \"value1\" {\n\t\tt.Error(\"Expected GetByIndex(0) to return key1 and value1\")\n\t}\n\n\tkey, value = tree.GetByIndex(1)\n\tif key != \"key2\" || value != \"value2\" {\n\t\tt.Error(\"Expected GetByIndex(1) to return key2 and value2\")\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"Expected GetByIndex to panic for out-of-range index\")\n\t\t}\n\t}()\n\ttree.GetByIndex(2)\n}\n\nfunc TestTreeRemove(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\n\tvalue, removed := tree.Remove(\"key1\")\n\tif !removed || value != \"value1\" || tree.Size() != 0 {\n\t\tt.Error(\"Expected Remove to remove key-value pair\")\n\t}\n\n\t_, removed = tree.Remove(\"key2\")\n\tif removed {\n\t\tt.Error(\"Expected Remove to return false for non-existent key\")\n\t}\n}\n\nfunc TestTreeIterate(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\tvar keys []string\n\ttree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tkeys = append(keys, key)\n\t\treturn false\n\t})\n\n\texpectedKeys := []string{\"key1\", \"key2\", \"key3\"}\n\tif !slicesEqual(keys, expectedKeys) {\n\t\tt.Errorf(\"Expected keys %v, got %v\", expectedKeys, keys)\n\t}\n}\n\nfunc TestTreeReverseIterate(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\tvar keys []string\n\ttree.ReverseIterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tkeys = append(keys, key)\n\t\treturn false\n\t})\n\n\texpectedKeys := []string{\"key3\", \"key2\", \"key1\"}\n\tif !slicesEqual(keys, expectedKeys) {\n\t\tt.Errorf(\"Expected keys %v, got %v\", expectedKeys, keys)\n\t}\n}\n\nfunc TestTreeIterateByOffset(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\tvar keys []string\n\ttree.IterateByOffset(1, 2, func(key string, value interface{}) bool {\n\t\tkeys = append(keys, key)\n\t\treturn false\n\t})\n\n\texpectedKeys := []string{\"key2\", \"key3\"}\n\tif !slicesEqual(keys, expectedKeys) {\n\t\tt.Errorf(\"Expected keys %v, got %v\", expectedKeys, keys)\n\t}\n}\n\nfunc TestTreeReverseIterateByOffset(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\tvar keys []string\n\ttree.ReverseIterateByOffset(1, 2, func(key string, value interface{}) bool {\n\t\tkeys = append(keys, key)\n\t\treturn false\n\t})\n\n\texpectedKeys := []string{\"key2\", \"key1\"}\n\tif !slicesEqual(keys, expectedKeys) {\n\t\tt.Errorf(\"Expected keys %v, got %v\", expectedKeys, keys)\n\t}\n}\n"},{"name":"z_0_filetest.gno","body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\t// node, _ = node.Set(\"key0\", \"value0\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key1\", \"value1\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 2\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"ModTime\": \"7\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"627e8e517e7ae5db0f3b753e2a32b607989198b6\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:9]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:8]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"b28057ab7be6383785c0a5503e8a531bdbc21851\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:7]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"6da365f0d6cacbcdf53cd5a4b125803cddce08c2\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"f216afe7b5a17f4ebdbb98dceccedbc22e237596\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:6]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"ff1a50d8489090af37a2c7766d659f0d717939b5\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//         }\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"5\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"Column\": \"0\",\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"ae86874f9b47fa5e64c30b3e92e9d07f2ec967a4\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"z_0.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.1\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"Column\": \"1\",\n//                         \"File\": \"z_0.gno\",\n//                         \"Line\": \"10\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"z_0.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"Column\": \"1\",\n//                         \"File\": \"z_0.gno\",\n//                         \"Line\": \"15\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         }\n//     ]\n// }\n"},{"name":"z_1_filetest.gno","body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\tnode, _ = node.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key2\", \"value2\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:15]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:14]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"143aebc820da33550f7338723fb1e2eec575b196\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:13]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"2f3adc5d0f2a3fe0331cfa93572a7abdde14c9aa\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"2e733a8e9e74fe14f0a5d10fb0f6728fa53d052d\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:12]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"fe20a19f956511f274dc77854e9e5468387260f4\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:11]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"c89a71bdf045e8bde2059dc9d33839f916e02e5d\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"90fa67f8c47db4b9b2a60425dff08d5a3385100f\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:10]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"83e42caaf53070dd95b5f859053eb51ed900bbda\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\"\n//         }\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"9\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"Column\": \"0\",\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"1faa9fa4ba1935121a6d3f0a623772e9d4499b0a\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"z_1.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.1\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"Column\": \"1\",\n//                         \"File\": \"z_1.gno\",\n//                         \"Line\": \"10\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"z_1.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"Column\": \"1\",\n//                         \"File\": \"z_1.gno\",\n//                         \"Line\": \"15\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         }\n//     ]\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]\n"},{"name":"z_2_filetest.gno","body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar tree avl.Tree\n\nfunc init() {\n\ttree.Set(\"key0\", \"value0\")\n\ttree.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tupdated = tree.Set(\"key2\", \"value2\")\n\tprintln(updated, tree.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:16]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:16\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:15]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"db333c89cd6773709e031f1f4e4ed4d3fed66c11\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:16\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:14]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"849a50d6c78d65742752e3c89ad8dd556e2e63cb\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"b4fc2fdd2d0fe936c87ed2ace97136cffeed207f\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:13]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"a1160b0060ad752dbfe5fe436f7734bb19136150\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:12]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"fd95e08763159ac529e26986d652e752e78b6325\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"3ecdcf148fe2f9e97b72a3bedf303b2ba56d4f4b\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:11]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"63126557dba88f8556f7a0ccbbfc1d218ae7a302\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\"\n//         }\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:3]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"d31c7e797793e03ffe0bbcb72f963264f8300d22\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\",\n//         \"ModTime\": \"10\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:6]\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"avlhelpers","path":"gno.land/p/demo/avlhelpers","files":[{"name":"avlhelpers.gno","body":"package avlhelpers\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\n// Iterate the keys in-order starting from the given prefix.\n// It calls the provided callback function for each key-value pair encountered.\n// If the callback returns true, the iteration is stopped.\n// The prefix and keys are treated as byte strings, ignoring possible multi-byte Unicode runes.\nfunc IterateByteStringKeysByPrefix(tree avl.ITree, prefix string, cb avl.IterCbFn) {\n\tend := \"\"\n\tn := len(prefix)\n\t// To make the end of the search, increment the final character ASCII by one.\n\tfor n \u003e 0 {\n\t\tif ascii := int(prefix[n-1]); ascii \u003c 0xff {\n\t\t\tend = prefix[0:n-1] + string(ascii+1)\n\t\t\tbreak\n\t\t}\n\n\t\t// The last character is 0xff. Try the previous character.\n\t\tn--\n\t}\n\n\ttree.Iterate(prefix, end, cb)\n}\n\n// Get a list of keys starting from the given prefix. Limit the\n// number of results to maxResults.\n// The prefix and keys are treated as byte strings, ignoring possible multi-byte Unicode runes.\nfunc ListByteStringKeysByPrefix(tree avl.ITree, prefix string, maxResults int) []string {\n\tresult := []string{}\n\tIterateByteStringKeysByPrefix(tree, prefix, func(key string, value interface{}) bool {\n\t\tresult = append(result, key)\n\t\tif len(result) \u003e= maxResults {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\treturn result\n}\n"},{"name":"z_0_filetest.gno","body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"encoding/hex\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/avlhelpers\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc main() {\n\ttree := avl.NewTree()\n\n\t{\n\t\t// Empty tree.\n\t\tmatches := avlhelpers.ListByteStringKeysByPrefix(tree, \"\", 10)\n\t\tprintln(ufmt.Sprintf(\"# matches: %d\", len(matches)))\n\t}\n\n\ttree.Set(\"alice\", \"\")\n\ttree.Set(\"andy\", \"\")\n\ttree.Set(\"bob\", \"\")\n\n\t{\n\t\t// Match only alice.\n\t\tmatches := avlhelpers.ListByteStringKeysByPrefix(tree, \"al\", 10)\n\t\tprintln(ufmt.Sprintf(\"# matches: %d\", len(matches)))\n\t\tprintln(\"match: \" + matches[0])\n\t}\n\n\t{\n\t\t// Match alice and andy.\n\t\tmatches := avlhelpers.ListByteStringKeysByPrefix(tree, \"a\", 10)\n\t\tprintln(ufmt.Sprintf(\"# matches: %d\", len(matches)))\n\t\tprintln(\"match: \" + matches[0])\n\t\tprintln(\"match: \" + matches[1])\n\t}\n\n\t{\n\t\t// Match alice and andy limited to 1.\n\t\tmatches := avlhelpers.ListByteStringKeysByPrefix(tree, \"a\", 1)\n\t\tprintln(ufmt.Sprintf(\"# matches: %d\", len(matches)))\n\t\tprintln(\"match: \" + matches[0])\n\t}\n\n\ttree = avl.NewTree()\n\ttree.Set(\"a\\xff\", \"\")\n\ttree.Set(\"a\\xff\\xff\", \"\")\n\ttree.Set(\"b\", \"\")\n\ttree.Set(\"\\xff\\xff\\x00\", \"\")\n\n\t{\n\t\t// Match only \"a\\xff\\xff\".\n\t\tmatches := avlhelpers.ListByteStringKeysByPrefix(tree, \"a\\xff\\xff\", 10)\n\t\tprintln(ufmt.Sprintf(\"# matches: %d\", len(matches)))\n\t\tprintln(ufmt.Sprintf(\"match: %s\", hex.EncodeToString([]byte(matches[0]))))\n\t}\n\n\t{\n\t\t// Match \"a\\xff\" and \"a\\xff\\xff\".\n\t\tmatches := avlhelpers.ListByteStringKeysByPrefix(tree, \"a\\xff\", 10)\n\t\tprintln(ufmt.Sprintf(\"# matches: %d\", len(matches)))\n\t\tprintln(ufmt.Sprintf(\"match: %s\", hex.EncodeToString([]byte(matches[0]))))\n\t\tprintln(ufmt.Sprintf(\"match: %s\", hex.EncodeToString([]byte(matches[1]))))\n\t}\n\n\t{\n\t\t// Edge case: Match only \"\\xff\\xff\\x00\".\n\t\tmatches := avlhelpers.ListByteStringKeysByPrefix(tree, \"\\xff\\xff\", 10)\n\t\tprintln(ufmt.Sprintf(\"# matches: %d\", len(matches)))\n\t\tprintln(ufmt.Sprintf(\"match: %s\", hex.EncodeToString([]byte(matches[0]))))\n\t}\n}\n\n// Output:\n// # matches: 0\n// # matches: 1\n// match: alice\n// # matches: 2\n// match: alice\n// match: andy\n// # matches: 1\n// match: alice\n// # matches: 1\n// match: 61ffff\n// # matches: 2\n// match: 61ff\n// match: 61ffff\n// # matches: 1\n// match: ffff00\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"pager","path":"gno.land/p/demo/avl/pager","files":[{"name":"pager.gno","body":"package pager\n\nimport (\n\t\"math\"\n\t\"net/url\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// Pager is a struct that holds the AVL tree and pagination parameters.\ntype Pager struct {\n\tTree            avl.ITree\n\tPageQueryParam  string\n\tSizeQueryParam  string\n\tDefaultPageSize int\n\tReversed        bool\n}\n\n// Page represents a single page of results.\ntype Page struct {\n\tItems      []Item\n\tPageNumber int\n\tPageSize   int\n\tTotalItems int\n\tTotalPages int\n\tHasPrev    bool\n\tHasNext    bool\n\tPager      *Pager // Reference to the parent Pager\n}\n\n// Item represents a key-value pair in the AVL tree.\ntype Item struct {\n\tKey   string\n\tValue interface{}\n}\n\n// NewPager creates a new Pager with default values.\nfunc NewPager(tree avl.ITree, defaultPageSize int, reversed bool) *Pager {\n\treturn \u0026Pager{\n\t\tTree:            tree,\n\t\tPageQueryParam:  \"page\",\n\t\tSizeQueryParam:  \"size\",\n\t\tDefaultPageSize: defaultPageSize,\n\t\tReversed:        reversed,\n\t}\n}\n\n// GetPage retrieves a page of results from the AVL tree.\nfunc (p *Pager) GetPage(pageNumber int) *Page {\n\treturn p.GetPageWithSize(pageNumber, p.DefaultPageSize)\n}\n\nfunc (p *Pager) GetPageWithSize(pageNumber, pageSize int) *Page {\n\ttotalItems := p.Tree.Size()\n\ttotalPages := int(math.Ceil(float64(totalItems) / float64(pageSize)))\n\n\tpage := \u0026Page{\n\t\tTotalItems: totalItems,\n\t\tTotalPages: totalPages,\n\t\tPageSize:   pageSize,\n\t\tPager:      p,\n\t}\n\n\t// pages without content\n\tif pageSize \u003c 1 {\n\t\treturn page\n\t}\n\n\t// page number provided is not available\n\tif pageNumber \u003c 1 {\n\t\tpage.HasNext = totalPages \u003e 0\n\t\treturn page\n\t}\n\n\t// page number provided is outside the range of total pages\n\tif pageNumber \u003e totalPages {\n\t\tpage.PageNumber = pageNumber\n\t\tpage.HasPrev = pageNumber \u003e 0\n\t\treturn page\n\t}\n\n\tstartIndex := (pageNumber - 1) * pageSize\n\tendIndex := startIndex + pageSize\n\tif endIndex \u003e totalItems {\n\t\tendIndex = totalItems\n\t}\n\n\titems := []Item{}\n\n\tif p.Reversed {\n\t\tp.Tree.IterateByOffset(startIndex, endIndex-startIndex, func(key string, value interface{}) bool {\n\t\t\titems = append(items, Item{Key: key, Value: value})\n\t\t\treturn false\n\t\t})\n\t} else {\n\t\tp.Tree.ReverseIterateByOffset(startIndex, endIndex-startIndex, func(key string, value interface{}) bool {\n\t\t\titems = append(items, Item{Key: key, Value: value})\n\t\t\treturn false\n\t\t})\n\t}\n\n\tpage.Items = items\n\tpage.PageNumber = pageNumber\n\tpage.HasPrev = pageNumber \u003e 1\n\tpage.HasNext = pageNumber \u003c totalPages\n\treturn page\n}\n\nfunc (p *Pager) MustGetPageByPath(rawURL string) *Page {\n\tpage, err := p.GetPageByPath(rawURL)\n\tif err != nil {\n\t\tpanic(\"invalid path\")\n\t}\n\treturn page\n}\n\n// GetPageByPath retrieves a page of results based on the query parameters in the URL path.\nfunc (p *Pager) GetPageByPath(rawURL string) (*Page, error) {\n\tpageNumber, pageSize, err := p.ParseQuery(rawURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn p.GetPageWithSize(pageNumber, pageSize), nil\n}\n\n// Picker generates the Markdown UI for the page Picker\nfunc (p *Page) Picker() string {\n\tpageNumber := p.PageNumber\n\tpageNumber = max(pageNumber, 1)\n\n\tif p.TotalPages \u003c= 1 {\n\t\treturn \"\"\n\t}\n\n\tmd := \"\"\n\n\tif p.HasPrev {\n\t\t// Always show the first page link\n\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", 1, p.Pager.PageQueryParam, 1)\n\n\t\t// Before\n\t\tif p.PageNumber \u003e 4 {\n\t\t\tmd += \" | \"\n\t\t}\n\n\t\tif p.PageNumber \u003e 3 {\n\t\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", p.PageNumber-2, p.Pager.PageQueryParam, p.PageNumber-2)\n\t\t}\n\n\t\tif p.PageNumber \u003e 2 {\n\t\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", p.PageNumber-1, p.Pager.PageQueryParam, p.PageNumber-1)\n\t\t}\n\t}\n\n\tif p.PageNumber \u003e 0 \u0026\u0026 p.PageNumber \u003c= p.TotalPages {\n\t\t// Current page\n\t\tmd += ufmt.Sprintf(\"**%d**\", p.PageNumber)\n\t} else {\n\t\tmd += ufmt.Sprintf(\"_%d_\", p.PageNumber)\n\t}\n\n\tif p.HasNext {\n\t\tmd += \" | \"\n\n\t\tif p.PageNumber \u003c p.TotalPages-1 {\n\t\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", p.PageNumber+1, p.Pager.PageQueryParam, p.PageNumber+1)\n\t\t}\n\n\t\tif p.PageNumber \u003c p.TotalPages-2 {\n\t\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", p.PageNumber+2, p.Pager.PageQueryParam, p.PageNumber+2)\n\t\t}\n\n\t\tif p.PageNumber \u003c p.TotalPages-3 {\n\t\t\tmd += \" | \"\n\t\t}\n\n\t\t// Always show the last page link\n\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d)\", p.TotalPages, p.Pager.PageQueryParam, p.TotalPages)\n\t}\n\n\treturn md\n}\n\n// ParseQuery parses the URL to extract the page number and page size.\nfunc (p *Pager) ParseQuery(rawURL string) (int, int, error) {\n\tu, err := url.Parse(rawURL)\n\tif err != nil {\n\t\treturn 1, p.DefaultPageSize, err\n\t}\n\n\tquery := u.Query()\n\tpageNumber := 1\n\tpageSize := p.DefaultPageSize\n\n\tif p.PageQueryParam != \"\" {\n\t\tif pageStr := query.Get(p.PageQueryParam); pageStr != \"\" {\n\t\t\tpageNumber, err = strconv.Atoi(pageStr)\n\t\t\tif err != nil || pageNumber \u003c 1 {\n\t\t\t\tpageNumber = 1\n\t\t\t}\n\t\t}\n\t}\n\n\tif p.SizeQueryParam != \"\" {\n\t\tif sizeStr := query.Get(p.SizeQueryParam); sizeStr != \"\" {\n\t\t\tpageSize, err = strconv.Atoi(sizeStr)\n\t\t\tif err != nil || pageSize \u003c 1 {\n\t\t\t\tpageSize = p.DefaultPageSize\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pageNumber, pageSize, nil\n}\n\nfunc max(a, b int) int {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"},{"name":"pager_test.gno","body":"package pager\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/uassert\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/urequire\"\n)\n\nfunc TestPager_GetPage(t *testing.T) {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\ttree := avl.NewTree()\n\ttree.Set(\"a\", 1)\n\ttree.Set(\"b\", 2)\n\ttree.Set(\"c\", 3)\n\ttree.Set(\"d\", 4)\n\ttree.Set(\"e\", 5)\n\n\tt.Run(\"normal ordering\", func(t *testing.T) {\n\t\t// Create a new pager.\n\t\tpager := NewPager(tree, 10, false)\n\n\t\t// Define test cases.\n\t\ttests := []struct {\n\t\t\tpageNumber int\n\t\t\tpageSize   int\n\t\t\texpected   []Item\n\t\t}{\n\t\t\t{1, 2, []Item{{Key: \"a\", Value: 1}, {Key: \"b\", Value: 2}}},\n\t\t\t{2, 2, []Item{{Key: \"c\", Value: 3}, {Key: \"d\", Value: 4}}},\n\t\t\t{3, 2, []Item{{Key: \"e\", Value: 5}}},\n\t\t\t{1, 3, []Item{{Key: \"a\", Value: 1}, {Key: \"b\", Value: 2}, {Key: \"c\", Value: 3}}},\n\t\t\t{2, 3, []Item{{Key: \"d\", Value: 4}, {Key: \"e\", Value: 5}}},\n\t\t\t{1, 5, []Item{{Key: \"a\", Value: 1}, {Key: \"b\", Value: 2}, {Key: \"c\", Value: 3}, {Key: \"d\", Value: 4}, {Key: \"e\", Value: 5}}},\n\t\t\t{2, 5, []Item{}},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tpage := pager.GetPageWithSize(tt.pageNumber, tt.pageSize)\n\n\t\t\tuassert.Equal(t, len(tt.expected), len(page.Items))\n\n\t\t\tfor i, item := range page.Items {\n\t\t\t\tuassert.Equal(t, tt.expected[i].Key, item.Key)\n\t\t\t\tuassert.Equal(t, tt.expected[i].Value, item.Value)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"reversed ordering\", func(t *testing.T) {\n\t\t// Create a new pager.\n\t\tpager := NewPager(tree, 10, true)\n\n\t\t// Define test cases.\n\t\ttests := []struct {\n\t\t\tpageNumber int\n\t\t\tpageSize   int\n\t\t\texpected   []Item\n\t\t}{\n\t\t\t{1, 2, []Item{{Key: \"e\", Value: 5}, {Key: \"d\", Value: 4}}},\n\t\t\t{2, 2, []Item{{Key: \"c\", Value: 3}, {Key: \"b\", Value: 2}}},\n\t\t\t{3, 2, []Item{{Key: \"a\", Value: 1}}},\n\t\t\t{1, 3, []Item{{Key: \"e\", Value: 5}, {Key: \"d\", Value: 4}, {Key: \"c\", Value: 3}}},\n\t\t\t{2, 3, []Item{{Key: \"b\", Value: 2}, {Key: \"a\", Value: 1}}},\n\t\t\t{1, 5, []Item{{Key: \"e\", Value: 5}, {Key: \"d\", Value: 4}, {Key: \"c\", Value: 3}, {Key: \"b\", Value: 2}, {Key: \"a\", Value: 1}}},\n\t\t\t{2, 5, []Item{}},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tpage := pager.GetPageWithSize(tt.pageNumber, tt.pageSize)\n\n\t\t\tuassert.Equal(t, len(tt.expected), len(page.Items))\n\n\t\t\tfor i, item := range page.Items {\n\t\t\t\tuassert.Equal(t, tt.expected[i].Key, item.Key)\n\t\t\t\tuassert.Equal(t, tt.expected[i].Value, item.Value)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestPager_GetPageByPath(t *testing.T) {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\ttree := avl.NewTree()\n\tfor i := 0; i \u003c 50; i++ {\n\t\ttree.Set(ufmt.Sprintf(\"key%d\", i), i)\n\t}\n\n\t// Create a new pager.\n\tpager := NewPager(tree, 10, false)\n\n\t// Define test cases.\n\ttests := []struct {\n\t\trawURL       string\n\t\texpectedPage int\n\t\texpectedSize int\n\t}{\n\t\t{\"/r/foo:bar/baz?size=10\u0026page=1\", 1, 10},\n\t\t{\"/r/foo:bar/baz?size=10\u0026page=2\", 2, 10},\n\t\t{\"/r/foo:bar/baz?page=3\", 3, pager.DefaultPageSize},\n\t\t{\"/r/foo:bar/baz?size=20\", 1, 20},\n\t\t{\"/r/foo:bar/baz\", 1, pager.DefaultPageSize},\n\t}\n\n\tfor _, tt := range tests {\n\t\tpage, err := pager.GetPageByPath(tt.rawURL)\n\t\turequire.NoError(t, err, ufmt.Sprintf(\"GetPageByPath(%s) returned error: %v\", tt.rawURL, err))\n\n\t\tuassert.Equal(t, tt.expectedPage, page.PageNumber)\n\t\tuassert.Equal(t, tt.expectedSize, page.PageSize)\n\t}\n}\n\nfunc TestPage_Picker(t *testing.T) {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\ttree := avl.NewTree()\n\ttree.Set(\"a\", 1)\n\ttree.Set(\"b\", 2)\n\ttree.Set(\"c\", 3)\n\ttree.Set(\"d\", 4)\n\ttree.Set(\"e\", 5)\n\n\t// Create a new pager.\n\tpager := NewPager(tree, 10, false)\n\n\t// Define test cases.\n\ttests := []struct {\n\t\tpageNumber int\n\t\tpageSize   int\n\t\texpected   string\n\t}{\n\t\t{1, 2, \"**1** | [2](?page=2) | [3](?page=3)\"},\n\t\t{2, 2, \"[1](?page=1) | **2** | [3](?page=3)\"},\n\t\t{3, 2, \"[1](?page=1) | [2](?page=2) | **3**\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tpage := pager.GetPageWithSize(tt.pageNumber, tt.pageSize)\n\n\t\tui := page.Picker()\n\t\tuassert.Equal(t, tt.expected, ui)\n\t}\n}\n\nfunc TestPager_UI_WithManyPages(t *testing.T) {\n\t// Create a new AVL tree and populate it with many key-value pairs.\n\ttree := avl.NewTree()\n\tfor i := 0; i \u003c 100; i++ {\n\t\ttree.Set(ufmt.Sprintf(\"key%d\", i), i)\n\t}\n\n\t// Create a new pager.\n\tpager := NewPager(tree, 10, false)\n\n\t// Define test cases for a large number of pages.\n\ttests := []struct {\n\t\tpageNumber int\n\t\tpageSize   int\n\t\texpected   string\n\t}{\n\t\t// XXX: -1\n\t\t// XXX: 0\n\t\t{1, 10, \"**1** | [2](?page=2) | [3](?page=3) |  | [10](?page=10)\"},\n\t\t{2, 10, \"[1](?page=1) | **2** | [3](?page=3) | [4](?page=4) |  | [10](?page=10)\"},\n\t\t{3, 10, \"[1](?page=1) | [2](?page=2) | **3** | [4](?page=4) | [5](?page=5) |  | [10](?page=10)\"},\n\t\t{4, 10, \"[1](?page=1) | [2](?page=2) | [3](?page=3) | **4** | [5](?page=5) | [6](?page=6) |  | [10](?page=10)\"},\n\t\t{5, 10, \"[1](?page=1) |  | [3](?page=3) | [4](?page=4) | **5** | [6](?page=6) | [7](?page=7) |  | [10](?page=10)\"},\n\t\t{6, 10, \"[1](?page=1) |  | [4](?page=4) | [5](?page=5) | **6** | [7](?page=7) | [8](?page=8) |  | [10](?page=10)\"},\n\t\t{7, 10, \"[1](?page=1) |  | [5](?page=5) | [6](?page=6) | **7** | [8](?page=8) | [9](?page=9) | [10](?page=10)\"},\n\t\t{8, 10, \"[1](?page=1) |  | [6](?page=6) | [7](?page=7) | **8** | [9](?page=9) | [10](?page=10)\"},\n\t\t{9, 10, \"[1](?page=1) |  | [7](?page=7) | [8](?page=8) | **9** | [10](?page=10)\"},\n\t\t{10, 10, \"[1](?page=1) |  | [8](?page=8) | [9](?page=9) | **10**\"},\n\t\t// XXX: 11\n\t}\n\n\tfor _, tt := range tests {\n\t\tpage := pager.GetPageWithSize(tt.pageNumber, tt.pageSize)\n\n\t\tui := page.Picker()\n\t\tuassert.Equal(t, tt.expected, ui)\n\t}\n}\n\nfunc TestPager_ParseQuery(t *testing.T) {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\ttree := avl.NewTree()\n\ttree.Set(\"a\", 1)\n\ttree.Set(\"b\", 2)\n\ttree.Set(\"c\", 3)\n\ttree.Set(\"d\", 4)\n\ttree.Set(\"e\", 5)\n\n\t// Create a new pager.\n\tpager := NewPager(tree, 10, false)\n\n\t// Define test cases.\n\ttests := []struct {\n\t\trawURL        string\n\t\texpectedPage  int\n\t\texpectedSize  int\n\t\texpectedError bool\n\t}{\n\t\t{\"/r/foo:bar/baz?size=2\u0026page=1\", 1, 2, false},\n\t\t{\"/r/foo:bar/baz?size=3\u0026page=2\", 2, 3, false},\n\t\t{\"/r/foo:bar/baz?size=5\u0026page=3\", 3, 5, false},\n\t\t{\"/r/foo:bar/baz?page=2\", 2, pager.DefaultPageSize, false},\n\t\t{\"/r/foo:bar/baz?size=3\", 1, 3, false},\n\t\t{\"/r/foo:bar/baz\", 1, pager.DefaultPageSize, false},\n\t\t{\"/r/foo:bar/baz?size=0\u0026page=0\", 1, pager.DefaultPageSize, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tpage, size, err := pager.ParseQuery(tt.rawURL)\n\t\tif tt.expectedError {\n\t\t\tuassert.Error(t, err, ufmt.Sprintf(\"ParseQuery(%s) expected error but got none\", tt.rawURL))\n\t\t} else {\n\t\t\turequire.NoError(t, err, ufmt.Sprintf(\"ParseQuery(%s) returned error: %v\", tt.rawURL, err))\n\t\t\tuassert.Equal(t, tt.expectedPage, page, ufmt.Sprintf(\"ParseQuery(%s) returned page %d, expected %d\", tt.rawURL, page, tt.expectedPage))\n\t\t\tuassert.Equal(t, tt.expectedSize, size, ufmt.Sprintf(\"ParseQuery(%s) returned size %d, expected %d\", tt.rawURL, size, tt.expectedSize))\n\t\t}\n\t}\n}\n"},{"name":"z_filetest.gno","body":"package main\n\nimport (\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/avl/pager\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc main() {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\tvar id seqid.ID\n\ttree := avl.NewTree()\n\tfor i := 0; i \u003c 42; i++ {\n\t\ttree.Set(id.Next().String(), i)\n\t}\n\n\t// Create a new pager.\n\tpager := pager.NewPager(tree, 7, false)\n\n\tfor pn := -1; pn \u003c 8; pn++ {\n\t\tpage := pager.GetPage(pn)\n\n\t\tprintln(ufmt.Sprintf(\"## Page %d of %d\", page.PageNumber, page.TotalPages))\n\t\tfor idx, item := range page.Items {\n\t\t\tprintln(ufmt.Sprintf(\"- idx=%d key=%s value=%d\", idx, item.Key, item.Value))\n\t\t}\n\t\tprintln(page.Picker())\n\t\tprintln()\n\t}\n}\n\n// Output:\n// ## Page 0 of 6\n// _0_ | [1](?page=1) | [2](?page=2) |  | [6](?page=6)\n//\n// ## Page 0 of 6\n// _0_ | [1](?page=1) | [2](?page=2) |  | [6](?page=6)\n//\n// ## Page 1 of 6\n// - idx=0 key=0000001 value=0\n// - idx=1 key=0000002 value=1\n// - idx=2 key=0000003 value=2\n// - idx=3 key=0000004 value=3\n// - idx=4 key=0000005 value=4\n// - idx=5 key=0000006 value=5\n// - idx=6 key=0000007 value=6\n// **1** | [2](?page=2) | [3](?page=3) |  | [6](?page=6)\n//\n// ## Page 2 of 6\n// - idx=0 key=0000008 value=7\n// - idx=1 key=0000009 value=8\n// - idx=2 key=000000a value=9\n// - idx=3 key=000000b value=10\n// - idx=4 key=000000c value=11\n// - idx=5 key=000000d value=12\n// - idx=6 key=000000e value=13\n// [1](?page=1) | **2** | [3](?page=3) | [4](?page=4) |  | [6](?page=6)\n//\n// ## Page 3 of 6\n// - idx=0 key=000000f value=14\n// - idx=1 key=000000g value=15\n// - idx=2 key=000000h value=16\n// - idx=3 key=000000j value=17\n// - idx=4 key=000000k value=18\n// - idx=5 key=000000m value=19\n// - idx=6 key=000000n value=20\n// [1](?page=1) | [2](?page=2) | **3** | [4](?page=4) | [5](?page=5) | [6](?page=6)\n//\n// ## Page 4 of 6\n// - idx=0 key=000000p value=21\n// - idx=1 key=000000q value=22\n// - idx=2 key=000000r value=23\n// - idx=3 key=000000s value=24\n// - idx=4 key=000000t value=25\n// - idx=5 key=000000v value=26\n// - idx=6 key=000000w value=27\n// [1](?page=1) | [2](?page=2) | [3](?page=3) | **4** | [5](?page=5) | [6](?page=6)\n//\n// ## Page 5 of 6\n// - idx=0 key=000000x value=28\n// - idx=1 key=000000y value=29\n// - idx=2 key=000000z value=30\n// - idx=3 key=0000010 value=31\n// - idx=4 key=0000011 value=32\n// - idx=5 key=0000012 value=33\n// - idx=6 key=0000013 value=34\n// [1](?page=1) |  | [3](?page=3) | [4](?page=4) | **5** | [6](?page=6)\n//\n// ## Page 6 of 6\n// - idx=0 key=0000014 value=35\n// - idx=1 key=0000015 value=36\n// - idx=2 key=0000016 value=37\n// - idx=3 key=0000017 value=38\n// - idx=4 key=0000018 value=39\n// - idx=5 key=0000019 value=40\n// - idx=6 key=000001a value=41\n// [1](?page=1) |  | [4](?page=4) | [5](?page=5) | **6**\n//\n// ## Page 7 of 6\n// [1](?page=1) |  | [5](?page=5) | [6](?page=6) | _7_\n//\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"rotree","path":"gno.land/p/demo/avl/rotree","files":[{"name":"rotree.gno","body":"// Package rotree provides a read-only wrapper for avl.Tree with safe value transformation.\n//\n// It is useful when you want to expose a read-only view of a tree while ensuring that\n// the sensitive data cannot be modified.\n//\n// Example:\n//\n//\t// Define a user structure with sensitive data\n//\ttype User struct {\n//\t\tName     string\n//\t\tBalance  int\n//\t\tInternal string // sensitive field\n//\t}\n//\n//\t// Create and populate the original tree\n//\tprivateTree := avl.NewTree()\n//\tprivateTree.Set(\"alice\", \u0026User{\n//\t\tName:     \"Alice\",\n//\t\tBalance:  100,\n//\t\tInternal: \"sensitive\",\n//\t})\n//\n//\t// Create a safe transformation function that copies the struct\n//\t// while excluding sensitive data\n//\tmakeEntrySafeFn := func(v interface{}) interface{} {\n//\t\tu := v.(*User)\n//\t\treturn \u0026User{\n//\t\t\tName:     u.Name,\n//\t\t\tBalance:  u.Balance,\n//\t\t\tInternal: \"\", // omit sensitive data\n//\t\t}\n//\t}\n//\n//\t// Create a read-only view of the tree\n//\tPublicTree := rotree.Wrap(tree, makeEntrySafeFn)\n//\n//\t// Safely access the data\n//\tvalue, _ := roTree.Get(\"alice\")\n//\tuser := value.(*User)\n//\t// user.Name == \"Alice\"\n//\t// user.Balance == 100\n//\t// user.Internal == \"\" (sensitive data is filtered)\npackage rotree\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\n// Wrap creates a new ReadOnlyTree from an existing avl.Tree and a safety transformation function.\n// If makeEntrySafeFn is nil, values will be returned as-is without transformation.\n//\n// makeEntrySafeFn is a function that transforms a tree entry into a safe version that can be exposed to external users.\n// This function should be implemented based on the specific safety requirements of your use case:\n//\n//  1. No-op transformation: For primitive types (int, string, etc.) or already safe objects,\n//     simply pass nil as the makeEntrySafeFn to return values as-is.\n//\n//  2. Defensive copying: For mutable types like slices or maps, you should create a deep copy\n//     to prevent modification of the original data.\n//     Example: func(v interface{}) interface{} { return append([]int{}, v.([]int)...) }\n//\n//  3. Read-only wrapper: Return a read-only version of the object that implements\n//     a limited interface.\n//     Example: func(v interface{}) interface{} { return NewReadOnlyObject(v) }\n//\n//  4. DAO transformation: Transform the object into a data access object that\n//     controls how the underlying data can be accessed.\n//     Example: func(v interface{}) interface{} { return NewDAO(v) }\n//\n// The function ensures that the returned object is safe to expose to untrusted code,\n// preventing unauthorized modifications to the original data structure.\nfunc Wrap(tree *avl.Tree, makeEntrySafeFn func(interface{}) interface{}) *ReadOnlyTree {\n\treturn \u0026ReadOnlyTree{\n\t\ttree:            tree,\n\t\tmakeEntrySafeFn: makeEntrySafeFn,\n\t}\n}\n\n// ReadOnlyTree wraps an avl.Tree and provides read-only access.\ntype ReadOnlyTree struct {\n\ttree            *avl.Tree\n\tmakeEntrySafeFn func(interface{}) interface{}\n}\n\n// Verify that ReadOnlyTree implements ITree\nvar _ avl.ITree = (*ReadOnlyTree)(nil)\n\n// getSafeValue applies the makeEntrySafeFn if it exists, otherwise returns the original value\nfunc (roTree *ReadOnlyTree) getSafeValue(value interface{}) interface{} {\n\tif roTree.makeEntrySafeFn == nil {\n\t\treturn value\n\t}\n\treturn roTree.makeEntrySafeFn(value)\n}\n\n// Size returns the number of key-value pairs in the tree.\nfunc (roTree *ReadOnlyTree) Size() int {\n\treturn roTree.tree.Size()\n}\n\n// Has checks whether a key exists in the tree.\nfunc (roTree *ReadOnlyTree) Has(key string) bool {\n\treturn roTree.tree.Has(key)\n}\n\n// Get retrieves the value associated with the given key, converted to a safe format.\nfunc (roTree *ReadOnlyTree) Get(key string) (interface{}, bool) {\n\tvalue, exists := roTree.tree.Get(key)\n\tif !exists {\n\t\treturn nil, false\n\t}\n\treturn roTree.getSafeValue(value), true\n}\n\n// GetByIndex retrieves the key-value pair at the specified index in the tree, with the value converted to a safe format.\nfunc (roTree *ReadOnlyTree) GetByIndex(index int) (string, interface{}) {\n\tkey, value := roTree.tree.GetByIndex(index)\n\treturn key, roTree.getSafeValue(value)\n}\n\n// Iterate performs an in-order traversal of the tree within the specified key range.\nfunc (roTree *ReadOnlyTree) Iterate(start, end string, cb avl.IterCbFn) bool {\n\treturn roTree.tree.Iterate(start, end, func(key string, value interface{}) bool {\n\t\treturn cb(key, roTree.getSafeValue(value))\n\t})\n}\n\n// ReverseIterate performs a reverse in-order traversal of the tree within the specified key range.\nfunc (roTree *ReadOnlyTree) ReverseIterate(start, end string, cb avl.IterCbFn) bool {\n\treturn roTree.tree.ReverseIterate(start, end, func(key string, value interface{}) bool {\n\t\treturn cb(key, roTree.getSafeValue(value))\n\t})\n}\n\n// IterateByOffset performs an in-order traversal of the tree starting from the specified offset.\nfunc (roTree *ReadOnlyTree) IterateByOffset(offset int, count int, cb avl.IterCbFn) bool {\n\treturn roTree.tree.IterateByOffset(offset, count, func(key string, value interface{}) bool {\n\t\treturn cb(key, roTree.getSafeValue(value))\n\t})\n}\n\n// ReverseIterateByOffset performs a reverse in-order traversal of the tree starting from the specified offset.\nfunc (roTree *ReadOnlyTree) ReverseIterateByOffset(offset int, count int, cb avl.IterCbFn) bool {\n\treturn roTree.tree.ReverseIterateByOffset(offset, count, func(key string, value interface{}) bool {\n\t\treturn cb(key, roTree.getSafeValue(value))\n\t})\n}\n\n// Set is not supported on ReadOnlyTree and will panic.\nfunc (roTree *ReadOnlyTree) Set(key string, value interface{}) bool {\n\tpanic(\"Set operation not supported on ReadOnlyTree\")\n}\n\n// Remove is not supported on ReadOnlyTree and will panic.\nfunc (roTree *ReadOnlyTree) Remove(key string) (value interface{}, removed bool) {\n\tpanic(\"Remove operation not supported on ReadOnlyTree\")\n}\n\n// RemoveByIndex is not supported on ReadOnlyTree and will panic.\nfunc (roTree *ReadOnlyTree) RemoveByIndex(index int) (key string, value interface{}) {\n\tpanic(\"RemoveByIndex operation not supported on ReadOnlyTree\")\n}\n"},{"name":"rotree_test.gno","body":"package rotree\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nfunc TestExample(t *testing.T) {\n\t// User represents our internal data structure\n\ttype User struct {\n\t\tID       string\n\t\tName     string\n\t\tBalance  int\n\t\tInternal string // sensitive internal data\n\t}\n\n\t// Create and populate the original tree with user pointers\n\ttree := avl.NewTree()\n\ttree.Set(\"alice\", \u0026User{\n\t\tID:       \"1\",\n\t\tName:     \"Alice\",\n\t\tBalance:  100,\n\t\tInternal: \"sensitive_data_1\",\n\t})\n\ttree.Set(\"bob\", \u0026User{\n\t\tID:       \"2\",\n\t\tName:     \"Bob\",\n\t\tBalance:  200,\n\t\tInternal: \"sensitive_data_2\",\n\t})\n\n\t// Define a makeEntrySafeFn that:\n\t// 1. Creates a defensive copy of the User struct\n\t// 2. Omits sensitive internal data\n\tmakeEntrySafeFn := func(v interface{}) interface{} {\n\t\toriginalUser := v.(*User)\n\t\treturn \u0026User{\n\t\t\tID:       originalUser.ID,\n\t\t\tName:     originalUser.Name,\n\t\t\tBalance:  originalUser.Balance,\n\t\t\tInternal: \"\", // Omit sensitive data\n\t\t}\n\t}\n\n\t// Create a read-only view of the tree\n\troTree := Wrap(tree, makeEntrySafeFn)\n\n\t// Test retrieving and verifying a user\n\tt.Run(\"Get User\", func(t *testing.T) {\n\t\t// Get user from read-only tree\n\t\tvalue, exists := roTree.Get(\"alice\")\n\t\tif !exists {\n\t\t\tt.Fatal(\"User 'alice' not found\")\n\t\t}\n\n\t\tuser := value.(*User)\n\n\t\t// Verify user data is correct\n\t\tif user.Name != \"Alice\" || user.Balance != 100 {\n\t\t\tt.Errorf(\"Unexpected user data: got name=%s balance=%d\", user.Name, user.Balance)\n\t\t}\n\n\t\t// Verify sensitive data is not exposed\n\t\tif user.Internal != \"\" {\n\t\t\tt.Error(\"Sensitive data should not be exposed\")\n\t\t}\n\n\t\t// Verify it's a different instance than the original\n\t\toriginalValue, _ := tree.Get(\"alice\")\n\t\toriginalUser := originalValue.(*User)\n\t\tif user == originalUser {\n\t\t\tt.Error(\"Read-only tree should return a copy, not the original pointer\")\n\t\t}\n\t})\n\n\t// Test iterating over users\n\tt.Run(\"Iterate Users\", func(t *testing.T) {\n\t\tcount := 0\n\t\troTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tuser := value.(*User)\n\t\t\t// Verify each user has empty Internal field\n\t\t\tif user.Internal != \"\" {\n\t\t\t\tt.Error(\"Sensitive data exposed during iteration\")\n\t\t\t}\n\t\t\tcount++\n\t\t\treturn false\n\t\t})\n\n\t\tif count != 2 {\n\t\t\tt.Errorf(\"Expected 2 users, got %d\", count)\n\t\t}\n\t})\n\n\t// Verify that modifications to the returned user don't affect the original\n\tt.Run(\"Modification Safety\", func(t *testing.T) {\n\t\tvalue, _ := roTree.Get(\"alice\")\n\t\tuser := value.(*User)\n\n\t\t// Try to modify the returned user\n\t\tuser.Balance = 999\n\t\tuser.Internal = \"hacked\"\n\n\t\t// Verify original is unchanged\n\t\toriginalValue, _ := tree.Get(\"alice\")\n\t\toriginalUser := originalValue.(*User)\n\t\tif originalUser.Balance != 100 || originalUser.Internal != \"sensitive_data_1\" {\n\t\t\tt.Error(\"Original user data was modified\")\n\t\t}\n\t})\n}\n\nfunc TestReadOnlyTree(t *testing.T) {\n\t// Example of a makeEntrySafeFn that appends \"_readonly\" to demonstrate transformation\n\tmakeEntrySafeFn := func(value interface{}) interface{} {\n\t\treturn value.(string) + \"_readonly\"\n\t}\n\n\ttree := avl.NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\troTree := Wrap(tree, makeEntrySafeFn)\n\n\ttests := []struct {\n\t\tname     string\n\t\tkey      string\n\t\texpected interface{}\n\t\texists   bool\n\t}{\n\t\t{\"ExistingKey1\", \"key1\", \"value1_readonly\", true},\n\t\t{\"ExistingKey2\", \"key2\", \"value2_readonly\", true},\n\t\t{\"NonExistingKey\", \"key4\", nil, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvalue, exists := roTree.Get(tt.key)\n\t\t\tif exists != tt.exists || value != tt.expected {\n\t\t\t\tt.Errorf(\"For key %s, expected %v (exists: %v), got %v (exists: %v)\", tt.key, tt.expected, tt.exists, value, exists)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Add example tests showing different makeEntrySafeFn implementations\nfunc TestMakeEntrySafeFnVariants(t *testing.T) {\n\ttree := avl.NewTree()\n\ttree.Set(\"slice\", []int{1, 2, 3})\n\ttree.Set(\"map\", map[string]int{\"a\": 1})\n\n\ttests := []struct {\n\t\tname            string\n\t\tmakeEntrySafeFn func(interface{}) interface{}\n\t\tkey             string\n\t\tvalidate        func(t *testing.T, value interface{})\n\t}{\n\t\t{\n\t\t\tname: \"Defensive Copy Slice\",\n\t\t\tmakeEntrySafeFn: func(v interface{}) interface{} {\n\t\t\t\toriginal := v.([]int)\n\t\t\t\treturn append([]int{}, original...)\n\t\t\t},\n\t\t\tkey: \"slice\",\n\t\t\tvalidate: func(t *testing.T, value interface{}) {\n\t\t\t\tslice := value.([]int)\n\t\t\t\t// Modify the returned slice\n\t\t\t\tslice[0] = 999\n\t\t\t\t// Verify original is unchanged\n\t\t\t\toriginalValue, _ := tree.Get(\"slice\")\n\t\t\t\toriginal := originalValue.([]int)\n\t\t\t\tif original[0] != 1 {\n\t\t\t\t\tt.Error(\"Original slice was modified\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t// Add more test cases for different makeEntrySafeFn implementations\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\troTree := Wrap(tree, tt.makeEntrySafeFn)\n\t\t\tvalue, exists := roTree.Get(tt.key)\n\t\t\tif !exists {\n\t\t\t\tt.Fatal(\"Key not found\")\n\t\t\t}\n\t\t\ttt.validate(t, value)\n\t\t})\n\t}\n}\n\nfunc TestNilMakeEntrySafeFn(t *testing.T) {\n\t// Create a tree with some test data\n\ttree := avl.NewTree()\n\toriginalValue := []int{1, 2, 3}\n\ttree.Set(\"test\", originalValue)\n\n\t// Create a ReadOnlyTree with nil makeEntrySafeFn\n\troTree := Wrap(tree, nil)\n\n\t// Test that we get back the original value\n\tvalue, exists := roTree.Get(\"test\")\n\tif !exists {\n\t\tt.Fatal(\"Key not found\")\n\t}\n\n\t// Verify it's the exact same slice (not a copy)\n\tretrievedSlice := value.([]int)\n\tif \u0026retrievedSlice[0] != \u0026originalValue[0] {\n\t\tt.Error(\"Expected to get back the original slice reference\")\n\t}\n\n\t// Test through iteration as well\n\troTree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tretrievedSlice := value.([]int)\n\t\tif \u0026retrievedSlice[0] != \u0026originalValue[0] {\n\t\t\tt.Error(\"Expected to get back the original slice reference in iteration\")\n\t\t}\n\t\treturn false\n\t})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"storage","path":"gno.land/r/x/benchmark/storage","files":[{"name":"boards.gno","body":"package storage\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nvar boards avl.Tree\n\ntype Board interface {\n\tAddPost(title, content string)\n\tGetPost(id int) (Post, bool)\n\tSize() int\n}\n\n// posts are persisted in an avl tree\ntype TreeBoard struct {\n\tid    int\n\tposts *avl.Tree\n}\n\nfunc (b *TreeBoard) AddPost(title, content string) {\n\tn := b.posts.Size()\n\tp := Post{n, title, content}\n\tb.posts.Set(strconv.Itoa(n), p)\n}\n\nfunc (b *TreeBoard) GetPost(id int) (Post, bool) {\n\tp, ok := b.posts.Get(strconv.Itoa(id))\n\tif ok {\n\t\treturn p.(Post), ok\n\t} else {\n\t\treturn Post{}, ok\n\t}\n}\n\nfunc (b *TreeBoard) Size() int {\n\treturn b.posts.Size()\n}\n\n// posts are persisted in a map\ntype MapBoard struct {\n\tid    int\n\tposts map[int]Post\n}\n\nfunc (b *MapBoard) AddPost(title, content string) {\n\tn := len(b.posts)\n\tp := Post{n, title, content}\n\tb.posts[n] = p\n}\n\nfunc (b *MapBoard) GetPost(id int) (Post, bool) {\n\tp, ok := b.posts[id]\n\tif ok {\n\t\treturn p, ok\n\t} else {\n\t\treturn Post{}, ok\n\t}\n}\n\nfunc (b *MapBoard) Size() int {\n\treturn len(b.posts)\n}\n\n// posts are persisted in a slice\ntype SliceBoard struct {\n\tid    int\n\tposts []Post\n}\n\nfunc (b *SliceBoard) AddPost(title, content string) {\n\tn := len(b.posts)\n\tp := Post{n, title, content}\n\tb.posts = append(b.posts, p)\n}\n\nfunc (b *SliceBoard) GetPost(id int) (Post, bool) {\n\tif id \u003c len(b.posts) {\n\t\tp := b.posts[id]\n\n\t\treturn p, true\n\t} else {\n\t\treturn Post{}, false\n\t}\n}\n\nfunc (b *SliceBoard) Size() int {\n\treturn len(b.posts)\n}\n\ntype Post struct {\n\tid      int\n\ttitle   string\n\tcontent string\n}\n"},{"name":"forum.gno","body":"package storage\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nfunc init() {\n\t// we write to three common data structure for persistence\n\t// avl.Tree, map and slice.\n\tposts0 := avl.NewTree()\n\tb0 := \u0026TreeBoard{0, posts0}\n\tboards.Set(strconv.Itoa(0), b0)\n\n\tposts1 := make(map[int]Post)\n\tb1 := \u0026MapBoard{1, posts1}\n\tboards.Set(strconv.Itoa(1), b1)\n\n\tposts2 := []Post{}\n\tb2 := \u0026SliceBoard{2, posts2}\n\tboards.Set(strconv.Itoa(2), b2)\n}\n\n// post to all boards.\nfunc AddPost(title, content string) {\n\tfor i := 0; i \u003c boards.Size(); i++ {\n\t\tboardId := strconv.Itoa(i)\n\t\tb, ok := boards.Get(boardId)\n\t\tif ok {\n\t\t\tb.(Board).AddPost(title, content)\n\t\t}\n\t}\n}\n\nfunc GetPost(boardId, postId int) string {\n\tb, ok := boards.Get(strconv.Itoa(boardId))\n\tvar res string\n\n\tif ok {\n\t\tp, ok := b.(Board).GetPost(postId)\n\t\tif ok {\n\t\t\tres = p.title + \",\" + p.content\n\t\t}\n\t}\n\treturn res\n}\n\nfunc GetPostSize(boardId int) int {\n\tb, ok := boards.Get(strconv.Itoa(boardId))\n\tvar res int\n\n\tif ok {\n\t\tres = b.(Board).Size()\n\t} else {\n\t\tres = -1\n\t}\n\n\treturn res\n}\n\nfunc GetBoardSize() int {\n\treturn boards.Size()\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"users","path":"gno.land/r/demo/users","files":[{"name":"preregister.gno","body":"package users\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/users\"\n)\n\n// pre-restricted names\nvar preRestrictedNames = []string{\n\t\"bitcoin\", \"cosmos\", \"newtendermint\", \"ethereum\",\n}\n\n// pre-registered users\nvar preRegisteredUsers = []struct {\n\tName    string\n\tAddress std.Address\n}{\n\t// system name\n\t{\"archives\", \"g1xlnyjrnf03ju82v0f98ruhpgnquk28knmjfe5k\"}, // -\u003e @r_archives\n\t{\"demo\", \"g13ek2zz9qurzynzvssyc4sthwppnruhnp0gdz8n\"},     // -\u003e @r_demo\n\t{\"gno\", \"g19602kd9tfxrfd60sgreadt9zvdyyuudcyxsz8a\"},      // -\u003e @r_gno\n\t{\"gnoland\", \"g1g3lsfxhvaqgdv4ccemwpnms4fv6t3aq3p5z6u7\"},  // -\u003e @r_gnoland\n\t{\"gnolang\", \"g1yjlnm3z2630gg5mryjd79907e0zx658wxs9hnd\"},  // -\u003e @r_gnolang\n\t{\"gov\", \"g1g73v2anukg4ej7axwqpthsatzrxjsh0wk797da\"},      // -\u003e @r_gov\n\t{\"nt\", \"g15ge0ae9077eh40erwrn2eq0xw6wupwqthpv34l\"},       // -\u003e @r_nt\n\t{\"sys\", \"g1r929wt2qplfawe4lvqv9zuwfdcz4vxdun7qh8l\"},      // -\u003e @r_sys\n\t{\"x\", \"g164sdpew3c2t3rvxj3kmfv7c7ujlvcw2punzzuz\"},        // -\u003e @r_x\n\n\t// test1 user\n\t{\"test1\", \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"}, // -\u003e @test1\n}\n\nfunc init() {\n\t// add pre-registered users\n\tfor _, res := range preRegisteredUsers {\n\t\t// assert not already registered.\n\t\t_, ok := name2User.Get(res.Name)\n\t\tif ok {\n\t\t\tpanic(\"name already registered\")\n\t\t}\n\n\t\t_, ok = addr2User.Get(res.Address.String())\n\t\tif ok {\n\t\t\tpanic(\"address already registered\")\n\t\t}\n\n\t\tcounter++\n\t\tuser := \u0026users.User{\n\t\t\tAddress: res.Address,\n\t\t\tName:    res.Name,\n\t\t\tProfile: \"\",\n\t\t\tNumber:  counter,\n\t\t\tInvites: int(0),\n\t\t\tInviter: admin,\n\t\t}\n\t\tname2User.Set(res.Name, user)\n\t\taddr2User.Set(res.Address.String(), user)\n\t}\n\n\t// add pre-restricted names\n\tfor _, name := range preRestrictedNames {\n\t\tif _, ok := name2User.Get(name); ok {\n\t\t\tpanic(\"name already registered\")\n\t\t}\n\n\t\trestricted.Set(name, true)\n\t}\n}\n"},{"name":"users.gno","body":"package users\n\nimport (\n\t\"regexp\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/avl/pager\"\n\t\"gno.land/p/demo/avlhelpers\"\n\t\"gno.land/p/demo/users\"\n)\n\n//----------------------------------------\n// State\n\nvar (\n\tadmin std.Address = \"g1manfred47kzduec920z88wfr64ylksmdcedlf5\" // @moul\n\n\trestricted avl.Tree                  // Name -\u003e true - restricted name\n\tname2User  avl.Tree                  // Name -\u003e *users.User\n\taddr2User  avl.Tree                  // std.Address -\u003e *users.User\n\tinvites    avl.Tree                  // string(inviter+\":\"+invited) -\u003e true\n\tcounter    int                       // user id counter\n\tminFee     int64    = 20 * 1_000_000 // minimum gnot must be paid to register.\n\tmaxFeeMult int64    = 10             // maximum multiples of minFee accepted.\n)\n\n//----------------------------------------\n// Top-level functions\n\nfunc Register(inviter std.Address, name string, profile string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert invited or paid.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\n\tsentCoins := std.GetOrigSend()\n\tminCoin := std.NewCoin(\"ugnot\", minFee)\n\n\tif inviter == \"\" {\n\t\t// banker := std.GetBanker(std.BankerTypeOrigSend)\n\t\tif len(sentCoins) == 1 \u0026\u0026 sentCoins[0].IsGTE(minCoin) {\n\t\t\tif sentCoins[0].Amount \u003e minFee*maxFeeMult {\n\t\t\t\tpanic(\"payment must not be greater than \" + strconv.Itoa(int(minFee*maxFeeMult)))\n\t\t\t} else {\n\t\t\t\t// ok\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(\"payment must not be less than \" + strconv.Itoa(int(minFee)))\n\t\t}\n\t} else {\n\t\tinvitekey := inviter.String() + \":\" + caller.String()\n\t\t_, ok := invites.Get(invitekey)\n\t\tif !ok {\n\t\t\tpanic(\"invalid invitation\")\n\t\t}\n\t\tinvites.Remove(invitekey)\n\t}\n\n\t// assert not already registered.\n\t_, ok := name2User.Get(name)\n\tif ok {\n\t\tpanic(\"name already registered: \" + name)\n\t}\n\t_, ok = addr2User.Get(caller.String())\n\tif ok {\n\t\tpanic(\"address already registered: \" + caller.String())\n\t}\n\n\tisInviterAdmin := inviter == admin\n\n\t// check for restricted name\n\tif _, isRestricted := restricted.Get(name); isRestricted {\n\t\t// only address invite by the admin can register restricted name\n\t\tif !isInviterAdmin {\n\t\t\tpanic(\"restricted name: \" + name)\n\t\t}\n\n\t\trestricted.Remove(name)\n\t}\n\n\t// assert name is valid.\n\t// admin inviter can bypass name restriction\n\tif !isInviterAdmin \u0026\u0026 !reName.MatchString(name) {\n\t\tpanic(\"invalid name: \" + name + \" (must be at least 6 characters, lowercase alphanumeric with underscore)\")\n\t}\n\n\t// remainder of fees go toward invites.\n\tinvites := int(0)\n\tif len(sentCoins) == 1 {\n\t\tif sentCoins[0].Denom == \"ugnot\" \u0026\u0026 sentCoins[0].Amount \u003e= minFee {\n\t\t\tinvites = int(sentCoins[0].Amount / minFee)\n\t\t\tif inviter == \"\" \u0026\u0026 invites \u003e 0 {\n\t\t\t\tinvites -= 1\n\t\t\t}\n\t\t}\n\t}\n\t// register.\n\tcounter++\n\tuser := \u0026users.User{\n\t\tAddress: caller,\n\t\tName:    name,\n\t\tProfile: profile,\n\t\tNumber:  counter,\n\t\tInvites: invites,\n\t\tInviter: inviter,\n\t}\n\tname2User.Set(name, user)\n\taddr2User.Set(caller.String(), user)\n}\n\nfunc Invite(invitee string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// get caller/inviter.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\tlines := strings.Split(invitee, \"\\n\")\n\tif caller == admin {\n\t\t// nothing to do, all good\n\t} else {\n\t\t// ensure has invites.\n\t\tuserI, ok := addr2User.Get(caller.String())\n\t\tif !ok {\n\t\t\tpanic(\"user unknown\")\n\t\t}\n\t\tuser := userI.(*users.User)\n\t\tif user.Invites \u003c= 0 {\n\t\t\tpanic(\"user has no invite tokens\")\n\t\t}\n\t\tuser.Invites -= len(lines)\n\t\tif user.Invites \u003c 0 {\n\t\t\tpanic(\"user has insufficient invite tokens\")\n\t\t}\n\t}\n\t// for each line...\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue // file bodies have a trailing newline.\n\t\t} else if strings.HasPrefix(line, `//`) {\n\t\t\tcontinue // comment\n\t\t}\n\t\t// record invite.\n\t\tinvitekey := string(caller) + \":\" + string(line)\n\t\tinvites.Set(invitekey, true)\n\t}\n}\n\nfunc GrantInvites(invites string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// for each line...\n\tlines := strings.Split(invites, \"\\n\")\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue // file bodies have a trailing newline.\n\t\t} else if strings.HasPrefix(line, `//`) {\n\t\t\tcontinue // comment\n\t\t}\n\t\t// parse name and invites.\n\t\tvar name string\n\t\tvar invites int\n\t\tparts := strings.Split(line, \":\")\n\t\tif len(parts) == 1 { // short for :1.\n\t\t\tname = parts[0]\n\t\t\tinvites = 1\n\t\t} else if len(parts) == 2 {\n\t\t\tname = parts[0]\n\t\t\tinvites_, err := strconv.Atoi(parts[1])\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tinvites = int(invites_)\n\t\t} else {\n\t\t\tpanic(\"should not happen\")\n\t\t}\n\t\t// give invites.\n\t\tuserI, ok := name2User.Get(name)\n\t\tif !ok {\n\t\t\t// maybe address.\n\t\t\tuserI, ok = addr2User.Get(name)\n\t\t\tif !ok {\n\t\t\t\tpanic(\"invalid user \" + name)\n\t\t\t}\n\t\t}\n\t\tuser := userI.(*users.User)\n\t\tuser.Invites += invites\n\t}\n}\n\n// Any leftover fees go toward invitations.\nfunc SetMinFee(newMinFee int64) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin caller.\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// update global variables.\n\tminFee = newMinFee\n}\n\n// This helps prevent fat finger accidents.\nfunc SetMaxFeeMultiple(newMaxFeeMult int64) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin caller.\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// update global variables.\n\tmaxFeeMult = newMaxFeeMult\n}\n\n//----------------------------------------\n// Exposed public functions\n\nfunc GetUserByName(name string) *users.User {\n\tuserI, ok := name2User.Get(name)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn userI.(*users.User)\n}\n\nfunc GetUserByAddress(addr std.Address) *users.User {\n\tuserI, ok := addr2User.Get(addr.String())\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn userI.(*users.User)\n}\n\n// unlike GetUserByName, input must be \"@\" prefixed for names.\nfunc GetUserByAddressOrName(input users.AddressOrName) *users.User {\n\tname, isName := input.GetName()\n\tif isName {\n\t\treturn GetUserByName(name)\n\t}\n\treturn GetUserByAddress(std.Address(input))\n}\n\n// Get a list of user names starting from the given prefix. Limit the\n// number of results to maxResults. (This can be used for a name search tool.)\nfunc ListUsersByPrefix(prefix string, maxResults int) []string {\n\treturn avlhelpers.ListByteStringKeysByPrefix(\u0026name2User, prefix, maxResults)\n}\n\nfunc Resolve(input users.AddressOrName) std.Address {\n\tname, isName := input.GetName()\n\tif !isName {\n\t\treturn std.Address(input) // TODO check validity\n\t}\n\n\tuser := GetUserByName(name)\n\treturn user.Address\n}\n\n// Add restricted name to the list\nfunc AdminAddRestrictedName(name string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// get caller\n\tcaller := std.GetOrigCaller()\n\t// assert admin\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\n\tif user := GetUserByName(name); user != nil {\n\t\tpanic(\"already registered name\")\n\t}\n\n\t// register restricted name\n\n\trestricted.Set(name, true)\n}\n\n//----------------------------------------\n// Constants\n\n// NOTE: name length must be clearly distinguishable from a bech32 address.\nvar reName = regexp.MustCompile(`^[a-z]+[_a-z0-9]{5,16}$`)\n\n//----------------------------------------\n// Render main page\n\nfunc Render(fullPath string) string {\n\tpath, _ := splitPathAndQuery(fullPath)\n\tif path == \"\" {\n\t\treturn renderHome(fullPath)\n\t} else if len(path) \u003e= 38 { // 39? 40?\n\t\tif path[:2] != \"g1\" {\n\t\t\treturn \"invalid address \" + path\n\t\t}\n\t\tuser := GetUserByAddress(std.Address(path))\n\t\tif user == nil {\n\t\t\t// TODO: display basic information about account.\n\t\t\treturn \"unknown address \" + path\n\t\t}\n\t\treturn user.Render()\n\t} else {\n\t\tuser := GetUserByName(path)\n\t\tif user == nil {\n\t\t\treturn \"unknown username \" + path\n\t\t}\n\t\treturn user.Render()\n\t}\n}\n\nfunc renderHome(path string) string {\n\tdoc := \"\"\n\n\tpage := pager.NewPager(\u0026name2User, 50, false).MustGetPageByPath(path)\n\n\tfor _, item := range page.Items {\n\t\tuser := item.Value.(*users.User)\n\t\tdoc += \" * [\" + user.Name + \"](/r/demo/users:\" + user.Name + \")\\n\"\n\t}\n\tdoc += \"\\n\"\n\tdoc += page.Picker()\n\treturn doc\n}\n\nfunc splitPathAndQuery(fullPath string) (string, string) {\n\tparts := strings.SplitN(fullPath, \"?\", 2)\n\tpath := parts[0]\n\tqueryString := \"\"\n\tif len(parts) \u003e 1 {\n\t\tqueryString = \"?\" + parts[1]\n\t}\n\treturn path, queryString\n}\n"},{"name":"users_test.gno","body":"package users\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestPreRegisteredTest1(t *testing.T) {\n\tnames := ListUsersByPrefix(\"test1\", 1)\n\tuassert.Equal(t, len(names), 1)\n\tuassert.Equal(t, names[0], \"test1\")\n}\n"},{"name":"z_0_b_filetest.gno","body":"package main\n\n// SEND: 19900000ugnot\n\nimport (\n\t\"gno.land/r/demo/users\"\n)\n\nfunc main() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tprintln(\"done\")\n}\n\n// Error:\n// payment must not be less than 20000000\n"},{"name":"z_0_filetest.gno","body":"package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nfunc main() {\n\tstd.TestSetOrigSend(std.Coins{std.NewCoin(\"dontcare\", 1)}, nil)\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tprintln(\"done\")\n}\n\n// Error:\n// incompatible coin denominations: dontcare, ugnot\n"},{"name":"z_10_filetest.gno","body":"// PKGPATH: gno.land/r/demo/users_test\npackage users_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc init() {\n\tcaller := std.GetOrigCaller() // main\n\ttest2 := testutils.TestAddress(\"test2\")\n\t// as admin, invite gnouser and test2\n\tstd.TestSetOrigCaller(admin)\n\tusers.Invite(caller.String() + \"\\n\" + test2.String())\n\t// register as caller\n\tstd.TestSetOrigCaller(caller)\n\tusers.Register(admin, \"gnouser\", \"my profile\")\n}\n\nfunc main() {\n\t// register as test2\n\ttest2 := testutils.TestAddress(\"test2\")\n\tstd.TestSetOrigCaller(test2)\n\tusers.Register(admin, \"test222\", \"my profile 2\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"},{"name":"z_11_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tstd.TestSetOrigCaller(admin)\n\tusers.AdminAddRestrictedName(\"superrestricted\")\n\n\t// test restricted name\n\tstd.TestSetOrigCaller(caller)\n\tusers.Register(\"\", \"superrestricted\", \"my profile\")\n\tprintln(\"done\")\n}\n\n// Error:\n// restricted name: superrestricted\n"},{"name":"z_11b_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tstd.TestSetOrigCaller(admin)\n\t// add restricted name\n\tusers.AdminAddRestrictedName(\"superrestricted\")\n\t// grant invite to caller\n\tusers.Invite(caller.String())\n\t// set back caller\n\tstd.TestSetOrigCaller(caller)\n\t// register restricted name with admin invite\n\tusers.Register(admin, \"superrestricted\", \"my profile\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"},{"name":"z_12_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nfunc main() {\n\tusers.Register(\"\", \"alicia\", \"my profile\")\n\n\t{\n\t\t// Normal usage\n\t\tnames := users.ListUsersByPrefix(\"a\", 1)\n\t\tprintln(\"# names: \" + strconv.Itoa(len(names)))\n\t\tprintln(\"name: \" + names[0])\n\t}\n\n\t{\n\t\t// Empty prefix: match all\n\t\tnames := users.ListUsersByPrefix(\"\", 1)\n\t\tprintln(\"# names: \" + strconv.Itoa(len(names)))\n\t\tprintln(\"name: \" + names[0])\n\t}\n\n\t{\n\t\t// The prefix is before \"alicia\"\n\t\tnames := users.ListUsersByPrefix(\"alich\", 1)\n\t\tprintln(\"# names: \" + strconv.Itoa(len(names)))\n\t}\n\n\t{\n\t\t// The prefix is after the last name\n\t\tnames := users.ListUsersByPrefix(\"y\", 10)\n\t\tprintln(\"# names: \" + strconv.Itoa(len(names)))\n\t}\n\n\t// More tests are in p/demo/avlhelpers\n}\n\n// Output:\n// # names: 1\n// name: alicia\n// # names: 1\n// name: alicia\n// # names: 0\n// # names: 0\n"},{"name":"z_13_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nfunc main() {\n\t{\n\t\t// Verify pre-registered test1 user\n\t\tnames := users.ListUsersByPrefix(\"test1\", 1)\n\t\tprintln(\"# names: \" + strconv.Itoa(len(names)))\n\t\tprintln(\"name: \" + names[0])\n\t}\n}\n\n// Output:\n// # names: 1\n// name: test1\n"},{"name":"z_1_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"gno.land/r/demo/users\"\n)\n\nfunc main() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"},{"name":"z_2_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"},{"name":"z_3_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"},{"name":"z_4_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\ttest2 := testutils.TestAddress(\"test2\")\n\tusers.Invite(test1.String())\n\t// switch to test2 (not test1)\n\tstd.TestSetOrigCaller(test2)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\tprintln(\"done\")\n}\n\n// Error:\n// invalid invitation\n"},{"name":"z_5_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\tprintln(users.Render(\"\"))\n\tprintln(\"========================================\")\n\tprintln(users.Render(\"?page=2\"))\n\tprintln(\"========================================\")\n\tprintln(users.Render(\"gnouser\"))\n\tprintln(\"========================================\")\n\tprintln(users.Render(\"satoshi\"))\n\tprintln(\"========================================\")\n\tprintln(users.Render(\"badname\"))\n}\n\n// Output:\n//  * [archives](/r/demo/users:archives)\n//  * [demo](/r/demo/users:demo)\n//  * [gno](/r/demo/users:gno)\n//  * [gnoland](/r/demo/users:gnoland)\n//  * [gnolang](/r/demo/users:gnolang)\n//  * [gnouser](/r/demo/users:gnouser)\n//  * [gov](/r/demo/users:gov)\n//  * [nt](/r/demo/users:nt)\n//  * [satoshi](/r/demo/users:satoshi)\n//  * [sys](/r/demo/users:sys)\n//  * [test1](/r/demo/users:test1)\n//  * [x](/r/demo/users:x)\n//\n//\n// ========================================\n//\n//\n// ========================================\n// ## user gnouser\n//\n//  * address = g1wymu47drhr0kuq2098m792lytgtj2nyx77yrsm\n//  * 9 invites\n//\n// my profile\n//\n// ========================================\n// ## user satoshi\n//\n//  * address = g1w3jhxap3ta047h6lta047h6lta047h6l4mfnm7\n//  * 0 invites\n//  * invited by g1wymu47drhr0kuq2098m792lytgtj2nyx77yrsm\n//\n// my other profile\n//\n// ========================================\n// unknown username badname\n"},{"name":"z_6_filetest.gno","body":"package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller()\n\t// as admin, grant invites to unregistered user.\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\tprintln(\"done\")\n}\n\n// Error:\n// invalid user g1wymu47drhr0kuq2098m792lytgtj2nyx77yrsm\n"},{"name":"z_7_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\t// as admin, grant invites to gnouser(again) and satoshi.\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\\n\" + test1.String() + \":1\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"},{"name":"z_7b_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\\n\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\t// as admin, grant invites to gnouser(again) and satoshi.\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\\n\" + test1.String() + \":1\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"},{"name":"z_8_filetest.gno","body":"package main\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\t// as admin, grant invites to gnouser(again) and nonexistent user.\n\tstd.TestSetOrigCaller(admin)\n\ttest2 := testutils.TestAddress(\"test2\")\n\tusers.GrantInvites(caller.String() + \":1\\n\" + test2.String() + \":1\")\n\tprintln(\"done\")\n}\n\n// Error:\n// invalid user g1w3jhxapjta047h6lta047h6lta047h6laqcyu4\n"},{"name":"z_9_filetest.gno","body":"package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1manfred47kzduec920z88wfr64ylksmdcedlf5\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\ttest2 := testutils.TestAddress(\"test2\")\n\t// as admin, invite gnouser and test2\n\tstd.TestSetOrigCaller(admin)\n\tusers.Invite(caller.String() + \"\\n\" + test2.String())\n\t// register as caller\n\tstd.TestSetOrigCaller(caller)\n\tusers.Register(admin, \"gnouser\", \"my profile\")\n\t// register as test2\n\tstd.TestSetOrigCaller(test2)\n\tusers.Register(admin, \"test222\", \"my profile 2\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g16w0tyhp6h6npxhjuhjra5levddhjfwfcz8te7e","send":"","pkg_path":"gno.land/r/demo/memeland","func":"Upvote","args":["000000w"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ay6C7JCuWj9+4StDMf++T6bAUh7kRbrnsG5mX7aX0n/l"},"signature":"iLJsq3BAUPOD0ggRpWrEgzNhllFmiHuWVydBaUmHnhcUa/7ZG0YIiUIJPyUR3lACprrEv5WKn1Q5YgHEI8ktXQ=="}],"memo":""},"metadata":{"timestamp":"1734563386"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"Vote","args":["10","true","",""]}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"vRHKkRKxFk9nZynTuC8wAFBB+AozfS47NfyUqZ7kpEJ0gX3AY66009Umh0aUZxf17nA9IkyHiOfAZulv1MKOqg=="}],"memo":""},"metadata":{"timestamp":"1734609622"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"Vote","args":["10","true","",""]}],"fee":{"gas_wanted":"1400000","gas_fee":"1400000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"JgMnFFGZFP5UTFLEkIZ776+gcl8csR+oE0+mx7XZXdhhXzbGacCiCqe0to9yVd+MKokZ9C2upKVMFfhOXZoLaw=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734544764"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/space/v1rc1","func":"SubmitEditorsModificationProposal","args":["Add editors to space news","Add 3 editors to the Gnome Space news section","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\ng1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"9783795ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"Wi/0Eqhs6hwk9dsUAR5Un36LuMjLtwVRSvLLk8XtanRvl0ZeXlWRsykdFpBPnhNjKERdMVxIXRPxrBGl30eZyA=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734531914"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/space/v1rc1","func":"SubmitEditorsModificationProposal","args":["Add editors to space news","Add 3 editors to the Gnome Space news section","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\ng1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"9783795ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"um/socpb7Kn7rpeuvf1Wbsp7PLALFDUZdqGPPdScxd1OIfxG8UGJeDJbZCMfqUSp3WhRKOhok/79K5l83+vkcA=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734531974"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/space/v1rc1","func":"SubmitEditorsModificationProposal","args":["Add members","Add 3 members to Gnome Space news to edit news section","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\ng1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2\ng1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"B21sM+8SAtCKUWk03qrMcpRec9onongQ4Q0tHa3ZoMASi7pW9KCjm1ngzIkzkH/8+CQMV5X929SiBMpCBfpSLw=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734532115"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial ","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"1300000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"4J6+pFGM5YPe9WtrH8kWhd+EwnCXc/zJblCwZjIm9B1475iu2vyj3EMxmWZKuj60MyLVNGbFWDPefeMpwvr3hQ=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734538939"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial ","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"1300000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"UdxjizIwsgLkhaOqB2C5NF4rwYmjk/s4ugU04inhiqVxYTGOnwPA2eMrcqqSnHFo4lwuzIHFf0RaK9JYVnp4kg=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734533164"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial ","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"1300000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"fBkhtq9mNO/oGshlZknBvQKm5DVOV36yA6808BY9miBKno6dNy98/ly9H5POuTg7bX5CpFG5TmGRFYOtd0lWzA=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734533541"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial ","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"15000000","gas_fee":"1500000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"1n2FMXA/QTD1hnJQd646thqjmxqVneRW/XZn5JXZrBdjBjqlytFzau5Js9R5EQq4wcngYZlZ3/4pPRUdWixDug=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734533320"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial ","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"1600000","gas_fee":"1600000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"UizLcYKBWb526VM2VHqCHZuFMfJx82AvBumM6roVstZ81fiSjNnlvZ3iAcSrmmsK1JJk92WRgwJ89WWUop5tTw=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734539039"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial ","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"1650000","gas_fee":"1650000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"LEmd6XAMyRGlDShmJU3PBx0cC1wucOqeP41Hng1zU7cZz7EuKLvVBCl5LzL3qcFaoTIi5Da6B/yTgZD2E/amRQ=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734539115"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial ","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"3000000","gas_fee":"3000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7MWSLkjf+z/CYfMh6KVHEaHLDWpnfGBRDqFO81j1FRN"},"signature":"vBm9y3bAbZLyWN96AQE9j/BTVU+Zs9Pwv1IP8OUXztYJB+k6SRUltf6Nd6n+OtmCE3XNqe8riaY2wCQ3Dyy8Pg=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734539190"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"AdvanceProposals","args":null}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"rm1G6mTneDzzYzGyDVdn6/6NOG//UtjlPXBjM43D/vs/pAAPdzgxX9ZZ91+XCmDDD/l0Rr5APk590xpgG29Pqw=="}],"memo":""},"metadata":{"timestamp":"1734628647"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"AdvanceProposals","args":null}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"vIhdcSVOq3dxOqitBwanv3oNb3fC2StGzKVCGPUqm+4Wo9IbWd5m2Ky8gJnZyKaTE4DkrAEgN7tjIgwbqPQrPg=="}],"memo":""},"metadata":{"timestamp":"1734544428"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"Vote","args":["10","true","",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"W+jhVodwfuQtGXtl5ka+Dn5KQY7EHGguQ6Crj+24+ypcHorGYovBIX45Ihd6xOTVJVVlj/WyQOtn2gRYZyGBLQ=="}],"memo":""},"metadata":{"timestamp":"1734538818"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"Vote","args":["10","true","",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"1200000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"JIntZd2IXRjVdplgp3d3h8v0zmA7uW89eEdyGeviWfpJznKSZ6SaECVxJVCXFs+n5tLzjMQd29vb9J0tt13GRA=="}],"memo":""},"metadata":{"timestamp":"1734538838"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"Vote","args":["10","true","",""]}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"TxgihsgaXKnh2QSMp8yslWyt/VAMoDr3J6UlPrTNoKAWZX3/JtrO9lf86aHz0ZBmMR0oadhvHAFM8ljlmqLBNA=="}],"memo":""},"metadata":{"timestamp":"1734538874"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"Vote","args":["11","true","",""]}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"EGuwM14piMngGpeykcJaLLsBBUBhVWjyJI4UvFTZjhsGEYHWoYLEOHQQVfzLZ+IFS1cyBM0pe7CMPdwKZfwOiw=="}],"memo":""},"metadata":{"timestamp":"1734620538"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/space/v1rc1","func":"SubmitEditorsModificationProposal","args":["Add Initial Editors","Adds editors to be able to manage News","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7\ng1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"Wfp+oig+L0wZQAlmDN3gfrdc8v2XIjuKKaaltSVt0YspgqM5aFvSqW72I+rweR+gdZMyYTnt5RHg0Ilq9NR7qg=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734538281"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/space/v1rc1","func":"SubmitEditorsModificationProposal","args":["Add Initial Editors","Adds editors to be able to manage News","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7\ng1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"RQMax9yhOeilH8Ap97d/KuHDqZ5B+hqj8Y6p62tibGBU6H6n8yyxKx0bTdLOMVB1zViiVUh79lmY1ue4TsjatQ=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734538316"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/space/v1rc1","func":"SubmitEditorsModificationProposal","args":["Add Initial Editors","Adds editors to be able to manage News","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7\ng1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2",""]}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"12uU28uK4bZmndowPTHEcRnC6m19WrYpuu1AY10wrX8+h9dLRk9RSr3GaI4rErclt66nvlKtIYFNX05AZMRtnQ=="}],"memo":""},"metadata":{"timestamp":"1734538758"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"tozmA6xZUFPBfZUS2QkzGUmgmcR5kI1EJzFAfPro+BMr3wBhLs/GlxFmmWgxjeT9iifbfbI9UZOJLH+lxA03sw=="}],"memo":""},"metadata":{"timestamp":"1734620182"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"20000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"BHvuxcDR6/VcKUbbmgYwNUYG9HqBjdEK5GSv1VtLT1xexysMqAyyykhE+UICrQb5SyoaPeroyNVZr7zzQjRtlg=="}],"memo":""},"metadata":{"timestamp":"1734620217"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"30000000","gas_fee":"3000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"qe6+7vTonjnSPJpNjPQgvW+43yPDeeiVfC0H8p5Bw+8/9uvOw6xLyH98lNzyKBzBp9oxmnvLxH3IhYWipKQyQA=="}],"memo":""},"metadata":{"timestamp":"1734620347"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"Vote","args":["11","true","",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"7mgBHDRe33LK9n4VKgn9Vk7NGpfAN+b8NTdE693dxnQ0CD7HBKe9stPe++7Ms9mkJ3OhIIgNDApUCPtQbnqpJg=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734674953"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/dao/v1rc1","func":"Vote","args":["11","true","",""]}],"fee":{"gas_wanted":"13000000","gas_fee":"1300000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"uGljAT3F9eu+uT996gr0JQTN0tsGOFA4hlzUehpMgwYjNB6Q+nwiM5yx0UeQs/UvP2UgvooIx38XXxCY7OLb7Q=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734674993"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"1000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"asxnzRfBzKrQToYKlwjIpy/z4kjYgp5rSfHMTgR02S0fncO6uYpqhU9NP/pEezz7G1jZj7PKZ6cJ1x5X2h3DAg=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734539697"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"10000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"u8kzKWZB1MMxI3y1yWnzfAv1rdvWZycAFzlqPP1x9WckmfZGYtHgqXp1CJSKZsvFBaGL8RXux8WYBfaW5gWyiQ=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734539858"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"WNm4W1ShKTFfJQhS8JsLaQYQskjMaE+Sv5oR2nbocuZtE59+sTOnfohbmmxKTm45E8+OFKlOvGdb9b3BMzcscA=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734573279"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"ujKMprCE4khrHUCvFh4TWzBHZMIjy0dd8NPsDmhNO7gOJQwk0+drOfz6cT/XAKCQZamdDh5O4IaPk/+CEPMNTA=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734574158"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"zEbe79zyR52uWB81BQdLBIUes+8z9u90+EZ8U/5gOU5nLcUiGgrD95T8vOGXJkRXNlelspjoKXlfq33CmZ6R9Q=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734573440"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","Beginner, Moodboard","false"]}],"fee":{"gas_wanted":"10000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"Tc9/+p8dTnJhpo9cQTdwCg3EslO99jo/VQ9V+ubgAK1VPgRhrk7qG4KXTU87rQ6HtDGJpVxO1eYhDCXZNSdtlA=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734539642"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"79Z59KD9YLvEluRgr3d5OAQ7tPUDRgGdFKk2xPi9RbND7pyEvb9V2rgzQTQ059dP5Yff9P8oSwkqFNyOYvCZwg=="}],"memo":""},"metadata":{"timestamp":"1734619589"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"10000000","gas_fee":"3000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"upo2TqQgs/1m+O9R/99sxD07sNt+i6yXgIuD783IW1FP7JGgWV/E8vSewOpbM7/BUZenInaH07g20DIxKUrqHQ=="}],"memo":""},"metadata":{"timestamp":"1734619855"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"11000000","gas_fee":"1100000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"1kfjvMNZdIJ+uNRq4BuYF1tjODPOrSGo5bvTPmqwCKp/5agKdqoCbGBDALYpHfGFZ3DpoTx1Wm+2aI+CyptG0w=="}],"memo":""},"metadata":{"timestamp":"1734620106"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"2000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"La6LhLZ4Srxb8InuQhvunkWF40Nj7WcBYag/X/Ki9zcgCm2LQsOGp5dzP7m032ivJKsOKoZF1zgMAZPWktu4fw=="}],"memo":""},"metadata":{"timestamp":"1734619619"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"20000000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"1305BwGhaj1Jrv7PbWPuRjWk0OxljMkqIKXDdSDfoSlWrFArxR2LRuBExDWWxfOrT4Cm4fj3SJFoN2JuRRt3Hw=="}],"memo":""},"metadata":{"timestamp":"1734620192"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Add GnoMood tutorial","Proposal to add the GnoMood tutorial to the tutorials realm","how-to-create-a-mood-board-realm","How to create GnoMood, a simple mood board realm","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"3000000","gas_fee":"3000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"tlY6NZ4ATTr0LmoiUWpQbqGCM8xdAUjSC9//GIkCuc0URXz3SDi2wRMXb24vSHY9mV4dHlOkR8OOvgo1rd/phQ=="}],"memo":""},"metadata":{"timestamp":"1734619659"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Smart Contract Data Management With The gno.land AVL Tree Package","Proposal to add the AVL Tree tutorial to gno.me","smart-contract-data-management-with-avl-tree","Learn how AVL trees bring balanced, efficient, and memory-conscious data operations to gno smart contracts. This tutorial walks you through understanding, creating, and using AVL trees for fast lookups, ordered traversals, and dynamic data handling.","f2bdc5cf8db8ef429685d4e43690498da1ec5a3692383ec2594abf4d85dc3f79","https://github.com/NewTendermint/gno.me/blob/kh.avl-tree-basics-tutorial/proposals/tutorials/avl-tree-basics/index.md","g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","","gnoland gno data-structures avl","false"]}],"fee":{"gas_wanted":"25000000","gas_fee":"2500000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"72PJY/18HLDlWElG2MfJdk1ZHUtGUojc8oxT8DUSW8k1+uHfILBLp2a67HjoVfPoAYO3UR+SiXJ9zYfePxl1vw=="}],"memo":""},"metadata":{"timestamp":"1734676213"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["Smart Contract Data Management With The gno.land AVL Tree Package","Proposal to add the AVL Tree tutorial to gno.me","smart-contract-data-management-with-avl-tree","Learn how AVL trees bring balanced, efficient, and memory-conscious data operations to gno smart contracts. This tutorial walks you through understanding, creating, and using AVL trees for fast lookups, ordered traversals, and dynamic data handling.","f2bdc5cf8db8ef429685d4e43690498da1ec5a3692383ec2594abf4d85dc3f79","https://github.com/NewTendermint/gno.me/blob/kh.avl-tree-basics-tutorial/proposals/tutorials/avl-tree-basics/index.md","g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","","gnoland gno data-structures avl","false"]}],"fee":{"gas_wanted":"26000000","gas_fee":"2600000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"VvE+UKpRHXJVEBQI2Rl1g3OhBICrYA9YXLzC3KGhV/BYhGeCmf6Bk1HPWL6v3tKFivIw4bqCb2SoUYArjPNbHg=="}],"memo":""},"metadata":{"timestamp":"1734676248"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["TEST: VOTE NO ON THIS PROPOSAL IF YOU VOTE AT ALL","TEST: VOTE NO ON THIS PROPOSAL IF YOU VOTE AT ALL","test-202412191142","TEST: VOTE NO ON THIS PROPOSAL IF YOU VOTE AT ALL","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"20000000","gas_fee":"3000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"X4lwnRXOOMLufDkYR3+RnAfbtEL1Sjfxv6eyjJMP0as07MKW2sOHlbaC7u5okh8lMW278F27uf7GpmE/ZdGXEg=="}],"memo":""},"metadata":{"timestamp":"1734637679"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"SubmitCreationProposal","args":["TEST: VOTE NO ON THIS PROPOSAL IF YOU VOTE AT ALL","TEST: VOTE NO ON THIS PROPOSAL IF YOU VOTE AT ALL","test-202412191142","TEST: VOTE NO ON THIS PROPOSAL IF YOU VOTE AT ALL","81142d85dce94522d7725015231a44c08e04588a33d3366c4d6e3a4f6bfb6b0f","https://github.com/NewTendermint/gno.me/blob/docs/mood-board/content/tutorials/how-to-create-a-mood-board-realm/index.md","g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5","g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun\ng1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","beginner dapp","false"]}],"fee":{"gas_wanted":"30000000","gas_fee":"3000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"TcJXJjaD3Web7sVp8dkjKwYB2iUBi5vErJLi2rSHkd4IP/RKKs8iiDctfySh/7+mvkhpYPbrLf6okmg/KTKxyg=="}],"memo":""},"metadata":{"timestamp":"1734633783"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"TutorialExists","args":["foo-bar"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"neMTQ30b+Ibb21KspgjXdwH0I4L//wJDE/YkT7VrOhdyjTdg5Ei/lQ0cGlBmLcb9YlGmzyRE4c9zhizwNtJUnw=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734573023"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","send":"","pkg_path":"gno.land/r/gnome/tutorials/v1rc1","func":"TutorialExists","args":["foo-bar"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+8e+xKl/HkBcdwQCmlkKhoekH4RUvskOJan85VTUFix"},"signature":"skyPntxP3j/FbB1zsb/E8KYHauw3zhYgosDZ/2/O3d5T0GE1AyxHMCNXokTF3cL60Oda5Ydyx9nLCFxHKgRKkg=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1734575197"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1juz2yxmdsa6audkp6ep9vfv80c8p5u76e03vvh","amount":"1000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"NhY11mPtGq5h/vXbC8kRApa5j6MovQ9A8jCaiIawpTlIu/vRCAStDio8v8D8JQmBYj66zrDzrsAp9nzbq6Aj2A=="}],"memo":""},"metadata":{"timestamp":"1734695836"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1n2mpwnwtfwpa7qngxfdemrk598r8yn52qhm9j9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"5mkoPOkjBIdr0HzU/n2bddMKiXB0hAEgvbXsIe+8CloxCjfl9Q4ZYN4QjPgNhvbkztVX+PSEt9nI0Sag9fYjYQ=="}],"memo":""},"metadata":{"timestamp":"1734698567"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"example","path":"gno.land/r/x/jeronimo_render_proxy","files":[{"name":"example.gno","body":"package example\n\nfunc Render(string) string {\n\treturn `# Render Proxy\n\nThis example shows how proxying render calls can be used to allow updating realms to new\nversions while keeping the same realm path. The idea is to have a simple \"parent\" realm\nthat only keeps track of the latest realm version and forwards all render calls to it.\n\nBy only focusing on the 'Render()' function the proxy realm keeps its public functions\nstable allowing each version to update their public functions and exposed types without\nneeding to also update the proxy realm.\n\nAny interaction or transaction must be sent to the latest, or target, realm version while\nrender calls are sent to the proxy realm.\n\nEach realm version registers itself on deployment as the latest available version, and\nits allowed to do so because each versioned realm path shares the proxy realm path.\n`\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"avl","path":"gno.land/p/demo/avl","files":[{"name":"node.gno","body":"package avl\n\n//----------------------------------------\n// Node\n\n// Node represents a node in an AVL tree.\ntype Node struct {\n\tkey       string      // key is the unique identifier for the node.\n\tvalue     interface{} // value is the data stored in the node.\n\theight    int8        // height is the height of the node in the tree.\n\tsize      int         // size is the number of nodes in the subtree rooted at this node.\n\tleftNode  *Node       // leftNode is the left child of the node.\n\trightNode *Node       // rightNode is the right child of the node.\n}\n\n// NewNode creates a new node with the given key and value.\nfunc NewNode(key string, value interface{}) *Node {\n\treturn \u0026Node{\n\t\tkey:    key,\n\t\tvalue:  value,\n\t\theight: 0,\n\t\tsize:   1,\n\t}\n}\n\n// Size returns the size of the subtree rooted at the node.\nfunc (node *Node) Size() int {\n\tif node == nil {\n\t\treturn 0\n\t}\n\treturn node.size\n}\n\n// IsLeaf checks if the node is a leaf node (has no children).\nfunc (node *Node) IsLeaf() bool {\n\treturn node.height == 0\n}\n\n// Key returns the key of the node.\nfunc (node *Node) Key() string {\n\treturn node.key\n}\n\n// Value returns the value of the node.\nfunc (node *Node) Value() interface{} {\n\treturn node.value\n}\n\n// _copy creates a copy of the node (excluding value).\nfunc (node *Node) _copy() *Node {\n\tif node.height == 0 {\n\t\tpanic(\"Why are you copying a value node?\")\n\t}\n\treturn \u0026Node{\n\t\tkey:       node.key,\n\t\theight:    node.height,\n\t\tsize:      node.size,\n\t\tleftNode:  node.leftNode,\n\t\trightNode: node.rightNode,\n\t}\n}\n\n// Has checks if a node with the given key exists in the subtree rooted at the node.\nfunc (node *Node) Has(key string) (has bool) {\n\tif node == nil {\n\t\treturn false\n\t}\n\tif node.key == key {\n\t\treturn true\n\t}\n\tif node.height == 0 {\n\t\treturn false\n\t}\n\tif key \u003c node.key {\n\t\treturn node.getLeftNode().Has(key)\n\t}\n\treturn node.getRightNode().Has(key)\n}\n\n// Get searches for a node with the given key in the subtree rooted at the node\n// and returns its index, value, and whether it exists.\nfunc (node *Node) Get(key string) (index int, value interface{}, exists bool) {\n\tif node == nil {\n\t\treturn 0, nil, false\n\t}\n\n\tif node.height == 0 {\n\t\tif node.key == key {\n\t\t\treturn 0, node.value, true\n\t\t}\n\t\tif node.key \u003c key {\n\t\t\treturn 1, nil, false\n\t\t}\n\t\treturn 0, nil, false\n\t}\n\n\tif key \u003c node.key {\n\t\treturn node.getLeftNode().Get(key)\n\t}\n\n\trightNode := node.getRightNode()\n\tindex, value, exists = rightNode.Get(key)\n\tindex += node.size - rightNode.size\n\treturn index, value, exists\n}\n\n// GetByIndex retrieves the key-value pair of the node at the given index\n// in the subtree rooted at the node.\nfunc (node *Node) GetByIndex(index int) (key string, value interface{}) {\n\tif node.height == 0 {\n\t\tif index == 0 {\n\t\t\treturn node.key, node.value\n\t\t}\n\t\tpanic(\"GetByIndex asked for invalid index\")\n\t}\n\t// TODO: could improve this by storing the sizes\n\tleftNode := node.getLeftNode()\n\tif index \u003c leftNode.size {\n\t\treturn leftNode.GetByIndex(index)\n\t}\n\treturn node.getRightNode().GetByIndex(index - leftNode.size)\n}\n\n// Set inserts a new node with the given key-value pair into the subtree rooted at the node,\n// and returns the new root of the subtree and whether an existing node was updated.\n//\n// XXX consider a better way to do this... perhaps split Node from Node.\nfunc (node *Node) Set(key string, value interface{}) (newSelf *Node, updated bool) {\n\tif node == nil {\n\t\treturn NewNode(key, value), false\n\t}\n\n\tif node.height == 0 {\n\t\treturn node.setLeaf(key, value)\n\t}\n\n\tnode = node._copy()\n\tif key \u003c node.key {\n\t\tnode.leftNode, updated = node.getLeftNode().Set(key, value)\n\t} else {\n\t\tnode.rightNode, updated = node.getRightNode().Set(key, value)\n\t}\n\n\tif updated {\n\t\treturn node, updated\n\t}\n\n\tnode.calcHeightAndSize()\n\treturn node.balance(), updated\n}\n\n// setLeaf inserts a new leaf node with the given key-value pair into the subtree rooted at the node,\n// and returns the new root of the subtree and whether an existing node was updated.\nfunc (node *Node) setLeaf(key string, value interface{}) (newSelf *Node, updated bool) {\n\tif key == node.key {\n\t\treturn NewNode(key, value), true\n\t}\n\n\tif key \u003c node.key {\n\t\treturn \u0026Node{\n\t\t\tkey:       node.key,\n\t\t\theight:    1,\n\t\t\tsize:      2,\n\t\t\tleftNode:  NewNode(key, value),\n\t\t\trightNode: node,\n\t\t}, false\n\t}\n\n\treturn \u0026Node{\n\t\tkey:       key,\n\t\theight:    1,\n\t\tsize:      2,\n\t\tleftNode:  node,\n\t\trightNode: NewNode(key, value),\n\t}, false\n}\n\n// Remove deletes the node with the given key from the subtree rooted at the node.\n// returns the new root of the subtree, the new leftmost leaf key (if changed),\n// the removed value and the removal was successful.\nfunc (node *Node) Remove(key string) (\n\tnewNode *Node, newKey string, value interface{}, removed bool,\n) {\n\tif node == nil {\n\t\treturn nil, \"\", nil, false\n\t}\n\tif node.height == 0 {\n\t\tif key == node.key {\n\t\t\treturn nil, \"\", node.value, true\n\t\t}\n\t\treturn node, \"\", nil, false\n\t}\n\tif key \u003c node.key {\n\t\tvar newLeftNode *Node\n\t\tnewLeftNode, newKey, value, removed = node.getLeftNode().Remove(key)\n\t\tif !removed {\n\t\t\treturn node, \"\", value, false\n\t\t}\n\t\tif newLeftNode == nil { // left node held value, was removed\n\t\t\treturn node.rightNode, node.key, value, true\n\t\t}\n\t\tnode = node._copy()\n\t\tnode.leftNode = newLeftNode\n\t\tnode.calcHeightAndSize()\n\t\tnode = node.balance()\n\t\treturn node, newKey, value, true\n\t}\n\n\tvar newRightNode *Node\n\tnewRightNode, newKey, value, removed = node.getRightNode().Remove(key)\n\tif !removed {\n\t\treturn node, \"\", value, false\n\t}\n\tif newRightNode == nil { // right node held value, was removed\n\t\treturn node.leftNode, \"\", value, true\n\t}\n\tnode = node._copy()\n\tnode.rightNode = newRightNode\n\tif newKey != \"\" {\n\t\tnode.key = newKey\n\t}\n\tnode.calcHeightAndSize()\n\tnode = node.balance()\n\treturn node, \"\", value, true\n}\n\n// getLeftNode returns the left child of the node.\nfunc (node *Node) getLeftNode() *Node {\n\treturn node.leftNode\n}\n\n// getRightNode returns the right child of the node.\nfunc (node *Node) getRightNode() *Node {\n\treturn node.rightNode\n}\n\n// rotateRight performs a right rotation on the node and returns the new root.\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateRight() *Node {\n\tnode = node._copy()\n\tl := node.getLeftNode()\n\t_l := l._copy()\n\n\t_lrCached := _l.rightNode\n\t_l.rightNode = node\n\tnode.leftNode = _lrCached\n\n\tnode.calcHeightAndSize()\n\t_l.calcHeightAndSize()\n\n\treturn _l\n}\n\n// rotateLeft performs a left rotation on the node and returns the new root.\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateLeft() *Node {\n\tnode = node._copy()\n\tr := node.getRightNode()\n\t_r := r._copy()\n\n\t_rlCached := _r.leftNode\n\t_r.leftNode = node\n\tnode.rightNode = _rlCached\n\n\tnode.calcHeightAndSize()\n\t_r.calcHeightAndSize()\n\n\treturn _r\n}\n\n// calcHeightAndSize updates the height and size of the node based on its children.\n// NOTE: mutates height and size\nfunc (node *Node) calcHeightAndSize() {\n\tnode.height = maxInt8(node.getLeftNode().height, node.getRightNode().height) + 1\n\tnode.size = node.getLeftNode().size + node.getRightNode().size\n}\n\n// calcBalance calculates the balance factor of the node.\nfunc (node *Node) calcBalance() int {\n\treturn int(node.getLeftNode().height) - int(node.getRightNode().height)\n}\n\n// balance balances the subtree rooted at the node and returns the new root.\n// NOTE: assumes that node can be modified\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) balance() (newSelf *Node) {\n\tbalance := node.calcBalance()\n\tif balance \u003e= -1 {\n\t\treturn node\n\t}\n\tif balance \u003e 1 {\n\t\tif node.getLeftNode().calcBalance() \u003e= 0 {\n\t\t\t// Left Left Case\n\t\t\treturn node.rotateRight()\n\t\t}\n\t\t// Left Right Case\n\t\tleft := node.getLeftNode()\n\t\tnode.leftNode = left.rotateLeft()\n\t\treturn node.rotateRight()\n\t}\n\n\tif node.getRightNode().calcBalance() \u003c= 0 {\n\t\t// Right Right Case\n\t\treturn node.rotateLeft()\n\t}\n\n\t// Right Left Case\n\tright := node.getRightNode()\n\tnode.rightNode = right.rotateRight()\n\treturn node.rotateLeft()\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) Iterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, true, true, cb)\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) ReverseIterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, false, true, cb)\n}\n\n// TraverseInRange traverses all nodes, including inner nodes.\n// Start is inclusive and end is exclusive when ascending,\n// Start and end are inclusive when descending.\n// Empty start and empty end denote no start and no end.\n// If leavesOnly is true, only visit leaf nodes.\n// NOTE: To simulate an exclusive reverse traversal,\n// just append 0x00 to start.\nfunc (node *Node) TraverseInRange(start, end string, ascending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\tafterStart := (start == \"\" || start \u003c node.key)\n\tstartOrAfter := (start == \"\" || start \u003c= node.key)\n\tbeforeEnd := false\n\tif ascending {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c end)\n\t} else {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c= end)\n\t}\n\n\t// Run callback per inner/leaf node.\n\tstop := false\n\tif (!node.IsLeaf() \u0026\u0026 !leavesOnly) ||\n\t\t(node.IsLeaf() \u0026\u0026 startOrAfter \u0026\u0026 beforeEnd) {\n\t\tstop = cb(node)\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t}\n\tif node.IsLeaf() {\n\t\treturn stop\n\t}\n\n\tif ascending {\n\t\t// check lower nodes, then higher\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t} else {\n\t\t// check the higher nodes first\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t}\n\n\treturn stop\n}\n\n// TraverseByOffset traverses all nodes, including inner nodes.\n// A limit of math.MaxInt means no limit.\nfunc (node *Node) TraverseByOffset(offset, limit int, ascending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\n\t// fast paths. these happen only if TraverseByOffset is called directly on a leaf.\n\tif limit \u003c= 0 || offset \u003e= node.size {\n\t\treturn false\n\t}\n\tif node.IsLeaf() {\n\t\tif offset \u003e 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn cb(node)\n\t}\n\n\t// go to the actual recursive function.\n\treturn node.traverseByOffset(offset, limit, ascending, leavesOnly, cb)\n}\n\n// TraverseByOffset traverses the subtree rooted at the node by offset and limit,\n// in either ascending or descending order, and applies the callback function to each traversed node.\n// If leavesOnly is true, only leaf nodes are visited.\nfunc (node *Node) traverseByOffset(offset, limit int, ascending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\t// caller guarantees: offset \u003c node.size; limit \u003e 0.\n\tif !leavesOnly {\n\t\tif cb(node) {\n\t\t\treturn true // Stop traversal if callback returns true\n\t\t}\n\t}\n\tfirst, second := node.getLeftNode(), node.getRightNode()\n\tif !ascending {\n\t\tfirst, second = second, first\n\t}\n\tif first.IsLeaf() {\n\t\t// either run or skip, based on offset\n\t\tif offset \u003e 0 {\n\t\t\toffset--\n\t\t} else {\n\t\t\tif cb(first) {\n\t\t\t\treturn true // Stop traversal if callback returns true\n\t\t\t}\n\t\t\tlimit--\n\t\t\tif limit \u003c= 0 {\n\t\t\t\treturn true // Stop traversal when limit is reached\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// possible cases:\n\t\t// 1 the offset given skips the first node entirely\n\t\t// 2 the offset skips none or part of the first node, but the limit requires some of the second node.\n\t\t// 3 the offset skips none or part of the first node, and the limit stops our search on the first node.\n\t\tif offset \u003e= first.size {\n\t\t\toffset -= first.size // 1\n\t\t} else {\n\t\t\tif first.traverseByOffset(offset, limit, ascending, leavesOnly, cb) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// number of leaves which could actually be called from inside\n\t\t\tdelta := first.size - offset\n\t\t\toffset = 0\n\t\t\tif delta \u003e= limit {\n\t\t\t\treturn true // 3\n\t\t\t}\n\t\t\tlimit -= delta // 2\n\t\t}\n\t}\n\n\t// because of the caller guarantees and the way we handle the first node,\n\t// at this point we know that limit \u003e 0 and there must be some values in\n\t// this second node that we include.\n\n\t// =\u003e if the second node is a leaf, it has to be included.\n\tif second.IsLeaf() {\n\t\treturn cb(second)\n\t}\n\t// =\u003e if it is not a leaf, it will still be enough to recursively call this\n\t// function with the updated offset and limit\n\treturn second.traverseByOffset(offset, limit, ascending, leavesOnly, cb)\n}\n\n// Only used in testing...\nfunc (node *Node) lmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getLeftNode().lmd()\n}\n\n// Only used in testing...\nfunc (node *Node) rmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getRightNode().rmd()\n}\n\nfunc maxInt8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"},{"name":"node_test.gno","body":"package avl\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestTraverseByOffset(t *testing.T) {\n\tconst testStrings = `Alfa\nAlfred\nAlpha\nAlphabet\nBeta\nBeth\nBook\nBrowser`\n\ttt := []struct {\n\t\tname string\n\t\tasc  bool\n\t}{\n\t\t{\"ascending\", true},\n\t\t{\"descending\", false},\n\t}\n\n\tfor _, tt := range tt {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// use sl to insert the values, and reversed to match the values\n\t\t\t// we do this to ensure that the order of TraverseByOffset is independent\n\t\t\t// from the insertion order\n\t\t\tsl := strings.Split(testStrings, \"\\n\")\n\t\t\tsort.Strings(sl)\n\t\t\treversed := append([]string{}, sl...)\n\t\t\treverseSlice(reversed)\n\n\t\t\tif !tt.asc {\n\t\t\t\tsl, reversed = reversed, sl\n\t\t\t}\n\n\t\t\tr := NewNode(reversed[0], nil)\n\t\t\tfor _, v := range reversed[1:] {\n\t\t\t\tr, _ = r.Set(v, nil)\n\t\t\t}\n\n\t\t\tvar result []string\n\t\t\tfor i := 0; i \u003c len(sl); i++ {\n\t\t\t\tr.TraverseByOffset(i, 1, tt.asc, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif !slicesEqual(sl, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", sl, result)\n\t\t\t}\n\n\t\t\tfor l := 2; l \u003c= len(sl); l++ {\n\t\t\t\t// \"slices\"\n\t\t\t\tfor i := 0; i \u003c= len(sl); i++ {\n\t\t\t\t\tmax := i + l\n\t\t\t\t\tif max \u003e len(sl) {\n\t\t\t\t\t\tmax = len(sl)\n\t\t\t\t\t}\n\t\t\t\t\texp := sl[i:max]\n\t\t\t\t\tactual := []string{}\n\n\t\t\t\t\tr.TraverseByOffset(i, l, tt.asc, true, func(tr *Node) bool {\n\t\t\t\t\t\tactual = append(actual, tr.Key())\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\tif !slicesEqual(exp, actual) {\n\t\t\t\t\t\tt.Errorf(\"want %v got %v\", exp, actual)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHas(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\thasKey   string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\t\"has key in non-empty tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"B\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in non-empty tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"has key in single-node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t\"A\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in single-node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t\"B\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in empty tree\",\n\t\t\t[]string{},\n\t\t\t\"A\",\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tresult := tree.Has(tt.hasKey)\n\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinput        []string\n\t\tgetKey       string\n\t\texpectIdx    int\n\t\texpectVal    interface{}\n\t\texpectExists bool\n\t}{\n\t\t{\n\t\t\t\"get existing key\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"B\",\n\t\t\t1,\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"get non-existent key (smaller)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"@\",\n\t\t\t0,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get non-existent key (larger)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\t5,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get from empty tree\",\n\t\t\t[]string{},\n\t\t\t\"A\",\n\t\t\t0,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tidx, val, exists := tree.Get(tt.getKey)\n\n\t\t\tif idx != tt.expectIdx {\n\t\t\t\tt.Errorf(\"Expected index %d, got %d\", tt.expectIdx, idx)\n\t\t\t}\n\n\t\t\tif val != tt.expectVal {\n\t\t\t\tt.Errorf(\"Expected value %v, got %v\", tt.expectVal, val)\n\t\t\t}\n\n\t\t\tif exists != tt.expectExists {\n\t\t\t\tt.Errorf(\"Expected exists %t, got %t\", tt.expectExists, exists)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetByIndex(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       []string\n\t\tidx         int\n\t\texpectKey   string\n\t\texpectVal   interface{}\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\t\"get by valid index\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t2,\n\t\t\t\"C\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by valid index (smallest)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t0,\n\t\t\t\"A\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by valid index (largest)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t4,\n\t\t\t\"E\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by invalid index (negative)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t-1,\n\t\t\t\"\",\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"get by invalid index (out of range)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t5,\n\t\t\t\"\",\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected a panic but didn't get one\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tkey, val := tree.GetByIndex(tt.idx)\n\n\t\t\tif !tt.expectPanic {\n\t\t\t\tif key != tt.expectKey {\n\t\t\t\t\tt.Errorf(\"Expected key %s, got %s\", tt.expectKey, key)\n\t\t\t\t}\n\n\t\t\t\tif val != tt.expectVal {\n\t\t\t\t\tt.Errorf(\"Expected value %v, got %v\", tt.expectVal, val)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRemove(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinput     []string\n\t\tremoveKey string\n\t\texpected  []string\n\t}{\n\t\t{\n\t\t\t\"remove leaf node\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"D\"},\n\t\t\t\"B\",\n\t\t\t[]string{\"A\", \"C\", \"D\"},\n\t\t},\n\t\t{\n\t\t\t\"remove node with one child\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"D\"},\n\t\t\t\"A\",\n\t\t\t[]string{\"B\", \"C\", \"D\"},\n\t\t},\n\t\t{\n\t\t\t\"remove node with two children\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"C\",\n\t\t\t[]string{\"A\", \"B\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"remove root node\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"C\",\n\t\t\t[]string{\"A\", \"B\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"remove non-existent key\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\ttree, _, _, _ = tree.Remove(tt.removeKey)\n\n\t\t\tresult := make([]string, 0)\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTraverse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"empty tree\",\n\t\t\t[]string{},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"single node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t[]string{\"A\"},\n\t\t},\n\t\t{\n\t\t\t\"small tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"large tree\",\n\t\t\t[]string{\"H\", \"D\", \"L\", \"B\", \"F\", \"J\", \"N\", \"A\", \"C\", \"E\", \"G\", \"I\", \"K\", \"M\", \"O\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tt.Run(\"iterate\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"ReverseIterate\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\ttree.ReverseIterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\texpected := make([]string, len(tt.expected))\n\t\t\t\tcopy(expected, tt.expected)\n\t\t\t\tfor i, j := 0, len(expected)-1; i \u003c j; i, j = i+1, j-1 {\n\t\t\t\t\texpected[i], expected[j] = expected[j], expected[i]\n\t\t\t\t}\n\t\t\t\tif !slicesEqual(expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", expected, result)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"TraverseInRange\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\tstart, end := \"C\", \"M\"\n\t\t\t\ttree.TraverseInRange(start, end, true, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\texpected := make([]string, 0)\n\t\t\t\tfor _, key := range tt.expected {\n\t\t\t\t\tif key \u003e= start \u0026\u0026 key \u003c end {\n\t\t\t\t\t\texpected = append(expected, key)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !slicesEqual(expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", expected, result)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"early termination\", func(t *testing.T) {\n\t\t\t\tif len(tt.input) == 0 {\n\t\t\t\t\treturn // Skip for empty tree\n\t\t\t\t}\n\n\t\t\t\tvar result []string\n\t\t\t\tvar count int\n\t\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\t\tcount++\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn true // Stop after first item\n\t\t\t\t})\n\n\t\t\t\tif count != 1 {\n\t\t\t\t\tt.Errorf(\"Expected callback to be called exactly once, got %d calls\", count)\n\t\t\t\t}\n\t\t\t\tif len(result) != 1 {\n\t\t\t\t\tt.Errorf(\"Expected exactly one result, got %d items\", len(result))\n\t\t\t\t}\n\t\t\t\tif len(result) \u003e 0 \u0026\u0026 result[0] != tt.expected[0] {\n\t\t\t\t\tt.Errorf(\"Expected first item to be %v, got %v\", tt.expected[0], result[0])\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRotateWhenHeightDiffers(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"right rotation when left subtree is higher\",\n\t\t\t[]string{\"E\", \"C\", \"A\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"left rotation when right subtree is higher\",\n\t\t\t[]string{\"A\", \"C\", \"E\", \"D\", \"F\"},\n\t\t\t[]string{\"A\", \"C\", \"D\", \"E\", \"F\"},\n\t\t},\n\t\t{\n\t\t\t\"left-right rotation\",\n\t\t\t[]string{\"E\", \"A\", \"C\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"right-left rotation\",\n\t\t\t[]string{\"A\", \"E\", \"C\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\t// perform rotation or balance\n\t\t\ttree = tree.balance()\n\n\t\t\t// check tree structure\n\t\t\tvar result []string\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRotateAndBalance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"right rotation\",\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"left rotation\",\n\t\t\t[]string{\"E\", \"D\", \"C\", \"B\", \"A\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"left-right rotation\",\n\t\t\t[]string{\"C\", \"A\", \"E\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"right-left rotation\",\n\t\t\t[]string{\"C\", \"E\", \"A\", \"D\", \"B\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\ttree = tree.balance()\n\n\t\t\tvar result []string\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc slicesEqual(w1, w2 []string) bool {\n\tif len(w1) != len(w2) {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c len(w1); i++ {\n\t\tif w1[i] != w2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc maxint8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc reverseSlice(ss []string) {\n\tfor i := 0; i \u003c len(ss)/2; i++ {\n\t\tj := len(ss) - 1 - i\n\t\tss[i], ss[j] = ss[j], ss[i]\n\t}\n}\n"},{"name":"tree.gno","body":"package avl\n\ntype ITree interface {\n\t// read operations\n\n\tSize() int\n\tHas(key string) bool\n\tGet(key string) (value interface{}, exists bool)\n\tGetByIndex(index int) (key string, value interface{})\n\tIterate(start, end string, cb IterCbFn) bool\n\tReverseIterate(start, end string, cb IterCbFn) bool\n\tIterateByOffset(offset int, count int, cb IterCbFn) bool\n\tReverseIterateByOffset(offset int, count int, cb IterCbFn) bool\n\n\t// write operations\n\n\tSet(key string, value interface{}) (updated bool)\n\tRemove(key string) (value interface{}, removed bool)\n}\n\ntype IterCbFn func(key string, value interface{}) bool\n\n//----------------------------------------\n// Tree\n\n// The zero struct can be used as an empty tree.\ntype Tree struct {\n\tnode *Node\n}\n\n// NewTree creates a new empty AVL tree.\nfunc NewTree() *Tree {\n\treturn \u0026Tree{\n\t\tnode: nil,\n\t}\n}\n\n// Size returns the number of key-value pair in the tree.\nfunc (tree *Tree) Size() int {\n\treturn tree.node.Size()\n}\n\n// Has checks whether a key exists in the tree.\n// It returns true if the key exists, otherwise false.\nfunc (tree *Tree) Has(key string) (has bool) {\n\treturn tree.node.Has(key)\n}\n\n// Get retrieves the value associated with the given key.\n// It returns the value and a boolean indicating whether the key exists.\nfunc (tree *Tree) Get(key string) (value interface{}, exists bool) {\n\t_, value, exists = tree.node.Get(key)\n\treturn\n}\n\n// GetByIndex retrieves the key-value pair at the specified index in the tree.\n// It returns the key and value at the given index.\nfunc (tree *Tree) GetByIndex(index int) (key string, value interface{}) {\n\treturn tree.node.GetByIndex(index)\n}\n\n// Set inserts a key-value pair into the tree.\n// If the key already exists, the value will be updated.\n// It returns a boolean indicating whether the key was newly inserted or updated.\nfunc (tree *Tree) Set(key string, value interface{}) (updated bool) {\n\tnewnode, updated := tree.node.Set(key, value)\n\ttree.node = newnode\n\treturn updated\n}\n\n// Remove removes a key-value pair from the tree.\n// It returns the removed value and a boolean indicating whether the key was found and removed.\nfunc (tree *Tree) Remove(key string) (value interface{}, removed bool) {\n\tnewnode, _, value, removed := tree.node.Remove(key)\n\ttree.node = newnode\n\treturn value, removed\n}\n\n// Iterate performs an in-order traversal of the tree within the specified key range.\n// It calls the provided callback function for each key-value pair encountered.\n// If the callback returns true, the iteration is stopped.\nfunc (tree *Tree) Iterate(start, end string, cb IterCbFn) bool {\n\treturn tree.node.TraverseInRange(start, end, true, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// ReverseIterate performs a reverse in-order traversal of the tree within the specified key range.\n// It calls the provided callback function for each key-value pair encountered.\n// If the callback returns true, the iteration is stopped.\nfunc (tree *Tree) ReverseIterate(start, end string, cb IterCbFn) bool {\n\treturn tree.node.TraverseInRange(start, end, false, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// IterateByOffset performs an in-order traversal of the tree starting from the specified offset.\n// It calls the provided callback function for each key-value pair encountered, up to the specified count.\n// If the callback returns true, the iteration is stopped.\nfunc (tree *Tree) IterateByOffset(offset int, count int, cb IterCbFn) bool {\n\treturn tree.node.TraverseByOffset(offset, count, true, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// ReverseIterateByOffset performs a reverse in-order traversal of the tree starting from the specified offset.\n// It calls the provided callback function for each key-value pair encountered, up to the specified count.\n// If the callback returns true, the iteration is stopped.\nfunc (tree *Tree) ReverseIterateByOffset(offset int, count int, cb IterCbFn) bool {\n\treturn tree.node.TraverseByOffset(offset, count, false, true,\n\t\tfunc(node *Node) bool {\n\t\t\treturn cb(node.Key(), node.Value())\n\t\t},\n\t)\n}\n\n// Verify that Tree implements TreeInterface\nvar _ ITree = (*Tree)(nil)\n"},{"name":"tree_test.gno","body":"package avl\n\nimport \"testing\"\n\nfunc TestNewTree(t *testing.T) {\n\ttree := NewTree()\n\tif tree.node != nil {\n\t\tt.Error(\"Expected tree.node to be nil\")\n\t}\n}\n\nfunc TestTreeSize(t *testing.T) {\n\ttree := NewTree()\n\tif tree.Size() != 0 {\n\t\tt.Error(\"Expected empty tree size to be 0\")\n\t}\n\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\tif tree.Size() != 2 {\n\t\tt.Error(\"Expected tree size to be 2\")\n\t}\n}\n\nfunc TestTreeHas(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\n\tif !tree.Has(\"key1\") {\n\t\tt.Error(\"Expected tree to have key1\")\n\t}\n\n\tif tree.Has(\"key2\") {\n\t\tt.Error(\"Expected tree to not have key2\")\n\t}\n}\n\nfunc TestTreeGet(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\n\tvalue, exists := tree.Get(\"key1\")\n\tif !exists || value != \"value1\" {\n\t\tt.Error(\"Expected Get to return value1 and true\")\n\t}\n\n\t_, exists = tree.Get(\"key2\")\n\tif exists {\n\t\tt.Error(\"Expected Get to return false for non-existent key\")\n\t}\n}\n\nfunc TestTreeGetByIndex(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\n\tkey, value := tree.GetByIndex(0)\n\tif key != \"key1\" || value != \"value1\" {\n\t\tt.Error(\"Expected GetByIndex(0) to return key1 and value1\")\n\t}\n\n\tkey, value = tree.GetByIndex(1)\n\tif key != \"key2\" || value != \"value2\" {\n\t\tt.Error(\"Expected GetByIndex(1) to return key2 and value2\")\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"Expected GetByIndex to panic for out-of-range index\")\n\t\t}\n\t}()\n\ttree.GetByIndex(2)\n}\n\nfunc TestTreeRemove(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\n\tvalue, removed := tree.Remove(\"key1\")\n\tif !removed || value != \"value1\" || tree.Size() != 0 {\n\t\tt.Error(\"Expected Remove to remove key-value pair\")\n\t}\n\n\t_, removed = tree.Remove(\"key2\")\n\tif removed {\n\t\tt.Error(\"Expected Remove to return false for non-existent key\")\n\t}\n}\n\nfunc TestTreeIterate(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\tvar keys []string\n\ttree.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tkeys = append(keys, key)\n\t\treturn false\n\t})\n\n\texpectedKeys := []string{\"key1\", \"key2\", \"key3\"}\n\tif !slicesEqual(keys, expectedKeys) {\n\t\tt.Errorf(\"Expected keys %v, got %v\", expectedKeys, keys)\n\t}\n}\n\nfunc TestTreeReverseIterate(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\tvar keys []string\n\ttree.ReverseIterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tkeys = append(keys, key)\n\t\treturn false\n\t})\n\n\texpectedKeys := []string{\"key3\", \"key2\", \"key1\"}\n\tif !slicesEqual(keys, expectedKeys) {\n\t\tt.Errorf(\"Expected keys %v, got %v\", expectedKeys, keys)\n\t}\n}\n\nfunc TestTreeIterateByOffset(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\tvar keys []string\n\ttree.IterateByOffset(1, 2, func(key string, value interface{}) bool {\n\t\tkeys = append(keys, key)\n\t\treturn false\n\t})\n\n\texpectedKeys := []string{\"key2\", \"key3\"}\n\tif !slicesEqual(keys, expectedKeys) {\n\t\tt.Errorf(\"Expected keys %v, got %v\", expectedKeys, keys)\n\t}\n}\n\nfunc TestTreeReverseIterateByOffset(t *testing.T) {\n\ttree := NewTree()\n\ttree.Set(\"key1\", \"value1\")\n\ttree.Set(\"key2\", \"value2\")\n\ttree.Set(\"key3\", \"value3\")\n\n\tvar keys []string\n\ttree.ReverseIterateByOffset(1, 2, func(key string, value interface{}) bool {\n\t\tkeys = append(keys, key)\n\t\treturn false\n\t})\n\n\texpectedKeys := []string{\"key2\", \"key1\"}\n\tif !slicesEqual(keys, expectedKeys) {\n\t\tt.Errorf(\"Expected keys %v, got %v\", expectedKeys, keys)\n\t}\n}\n"},{"name":"z_0_filetest.gno","body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\t// node, _ = node.Set(\"key0\", \"value0\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key1\", \"value1\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 2\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"ModTime\": \"7\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"627e8e517e7ae5db0f3b753e2a32b607989198b6\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:9]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:8]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"b28057ab7be6383785c0a5503e8a531bdbc21851\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:7]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"6da365f0d6cacbcdf53cd5a4b125803cddce08c2\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"f216afe7b5a17f4ebdbb98dceccedbc22e237596\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:6]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"ff1a50d8489090af37a2c7766d659f0d717939b5\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//         }\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"5\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"Column\": \"0\",\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"ae86874f9b47fa5e64c30b3e92e9d07f2ec967a4\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"z_0.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.1\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"Column\": \"1\",\n//                         \"File\": \"z_0.gno\",\n//                         \"Line\": \"10\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"z_0.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"Column\": \"1\",\n//                         \"File\": \"z_0.gno\",\n//                         \"Line\": \"15\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         }\n//     ]\n// }\n"},{"name":"z_1_filetest.gno","body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\tnode, _ = node.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key2\", \"value2\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:15]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:14]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"143aebc820da33550f7338723fb1e2eec575b196\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:13]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"2f3adc5d0f2a3fe0331cfa93572a7abdde14c9aa\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"2e733a8e9e74fe14f0a5d10fb0f6728fa53d052d\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:12]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"fe20a19f956511f274dc77854e9e5468387260f4\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:11]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"c89a71bdf045e8bde2059dc9d33839f916e02e5d\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"90fa67f8c47db4b9b2a60425dff08d5a3385100f\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:10]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"83e42caaf53070dd95b5f859053eb51ed900bbda\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\"\n//         }\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"9\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"Column\": \"0\",\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"1faa9fa4ba1935121a6d3f0a623772e9d4499b0a\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"z_1.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.1\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"Column\": \"1\",\n//                         \"File\": \"z_1.gno\",\n//                         \"Line\": \"10\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"z_1.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"NativeName\": \"\",\n//                 \"NativePkg\": \"\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"Column\": \"1\",\n//                         \"File\": \"z_1.gno\",\n//                         \"Line\": \"15\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         }\n//     ]\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]\n"},{"name":"z_2_filetest.gno","body":"// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar tree avl.Tree\n\nfunc init() {\n\ttree.Set(\"key0\", \"value0\")\n\ttree.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tupdated = tree.Set(\"key2\", \"value2\")\n\tprintln(updated, tree.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:16]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:16\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:15]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"db333c89cd6773709e031f1f4e4ed4d3fed66c11\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:16\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:14]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"849a50d6c78d65742752e3c89ad8dd556e2e63cb\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"b4fc2fdd2d0fe936c87ed2ace97136cffeed207f\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:15\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:13]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"a1160b0060ad752dbfe5fe436f7734bb19136150\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:14\"\n//         }\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:12]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"fd95e08763159ac529e26986d652e752e78b6325\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"3ecdcf148fe2f9e97b72a3bedf303b2ba56d4f4b\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:13\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:11]={\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\",\n//         \"RefCount\": \"1\"\n//     },\n//     \"Value\": {\n//         \"T\": {\n//             \"@type\": \"/gno.RefType\",\n//             \"ID\": \"gno.land/p/demo/avl.Node\"\n//         },\n//         \"V\": {\n//             \"@type\": \"/gno.RefValue\",\n//             \"Hash\": \"63126557dba88f8556f7a0ccbbfc1d218ae7a302\",\n//             \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:12\"\n//         }\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:3]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Hash\": \"d31c7e797793e03ffe0bbcb72f963264f8300d22\",\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:11\"\n//                 },\n//                 \"Index\": \"0\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\",\n//         \"ModTime\": \"10\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:6]\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"mgroup","path":"gno.land/p/n2p5/mgroup","files":[{"name":"mgroup.gno","body":"// Package mgroup is a simple managed group managing ownership and membership\n// for authorization in gno realms. The ManagedGroup struct is used to manage\n// the owner, backup owners, and members of a group. The owner is the primary\n// owner of the group and can add and remove backup owners and members. Backup\n// owners can claim ownership of the group. This is meant to provide backup\n// accounts for the owner in case the owner account is lost or compromised.\n// Members are used to authorize actions across realms.\npackage mgroup\n\nimport (\n\t\"errors\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ownable\"\n)\n\nvar (\n\tErrCannotRemoveOwner = errors.New(\"mgroup: cannot remove owner\")\n\tErrNotBackupOwner    = errors.New(\"mgroup: not a backup owner\")\n\tErrNotMember         = errors.New(\"mgroup: not a member\")\n\tErrInvalidAddress    = errors.New(\"mgroup: address is invalid\")\n)\n\ntype ManagedGroup struct {\n\towner        *ownable.Ownable\n\tbackupOwners *avl.Tree\n\tmembers      *avl.Tree\n}\n\n// New creates a new ManagedGroup with the owner set to the provided address.\n// The owner is automatically added as a backup owner and member of the group.\nfunc New(ownerAddress std.Address) *ManagedGroup {\n\tg := \u0026ManagedGroup{\n\t\towner:        ownable.NewWithAddress(ownerAddress),\n\t\tbackupOwners: avl.NewTree(),\n\t\tmembers:      avl.NewTree(),\n\t}\n\tg.AddBackupOwner(ownerAddress)\n\tg.AddMember(ownerAddress)\n\treturn g\n}\n\n// AddBackupOwner adds a backup owner to the group by std.Address.\n// If the caller is not the owner, an error is returned.\nfunc (g *ManagedGroup) AddBackupOwner(addr std.Address) error {\n\tif !g.owner.CallerIsOwner() {\n\t\treturn ownable.ErrUnauthorized\n\t}\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\tg.backupOwners.Set(addr.String(), struct{}{})\n\treturn nil\n}\n\n// RemoveBackupOwner removes a backup owner from the group by std.Address.\n// The owner cannot be removed. If the caller is not the owner, an error is returned.\nfunc (g *ManagedGroup) RemoveBackupOwner(addr std.Address) error {\n\tif !g.owner.CallerIsOwner() {\n\t\treturn ownable.ErrUnauthorized\n\t}\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\tif addr == g.Owner() {\n\t\treturn ErrCannotRemoveOwner\n\t}\n\tg.backupOwners.Remove(addr.String())\n\treturn nil\n}\n\n// ClaimOwnership allows a backup owner to claim ownership of the group.\n// If the caller is not a backup owner, an error is returned.\n// The caller is automatically added as a member of the group.\nfunc (g *ManagedGroup) ClaimOwnership() error {\n\tcaller := std.PrevRealm().Addr()\n\t// already owner, skip\n\tif caller == g.Owner() {\n\t\treturn nil\n\t}\n\tif !g.IsBackupOwner(caller) {\n\t\treturn ErrNotMember\n\t}\n\tg.owner = ownable.NewWithAddress(caller)\n\tg.AddMember(caller)\n\treturn nil\n}\n\n// AddMember adds a member to the group by std.Address.\n// If the caller is not the owner, an error is returned.\nfunc (g *ManagedGroup) AddMember(addr std.Address) error {\n\tif !g.owner.CallerIsOwner() {\n\t\treturn ownable.ErrUnauthorized\n\t}\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\tg.members.Set(addr.String(), struct{}{})\n\treturn nil\n}\n\n// RemoveMember removes a member from the group by std.Address.\n// The owner cannot be removed. If the caller is not the owner,\n// an error is returned.\nfunc (g *ManagedGroup) RemoveMember(addr std.Address) error {\n\tif !g.owner.CallerIsOwner() {\n\t\treturn ownable.ErrUnauthorized\n\t}\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\tif addr == g.Owner() {\n\t\treturn ErrCannotRemoveOwner\n\t}\n\tg.members.Remove(addr.String())\n\treturn nil\n}\n\n// MemberCount returns the number of members in the group.\nfunc (g *ManagedGroup) MemberCount() int {\n\treturn g.members.Size()\n}\n\n// BackupOwnerCount returns the number of backup owners in the group.\nfunc (g *ManagedGroup) BackupOwnerCount() int {\n\treturn g.backupOwners.Size()\n}\n\n// IsMember checks if an address is a member of the group.\nfunc (g *ManagedGroup) IsMember(addr std.Address) bool {\n\treturn g.members.Has(addr.String())\n}\n\n// IsBackupOwner checks if an address is a backup owner in the group.\nfunc (g *ManagedGroup) IsBackupOwner(addr std.Address) bool {\n\treturn g.backupOwners.Has(addr.String())\n}\n\n// Owner returns the owner of the group.\nfunc (g *ManagedGroup) Owner() std.Address {\n\treturn g.owner.Owner()\n}\n\n// BackupOwners returns a slice of all backup owners in the group, using the underlying\n// avl.Tree to iterate over the backup owners. If you have a large group, you may\n// want to use BackupOwnersWithOffset to iterate over backup owners in chunks.\nfunc (g *ManagedGroup) BackupOwners() []string {\n\treturn g.BackupOwnersWithOffset(0, g.BackupOwnerCount())\n}\n\n// Members returns a slice of all members in the group, using the underlying\n// avl.Tree to iterate over the members. If you have a large group, you may\n// want to use MembersWithOffset to iterate over members in chunks.\nfunc (g *ManagedGroup) Members() []string {\n\treturn g.MembersWithOffset(0, g.MemberCount())\n}\n\n// BackupOwnersWithOffset returns a slice of backup owners in the group, using the underlying\n// avl.Tree to iterate over the backup owners. The offset and count parameters allow you\n// to iterate over backup owners in chunks to support patterns such as pagination.\nfunc (g *ManagedGroup) BackupOwnersWithOffset(offset, count int) []string {\n\treturn sliceWithOffset(g.backupOwners, offset, count)\n}\n\n// MembersWithOffset returns a slice of members in the group, using the underlying\n// avl.Tree to iterate over the members. The offset and count parameters allow you\n// to iterate over members in chunks to support patterns such as pagination.\nfunc (g *ManagedGroup) MembersWithOffset(offset, count int) []string {\n\treturn sliceWithOffset(g.members, offset, count)\n}\n\n// sliceWithOffset is a helper function to iterate over an avl.Tree with an offset and count.\nfunc sliceWithOffset(t *avl.Tree, offset, count int) []string {\n\tvar result []string\n\tt.IterateByOffset(offset, count, func(k string, _ interface{}) bool {\n\t\tif k == \"\" {\n\t\t\treturn true\n\t\t}\n\t\tresult = append(result, k)\n\t\treturn false\n\t})\n\treturn result\n}\n"},{"name":"mgroup_test.gno","body":"package mgroup\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestManagedGroup(t *testing.T) {\n\tt.Parallel()\n\n\tu1 := testutils.TestAddress(\"u1\")\n\tu2 := testutils.TestAddress(\"u2\")\n\tu3 := testutils.TestAddress(\"u3\")\n\n\tt.Run(\"AddBackupOwner\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\t// happy path\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\terr := g.AddBackupOwner(u2)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", err.Error())\n\t\t\t}\n\t\t}\n\t\t// ensure checking for authorized caller\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u2)\n\t\t\terr := g.AddBackupOwner(u3)\n\t\t\tif err != ownable.ErrUnauthorized {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrNotBackupOwner.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t\t// ensure invalid address is caught\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\tvar badAddr std.Address\n\t\t\terr := g.AddBackupOwner(badAddr)\n\t\t\tif err != ErrInvalidAddress {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrInvalidAddress.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"RemoveBackupOwner\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\t// happy path\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\tg.AddBackupOwner(u2)\n\t\t\terr := g.RemoveBackupOwner(u2)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", err.Error())\n\t\t\t}\n\t\t}\n\t\t// running this twice should not error.\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\terr := g.RemoveBackupOwner(u2)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", err.Error())\n\t\t\t}\n\t\t}\n\t\t// ensure checking for authorized caller\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u2)\n\t\t\terr := g.RemoveBackupOwner(u3)\n\t\t\tif err != ownable.ErrUnauthorized {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrNotBackupOwner.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\tvar badAddr std.Address\n\t\t\terr := g.RemoveBackupOwner(badAddr)\n\t\t\tif err != ErrInvalidAddress {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrInvalidAddress.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\terr := g.RemoveBackupOwner(u1)\n\t\t\tif err != ErrCannotRemoveOwner {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrCannotRemoveOwner.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"ClaimOwnership\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\tg.AddBackupOwner(u2)\n\t\t// happy path\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u2)\n\t\t\terr := g.ClaimOwnership()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", err.Error())\n\t\t\t}\n\t\t\tif g.Owner() != u2 {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", u2, g.Owner())\n\t\t\t}\n\t\t\tif !g.IsMember(u2) {\n\t\t\t\tt.Errorf(\"expected %v to be a member\", u2)\n\t\t\t}\n\t\t}\n\t\t// running this twice should not error.\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u2)\n\t\t\terr := g.ClaimOwnership()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", err.Error())\n\t\t\t}\n\t\t}\n\t\t// ensure checking for authorized caller\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u3)\n\t\t\terr := g.ClaimOwnership()\n\t\t\tif err != ErrNotMember {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrNotMember.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"AddMember\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\t// happy path\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\terr := g.AddMember(u2)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", err.Error())\n\t\t\t}\n\t\t\tif !g.IsMember(u2) {\n\t\t\t\tt.Errorf(\"expected %v to be a member\", u2)\n\t\t\t}\n\t\t}\n\t\t// ensure checking for authorized caller\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u2)\n\t\t\terr := g.AddMember(u3)\n\t\t\tif err != ownable.ErrUnauthorized {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ownable.ErrUnauthorized.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t\t// ensure invalid address is caught\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\tvar badAddr std.Address\n\t\t\terr := g.AddMember(badAddr)\n\t\t\tif err != ErrInvalidAddress {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrInvalidAddress.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"RemoveMember\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\t// happy path\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\tg.AddMember(u2)\n\t\t\terr := g.RemoveMember(u2)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", err.Error())\n\t\t\t}\n\t\t\tif g.IsMember(u2) {\n\t\t\t\tt.Errorf(\"expected %v to not be a member\", u2)\n\t\t\t}\n\t\t}\n\t\t// running this twice should not error.\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\terr := g.RemoveMember(u2)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", err.Error())\n\t\t\t}\n\t\t}\n\t\t// ensure checking for authorized caller\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u2)\n\t\t\terr := g.RemoveMember(u3)\n\t\t\tif err != ownable.ErrUnauthorized {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ownable.ErrUnauthorized.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t\t// ensure invalid address is caught\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\tvar badAddr std.Address\n\t\t\terr := g.RemoveMember(badAddr)\n\t\t\tif err != ErrInvalidAddress {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrInvalidAddress.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t\t// ensure owner cannot be removed\n\t\t{\n\t\t\tstd.TestSetOrigCaller(u1)\n\t\t\terr := g.RemoveMember(u1)\n\t\t\tif err != ErrCannotRemoveOwner {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", ErrCannotRemoveOwner.Error(), err.Error())\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"MemberCount\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\tif g.MemberCount() != 1 {\n\t\t\tt.Errorf(\"expected 0, got %v\", g.MemberCount())\n\t\t}\n\t\tg.AddMember(u2)\n\t\tif g.MemberCount() != 2 {\n\t\t\tt.Errorf(\"expected 1, got %v\", g.MemberCount())\n\t\t}\n\t\tg.AddMember(u3)\n\t\tif g.MemberCount() != 3 {\n\t\t\tt.Errorf(\"expected 2, got %v\", g.MemberCount())\n\t\t}\n\t\tg.RemoveMember(u2)\n\t\tif g.MemberCount() != 2 {\n\t\t\tt.Errorf(\"expected 1, got %v\", g.MemberCount())\n\t\t}\n\t})\n\tt.Run(\"BackupOwnerCount\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\tif g.BackupOwnerCount() != 1 {\n\t\t\tt.Errorf(\"expected 0, got %v\", g.BackupOwnerCount())\n\t\t}\n\t\tg.AddBackupOwner(u2)\n\t\tif g.BackupOwnerCount() != 2 {\n\t\t\tt.Errorf(\"expected 1, got %v\", g.BackupOwnerCount())\n\t\t}\n\t\tg.AddBackupOwner(u3)\n\t\tif g.BackupOwnerCount() != 3 {\n\t\t\tt.Errorf(\"expected 2, got %v\", g.BackupOwnerCount())\n\t\t}\n\t\tg.RemoveBackupOwner(u2)\n\t\tif g.BackupOwnerCount() != 2 {\n\t\t\tt.Errorf(\"expected 1, got %v\", g.BackupOwnerCount())\n\t\t}\n\t})\n\tt.Run(\"IsMember\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\tif !g.IsMember(u1) {\n\t\t\tt.Errorf(\"expected %v to be a member\", u1)\n\t\t}\n\t\tif g.IsMember(u2) {\n\t\t\tt.Errorf(\"expected %v to not be a member\", u2)\n\t\t}\n\t\tg.AddMember(u2)\n\t\tif !g.IsMember(u2) {\n\t\t\tt.Errorf(\"expected %v to be a member\", u2)\n\t\t}\n\t})\n\tt.Run(\"IsBackupOwner\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\tif !g.IsBackupOwner(u1) {\n\t\t\tt.Errorf(\"expected %v to be a backup owner\", u1)\n\t\t}\n\t\tif g.IsBackupOwner(u2) {\n\t\t\tt.Errorf(\"expected %v to not be a backup owner\", u2)\n\t\t}\n\t\tg.AddBackupOwner(u2)\n\t\tif !g.IsBackupOwner(u2) {\n\t\t\tt.Errorf(\"expected %v to be a backup owner\", u2)\n\t\t}\n\t})\n\tt.Run(\"Owner\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tg := New(u1)\n\t\tif g.Owner() != u1 {\n\t\t\tt.Errorf(\"expected %v, got %v\", u1, g.Owner())\n\t\t}\n\t\tg.AddBackupOwner(u2)\n\t\tif g.Owner() != u1 {\n\t\t\tt.Errorf(\"expected %v, got %v\", u1, g.Owner())\n\t\t}\n\t\tstd.TestSetOrigCaller(u2)\n\t\tg.ClaimOwnership()\n\t\tif g.Owner() != u2 {\n\t\t\tt.Errorf(\"expected %v, got %v\", u2, g.Owner())\n\t\t}\n\t})\n\tt.Run(\"BackupOwners\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tstd.TestSetOrigCaller(u1)\n\t\tg := New(u1)\n\t\tg.AddBackupOwner(u2)\n\t\tg.AddBackupOwner(u3)\n\t\towners := g.BackupOwners()\n\t\tif len(owners) != 3 {\n\t\t\tt.Errorf(\"expected 2, got %v\", len(owners))\n\t\t}\n\t\tif owners[0] != u1.String() {\n\t\t\tt.Errorf(\"expected %v, got %v\", u2, owners[0])\n\t\t}\n\t\tif owners[1] != u3.String() {\n\t\t\tt.Errorf(\"expected %v, got %v\", u3, owners[1])\n\t\t}\n\t\tif owners[2] != u2.String() {\n\t\t\tt.Errorf(\"expected %v, got %v\", u3, owners[1])\n\t\t}\n\t})\n\tt.Run(\"Members\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tstd.TestSetOrigCaller(u1)\n\t\tg := New(u1)\n\t\tg.AddMember(u2)\n\t\tg.AddMember(u3)\n\t\tmembers := g.Members()\n\t\tif len(members) != 3 {\n\t\t\tt.Errorf(\"expected 2, got %v\", len(members))\n\t\t}\n\t\tif members[0] != u1.String() {\n\t\t\tt.Errorf(\"expected %v, got %v\", u2, members[0])\n\t\t}\n\t\tif members[1] != u3.String() {\n\t\t\tt.Errorf(\"expected %v, got %v\", u3, members[1])\n\t\t}\n\t\tif members[2] != u2.String() {\n\t\t\tt.Errorf(\"expected %v, got %v\", u3, members[1])\n\t\t}\n\t})\n}\n\nfunc TestSliceWithOffset(t *testing.T) {\n\tt.Parallel()\n\ttestTable := []struct {\n\t\tname          string\n\t\tslice         []string\n\t\toffset        int\n\t\tcount         int\n\t\texpected      []string\n\t\texpectedCount int\n\t}{\n\t\t{\n\t\t\tname:          \"empty\",\n\t\t\tslice:         []string{},\n\t\t\toffset:        0,\n\t\t\tcount:         0,\n\t\t\texpected:      []string{},\n\t\t\texpectedCount: 0,\n\t\t},\n\t\t{\n\t\t\tname:          \"single\",\n\t\t\tslice:         []string{\"a\"},\n\t\t\toffset:        0,\n\t\t\tcount:         1,\n\t\t\texpected:      []string{\"a\"},\n\t\t\texpectedCount: 1,\n\t\t},\n\t\t{\n\t\t\tname:          \"single offset\",\n\t\t\tslice:         []string{\"a\"},\n\t\t\toffset:        1,\n\t\t\tcount:         1,\n\t\t\texpected:      []string{},\n\t\t\texpectedCount: 0,\n\t\t},\n\t\t{\n\t\t\tname:          \"multiple\",\n\t\t\tslice:         []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"},\n\t\t\toffset:        0,\n\t\t\tcount:         10,\n\t\t\texpected:      []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"},\n\t\t\texpectedCount: 10,\n\t\t},\n\t\t{\n\t\t\tname:          \"multiple offset\",\n\t\t\tslice:         []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"},\n\t\t\toffset:        5,\n\t\t\tcount:         5,\n\t\t\texpected:      []string{\"f\", \"g\", \"h\", \"i\", \"j\"},\n\t\t\texpectedCount: 5,\n\t\t},\n\t\t{\n\t\t\tname:          \"multiple offset end\",\n\t\t\tslice:         []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"},\n\t\t\toffset:        10,\n\t\t\tcount:         5,\n\t\t\texpected:      []string{},\n\t\t\texpectedCount: 0,\n\t\t},\n\t\t{\n\t\t\tname:          \"multiple offset past end\",\n\t\t\tslice:         []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"},\n\t\t\toffset:        11,\n\t\t\tcount:         5,\n\t\t\texpected:      []string{},\n\t\t\texpectedCount: 0,\n\t\t},\n\t\t{\n\t\t\tname:          \"multiple offset count past end\",\n\t\t\tslice:         []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"},\n\t\t\toffset:        5,\n\t\t\tcount:         20,\n\t\t\texpected:      []string{\"f\", \"g\", \"h\", \"i\", \"j\"},\n\t\t\texpectedCount: 5,\n\t\t},\n\t}\n\tfor _, test := range testTable {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ttree := avl.NewTree()\n\t\t\tfor _, s := range test.slice {\n\t\t\t\ttree.Set(s, struct{}{})\n\t\t\t}\n\t\t\tslice := sliceWithOffset(tree, test.offset, test.count)\n\t\t\tif len(slice) != test.expectedCount {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expectedCount, len(slice))\n\t\t\t}\n\t\t})\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"pager","path":"gno.land/p/demo/avl/pager","files":[{"name":"pager.gno","body":"package pager\n\nimport (\n\t\"math\"\n\t\"net/url\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// Pager is a struct that holds the AVL tree and pagination parameters.\ntype Pager struct {\n\tTree            avl.ITree\n\tPageQueryParam  string\n\tSizeQueryParam  string\n\tDefaultPageSize int\n\tReversed        bool\n}\n\n// Page represents a single page of results.\ntype Page struct {\n\tItems      []Item\n\tPageNumber int\n\tPageSize   int\n\tTotalItems int\n\tTotalPages int\n\tHasPrev    bool\n\tHasNext    bool\n\tPager      *Pager // Reference to the parent Pager\n}\n\n// Item represents a key-value pair in the AVL tree.\ntype Item struct {\n\tKey   string\n\tValue interface{}\n}\n\n// NewPager creates a new Pager with default values.\nfunc NewPager(tree avl.ITree, defaultPageSize int, reversed bool) *Pager {\n\treturn \u0026Pager{\n\t\tTree:            tree,\n\t\tPageQueryParam:  \"page\",\n\t\tSizeQueryParam:  \"size\",\n\t\tDefaultPageSize: defaultPageSize,\n\t\tReversed:        reversed,\n\t}\n}\n\n// GetPage retrieves a page of results from the AVL tree.\nfunc (p *Pager) GetPage(pageNumber int) *Page {\n\treturn p.GetPageWithSize(pageNumber, p.DefaultPageSize)\n}\n\nfunc (p *Pager) GetPageWithSize(pageNumber, pageSize int) *Page {\n\ttotalItems := p.Tree.Size()\n\ttotalPages := int(math.Ceil(float64(totalItems) / float64(pageSize)))\n\n\tpage := \u0026Page{\n\t\tTotalItems: totalItems,\n\t\tTotalPages: totalPages,\n\t\tPageSize:   pageSize,\n\t\tPager:      p,\n\t}\n\n\t// pages without content\n\tif pageSize \u003c 1 {\n\t\treturn page\n\t}\n\n\t// page number provided is not available\n\tif pageNumber \u003c 1 {\n\t\tpage.HasNext = totalPages \u003e 0\n\t\treturn page\n\t}\n\n\t// page number provided is outside the range of total pages\n\tif pageNumber \u003e totalPages {\n\t\tpage.PageNumber = pageNumber\n\t\tpage.HasPrev = pageNumber \u003e 0\n\t\treturn page\n\t}\n\n\tstartIndex := (pageNumber - 1) * pageSize\n\tendIndex := startIndex + pageSize\n\tif endIndex \u003e totalItems {\n\t\tendIndex = totalItems\n\t}\n\n\titems := []Item{}\n\n\tif p.Reversed {\n\t\tp.Tree.ReverseIterateByOffset(startIndex, endIndex-startIndex, func(key string, value interface{}) bool {\n\t\t\titems = append(items, Item{Key: key, Value: value})\n\t\t\treturn false\n\t\t})\n\t} else {\n\t\tp.Tree.IterateByOffset(startIndex, endIndex-startIndex, func(key string, value interface{}) bool {\n\t\t\titems = append(items, Item{Key: key, Value: value})\n\t\t\treturn false\n\t\t})\n\t}\n\n\tpage.Items = items\n\tpage.PageNumber = pageNumber\n\tpage.HasPrev = pageNumber \u003e 1\n\tpage.HasNext = pageNumber \u003c totalPages\n\treturn page\n}\n\nfunc (p *Pager) MustGetPageByPath(rawURL string) *Page {\n\tpage, err := p.GetPageByPath(rawURL)\n\tif err != nil {\n\t\tpanic(\"invalid path\")\n\t}\n\treturn page\n}\n\n// GetPageByPath retrieves a page of results based on the query parameters in the URL path.\nfunc (p *Pager) GetPageByPath(rawURL string) (*Page, error) {\n\tpageNumber, pageSize, err := p.ParseQuery(rawURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn p.GetPageWithSize(pageNumber, pageSize), nil\n}\n\n// Picker generates the Markdown UI for the page Picker\nfunc (p *Page) Picker() string {\n\tpageNumber := p.PageNumber\n\tpageNumber = max(pageNumber, 1)\n\n\tif p.TotalPages \u003c= 1 {\n\t\treturn \"\"\n\t}\n\n\tmd := \"\"\n\n\tif p.HasPrev {\n\t\t// Always show the first page link\n\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", 1, p.Pager.PageQueryParam, 1)\n\n\t\t// Before\n\t\tif p.PageNumber \u003e 4 {\n\t\t\tmd += \" | \"\n\t\t}\n\n\t\tif p.PageNumber \u003e 3 {\n\t\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", p.PageNumber-2, p.Pager.PageQueryParam, p.PageNumber-2)\n\t\t}\n\n\t\tif p.PageNumber \u003e 2 {\n\t\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", p.PageNumber-1, p.Pager.PageQueryParam, p.PageNumber-1)\n\t\t}\n\t}\n\n\tif p.PageNumber \u003e 0 \u0026\u0026 p.PageNumber \u003c= p.TotalPages {\n\t\t// Current page\n\t\tmd += ufmt.Sprintf(\"**%d**\", p.PageNumber)\n\t} else {\n\t\tmd += ufmt.Sprintf(\"_%d_\", p.PageNumber)\n\t}\n\n\tif p.HasNext {\n\t\tmd += \" | \"\n\n\t\tif p.PageNumber \u003c p.TotalPages-1 {\n\t\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", p.PageNumber+1, p.Pager.PageQueryParam, p.PageNumber+1)\n\t\t}\n\n\t\tif p.PageNumber \u003c p.TotalPages-2 {\n\t\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d) | \", p.PageNumber+2, p.Pager.PageQueryParam, p.PageNumber+2)\n\t\t}\n\n\t\tif p.PageNumber \u003c p.TotalPages-3 {\n\t\t\tmd += \" | \"\n\t\t}\n\n\t\t// Always show the last page link\n\t\tmd += ufmt.Sprintf(\"[%d](?%s=%d)\", p.TotalPages, p.Pager.PageQueryParam, p.TotalPages)\n\t}\n\n\treturn md\n}\n\n// ParseQuery parses the URL to extract the page number and page size.\nfunc (p *Pager) ParseQuery(rawURL string) (int, int, error) {\n\tu, err := url.Parse(rawURL)\n\tif err != nil {\n\t\treturn 1, p.DefaultPageSize, err\n\t}\n\n\tquery := u.Query()\n\tpageNumber := 1\n\tpageSize := p.DefaultPageSize\n\n\tif p.PageQueryParam != \"\" {\n\t\tif pageStr := query.Get(p.PageQueryParam); pageStr != \"\" {\n\t\t\tpageNumber, err = strconv.Atoi(pageStr)\n\t\t\tif err != nil || pageNumber \u003c 1 {\n\t\t\t\tpageNumber = 1\n\t\t\t}\n\t\t}\n\t}\n\n\tif p.SizeQueryParam != \"\" {\n\t\tif sizeStr := query.Get(p.SizeQueryParam); sizeStr != \"\" {\n\t\t\tpageSize, err = strconv.Atoi(sizeStr)\n\t\t\tif err != nil || pageSize \u003c 1 {\n\t\t\t\tpageSize = p.DefaultPageSize\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pageNumber, pageSize, nil\n}\n\nfunc max(a, b int) int {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"},{"name":"pager_test.gno","body":"package pager\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/uassert\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/demo/urequire\"\n)\n\nfunc TestPager_GetPage(t *testing.T) {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\ttree := avl.NewTree()\n\ttree.Set(\"a\", 1)\n\ttree.Set(\"b\", 2)\n\ttree.Set(\"c\", 3)\n\ttree.Set(\"d\", 4)\n\ttree.Set(\"e\", 5)\n\n\tt.Run(\"normal ordering\", func(t *testing.T) {\n\t\t// Create a new pager.\n\t\tpager := NewPager(tree, 10, false)\n\n\t\t// Define test cases.\n\t\ttests := []struct {\n\t\t\tpageNumber int\n\t\t\tpageSize   int\n\t\t\texpected   []Item\n\t\t}{\n\t\t\t{1, 2, []Item{{Key: \"a\", Value: 1}, {Key: \"b\", Value: 2}}},\n\t\t\t{2, 2, []Item{{Key: \"c\", Value: 3}, {Key: \"d\", Value: 4}}},\n\t\t\t{3, 2, []Item{{Key: \"e\", Value: 5}}},\n\t\t\t{1, 3, []Item{{Key: \"a\", Value: 1}, {Key: \"b\", Value: 2}, {Key: \"c\", Value: 3}}},\n\t\t\t{2, 3, []Item{{Key: \"d\", Value: 4}, {Key: \"e\", Value: 5}}},\n\t\t\t{1, 5, []Item{{Key: \"a\", Value: 1}, {Key: \"b\", Value: 2}, {Key: \"c\", Value: 3}, {Key: \"d\", Value: 4}, {Key: \"e\", Value: 5}}},\n\t\t\t{2, 5, []Item{}},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tpage := pager.GetPageWithSize(tt.pageNumber, tt.pageSize)\n\n\t\t\tuassert.Equal(t, len(tt.expected), len(page.Items))\n\n\t\t\tfor i, item := range page.Items {\n\t\t\t\tuassert.Equal(t, tt.expected[i].Key, item.Key)\n\t\t\t\tuassert.Equal(t, tt.expected[i].Value, item.Value)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"reversed ordering\", func(t *testing.T) {\n\t\t// Create a new pager.\n\t\tpager := NewPager(tree, 10, true)\n\n\t\t// Define test cases.\n\t\ttests := []struct {\n\t\t\tpageNumber int\n\t\t\tpageSize   int\n\t\t\texpected   []Item\n\t\t}{\n\t\t\t{1, 2, []Item{{Key: \"e\", Value: 5}, {Key: \"d\", Value: 4}}},\n\t\t\t{2, 2, []Item{{Key: \"c\", Value: 3}, {Key: \"b\", Value: 2}}},\n\t\t\t{3, 2, []Item{{Key: \"a\", Value: 1}}},\n\t\t\t{1, 3, []Item{{Key: \"e\", Value: 5}, {Key: \"d\", Value: 4}, {Key: \"c\", Value: 3}}},\n\t\t\t{2, 3, []Item{{Key: \"b\", Value: 2}, {Key: \"a\", Value: 1}}},\n\t\t\t{1, 5, []Item{{Key: \"e\", Value: 5}, {Key: \"d\", Value: 4}, {Key: \"c\", Value: 3}, {Key: \"b\", Value: 2}, {Key: \"a\", Value: 1}}},\n\t\t\t{2, 5, []Item{}},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tpage := pager.GetPageWithSize(tt.pageNumber, tt.pageSize)\n\n\t\t\tuassert.Equal(t, len(tt.expected), len(page.Items))\n\n\t\t\tfor i, item := range page.Items {\n\t\t\t\tuassert.Equal(t, tt.expected[i].Key, item.Key)\n\t\t\t\tuassert.Equal(t, tt.expected[i].Value, item.Value)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestPager_GetPageByPath(t *testing.T) {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\ttree := avl.NewTree()\n\tfor i := 0; i \u003c 50; i++ {\n\t\ttree.Set(ufmt.Sprintf(\"key%d\", i), i)\n\t}\n\n\t// Create a new pager.\n\tpager := NewPager(tree, 10, false)\n\n\t// Define test cases.\n\ttests := []struct {\n\t\trawURL       string\n\t\texpectedPage int\n\t\texpectedSize int\n\t}{\n\t\t{\"/r/foo:bar/baz?size=10\u0026page=1\", 1, 10},\n\t\t{\"/r/foo:bar/baz?size=10\u0026page=2\", 2, 10},\n\t\t{\"/r/foo:bar/baz?page=3\", 3, pager.DefaultPageSize},\n\t\t{\"/r/foo:bar/baz?size=20\", 1, 20},\n\t\t{\"/r/foo:bar/baz\", 1, pager.DefaultPageSize},\n\t}\n\n\tfor _, tt := range tests {\n\t\tpage, err := pager.GetPageByPath(tt.rawURL)\n\t\turequire.NoError(t, err, ufmt.Sprintf(\"GetPageByPath(%s) returned error: %v\", tt.rawURL, err))\n\n\t\tuassert.Equal(t, tt.expectedPage, page.PageNumber)\n\t\tuassert.Equal(t, tt.expectedSize, page.PageSize)\n\t}\n}\n\nfunc TestPage_Picker(t *testing.T) {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\ttree := avl.NewTree()\n\ttree.Set(\"a\", 1)\n\ttree.Set(\"b\", 2)\n\ttree.Set(\"c\", 3)\n\ttree.Set(\"d\", 4)\n\ttree.Set(\"e\", 5)\n\n\t// Create a new pager.\n\tpager := NewPager(tree, 10, false)\n\n\t// Define test cases.\n\ttests := []struct {\n\t\tpageNumber int\n\t\tpageSize   int\n\t\texpected   string\n\t}{\n\t\t{1, 2, \"**1** | [2](?page=2) | [3](?page=3)\"},\n\t\t{2, 2, \"[1](?page=1) | **2** | [3](?page=3)\"},\n\t\t{3, 2, \"[1](?page=1) | [2](?page=2) | **3**\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tpage := pager.GetPageWithSize(tt.pageNumber, tt.pageSize)\n\n\t\tui := page.Picker()\n\t\tuassert.Equal(t, tt.expected, ui)\n\t}\n}\n\nfunc TestPager_UI_WithManyPages(t *testing.T) {\n\t// Create a new AVL tree and populate it with many key-value pairs.\n\ttree := avl.NewTree()\n\tfor i := 0; i \u003c 100; i++ {\n\t\ttree.Set(ufmt.Sprintf(\"key%d\", i), i)\n\t}\n\n\t// Create a new pager.\n\tpager := NewPager(tree, 10, false)\n\n\t// Define test cases for a large number of pages.\n\ttests := []struct {\n\t\tpageNumber int\n\t\tpageSize   int\n\t\texpected   string\n\t}{\n\t\t// XXX: -1\n\t\t// XXX: 0\n\t\t{1, 10, \"**1** | [2](?page=2) | [3](?page=3) |  | [10](?page=10)\"},\n\t\t{2, 10, \"[1](?page=1) | **2** | [3](?page=3) | [4](?page=4) |  | [10](?page=10)\"},\n\t\t{3, 10, \"[1](?page=1) | [2](?page=2) | **3** | [4](?page=4) | [5](?page=5) |  | [10](?page=10)\"},\n\t\t{4, 10, \"[1](?page=1) | [2](?page=2) | [3](?page=3) | **4** | [5](?page=5) | [6](?page=6) |  | [10](?page=10)\"},\n\t\t{5, 10, \"[1](?page=1) |  | [3](?page=3) | [4](?page=4) | **5** | [6](?page=6) | [7](?page=7) |  | [10](?page=10)\"},\n\t\t{6, 10, \"[1](?page=1) |  | [4](?page=4) | [5](?page=5) | **6** | [7](?page=7) | [8](?page=8) |  | [10](?page=10)\"},\n\t\t{7, 10, \"[1](?page=1) |  | [5](?page=5) | [6](?page=6) | **7** | [8](?page=8) | [9](?page=9) | [10](?page=10)\"},\n\t\t{8, 10, \"[1](?page=1) |  | [6](?page=6) | [7](?page=7) | **8** | [9](?page=9) | [10](?page=10)\"},\n\t\t{9, 10, \"[1](?page=1) |  | [7](?page=7) | [8](?page=8) | **9** | [10](?page=10)\"},\n\t\t{10, 10, \"[1](?page=1) |  | [8](?page=8) | [9](?page=9) | **10**\"},\n\t\t// XXX: 11\n\t}\n\n\tfor _, tt := range tests {\n\t\tpage := pager.GetPageWithSize(tt.pageNumber, tt.pageSize)\n\n\t\tui := page.Picker()\n\t\tuassert.Equal(t, tt.expected, ui)\n\t}\n}\n\nfunc TestPager_ParseQuery(t *testing.T) {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\ttree := avl.NewTree()\n\ttree.Set(\"a\", 1)\n\ttree.Set(\"b\", 2)\n\ttree.Set(\"c\", 3)\n\ttree.Set(\"d\", 4)\n\ttree.Set(\"e\", 5)\n\n\t// Create a new pager.\n\tpager := NewPager(tree, 10, false)\n\n\t// Define test cases.\n\ttests := []struct {\n\t\trawURL        string\n\t\texpectedPage  int\n\t\texpectedSize  int\n\t\texpectedError bool\n\t}{\n\t\t{\"/r/foo:bar/baz?size=2\u0026page=1\", 1, 2, false},\n\t\t{\"/r/foo:bar/baz?size=3\u0026page=2\", 2, 3, false},\n\t\t{\"/r/foo:bar/baz?size=5\u0026page=3\", 3, 5, false},\n\t\t{\"/r/foo:bar/baz?page=2\", 2, pager.DefaultPageSize, false},\n\t\t{\"/r/foo:bar/baz?size=3\", 1, 3, false},\n\t\t{\"/r/foo:bar/baz\", 1, pager.DefaultPageSize, false},\n\t\t{\"/r/foo:bar/baz?size=0\u0026page=0\", 1, pager.DefaultPageSize, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tpage, size, err := pager.ParseQuery(tt.rawURL)\n\t\tif tt.expectedError {\n\t\t\tuassert.Error(t, err, ufmt.Sprintf(\"ParseQuery(%s) expected error but got none\", tt.rawURL))\n\t\t} else {\n\t\t\turequire.NoError(t, err, ufmt.Sprintf(\"ParseQuery(%s) returned error: %v\", tt.rawURL, err))\n\t\t\tuassert.Equal(t, tt.expectedPage, page, ufmt.Sprintf(\"ParseQuery(%s) returned page %d, expected %d\", tt.rawURL, page, tt.expectedPage))\n\t\t\tuassert.Equal(t, tt.expectedSize, size, ufmt.Sprintf(\"ParseQuery(%s) returned size %d, expected %d\", tt.rawURL, size, tt.expectedSize))\n\t\t}\n\t}\n}\n"},{"name":"z_filetest.gno","body":"package main\n\nimport (\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/avl/pager\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc main() {\n\t// Create a new AVL tree and populate it with some key-value pairs.\n\tvar id seqid.ID\n\ttree := avl.NewTree()\n\tfor i := 0; i \u003c 42; i++ {\n\t\ttree.Set(id.Next().String(), i)\n\t}\n\n\t// Create a new pager.\n\tpager := pager.NewPager(tree, 7, false)\n\n\tfor pn := -1; pn \u003c 8; pn++ {\n\t\tpage := pager.GetPage(pn)\n\n\t\tprintln(ufmt.Sprintf(\"## Page %d of %d\", page.PageNumber, page.TotalPages))\n\t\tfor idx, item := range page.Items {\n\t\t\tprintln(ufmt.Sprintf(\"- idx=%d key=%s value=%d\", idx, item.Key, item.Value))\n\t\t}\n\t\tprintln(page.Picker())\n\t\tprintln()\n\t}\n}\n\n// Output:\n// ## Page 0 of 6\n// _0_ | [1](?page=1) | [2](?page=2) |  | [6](?page=6)\n//\n// ## Page 0 of 6\n// _0_ | [1](?page=1) | [2](?page=2) |  | [6](?page=6)\n//\n// ## Page 1 of 6\n// - idx=0 key=0000001 value=0\n// - idx=1 key=0000002 value=1\n// - idx=2 key=0000003 value=2\n// - idx=3 key=0000004 value=3\n// - idx=4 key=0000005 value=4\n// - idx=5 key=0000006 value=5\n// - idx=6 key=0000007 value=6\n// **1** | [2](?page=2) | [3](?page=3) |  | [6](?page=6)\n//\n// ## Page 2 of 6\n// - idx=0 key=0000008 value=7\n// - idx=1 key=0000009 value=8\n// - idx=2 key=000000a value=9\n// - idx=3 key=000000b value=10\n// - idx=4 key=000000c value=11\n// - idx=5 key=000000d value=12\n// - idx=6 key=000000e value=13\n// [1](?page=1) | **2** | [3](?page=3) | [4](?page=4) |  | [6](?page=6)\n//\n// ## Page 3 of 6\n// - idx=0 key=000000f value=14\n// - idx=1 key=000000g value=15\n// - idx=2 key=000000h value=16\n// - idx=3 key=000000j value=17\n// - idx=4 key=000000k value=18\n// - idx=5 key=000000m value=19\n// - idx=6 key=000000n value=20\n// [1](?page=1) | [2](?page=2) | **3** | [4](?page=4) | [5](?page=5) | [6](?page=6)\n//\n// ## Page 4 of 6\n// - idx=0 key=000000p value=21\n// - idx=1 key=000000q value=22\n// - idx=2 key=000000r value=23\n// - idx=3 key=000000s value=24\n// - idx=4 key=000000t value=25\n// - idx=5 key=000000v value=26\n// - idx=6 key=000000w value=27\n// [1](?page=1) | [2](?page=2) | [3](?page=3) | **4** | [5](?page=5) | [6](?page=6)\n//\n// ## Page 5 of 6\n// - idx=0 key=000000x value=28\n// - idx=1 key=000000y value=29\n// - idx=2 key=000000z value=30\n// - idx=3 key=0000010 value=31\n// - idx=4 key=0000011 value=32\n// - idx=5 key=0000012 value=33\n// - idx=6 key=0000013 value=34\n// [1](?page=1) |  | [3](?page=3) | [4](?page=4) | **5** | [6](?page=6)\n//\n// ## Page 6 of 6\n// - idx=0 key=0000014 value=35\n// - idx=1 key=0000015 value=36\n// - idx=2 key=0000016 value=37\n// - idx=3 key=0000017 value=38\n// - idx=4 key=0000018 value=39\n// - idx=5 key=0000019 value=40\n// - idx=6 key=000001a value=41\n// [1](?page=1) |  | [4](?page=4) | [5](?page=5) | **6**\n//\n// ## Page 7 of 6\n// [1](?page=1) |  | [5](?page=5) | [6](?page=6) | _7_\n//\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"list","path":"gno.land/p/demo/avl/list","files":[{"name":"list.gno","body":"// Package list implements a dynamic list data structure backed by an AVL tree.\n// It provides O(log n) operations for most list operations while maintaining\n// order stability.\n//\n// The list supports various operations including append, get, set, delete,\n// range queries, and iteration. It can store values of any type.\n//\n// Example usage:\n//\n//\t// Create a new list and add elements\n//\tvar l list.List\n//\tl.Append(1, 2, 3)\n//\n//\t// Get and set elements\n//\tvalue := l.Get(1)  // returns 2\n//\tl.Set(1, 42)      // updates index 1 to 42\n//\n//\t// Delete elements\n//\tl.Delete(0)       // removes first element\n//\n//\t// Iterate over elements\n//\tl.ForEach(func(index int, value interface{}) bool {\n//\t    ufmt.Printf(\"index %d: %v\\n\", index, value)\n//\t    return false  // continue iteration\n//\t})\n//\t// Output:\n//\t// index 0: 42\n//\t// index 1: 3\n//\n//\t// Create a list of specific size\n//\tl = list.Make(3, \"default\")  // creates [default, default, default]\n//\n//\t// Create a list using a variable declaration\n//\tvar l2 list.List\n//\tl2.Append(4, 5, 6)\n//\tprintln(l2.Len())  // Output: 3\npackage list\n\nimport (\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/seqid\"\n)\n\n// List represents an ordered sequence of items backed by an AVL tree\ntype List struct {\n\ttree  avl.Tree\n\tidGen seqid.ID\n}\n\n// Len returns the number of elements in the list.\n//\n// Example:\n//\n//\tl := list.New()\n//\tl.Append(1, 2, 3)\n//\tprintln(l.Len()) // Output: 3\nfunc (l *List) Len() int {\n\treturn l.tree.Size()\n}\n\n// Append adds one or more values to the end of the list.\n//\n// Example:\n//\n//\tl := list.New()\n//\tl.Append(1)        // adds single value\n//\tl.Append(2, 3, 4)  // adds multiple values\n//\tprintln(l.Len()) // Output: 4\nfunc (l *List) Append(values ...interface{}) {\n\tfor _, v := range values {\n\t\tl.tree.Set(l.idGen.Next().String(), v)\n\t}\n}\n\n// Get returns the value at the specified index.\n// Returns nil if index is out of bounds.\n//\n// Example:\n//\n//\tl := list.New()\n//\tl.Append(1, 2, 3)\n//\tprintln(l.Get(1))    // Output: 2\n//\tprintln(l.Get(-1))   // Output: nil\n//\tprintln(l.Get(999))  // Output: nil\nfunc (l *List) Get(index int) interface{} {\n\tif index \u003c 0 || index \u003e= l.tree.Size() {\n\t\treturn nil\n\t}\n\t_, value := l.tree.GetByIndex(index)\n\treturn value\n}\n\n// Set updates or appends a value at the specified index.\n// Returns true if the operation was successful, false otherwise.\n// For empty lists, only index 0 is valid (append case).\n//\n// Example:\n//\n//\tl := list.New()\n//\tl.Append(1, 2, 3)\n//\n//\tl.Set(1, 42)      // updates existing index\n//\tprintln(l.Get(1)) // Output: 42\n//\n//\tl.Set(3, 4)       // appends at end\n//\tprintln(l.Get(3)) // Output: 4\n//\n//\tl.Set(-1, 5)      // invalid index\n//\tprintln(l.Len()) // Output: 4 (list unchanged)\nfunc (l *List) Set(index int, value interface{}) bool {\n\tsize := l.tree.Size()\n\n\t// Handle empty list case - only allow index 0\n\tif size == 0 {\n\t\tif index == 0 {\n\t\t\tl.Append(value)\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tif index \u003c 0 || index \u003e size {\n\t\treturn false\n\t}\n\n\t// If setting at the end (append case)\n\tif index == size {\n\t\tl.Append(value)\n\t\treturn true\n\t}\n\n\t// Get the key at the specified index\n\tkey, _ := l.tree.GetByIndex(index)\n\tif key == \"\" {\n\t\treturn false\n\t}\n\n\t// Update the value at the existing key\n\tl.tree.Set(key, value)\n\treturn true\n}\n\n// Delete removes the element at the specified index.\n// Returns the deleted value and true if successful, nil and false otherwise.\n//\n// Example:\n//\n//\tl := list.New()\n//\tl.Append(1, 2, 3)\n//\n//\tval, ok := l.Delete(1)\n//\tprintln(val, ok)  // Output: 2 true\n//\tprintln(l.Len())  // Output: 2\n//\n//\tval, ok = l.Delete(-1)\n//\tprintln(val, ok)  // Output: nil false\nfunc (l *List) Delete(index int) (interface{}, bool) {\n\tsize := l.tree.Size()\n\t// Always return nil, false for empty list\n\tif size == 0 {\n\t\treturn nil, false\n\t}\n\n\tif index \u003c 0 || index \u003e= size {\n\t\treturn nil, false\n\t}\n\n\tkey, value := l.tree.GetByIndex(index)\n\tif key == \"\" {\n\t\treturn nil, false\n\t}\n\n\tl.tree.Remove(key)\n\treturn value, true\n}\n\n// Slice returns a slice of values from startIndex (inclusive) to endIndex (exclusive).\n// Returns nil if the range is invalid.\n//\n// Example:\n//\n//\tl := list.New()\n//\tl.Append(1, 2, 3, 4, 5)\n//\n//\tprintln(l.Slice(1, 4))   // Output: [2 3 4]\n//\tprintln(l.Slice(-1, 2))  // Output: [1 2]\n//\tprintln(l.Slice(3, 999)) // Output: [4 5]\n//\tprintln(l.Slice(3, 2))   // Output: nil\nfunc (l *List) Slice(startIndex, endIndex int) []interface{} {\n\tsize := l.tree.Size()\n\n\t// Normalize bounds\n\tif startIndex \u003c 0 {\n\t\tstartIndex = 0\n\t}\n\tif endIndex \u003e size {\n\t\tendIndex = size\n\t}\n\tif startIndex \u003e= endIndex {\n\t\treturn nil\n\t}\n\n\tcount := endIndex - startIndex\n\tresult := make([]interface{}, count)\n\n\ti := 0\n\tl.tree.IterateByOffset(startIndex, count, func(_ string, value interface{}) bool {\n\t\tresult[i] = value\n\t\ti++\n\t\treturn false\n\t})\n\treturn result\n}\n\n// ForEach iterates through all elements in the list.\nfunc (l *List) ForEach(fn func(index int, value interface{}) bool) {\n\tif l.tree.Size() == 0 {\n\t\treturn\n\t}\n\n\tindex := 0\n\tl.tree.IterateByOffset(0, l.tree.Size(), func(_ string, value interface{}) bool {\n\t\tresult := fn(index, value)\n\t\tindex++\n\t\treturn result\n\t})\n}\n\n// Clone creates a shallow copy of the list.\n//\n// Example:\n//\n//\tl := list.New()\n//\tl.Append(1, 2, 3)\n//\n//\tclone := l.Clone()\n//\tclone.Set(0, 42)\n//\n//\tprintln(l.Get(0))    // Output: 1\n//\tprintln(clone.Get(0)) // Output: 42\nfunc (l *List) Clone() *List {\n\tnewList := \u0026List{\n\t\ttree:  avl.Tree{},\n\t\tidGen: l.idGen,\n\t}\n\n\tsize := l.tree.Size()\n\tif size == 0 {\n\t\treturn newList\n\t}\n\n\tl.tree.IterateByOffset(0, size, func(_ string, value interface{}) bool {\n\t\tnewList.Append(value)\n\t\treturn false\n\t})\n\n\treturn newList\n}\n\n// DeleteRange removes elements from startIndex (inclusive) to endIndex (exclusive).\n// Returns the number of elements deleted.\n//\n// Example:\n//\n//\tl := list.New()\n//\tl.Append(1, 2, 3, 4, 5)\n//\n//\tdeleted := l.DeleteRange(1, 4)\n//\tprintln(deleted)     // Output: 3\n//\tprintln(l.Range(0, l.Len())) // Output: [1 5]\nfunc (l *List) DeleteRange(startIndex, endIndex int) int {\n\tsize := l.tree.Size()\n\n\t// Normalize bounds\n\tif startIndex \u003c 0 {\n\t\tstartIndex = 0\n\t}\n\tif endIndex \u003e size {\n\t\tendIndex = size\n\t}\n\tif startIndex \u003e= endIndex {\n\t\treturn 0\n\t}\n\n\t// Collect keys to delete\n\tkeysToDelete := make([]string, 0, endIndex-startIndex)\n\tl.tree.IterateByOffset(startIndex, endIndex-startIndex, func(key string, _ interface{}) bool {\n\t\tkeysToDelete = append(keysToDelete, key)\n\t\treturn false\n\t})\n\n\t// Delete collected keys\n\tfor _, key := range keysToDelete {\n\t\tl.tree.Remove(key)\n\t}\n\n\treturn len(keysToDelete)\n}\n"},{"name":"list_test.gno","body":"package list\n\nimport (\n\t\"testing\"\n)\n\nfunc TestList_Basic(t *testing.T) {\n\tvar l List\n\n\t// Test empty list\n\tif l.Len() != 0 {\n\t\tt.Errorf(\"new list should be empty, got len %d\", l.Len())\n\t}\n\n\t// Test append and length\n\tl.Append(1, 2, 3)\n\tif l.Len() != 3 {\n\t\tt.Errorf(\"expected len 3, got %d\", l.Len())\n\t}\n\n\t// Test get\n\tif v := l.Get(0); v != 1 {\n\t\tt.Errorf(\"expected 1 at index 0, got %v\", v)\n\t}\n\tif v := l.Get(1); v != 2 {\n\t\tt.Errorf(\"expected 2 at index 1, got %v\", v)\n\t}\n\tif v := l.Get(2); v != 3 {\n\t\tt.Errorf(\"expected 3 at index 2, got %v\", v)\n\t}\n\n\t// Test out of bounds\n\tif v := l.Get(-1); v != nil {\n\t\tt.Errorf(\"expected nil for negative index, got %v\", v)\n\t}\n\tif v := l.Get(3); v != nil {\n\t\tt.Errorf(\"expected nil for out of bounds index, got %v\", v)\n\t}\n}\n\nfunc TestList_Set(t *testing.T) {\n\tvar l List\n\tl.Append(1, 2, 3)\n\n\t// Test valid set within bounds\n\tif ok := l.Set(1, 42); !ok {\n\t\tt.Error(\"Set should return true for valid index\")\n\t}\n\tif v := l.Get(1); v != 42 {\n\t\tt.Errorf(\"expected 42 after Set, got %v\", v)\n\t}\n\n\t// Test set at size (append)\n\tif ok := l.Set(3, 4); !ok {\n\t\tt.Error(\"Set should return true when appending at size\")\n\t}\n\tif v := l.Get(3); v != 4 {\n\t\tt.Errorf(\"expected 4 after Set at size, got %v\", v)\n\t}\n\n\t// Test invalid sets\n\tif ok := l.Set(-1, 10); ok {\n\t\tt.Error(\"Set should return false for negative index\")\n\t}\n\tif ok := l.Set(5, 10); ok {\n\t\tt.Error(\"Set should return false for index \u003e size\")\n\t}\n\n\t// Verify list state hasn't changed after invalid operations\n\texpected := []interface{}{1, 42, 3, 4}\n\tfor i, want := range expected {\n\t\tif got := l.Get(i); got != want {\n\t\t\tt.Errorf(\"index %d = %v; want %v\", i, got, want)\n\t\t}\n\t}\n}\n\nfunc TestList_Delete(t *testing.T) {\n\tvar l List\n\tl.Append(1, 2, 3)\n\n\t// Test valid delete\n\tif v, ok := l.Delete(1); !ok || v != 2 {\n\t\tt.Errorf(\"Delete(1) = %v, %v; want 2, true\", v, ok)\n\t}\n\tif l.Len() != 2 {\n\t\tt.Errorf(\"expected len 2 after delete, got %d\", l.Len())\n\t}\n\tif v := l.Get(1); v != 3 {\n\t\tt.Errorf(\"expected 3 at index 1 after delete, got %v\", v)\n\t}\n\n\t// Test invalid delete\n\tif v, ok := l.Delete(-1); ok || v != nil {\n\t\tt.Errorf(\"Delete(-1) = %v, %v; want nil, false\", v, ok)\n\t}\n\tif v, ok := l.Delete(2); ok || v != nil {\n\t\tt.Errorf(\"Delete(2) = %v, %v; want nil, false\", v, ok)\n\t}\n}\n\nfunc TestList_Slice(t *testing.T) {\n\tvar l List\n\tl.Append(1, 2, 3, 4, 5)\n\n\t// Test valid ranges\n\tvalues := l.Slice(1, 4)\n\texpected := []interface{}{2, 3, 4}\n\tif !sliceEqual(values, expected) {\n\t\tt.Errorf(\"Slice(1,4) = %v; want %v\", values, expected)\n\t}\n\n\t// Test edge cases\n\tif values := l.Slice(-1, 2); !sliceEqual(values, []interface{}{1, 2}) {\n\t\tt.Errorf(\"Slice(-1,2) = %v; want [1 2]\", values)\n\t}\n\tif values := l.Slice(3, 10); !sliceEqual(values, []interface{}{4, 5}) {\n\t\tt.Errorf(\"Slice(3,10) = %v; want [4 5]\", values)\n\t}\n\tif values := l.Slice(3, 2); values != nil {\n\t\tt.Errorf(\"Slice(3,2) = %v; want nil\", values)\n\t}\n}\n\nfunc TestList_ForEach(t *testing.T) {\n\tvar l List\n\tl.Append(1, 2, 3)\n\n\tsum := 0\n\tl.ForEach(func(index int, value interface{}) bool {\n\t\tsum += value.(int)\n\t\treturn false\n\t})\n\n\tif sum != 6 {\n\t\tt.Errorf(\"ForEach sum = %d; want 6\", sum)\n\t}\n\n\t// Test early termination\n\tcount := 0\n\tl.ForEach(func(index int, value interface{}) bool {\n\t\tcount++\n\t\treturn true // stop after first item\n\t})\n\n\tif count != 1 {\n\t\tt.Errorf(\"ForEach early termination count = %d; want 1\", count)\n\t}\n}\n\nfunc TestList_Clone(t *testing.T) {\n\tvar l List\n\tl.Append(1, 2, 3)\n\n\tclone := l.Clone()\n\n\t// Test same length\n\tif clone.Len() != l.Len() {\n\t\tt.Errorf(\"clone.Len() = %d; want %d\", clone.Len(), l.Len())\n\t}\n\n\t// Test same values\n\tfor i := 0; i \u003c l.Len(); i++ {\n\t\tif clone.Get(i) != l.Get(i) {\n\t\t\tt.Errorf(\"clone.Get(%d) = %v; want %v\", i, clone.Get(i), l.Get(i))\n\t\t}\n\t}\n\n\t// Test independence\n\tl.Set(0, 42)\n\tif clone.Get(0) == l.Get(0) {\n\t\tt.Error(\"clone should be independent of original\")\n\t}\n}\n\nfunc TestList_DeleteRange(t *testing.T) {\n\tvar l List\n\tl.Append(1, 2, 3, 4, 5)\n\n\t// Test valid range delete\n\tdeleted := l.DeleteRange(1, 4)\n\tif deleted != 3 {\n\t\tt.Errorf(\"DeleteRange(1,4) deleted %d elements; want 3\", deleted)\n\t}\n\tif l.Len() != 2 {\n\t\tt.Errorf(\"after DeleteRange(1,4) len = %d; want 2\", l.Len())\n\t}\n\texpected := []interface{}{1, 5}\n\tfor i, want := range expected {\n\t\tif got := l.Get(i); got != want {\n\t\t\tt.Errorf(\"after DeleteRange(1,4) index %d = %v; want %v\", i, got, want)\n\t\t}\n\t}\n\n\t// Test edge cases\n\tl = List{}\n\tl.Append(1, 2, 3)\n\n\t// Delete with negative start\n\tif deleted := l.DeleteRange(-1, 2); deleted != 2 {\n\t\tt.Errorf(\"DeleteRange(-1,2) deleted %d elements; want 2\", deleted)\n\t}\n\n\t// Delete with end \u003e length\n\tl = List{}\n\tl.Append(1, 2, 3)\n\tif deleted := l.DeleteRange(1, 5); deleted != 2 {\n\t\tt.Errorf(\"DeleteRange(1,5) deleted %d elements; want 2\", deleted)\n\t}\n\n\t// Delete invalid range\n\tif deleted := l.DeleteRange(2, 1); deleted != 0 {\n\t\tt.Errorf(\"DeleteRange(2,1) deleted %d elements; want 0\", deleted)\n\t}\n\n\t// Delete empty range\n\tif deleted := l.DeleteRange(1, 1); deleted != 0 {\n\t\tt.Errorf(\"DeleteRange(1,1) deleted %d elements; want 0\", deleted)\n\t}\n}\n\nfunc TestList_EmptyOperations(t *testing.T) {\n\tvar l List\n\n\t// Operations on empty list\n\tif v := l.Get(0); v != nil {\n\t\tt.Errorf(\"Get(0) on empty list = %v; want nil\", v)\n\t}\n\n\t// Set should work at index 0 for empty list (append case)\n\tif ok := l.Set(0, 1); !ok {\n\t\tt.Error(\"Set(0,1) on empty list = false; want true\")\n\t}\n\tif v := l.Get(0); v != 1 {\n\t\tt.Errorf(\"Get(0) after Set = %v; want 1\", v)\n\t}\n\n\tl = List{} // Reset to empty list\n\tif v, ok := l.Delete(0); ok || v != nil {\n\t\tt.Errorf(\"Delete(0) on empty list = %v, %v; want nil, false\", v, ok)\n\t}\n\tif values := l.Slice(0, 1); values != nil {\n\t\tt.Errorf(\"Range(0,1) on empty list = %v; want nil\", values)\n\t}\n}\n\nfunc TestList_DifferentTypes(t *testing.T) {\n\tvar l List\n\n\t// Test with different types\n\tl.Append(42, \"hello\", true, 3.14)\n\n\tif v := l.Get(0).(int); v != 42 {\n\t\tt.Errorf(\"Get(0) = %v; want 42\", v)\n\t}\n\tif v := l.Get(1).(string); v != \"hello\" {\n\t\tt.Errorf(\"Get(1) = %v; want 'hello'\", v)\n\t}\n\tif v := l.Get(2).(bool); !v {\n\t\tt.Errorf(\"Get(2) = %v; want true\", v)\n\t}\n\tif v := l.Get(3).(float64); v != 3.14 {\n\t\tt.Errorf(\"Get(3) = %v; want 3.14\", v)\n\t}\n}\n\nfunc TestList_LargeOperations(t *testing.T) {\n\tvar l List\n\n\t// Test with larger number of elements\n\tn := 1000\n\tfor i := 0; i \u003c n; i++ {\n\t\tl.Append(i)\n\t}\n\n\tif l.Len() != n {\n\t\tt.Errorf(\"Len() = %d; want %d\", l.Len(), n)\n\t}\n\n\t// Test range on large list\n\tvalues := l.Slice(n-3, n)\n\texpected := []interface{}{n - 3, n - 2, n - 1}\n\tif !sliceEqual(values, expected) {\n\t\tt.Errorf(\"Range(%d,%d) = %v; want %v\", n-3, n, values, expected)\n\t}\n\n\t// Test large range deletion\n\tdeleted := l.DeleteRange(100, 900)\n\tif deleted != 800 {\n\t\tt.Errorf(\"DeleteRange(100,900) = %d; want 800\", deleted)\n\t}\n\tif l.Len() != 200 {\n\t\tt.Errorf(\"Len() after large delete = %d; want 200\", l.Len())\n\t}\n}\n\nfunc TestList_ChainedOperations(t *testing.T) {\n\tvar l List\n\n\t// Test sequence of operations\n\tl.Append(1, 2, 3)\n\tl.Delete(1)\n\tl.Append(4)\n\tl.Set(1, 5)\n\n\texpected := []interface{}{1, 5, 4}\n\tfor i, want := range expected {\n\t\tif got := l.Get(i); got != want {\n\t\t\tt.Errorf(\"index %d = %v; want %v\", i, got, want)\n\t\t}\n\t}\n}\n\nfunc TestList_RangeEdgeCases(t *testing.T) {\n\tvar l List\n\tl.Append(1, 2, 3, 4, 5)\n\n\t// Test various edge cases for Range\n\tcases := []struct {\n\t\tstart, end int\n\t\twant       []interface{}\n\t}{\n\t\t{-10, 2, []interface{}{1, 2}},\n\t\t{3, 10, []interface{}{4, 5}},\n\t\t{0, 0, nil},\n\t\t{5, 5, nil},\n\t\t{4, 3, nil},\n\t\t{-1, -1, nil},\n\t}\n\n\tfor _, tc := range cases {\n\t\tgot := l.Slice(tc.start, tc.end)\n\t\tif !sliceEqual(got, tc.want) {\n\t\t\tt.Errorf(\"Slice(%d,%d) = %v; want %v\", tc.start, tc.end, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestList_IndexConsistency(t *testing.T) {\n\tvar l List\n\n\t// Initial additions\n\tl.Append(1, 2, 3, 4, 5) // [1,2,3,4,5]\n\n\t// Delete from middle\n\tl.Delete(2) // [1,2,4,5]\n\n\t// Add more elements\n\tl.Append(6, 7) // [1,2,4,5,6,7]\n\n\t// Delete range from middle\n\tl.DeleteRange(1, 4) // [1,6,7]\n\n\t// Add more elements\n\tl.Append(8, 9, 10) // [1,6,7,8,9,10]\n\n\t// Verify sequence is continuous\n\texpected := []interface{}{1, 6, 7, 8, 9, 10}\n\tfor i, want := range expected {\n\t\tif got := l.Get(i); got != want {\n\t\t\tt.Errorf(\"index %d = %v; want %v\", i, got, want)\n\t\t}\n\t}\n\n\t// Verify no extra elements exist\n\tif l.Len() != len(expected) {\n\t\tt.Errorf(\"length = %d; want %d\", l.Len(), len(expected))\n\t}\n\n\t// Verify all indices are accessible\n\tallValues := l.Slice(0, l.Len())\n\tif !sliceEqual(allValues, expected) {\n\t\tt.Errorf(\"Slice(0, Len()) = %v; want %v\", allValues, expected)\n\t}\n\n\t// Verify no gaps in iteration\n\tvar iteratedValues []interface{}\n\tvar indices []int\n\tl.ForEach(func(index int, value interface{}) bool {\n\t\titeratedValues = append(iteratedValues, value)\n\t\tindices = append(indices, index)\n\t\treturn false\n\t})\n\n\t// Check values from iteration\n\tif !sliceEqual(iteratedValues, expected) {\n\t\tt.Errorf(\"ForEach values = %v; want %v\", iteratedValues, expected)\n\t}\n\n\t// Check indices are sequential\n\tfor i, idx := range indices {\n\t\tif idx != i {\n\t\t\tt.Errorf(\"ForEach index %d = %d; want %d\", i, idx, i)\n\t\t}\n\t}\n}\n\n// Helper function to compare slices\nfunc sliceEqual(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1sd5ezmxt4rwpy52u6wl3l3y085n8x0p6nllxm8","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"FqcS/1WSqaXgL9vfsW9jq87Dzx/X6ThvwBBZVc0Km+VJ1w0+E1DZfnbfWaiAmmOaYxpxijOORp1gIedZf2ZiTw=="}],"memo":""},"metadata":{"timestamp":"1734745256"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g14kdg0zn97xms3eza5xh6lcycmwm4zjksg4peum","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"CajmRNA7KHlKWr2UvcGBe4zA/vC+Ncd+EBHNqmnrGXMNCiXnUzSsaP/rPUVfOx+VeGZxXAnHXEI6xKBIrn2vdg=="}],"memo":""},"metadata":{"timestamp":"1734831883"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1573m9g33259m6zjztwrg82adllm0rl07x4psgf","amount":"5000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"qo/b8dTbTCLYKRUjevzBKmrwAzrokTxoEGM+I3PWDsEm/Ado2Ws9By93oP+cW5MYiYvFWRWJnLW4gzilRFI0HA=="}],"memo":""},"metadata":{"timestamp":"1734933466"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1n2mpwnwtfwpa7qngxfdemrk598r8yn52qhm9j9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"1yNliP/gkl378yXfpD9j+3MVWIUX6x5G+x85pWrZUqY27CT+s/FN89x7o9UWskxwbtVY3L90VqLVJbjhujW7kA=="}],"memo":""},"metadata":{"timestamp":"1734875124"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1n2mpwnwtfwpa7qngxfdemrk598r8yn52qhm9j9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"n+ZKh2/qgSu8AqtdMLnpEgH3MQRF91cZ1LsKMWeMzDsqAjZmOYHnoD3igFTdPRKol6kYfw/E4ON03YqIXj9OIw=="}],"memo":""},"metadata":{"timestamp":"1734790363"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1n2mpwnwtfwpa7qngxfdemrk598r8yn52qhm9j9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"zzwHlDl9ZgL8R6dFxE0WqzPLmtZ+TAoDSOTT50erNQFoHOgmjzpL8t6lCdCbxD2BGEckhV+mZNSfbP9xoX3O2Q=="}],"memo":""},"metadata":{"timestamp":"1734959203"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1uggg98wfa4jftqw2al4vqq4eayr7zkgakly0zs","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"IuwKRPJ2kR7ypEb+PFLqcn8phrKD2YghcljWBrj/WdAjansGcVYQCZ2whwNI9RvmsBYDpGo7bd3DULTjc0yJng=="}],"memo":""},"metadata":{"timestamp":"1734866086"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1uggg98wfa4jftqw2al4vqq4eayr7zkgakly0zs","amount":"5000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"NKrEwP7KquBsCP7bLcgh52284zz43pmWl0ykcF0+ApsiZ56UnrcbJY+7zVdJ+yPgt2kWc+Q3VK2dknVo5OQHfQ=="}],"memo":""},"metadata":{"timestamp":"1734866116"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1sd5ezmxt4rwpy52u6wl3l3y085n8x0p6nllxm8","send":"","pkg_path":"gno.land/r/leon/hof","func":"Upvote","args":["gno.land/r/matijamarjanovic/home"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aiv9tqagYf7E57BDv13G2FRAt+yvhG915Lu0eJSRl0z4"},"signature":"NhymZb+dlXqS4BHBU9jQLgc2dMsAUQJaysG5UMHdQDUMVMW5XW/XSu9iOljjcwPkQwDi7BI3nHJCFDoNDjWa8Q=="}],"memo":""},"metadata":{"timestamp":"1734745271"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1sd5ezmxt4rwpy52u6wl3l3y085n8x0p6nllxm8","send":"","pkg_path":"gno.land/r/leon/hof","func":"Upvote","args":["gno.land/r/n2p5/home"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aiv9tqagYf7E57BDv13G2FRAt+yvhG915Lu0eJSRl0z4"},"signature":"0aYM6pWJYDJY6VUKyVZ4Yedr4bDbGwW0j9ZNix8+VHEkUk6pVS9F2SDjWr+KLx3w8+OxMbBg83ErqMuBU56EkQ=="}],"memo":""},"metadata":{"timestamp":"1734745020"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1n2mpwnwtfwpa7qngxfdemrk598r8yn52qhm9j9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"n+ZKh2/qgSu8AqtdMLnpEgH3MQRF91cZ1LsKMWeMzDsqAjZmOYHnoD3igFTdPRKol6kYfw/E4ON03YqIXj9OIw=="}],"memo":""},"metadata":{"timestamp":"1735047218"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1manfred47kzduec920z88wfr64ylksmdcedlf5","package":{"name":"sapin","path":"gno.land/r/moul/sapin","files":[{"name":"README.md","body":"# sapin.gno\n\n\u003ca href=\"https://play.gno.land/github/moul/sapin.gno?file=sapin.gno\u0026run.expr=println(Sapin(2))\"\u003e\n  \u003cimg alt=\"play.gno.land\" src=\"https://img.shields.io/badge/Play-691a00.svg?logo=data:image/svg%2bxml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAxNTggMTU4Ij48cGF0aCBkPSJtMTU2IDItNiA1LTIgMmE1NCA1NCAwIDAgMS0yNCAxMmwtMyAxaC00Yy02IDAtOS0xLTE1LTNhNjIgNjIgMCAwIDAtMzUtNmgtMWwtNCAxYTYzIDYzIDAgMCAwLTUwIDY4bDEgMmEyNyAyNyAwIDAgMCAwIDRsNiAxNWEzMyAzMyAwIDAgMSAyIDIxIDYyIDYyIDAgMCAxLTMgOCA2MSA2MSAwIDAgMS0xMyAyMGwtMyA0LTEgMWgxbDEtMmEyMDYgMjA2IDAgMCAxIDYtNWwyLTJhODggODggMCAwIDAgOC03bDEtMSAyLTIgMy0zYTY2MSA2NjEgMCAwIDEgMjYtMjRsNjItNjIgNC00IDMtMyAyLTMgOS05IDMtMyAyLTMgNi02IDExLTEzIDMtMyAxLTEtMSAxWk03OSAyNWM5IDEgMTcgNCAyMyA4IDQgMiA1IDQgNSA3bC0xIDMtMSAydjFsLTItMmE0MSA0MSAwIDAgMC0zNC0xMCA0MyA0MyAwIDAgMC0zMyAyNyA0OSA0OSAwIDAgMC0zIDIwIDMxIDMxIDAgMCAwIDEgNWwyIDRjMSA1IDQgOSA3IDEzbDIgMnYxbC01IDEtNC0xYy0yLTEtNS01LTctMTBsLTEtMmE2MSA2MSAwIDAgMS0zLTEzIDY2IDY2IDAgMCAxIDAtMTRjMS01IDMtMTEgNi0xNmE1MyA1MyAwIDAgMSA0MC0yNmg4Wm0yIDEzaDFsMTEgMyAxMCA4djRMNzkgNzhsLTI2IDI1Yy0yIDEtNCAxLTYtMWwtNS03YTQwIDQwIDAgMCAxLTUtMTljMC04IDMtMTYgOC0yM2w5LThhNDEgNDEgMCAwIDEgMTktOGw4IDFabTQ0IDEzLTMgNnY3YTIyMSAyMjEgMCAwIDEgMiAxNGwtMSAxMGE0NiA0NiAwIDAgMS01NyAzNWgtOWMtMyAwLTcgMi03IDNsNCAyYTU3IDU3IDAgMCAwIDMyIDVoM2wzLTFhNTUgNTUgMCAwIDAgMzQtODJsLTEgMVoiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNMTEzIDU5Yy0xIDItMiA0LTEgNmwxIDNhMzggMzggMCAwIDEtNDggNDRoLTRsLTMgMmE0NCA0NCAwIDAgMCAxMCAzaDE1YTQyIDQyIDAgMCAwIDMxLTU4aC0xWiIgZmlsbD0iI2ZmZiIvPjwvc3ZnPg==\" /\u003e\n\u003c/a\u003e\u003c/br\u003e\u003c/br\u003e\n\n christmas tree in gno\n"},{"name":"render.gno","body":"package sapin\n\nimport \"strconv\"\n\nconst defaultSize int = 3\n\nfunc Render(path string) string {\n\tsize := defaultSize\n\n\tif path != \"\" {\n\t\tvar err error\n\t\tsize, err = strconv.Atoi(path)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tsapin := Sapin(size)\n\toutput := \"```\\n\" + sapin + \"```\\n\"\n\treturn output\n}\n"},{"name":"render_test.gno","body":"package sapin\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestRender(t *testing.T) {\n\ttt := []struct {\n\t\tpath string\n\t\twant string\n\t}{\n\t\t{\"1\", \"```\" + `\n   *\n  ***\n *****\n*******\n  |||\n` + \"```\\n\"},\n\t\t{\"\", \"```\" + `\n         *\n        ***\n       *****\n      *******\n       *****\n      *******\n     *********\n    ***********\n   *************\n     *********\n    ***********\n   *************\n  ***************\n *****************\n*******************\n        |||\n        |||\n        |||\n` + \"```\\n\"},\n\t}\n\n\tfor _, tc := range tt {\n\t\tname := tc.path\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := Render(tc.path)\n\t\t\twant := tc.want\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"expected \\n%s\\n, got \\n%s\\n.\", want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"sapin.gno","body":"package sapin\n\nimport \"strings\"\n\nfunc Sapin(size int) string {\n\tif size \u003c 1 {\n\t\treturn \"\"\n\t}\n\tvar b strings.Builder\n\tfor floor := 0; floor \u003c size; floor++ {\n\t\tfor j := 0; j \u003c floor+4; j++ {\n\t\t\tspaces := size*2 - (floor-1)*2 - j + size - 2\n\t\t\tbodies := j*2 + 1 + floor*4\n\t\t\tb.WriteString(strings.Repeat(\" \", spaces))\n\t\t\tb.WriteString(strings.Repeat(\"*\", bodies))\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\tfor i := 0; i \u003c size; i++ {\n\t\tspaces := (size-1)*3 + 2\n\t\tb.WriteString(strings.Repeat(\" \", spaces))\n\t\tb.WriteString(\"|||\\n\")\n\t}\n\treturn b.String()\n}\n"},{"name":"sapin_test.gno","body":"package sapin\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestSapin(t *testing.T) {\n\ttt := []struct {\n\t\tsize int\n\t\twant string\n\t}{\n\t\t{1, `\n   *\n  ***\n *****\n*******\n  |||\n`},\n\t\t{2, `\n      *\n     ***\n    *****\n   *******\n    *****\n   *******\n  *********\n ***********\n*************\n     |||\n     |||\n`},\n\t\t{3, `\n         *\n        ***\n       *****\n      *******\n       *****\n      *******\n     *********\n    ***********\n   *************\n     *********\n    ***********\n   *************\n  ***************\n *****************\n*******************\n        |||\n        |||\n        |||\n`},\n\t\t{4, `\n            *\n           ***\n          *****\n         *******\n          *****\n         *******\n        *********\n       ***********\n      *************\n        *********\n       ***********\n      *************\n     ***************\n    *****************\n   *******************\n      *************\n     ***************\n    *****************\n   *******************\n  *********************\n ***********************\n*************************\n           |||\n           |||\n           |||\n           |||\n`},\n\t\t{5, `\n               *\n              ***\n             *****\n            *******\n             *****\n            *******\n           *********\n          ***********\n         *************\n           *********\n          ***********\n         *************\n        ***************\n       *****************\n      *******************\n         *************\n        ***************\n       *****************\n      *******************\n     *********************\n    ***********************\n   *************************\n       *****************\n      *******************\n     *********************\n    ***********************\n   *************************\n  ***************************\n *****************************\n*******************************\n              |||\n              |||\n              |||\n              |||\n              |||\n`},\n\t\t// {50, ``},\n\t\t// {51, ``},\n\t}\n\n\tfor _, tc := range tt {\n\t\tname := fmt.Sprintf(\"%d\", tc.size)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := Sapin(tc.size)\n\t\t\twant := tc.want[1:]\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"expected \\n%s\\n, got \\n%s\\n.\", want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgBSSj+NLAA6icQ/Rf6vbrjtRbbjo197vms7Sf+eLYPI"},"signature":"8BNwRlBwGyPsGuWjspOmeX7iXUCiMuHcHmLXF9y9wBgfUVNU41Z97FaOjemUftHLlEboLvE/7ek9YGhgFOC7Lg=="}],"memo":""},"metadata":{"timestamp":"1735063615"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1manfred47kzduec920z88wfr64ylksmdcedlf5","package":{"name":"sapin","path":"gno.land/r/moul/sapin","files":[{"name":"README.md","body":"# sapin.gno\n\n\u003ca href=\"https://play.gno.land/github/moul/sapin.gno?file=sapin.gno\u0026run.expr=println(Sapin(2))\"\u003e\n  \u003cimg alt=\"play.gno.land\" src=\"https://img.shields.io/badge/Play-691a00.svg?logo=data:image/svg%2bxml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAxNTggMTU4Ij48cGF0aCBkPSJtMTU2IDItNiA1LTIgMmE1NCA1NCAwIDAgMS0yNCAxMmwtMyAxaC00Yy02IDAtOS0xLTE1LTNhNjIgNjIgMCAwIDAtMzUtNmgtMWwtNCAxYTYzIDYzIDAgMCAwLTUwIDY4bDEgMmEyNyAyNyAwIDAgMCAwIDRsNiAxNWEzMyAzMyAwIDAgMSAyIDIxIDYyIDYyIDAgMCAxLTMgOCA2MSA2MSAwIDAgMS0xMyAyMGwtMyA0LTEgMWgxbDEtMmEyMDYgMjA2IDAgMCAxIDYtNWwyLTJhODggODggMCAwIDAgOC03bDEtMSAyLTIgMy0zYTY2MSA2NjEgMCAwIDEgMjYtMjRsNjItNjIgNC00IDMtMyAyLTMgOS05IDMtMyAyLTMgNi02IDExLTEzIDMtMyAxLTEtMSAxWk03OSAyNWM5IDEgMTcgNCAyMyA4IDQgMiA1IDQgNSA3bC0xIDMtMSAydjFsLTItMmE0MSA0MSAwIDAgMC0zNC0xMCA0MyA0MyAwIDAgMC0zMyAyNyA0OSA0OSAwIDAgMC0zIDIwIDMxIDMxIDAgMCAwIDEgNWwyIDRjMSA1IDQgOSA3IDEzbDIgMnYxbC01IDEtNC0xYy0yLTEtNS01LTctMTBsLTEtMmE2MSA2MSAwIDAgMS0zLTEzIDY2IDY2IDAgMCAxIDAtMTRjMS01IDMtMTEgNi0xNmE1MyA1MyAwIDAgMSA0MC0yNmg4Wm0yIDEzaDFsMTEgMyAxMCA4djRMNzkgNzhsLTI2IDI1Yy0yIDEtNCAxLTYtMWwtNS03YTQwIDQwIDAgMCAxLTUtMTljMC04IDMtMTYgOC0yM2w5LThhNDEgNDEgMCAwIDEgMTktOGw4IDFabTQ0IDEzLTMgNnY3YTIyMSAyMjEgMCAwIDEgMiAxNGwtMSAxMGE0NiA0NiAwIDAgMS01NyAzNWgtOWMtMyAwLTcgMi03IDNsNCAyYTU3IDU3IDAgMCAwIDMyIDVoM2wzLTFhNTUgNTUgMCAwIDAgMzQtODJsLTEgMVoiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNMTEzIDU5Yy0xIDItMiA0LTEgNmwxIDNhMzggMzggMCAwIDEtNDggNDRoLTRsLTMgMmE0NCA0NCAwIDAgMCAxMCAzaDE1YTQyIDQyIDAgMCAwIDMxLTU4aC0xWiIgZmlsbD0iI2ZmZiIvPjwvc3ZnPg==\" /\u003e\n\u003c/a\u003e\u003c/br\u003e\u003c/br\u003e\n\n christmas tree in gno\n"},{"name":"render.gno","body":"package sapin\n\nimport \"strconv\"\n\nconst defaultSize int = 3\n\nfunc Render(path string) string {\n\tsize := defaultSize\n\n\tif path != \"\" {\n\t\tvar err error\n\t\tsize, err = strconv.Atoi(path)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tsapin := Sapin(size)\n\toutput := \"```\\n\" + sapin + \"```\\n\"\n\treturn output\n}\n"},{"name":"render_test.gno","body":"package sapin\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestRender(t *testing.T) {\n\ttt := []struct {\n\t\tpath string\n\t\twant string\n\t}{\n\t\t{\"1\", \"```\" + `\n   *\n  ***\n *****\n*******\n  |||\n` + \"```\\n\"},\n\t\t{\"\", \"```\" + `\n         *\n        ***\n       *****\n      *******\n       *****\n      *******\n     *********\n    ***********\n   *************\n     *********\n    ***********\n   *************\n  ***************\n *****************\n*******************\n        |||\n        |||\n        |||\n` + \"```\\n\"},\n\t}\n\n\tfor _, tc := range tt {\n\t\tname := tc.path\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := Render(tc.path)\n\t\t\twant := tc.want\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"expected \\n%s\\n, got \\n%s\\n.\", want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"sapin.gno","body":"package sapin\n\nimport \"strings\"\n\nfunc Sapin(size int) string {\n\tif size \u003c 1 {\n\t\treturn \"\"\n\t}\n\tvar b strings.Builder\n\tfor floor := 0; floor \u003c size; floor++ {\n\t\tfor j := 0; j \u003c floor+4; j++ {\n\t\t\tspaces := size*2 - (floor-1)*2 - j + size - 2\n\t\t\tbodies := j*2 + 1 + floor*4\n\t\t\tb.WriteString(strings.Repeat(\" \", spaces))\n\t\t\tb.WriteString(strings.Repeat(\"*\", bodies))\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\tfor i := 0; i \u003c size; i++ {\n\t\tspaces := (size-1)*3 + 2\n\t\tb.WriteString(strings.Repeat(\" \", spaces))\n\t\tb.WriteString(\"|||\\n\")\n\t}\n\treturn b.String()\n}\n"},{"name":"sapin_test.gno","body":"package sapin\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestSapin(t *testing.T) {\n\ttt := []struct {\n\t\tsize int\n\t\twant string\n\t}{\n\t\t{1, `\n   *\n  ***\n *****\n*******\n  |||\n`},\n\t\t{2, `\n      *\n     ***\n    *****\n   *******\n    *****\n   *******\n  *********\n ***********\n*************\n     |||\n     |||\n`},\n\t\t{3, `\n         *\n        ***\n       *****\n      *******\n       *****\n      *******\n     *********\n    ***********\n   *************\n     *********\n    ***********\n   *************\n  ***************\n *****************\n*******************\n        |||\n        |||\n        |||\n`},\n\t\t{4, `\n            *\n           ***\n          *****\n         *******\n          *****\n         *******\n        *********\n       ***********\n      *************\n        *********\n       ***********\n      *************\n     ***************\n    *****************\n   *******************\n      *************\n     ***************\n    *****************\n   *******************\n  *********************\n ***********************\n*************************\n           |||\n           |||\n           |||\n           |||\n`},\n\t\t{5, `\n               *\n              ***\n             *****\n            *******\n             *****\n            *******\n           *********\n          ***********\n         *************\n           *********\n          ***********\n         *************\n        ***************\n       *****************\n      *******************\n         *************\n        ***************\n       *****************\n      *******************\n     *********************\n    ***********************\n   *************************\n       *****************\n      *******************\n     *********************\n    ***********************\n   *************************\n  ***************************\n *****************************\n*******************************\n              |||\n              |||\n              |||\n              |||\n              |||\n`},\n\t\t// {50, ``},\n\t\t// {51, ``},\n\t}\n\n\tfor _, tc := range tt {\n\t\tname := fmt.Sprintf(\"%d\", tc.size)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := Sapin(tc.size)\n\t\t\twant := tc.want[1:]\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"expected \\n%s\\n, got \\n%s\\n.\", want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"20000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgBSSj+NLAA6icQ/Rf6vbrjtRbbjo197vms7Sf+eLYPI"},"signature":"cu96e+2d70yV6m9nguUZgY3eK+AJ2rdJBcXNbjWRXxUuiOZxYoXEXIOFFNFoy1x5AJR54OWE9nlIj+AEhcr1Kg=="}],"memo":""},"metadata":{"timestamp":"1735063630"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g150gdvn780ws7a3s9qpdvv7h4d9hq6vh672ely0","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"nov2deOcWm8Q3RH/eIWQuc+9+fJqcjVNVCVgWP5DwNIWIrA01ddItNXF9hZv7iqGgKfaDAEe+EQWmDDANyEqiQ=="}],"memo":""},"metadata":{"timestamp":"1735211150"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1c6428h6ty22tqxtxdvh6dp8q9crp8uhyjq5mnl","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"VttdPU99J3e4S9s14i5vb8CS11LMA2wSyu6wBmxRaABGkgP8JqG/t6WRNaZKKFEbwrCHTQ7YBYAGyl9S8ssjuQ=="}],"memo":""},"metadata":{"timestamp":"1735149613"}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1qhuef2450xh7g7na8s865nreu2xw8j84kgkvt5","to_address":"g1n2mpwnwtfwpa7qngxfdemrk598r8yn52qhm9j9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwEKz9MRdU4MCAzB3el9G4wLJJQeWiRYtRquzEgm19Z2"},"signature":"mrVed6DrynxDmqfi9952xqckktY0KGWuRjVW2am+3B0LFdNhVD6Kqvzf4fKZ9GIM90KnUdaHWhbHEZ+CaaXtTw=="}],"memo":""},"metadata":{"timestamp":"1735221372"}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"config","path":"gno.land/r/nemanya/config","files":[{"name":"config.gno","body":"package config\n\nimport (\n\t\"errors\"\n\t\"std\"\n)\n\nvar (\n\tmain   std.Address\n\tbackup std.Address\n\n\tErrInvalidAddr  = errors.New(\"Invalid address\")\n\tErrUnauthorized = errors.New(\"Unauthorized\")\n)\n\nfunc init() {\n\tmain = \"g1x9qyf6f34v2g52k4q5smn5tctmj3hl2kj7l2ql\"\n}\n\nfunc Address() std.Address {\n\treturn main\n}\n\nfunc Backup() std.Address {\n\treturn backup\n}\n\nfunc SetAddress(a std.Address) error {\n\tif !a.IsValid() {\n\t\treturn ErrInvalidAddr\n\t}\n\n\tif err := checkAuthorized(); err != nil {\n\t\treturn err\n\t}\n\n\tmain = a\n\treturn nil\n}\n\nfunc SetBackup(a std.Address) error {\n\tif !a.IsValid() {\n\t\treturn ErrInvalidAddr\n\t}\n\n\tif err := checkAuthorized(); err != nil {\n\t\treturn err\n\t}\n\n\tbackup = a\n\treturn nil\n}\n\nfunc checkAuthorized() error {\n\tcaller := std.PrevRealm().Addr()\n\tisAuthorized := caller == main || caller == backup\n\n\tif !isAuthorized {\n\t\treturn ErrUnauthorized\n\t}\n\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"home","path":"gno.land/r/nemanya/home","files":[{"name":"home.gno","body":"package home\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/nemanya/config\"\n)\n\ntype SocialLink struct {\n\tURL  string\n\tText string\n}\n\ntype Sponsor struct {\n\tAddress std.Address\n\tAmount  std.Coins\n}\n\ntype Project struct {\n\tName        string\n\tDescription string\n\tURL         string\n\tImageURL    string\n\tSponsors    map[std.Address]Sponsor\n}\n\nvar (\n\ttextArt        string\n\taboutMe        string\n\tsponsorInfo    string\n\tsocialLinks    map[string]SocialLink\n\tgnoProjects    map[string]Project\n\totherProjects  map[string]Project\n\ttotalDonations std.Coins\n)\n\nfunc init() {\n\ttextArt = renderTextArt()\n\taboutMe = \"I am a student of IT at Faculty of Sciences in Novi Sad, Serbia. My background is mainly in web and low-level programming, but since Web3 Bootcamp at Petnica this year I've been actively learning about blockchain and adjacent technologies. I am excited about contributing to the gno.land ecosystem and learning from the community.\\n\\n\"\n\tsponsorInfo = \"You can sponsor a project by sending GNOT to this address. Your sponsorship will be displayed on the project page. Thank you for supporting the development of gno.land!\\n\\n\"\n\n\tsocialLinks = map[string]SocialLink{\n\t\t\"GitHub\":   {URL: \"https://github.com/Nemanya8\", Text: \"Explore my repositories and open-source contributions.\"},\n\t\t\"LinkedIn\": {URL: \"https://www.linkedin.com/in/nemanjamatic/\", Text: \"Connect with me professionally.\"},\n\t\t\"Email Me\": {URL: \"mailto:matic.nemanya@gmail.com\", Text: \"Reach out for collaboration or inquiries.\"},\n\t}\n\n\tgnoProjects = make(map[string]Project)\n\totherProjects = make(map[string]Project)\n\n\tgnoProjects[\"Liberty Bridge\"] = Project{\n\t\tName:        \"Liberty Bridge\",\n\t\tDescription: \"Liberty Bridge was my first Web3 project, developed as part of the Web3 Bootcamp at Petnica. This project served as a centralized bridge between Ethereum and gno.land, enabling seamless asset transfers and fostering interoperability between the two ecosystems.\\n\\n The primary objective of Liberty Bridge was to address the challenges of connecting decentralized networks by implementing a user-friendly solution that simplified the process for users. The project incorporated mechanisms to securely transfer assets between the Ethereum and gno.land blockchains, ensuring efficiency and reliability while maintaining a centralized framework for governance and operations.\\n\\n Through this project, I gained hands-on knowledge of blockchain interoperability, Web3 protocols, and the intricacies of building solutions that bridge different blockchain ecosystems.\\n\\n\",\n\t\tURL:         \"https://gno.land\",\n\t\tImageURL:    \"https://github.com/Milosevic02/LibertyBridge/raw/main/lb_banner.png\",\n\t\tSponsors:    make(map[std.Address]Sponsor),\n\t}\n\n\totherProjects[\"Incognito\"] = Project{\n\t\tName:        \"Incognito\",\n\t\tDescription: \"Incognito is a Web3 platform built for Ethereum-based chains, designed to connect advertisers with users in a privacy-first and mutually beneficial way. Its modular architecture makes it easily expandable to other blockchains. Developed during the ETH Sofia Hackathon, it was recognized as a winning project for its innovation and impact.\\n\\n The platform allows advertisers to send personalized ads while sharing a portion of the marketing budget with users. It uses machine learning to match users based on wallet activity, ensuring precise targeting. User emails are stored securely on-chain and never shared, prioritizing privacy and transparency.\\n\\n With all campaign data stored on-chain, Incognito ensures decentralization and accountability. By rewarding users and empowering advertisers, it sets a new standard for fair and transparent blockchain-based advertising.\",\n\t\tURL:         \"https://github.com/Milosevic02/Incognito-ETHSofia\",\n\t\tImageURL:    \"\",\n\t\tSponsors:    make(map[std.Address]Sponsor),\n\t}\n}\n\nfunc Render(path string) string {\n\tvar sb strings.Builder\n\tsb.WriteString(\"# Hi, I'm\\n\")\n\tsb.WriteString(textArt)\n\tsb.WriteString(\"---\\n\")\n\tsb.WriteString(\"## About me\\n\")\n\tsb.WriteString(aboutMe)\n\tsb.WriteString(sponsorInfo)\n\tsb.WriteString(ufmt.Sprintf(\"# Total Sponsor Donations: %s\\n\", totalDonations.String()))\n\tsb.WriteString(\"---\\n\")\n\tsb.WriteString(renderProjects(gnoProjects, \"Gno Projects\"))\n\tsb.WriteString(\"---\\n\")\n\tsb.WriteString(renderProjects(otherProjects, \"Other Projects\"))\n\tsb.WriteString(\"---\\n\")\n\tsb.WriteString(renderSocialLinks())\n\n\treturn sb.String()\n}\n\nfunc renderTextArt() string {\n\tvar sb strings.Builder\n\tsb.WriteString(\"```\\n\")\n\tsb.WriteString(\"      ___           ___           ___           ___           ___           ___           ___     \\n\")\n\tsb.WriteString(\"     /\\\\__\\\\         /\\\\  \\\\         /\\\\__\\\\         /\\\\  \\\\         /\\\\__\\\\         |\\\\__\\\\         /\\\\  \\\\    \\n\")\n\tsb.WriteString(\"    /::|  |       /::\\\\  \\\\       /::|  |       /::\\\\  \\\\       /::|  |        |:|  |       /::\\\\  \\\\   \\n\")\n\tsb.WriteString(\"   /:|:|  |      /:/\\\\:\\\\  \\\\     /:|:|  |      /:/\\\\:\\\\  \\\\     /:|:|  |        |:|  |      /:/\\\\:\\\\  \\\\  \\n\")\n\tsb.WriteString(\"  /:/|:|  |__   /::\\\\~\\\\:\\\\  \\\\   /:/|:|__|__   /::\\\\~\\\\:\\\\  \\\\   /:/|:|  |__      |:|__|__   /::\\\\~\\\\:\\\\  \\\\ \\n\")\n\tsb.WriteString(\" /:/ |:| /\\\\__\\\\ /:/\\\\:\\\\ \\\\:\\\\__\\\\ /:/ |::::\\\\__\\\\ /:/\\\\:\\\\ \\\\:\\\\__\\\\ /:/ |:| /\\\\__\\\\     /::::\\\\__\\\\ /:/\\\\:\\\\ \\\\:\\\\__\\\\\\n\")\n\tsb.WriteString(\" \\\\/__|:|/:/  / \\\\:\\\\~\\\\:\\\\ \\\\/__/ \\\\/__/~~/:/  / \\\\/__\\\\:\\\\/:/  / \\\\/__|:|/:/  /    /:/~~/~    \\\\/__\\\\:\\\\/:/  / \\n\")\n\tsb.WriteString(\"     |:/:/  /   \\\\:\\\\ \\\\:\\\\__\\\\         /:/  /       \\\\::/  /      |:/:/  /    /:/  /           \\\\::/  /  \\n\")\n\tsb.WriteString(\"     |::/  /     \\\\:\\\\ \\\\/__/        /:/  /        /:/  /       |::/  /     \\\\/__/            /:/  /   \\n\")\n\tsb.WriteString(\"     /:/  /       \\\\:\\\\__\\\\         /:/  /        /:/  /        /:/  /                      /:/  /    \\n\")\n\tsb.WriteString(\"     \\\\/__/         \\\\/__/         \\\\/__/         \\\\/__/         \\\\/__/                       \\\\/__/     \\n\")\n\tsb.WriteString(\"\\n```\\n\")\n\treturn sb.String()\n}\n\nfunc renderSocialLinks() string {\n\tvar sb strings.Builder\n\tsb.WriteString(\"## Links\\n\\n\")\n\tsb.WriteString(\"You can find me here:\\n\\n\")\n\tsb.WriteString(ufmt.Sprintf(\"- [GitHub](%s) - %s\\n\", socialLinks[\"GitHub\"].URL, socialLinks[\"GitHub\"].Text))\n\tsb.WriteString(ufmt.Sprintf(\"- [LinkedIn](%s) - %s\\n\", socialLinks[\"LinkedIn\"].URL, socialLinks[\"LinkedIn\"].Text))\n\tsb.WriteString(ufmt.Sprintf(\"- [Email Me](%s) - %s\\n\", socialLinks[\"Email Me\"].URL, socialLinks[\"Email Me\"].Text))\n\tsb.WriteString(\"\\n\")\n\treturn sb.String()\n}\n\nfunc renderProjects(projectsMap map[string]Project, title string) string {\n\tvar sb strings.Builder\n\tsb.WriteString(ufmt.Sprintf(\"## %s\\n\\n\", title))\n\tfor _, project := range projectsMap {\n\t\tif project.ImageURL != \"\" {\n\t\t\tsb.WriteString(ufmt.Sprintf(\"![%s](%s)\\n\\n\", project.Name, project.ImageURL))\n\t\t}\n\t\tsb.WriteString(ufmt.Sprintf(\"### [%s](%s)\\n\\n\", project.Name, project.URL))\n\t\tsb.WriteString(project.Description + \"\\n\\n\")\n\n\t\tif len(project.Sponsors) \u003e 0 {\n\t\t\tsb.WriteString(ufmt.Sprintf(\"#### %s Sponsors\\n\", project.Name))\n\t\t\tfor _, sponsor := range project.Sponsors {\n\t\t\t\tsb.WriteString(ufmt.Sprintf(\"- %s: %s\\n\", sponsor.Address.String(), sponsor.Amount.String()))\n\t\t\t}\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\treturn sb.String()\n}\n\nfunc UpdateLink(name, newURL string) {\n\tif !isAuthorized(std.PrevRealm().Addr()) {\n\t\tpanic(config.ErrUnauthorized)\n\t}\n\n\tif _, exists := socialLinks[name]; !exists {\n\t\tpanic(\"Link with the given name does not exist\")\n\t}\n\n\tsocialLinks[name] = SocialLink{\n\t\tURL:  newURL,\n\t\tText: socialLinks[name].Text,\n\t}\n}\n\nfunc UpdateAboutMe(text string) {\n\tif !isAuthorized(std.PrevRealm().Addr()) {\n\t\tpanic(config.ErrUnauthorized)\n\t}\n\n\taboutMe = text\n}\n\nfunc AddGnoProject(name, description, url, imageURL string) {\n\tif !isAuthorized(std.PrevRealm().Addr()) {\n\t\tpanic(config.ErrUnauthorized)\n\t}\n\tproject := Project{\n\t\tName:        name,\n\t\tDescription: description,\n\t\tURL:         url,\n\t\tImageURL:    imageURL,\n\t\tSponsors:    make(map[std.Address]Sponsor),\n\t}\n\tgnoProjects[name] = project\n}\n\nfunc DeleteGnoProject(projectName string) {\n\tif !isAuthorized(std.PrevRealm().Addr()) {\n\t\tpanic(config.ErrUnauthorized)\n\t}\n\n\tif _, exists := gnoProjects[projectName]; !exists {\n\t\tpanic(\"Project not found\")\n\t}\n\n\tdelete(gnoProjects, projectName)\n}\n\nfunc AddOtherProject(name, description, url, imageURL string) {\n\tif !isAuthorized(std.PrevRealm().Addr()) {\n\t\tpanic(config.ErrUnauthorized)\n\t}\n\tproject := Project{\n\t\tName:        name,\n\t\tDescription: description,\n\t\tURL:         url,\n\t\tImageURL:    imageURL,\n\t\tSponsors:    make(map[std.Address]Sponsor),\n\t}\n\totherProjects[name] = project\n}\n\nfunc RemoveOtherProject(projectName string) {\n\tif !isAuthorized(std.PrevRealm().Addr()) {\n\t\tpanic(config.ErrUnauthorized)\n\t}\n\n\tif _, exists := otherProjects[projectName]; !exists {\n\t\tpanic(\"Project not found\")\n\t}\n\n\tdelete(otherProjects, projectName)\n}\n\nfunc isAuthorized(addr std.Address) bool {\n\treturn addr == config.Address() || addr == config.Backup()\n}\n\nfunc SponsorGnoProject(projectName string) {\n\taddress := std.GetOrigCaller()\n\tamount := std.GetOrigSend()\n\n\tif amount.AmountOf(\"ugnot\") == 0 {\n\t\tpanic(\"Donation must include GNOT\")\n\t}\n\n\tproject, exists := gnoProjects[projectName]\n\tif !exists {\n\t\tpanic(\"Gno project not found\")\n\t}\n\n\tproject.Sponsors[address] = Sponsor{\n\t\tAddress: address,\n\t\tAmount:  project.Sponsors[address].Amount.Add(amount),\n\t}\n\n\ttotalDonations = totalDonations.Add(amount)\n\n\tgnoProjects[projectName] = project\n}\n\nfunc SponsorOtherProject(projectName string) {\n\taddress := std.GetOrigCaller()\n\tamount := std.GetOrigSend()\n\n\tif amount.AmountOf(\"ugnot\") == 0 {\n\t\tpanic(\"Donation must include GNOT\")\n\t}\n\n\tproject, exists := otherProjects[projectName]\n\tif !exists {\n\t\tpanic(\"Other project not found\")\n\t}\n\n\tproject.Sponsors[address] = Sponsor{\n\t\tAddress: address,\n\t\tAmount:  project.Sponsors[address].Amount.Add(amount),\n\t}\n\n\ttotalDonations = totalDonations.Add(amount)\n\n\totherProjects[projectName] = project\n}\n\nfunc Withdraw() string {\n\tif !isAuthorized(std.PrevRealm().Addr()) {\n\t\tpanic(config.ErrUnauthorized)\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\trealmAddress := std.GetOrigPkgAddr()\n\tcoins := banker.GetCoins(realmAddress)\n\n\tif len(coins) == 0 {\n\t\treturn \"No coins available to withdraw\"\n\t}\n\n\tbanker.SendCoins(realmAddress, config.Address(), coins)\n\n\treturn \"Successfully withdrew all coins to config address\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"name":"typeutil","path":"gno.land/p/moul/typeutil","files":[{"name":"typeutil.gno","body":"// Package typeutil provides utility functions for converting between different types\n// and checking their states. It aims to provide consistent behavior across different\n// types while remaining lightweight and dependency-free.\npackage typeutil\n\nimport (\n\t\"errors\"\n\t\"sort\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// stringer is the interface that wraps the String method.\ntype stringer interface {\n\tString() string\n}\n\n// ToString converts any value to its string representation.\n// It supports a wide range of Go types including:\n//   - Basic: string, bool\n//   - Numbers: int, int8-64, uint, uint8-64, float32, float64\n//   - Special: time.Time, std.Address, []byte\n//   - Slices: []T for most basic types\n//   - Maps: map[string]string, map[string]interface{}\n//   - Interface: types implementing String() string\n//\n// Example usage:\n//\n//\tstr := typeutil.ToString(42)               // \"42\"\n//\tstr = typeutil.ToString([]int{1, 2})      // \"[1 2]\"\n//\tstr = typeutil.ToString(map[string]string{ // \"map[a:1 b:2]\"\n//\t    \"a\": \"1\",\n//\t    \"b\": \"2\",\n//\t})\nfunc ToString(val interface{}) string {\n\tif val == nil {\n\t\treturn \"\"\n\t}\n\n\t// First check if value implements Stringer interface\n\tif s, ok := val.(interface{ String() string }); ok {\n\t\treturn s.String()\n\t}\n\n\tswitch v := val.(type) {\n\t// Pointer types - dereference and recurse\n\tcase *string:\n\t\tif v == nil {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn *v\n\tcase *int:\n\t\tif v == nil {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn strconv.Itoa(*v)\n\tcase *bool:\n\t\tif v == nil {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn strconv.FormatBool(*v)\n\tcase *time.Time:\n\t\tif v == nil {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn v.String()\n\tcase *std.Address:\n\t\tif v == nil {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn string(*v)\n\n\t// String types\n\tcase string:\n\t\treturn v\n\tcase stringer:\n\t\treturn v.String()\n\n\t// Special types\n\tcase time.Time:\n\t\treturn v.String()\n\tcase std.Address:\n\t\treturn string(v)\n\tcase []byte:\n\t\treturn string(v)\n\tcase struct{}:\n\t\treturn \"{}\"\n\n\t// Integer types\n\tcase int:\n\t\treturn strconv.Itoa(v)\n\tcase int8:\n\t\treturn strconv.FormatInt(int64(v), 10)\n\tcase int16:\n\t\treturn strconv.FormatInt(int64(v), 10)\n\tcase int32:\n\t\treturn strconv.FormatInt(int64(v), 10)\n\tcase int64:\n\t\treturn strconv.FormatInt(v, 10)\n\tcase uint:\n\t\treturn strconv.FormatUint(uint64(v), 10)\n\tcase uint8:\n\t\treturn strconv.FormatUint(uint64(v), 10)\n\tcase uint16:\n\t\treturn strconv.FormatUint(uint64(v), 10)\n\tcase uint32:\n\t\treturn strconv.FormatUint(uint64(v), 10)\n\tcase uint64:\n\t\treturn strconv.FormatUint(v, 10)\n\n\t// Float types\n\tcase float32:\n\t\treturn strconv.FormatFloat(float64(v), 'f', -1, 32)\n\tcase float64:\n\t\treturn strconv.FormatFloat(v, 'f', -1, 64)\n\n\t// Boolean\n\tcase bool:\n\t\tif v {\n\t\t\treturn \"true\"\n\t\t}\n\t\treturn \"false\"\n\n\t// Slice types\n\tcase []string:\n\t\treturn join(v)\n\tcase []int:\n\t\treturn join(v)\n\tcase []int32:\n\t\treturn join(v)\n\tcase []int64:\n\t\treturn join(v)\n\tcase []float32:\n\t\treturn join(v)\n\tcase []float64:\n\t\treturn join(v)\n\tcase []interface{}:\n\t\treturn join(v)\n\tcase []time.Time:\n\t\treturn joinTimes(v)\n\tcase []stringer:\n\t\treturn join(v)\n\tcase []std.Address:\n\t\treturn joinAddresses(v)\n\tcase [][]byte:\n\t\treturn joinBytes(v)\n\n\t// Map types with various key types\n\tcase map[interface{}]interface{}, map[string]interface{}, map[string]string, map[string]int:\n\t\tvar b strings.Builder\n\t\tb.WriteString(\"map[\")\n\t\tfirst := true\n\n\t\tswitch m := v.(type) {\n\t\tcase map[interface{}]interface{}:\n\t\t\t// Convert all keys to strings for consistent ordering\n\t\t\tkeys := make([]string, 0)\n\t\t\tkeyMap := make(map[string]interface{})\n\n\t\t\tfor k := range m {\n\t\t\t\tkeyStr := ToString(k)\n\t\t\t\tkeys = append(keys, keyStr)\n\t\t\t\tkeyMap[keyStr] = k\n\t\t\t}\n\t\t\tsort.Strings(keys)\n\n\t\t\tfor _, keyStr := range keys {\n\t\t\t\tif !first {\n\t\t\t\t\tb.WriteString(\" \")\n\t\t\t\t}\n\t\t\t\torigKey := keyMap[keyStr]\n\t\t\t\tb.WriteString(keyStr)\n\t\t\t\tb.WriteString(\":\")\n\t\t\t\tb.WriteString(ToString(m[origKey]))\n\t\t\t\tfirst = false\n\t\t\t}\n\n\t\tcase map[string]interface{}:\n\t\t\tkeys := make([]string, 0)\n\t\t\tfor k := range m {\n\t\t\t\tkeys = append(keys, k)\n\t\t\t}\n\t\t\tsort.Strings(keys)\n\n\t\t\tfor _, k := range keys {\n\t\t\t\tif !first {\n\t\t\t\t\tb.WriteString(\" \")\n\t\t\t\t}\n\t\t\t\tb.WriteString(k)\n\t\t\t\tb.WriteString(\":\")\n\t\t\t\tb.WriteString(ToString(m[k]))\n\t\t\t\tfirst = false\n\t\t\t}\n\n\t\tcase map[string]string:\n\t\t\tkeys := make([]string, 0)\n\t\t\tfor k := range m {\n\t\t\t\tkeys = append(keys, k)\n\t\t\t}\n\t\t\tsort.Strings(keys)\n\n\t\t\tfor _, k := range keys {\n\t\t\t\tif !first {\n\t\t\t\t\tb.WriteString(\" \")\n\t\t\t\t}\n\t\t\t\tb.WriteString(k)\n\t\t\t\tb.WriteString(\":\")\n\t\t\t\tb.WriteString(m[k])\n\t\t\t\tfirst = false\n\t\t\t}\n\n\t\tcase map[string]int:\n\t\t\tkeys := make([]string, 0)\n\t\t\tfor k := range m {\n\t\t\t\tkeys = append(keys, k)\n\t\t\t}\n\t\t\tsort.Strings(keys)\n\n\t\t\tfor _, k := range keys {\n\t\t\t\tif !first {\n\t\t\t\t\tb.WriteString(\" \")\n\t\t\t\t}\n\t\t\t\tb.WriteString(k)\n\t\t\t\tb.WriteString(\":\")\n\t\t\t\tb.WriteString(strconv.Itoa(m[k]))\n\t\t\t\tfirst = false\n\t\t\t}\n\t\t}\n\t\tb.WriteString(\"]\")\n\t\treturn b.String()\n\n\t// Default\n\tdefault:\n\t\treturn \"\u003cunknown\u003e\"\n\t}\n}\n\nfunc join(slice interface{}) string {\n\tif IsZero(slice) {\n\t\treturn \"[]\"\n\t}\n\n\titems := ToInterfaceSlice(slice)\n\tif items == nil {\n\t\treturn \"[]\"\n\t}\n\n\tvar b strings.Builder\n\tb.WriteString(\"[\")\n\tfor i, item := range items {\n\t\tif i \u003e 0 {\n\t\t\tb.WriteString(\" \")\n\t\t}\n\t\tb.WriteString(ToString(item))\n\t}\n\tb.WriteString(\"]\")\n\treturn b.String()\n}\n\nfunc joinTimes(slice []time.Time) string {\n\tif len(slice) == 0 {\n\t\treturn \"[]\"\n\t}\n\tvar b strings.Builder\n\tb.WriteString(\"[\")\n\tfor i, t := range slice {\n\t\tif i \u003e 0 {\n\t\t\tb.WriteString(\" \")\n\t\t}\n\t\tb.WriteString(t.String())\n\t}\n\tb.WriteString(\"]\")\n\treturn b.String()\n}\n\nfunc joinAddresses(slice []std.Address) string {\n\tif len(slice) == 0 {\n\t\treturn \"[]\"\n\t}\n\tvar b strings.Builder\n\tb.WriteString(\"[\")\n\tfor i, addr := range slice {\n\t\tif i \u003e 0 {\n\t\t\tb.WriteString(\" \")\n\t\t}\n\t\tb.WriteString(string(addr))\n\t}\n\tb.WriteString(\"]\")\n\treturn b.String()\n}\n\nfunc joinBytes(slice [][]byte) string {\n\tif len(slice) == 0 {\n\t\treturn \"[]\"\n\t}\n\tvar b strings.Builder\n\tb.WriteString(\"[\")\n\tfor i, bytes := range slice {\n\t\tif i \u003e 0 {\n\t\t\tb.WriteString(\" \")\n\t\t}\n\t\tb.WriteString(string(bytes))\n\t}\n\tb.WriteString(\"]\")\n\treturn b.String()\n}\n\n// ToBool converts any value to a boolean based on common programming conventions.\n// For example:\n//   - Numbers: 0 is false, any other number is true\n//   - Strings: \"\", \"0\", \"false\", \"f\", \"no\", \"n\", \"off\" are false, others are true\n//   - Slices/Maps: empty is false, non-empty is true\n//   - nil: always false\n//   - bool: direct value\nfunc ToBool(val interface{}) bool {\n\tif IsZero(val) {\n\t\treturn false\n\t}\n\n\t// Handle special string cases\n\tif str, ok := val.(string); ok {\n\t\tstr = strings.ToLower(strings.TrimSpace(str))\n\t\treturn str != \"\" \u0026\u0026 str != \"0\" \u0026\u0026 str != \"false\" \u0026\u0026 str != \"f\" \u0026\u0026 str != \"no\" \u0026\u0026 str != \"n\" \u0026\u0026 str != \"off\"\n\t}\n\n\treturn true\n}\n\n// IsZero returns true if the value represents a \"zero\" or \"empty\" state for its type.\n// For example:\n//   - Numbers: 0\n//   - Strings: \"\"\n//   - Slices/Maps: empty\n//   - nil: true\n//   - bool: false\n//   - time.Time: IsZero()\n//   - std.Address: empty string\nfunc IsZero(val interface{}) bool {\n\tif val == nil {\n\t\treturn true\n\t}\n\n\tswitch v := val.(type) {\n\t// Pointer types - nil pointer is zero, otherwise check pointed value\n\tcase *bool:\n\t\treturn v == nil || !*v\n\tcase *string:\n\t\treturn v == nil || *v == \"\"\n\tcase *int:\n\t\treturn v == nil || *v == 0\n\tcase *time.Time:\n\t\treturn v == nil || v.IsZero()\n\tcase *std.Address:\n\t\treturn v == nil || string(*v) == \"\"\n\n\t// Bool\n\tcase bool:\n\t\treturn !v\n\n\t// String types\n\tcase string:\n\t\treturn v == \"\"\n\tcase stringer:\n\t\treturn v.String() == \"\"\n\n\t// Integer types\n\tcase int:\n\t\treturn v == 0\n\tcase int8:\n\t\treturn v == 0\n\tcase int16:\n\t\treturn v == 0\n\tcase int32:\n\t\treturn v == 0\n\tcase int64:\n\t\treturn v == 0\n\tcase uint:\n\t\treturn v == 0\n\tcase uint8:\n\t\treturn v == 0\n\tcase uint16:\n\t\treturn v == 0\n\tcase uint32:\n\t\treturn v == 0\n\tcase uint64:\n\t\treturn v == 0\n\n\t// Float types\n\tcase float32:\n\t\treturn v == 0\n\tcase float64:\n\t\treturn v == 0\n\n\t// Special types\n\tcase []byte:\n\t\treturn len(v) == 0\n\tcase time.Time:\n\t\treturn v.IsZero()\n\tcase std.Address:\n\t\treturn string(v) == \"\"\n\n\t// Slices (check if empty)\n\tcase []string:\n\t\treturn len(v) == 0\n\tcase []int:\n\t\treturn len(v) == 0\n\tcase []int32:\n\t\treturn len(v) == 0\n\tcase []int64:\n\t\treturn len(v) == 0\n\tcase []float32:\n\t\treturn len(v) == 0\n\tcase []float64:\n\t\treturn len(v) == 0\n\tcase []interface{}:\n\t\treturn len(v) == 0\n\tcase []time.Time:\n\t\treturn len(v) == 0\n\tcase []std.Address:\n\t\treturn len(v) == 0\n\tcase [][]byte:\n\t\treturn len(v) == 0\n\tcase []stringer:\n\t\treturn len(v) == 0\n\n\t// Maps (check if empty)\n\tcase map[string]string:\n\t\treturn len(v) == 0\n\tcase map[string]interface{}:\n\t\treturn len(v) == 0\n\n\tdefault:\n\t\treturn false // non-nil unknown types are considered non-zero\n\t}\n}\n\n// ToInterfaceSlice converts various slice types to []interface{}\nfunc ToInterfaceSlice(val interface{}) []interface{} {\n\tswitch v := val.(type) {\n\tcase []interface{}:\n\t\treturn v\n\tcase []string:\n\t\tresult := make([]interface{}, len(v))\n\t\tfor i, s := range v {\n\t\t\tresult[i] = s\n\t\t}\n\t\treturn result\n\tcase []int:\n\t\tresult := make([]interface{}, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = n\n\t\t}\n\t\treturn result\n\tcase []int32:\n\t\tresult := make([]interface{}, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = n\n\t\t}\n\t\treturn result\n\tcase []int64:\n\t\tresult := make([]interface{}, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = n\n\t\t}\n\t\treturn result\n\tcase []float32:\n\t\tresult := make([]interface{}, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = n\n\t\t}\n\t\treturn result\n\tcase []float64:\n\t\tresult := make([]interface{}, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = n\n\t\t}\n\t\treturn result\n\tcase []bool:\n\t\tresult := make([]interface{}, len(v))\n\t\tfor i, b := range v {\n\t\t\tresult[i] = b\n\t\t}\n\t\treturn result\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// ToMapStringInterface converts a map with string keys and any value type to map[string]interface{}\nfunc ToMapStringInterface(m interface{}) (map[string]interface{}, error) {\n\tresult := make(map[string]interface{})\n\n\tswitch v := m.(type) {\n\tcase map[string]interface{}:\n\t\treturn v, nil\n\tcase map[string]string:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[string]int:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[string]int64:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[string]float64:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[string]bool:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[string][]string:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = ToInterfaceSlice(val)\n\t\t}\n\tcase map[string][]int:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = ToInterfaceSlice(val)\n\t\t}\n\tcase map[string][]interface{}:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[string]map[string]interface{}:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[string]map[string]string:\n\t\tfor k, val := range v {\n\t\t\tif converted, err := ToMapStringInterface(val); err == nil {\n\t\t\t\tresult[k] = converted\n\t\t\t} else {\n\t\t\t\treturn nil, errors.New(\"failed to convert nested map at key: \" + k)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported map type: \" + ToString(m))\n\t}\n\n\treturn result, nil\n}\n\n// ToMapIntInterface converts a map with int keys and any value type to map[int]interface{}\nfunc ToMapIntInterface(m interface{}) (map[int]interface{}, error) {\n\tresult := make(map[int]interface{})\n\n\tswitch v := m.(type) {\n\tcase map[int]interface{}:\n\t\treturn v, nil\n\tcase map[int]string:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[int]int:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[int]int64:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[int]float64:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[int]bool:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[int][]string:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = ToInterfaceSlice(val)\n\t\t}\n\tcase map[int][]int:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = ToInterfaceSlice(val)\n\t\t}\n\tcase map[int][]interface{}:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[int]map[string]interface{}:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tcase map[int]map[int]interface{}:\n\t\tfor k, val := range v {\n\t\t\tresult[k] = val\n\t\t}\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported map type: \" + ToString(m))\n\t}\n\n\treturn result, nil\n}\n\n// ToStringSlice converts various slice types to []string\nfunc ToStringSlice(val interface{}) []string {\n\tswitch v := val.(type) {\n\tcase []string:\n\t\treturn v\n\tcase []interface{}:\n\t\tresult := make([]string, len(v))\n\t\tfor i, item := range v {\n\t\t\tresult[i] = ToString(item)\n\t\t}\n\t\treturn result\n\tcase []int:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.Itoa(n)\n\t\t}\n\t\treturn result\n\tcase []int32:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatInt(int64(n), 10)\n\t\t}\n\t\treturn result\n\tcase []int64:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatInt(n, 10)\n\t\t}\n\t\treturn result\n\tcase []float32:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatFloat(float64(n), 'f', -1, 32)\n\t\t}\n\t\treturn result\n\tcase []float64:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatFloat(n, 'f', -1, 64)\n\t\t}\n\t\treturn result\n\tcase []bool:\n\t\tresult := make([]string, len(v))\n\t\tfor i, b := range v {\n\t\t\tresult[i] = strconv.FormatBool(b)\n\t\t}\n\t\treturn result\n\tcase []time.Time:\n\t\tresult := make([]string, len(v))\n\t\tfor i, t := range v {\n\t\t\tresult[i] = t.String()\n\t\t}\n\t\treturn result\n\tcase []std.Address:\n\t\tresult := make([]string, len(v))\n\t\tfor i, addr := range v {\n\t\t\tresult[i] = string(addr)\n\t\t}\n\t\treturn result\n\tcase [][]byte:\n\t\tresult := make([]string, len(v))\n\t\tfor i, b := range v {\n\t\t\tresult[i] = string(b)\n\t\t}\n\t\treturn result\n\tcase []stringer:\n\t\tresult := make([]string, len(v))\n\t\tfor i, s := range v {\n\t\t\tresult[i] = s.String()\n\t\t}\n\t\treturn result\n\tcase []uint:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatUint(uint64(n), 10)\n\t\t}\n\t\treturn result\n\tcase []uint8:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatUint(uint64(n), 10)\n\t\t}\n\t\treturn result\n\tcase []uint16:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatUint(uint64(n), 10)\n\t\t}\n\t\treturn result\n\tcase []uint32:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatUint(uint64(n), 10)\n\t\t}\n\t\treturn result\n\tcase []uint64:\n\t\tresult := make([]string, len(v))\n\t\tfor i, n := range v {\n\t\t\tresult[i] = strconv.FormatUint(n, 10)\n\t\t}\n\t\treturn result\n\tdefault:\n\t\t// Try to convert using reflection if it's a slice\n\t\tif slice := ToInterfaceSlice(val); slice != nil {\n\t\t\tresult := make([]string, len(slice))\n\t\t\tfor i, item := range slice {\n\t\t\t\tresult[i] = ToString(item)\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\t\treturn nil\n\t}\n}\n"},{"name":"typeutil_test.gno","body":"package typeutil\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype testStringer struct {\n\tvalue string\n}\n\nfunc (t testStringer) String() string {\n\treturn \"test:\" + t.value\n}\n\nfunc TestToString(t *testing.T) {\n\t// setup test data\n\tstr := \"hello\"\n\tnum := 42\n\tb := true\n\tnow := time.Now()\n\taddr := std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\tstringer := testStringer{value: \"hello\"}\n\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    interface{}\n\t\texpected string\n\t}\n\n\ttests := []testCase{\n\t\t// basic types\n\t\t{\"string\", \"hello\", \"hello\"},\n\t\t{\"empty_string\", \"\", \"\"},\n\t\t{\"nil\", nil, \"\"},\n\n\t\t// integer types\n\t\t{\"int\", 42, \"42\"},\n\t\t{\"int8\", int8(8), \"8\"},\n\t\t{\"int16\", int16(16), \"16\"},\n\t\t{\"int32\", int32(32), \"32\"},\n\t\t{\"int64\", int64(64), \"64\"},\n\t\t{\"uint\", uint(42), \"42\"},\n\t\t{\"uint8\", uint8(8), \"8\"},\n\t\t{\"uint16\", uint16(16), \"16\"},\n\t\t{\"uint32\", uint32(32), \"32\"},\n\t\t{\"uint64\", uint64(64), \"64\"},\n\n\t\t// float types\n\t\t{\"float32\", float32(3.14), \"3.14\"},\n\t\t{\"float64\", 3.14159, \"3.14159\"},\n\n\t\t// boolean\n\t\t{\"bool_true\", true, \"true\"},\n\t\t{\"bool_false\", false, \"false\"},\n\n\t\t// special types\n\t\t{\"time\", now, now.String()},\n\t\t{\"address\", addr, string(addr)},\n\t\t{\"bytes\", []byte(\"hello\"), \"hello\"},\n\t\t{\"stringer\", stringer, \"test:hello\"},\n\n\t\t// slices\n\t\t{\"empty_slice\", []string{}, \"[]\"},\n\t\t{\"string_slice\", []string{\"a\", \"b\"}, \"[a b]\"},\n\t\t{\"int_slice\", []int{1, 2}, \"[1 2]\"},\n\t\t{\"int32_slice\", []int32{1, 2}, \"[1 2]\"},\n\t\t{\"int64_slice\", []int64{1, 2}, \"[1 2]\"},\n\t\t{\"float32_slice\", []float32{1.1, 2.2}, \"[1.1 2.2]\"},\n\t\t{\"float64_slice\", []float64{1.1, 2.2}, \"[1.1 2.2]\"},\n\t\t{\"bytes_slice\", [][]byte{[]byte(\"a\"), []byte(\"b\")}, \"[a b]\"},\n\t\t{\"time_slice\", []time.Time{now, now}, \"[\" + now.String() + \" \" + now.String() + \"]\"},\n\t\t{\"address_slice\", []std.Address{addr, addr}, \"[\" + string(addr) + \" \" + string(addr) + \"]\"},\n\t\t{\"interface_slice\", []interface{}{1, \"a\", true}, \"[1 a true]\"},\n\n\t\t// empty slices\n\t\t{\"empty_string_slice\", []string{}, \"[]\"},\n\t\t{\"empty_int_slice\", []int{}, \"[]\"},\n\t\t{\"empty_int32_slice\", []int32{}, \"[]\"},\n\t\t{\"empty_int64_slice\", []int64{}, \"[]\"},\n\t\t{\"empty_float32_slice\", []float32{}, \"[]\"},\n\t\t{\"empty_float64_slice\", []float64{}, \"[]\"},\n\t\t{\"empty_bytes_slice\", [][]byte{}, \"[]\"},\n\t\t{\"empty_time_slice\", []time.Time{}, \"[]\"},\n\t\t{\"empty_address_slice\", []std.Address{}, \"[]\"},\n\t\t{\"empty_interface_slice\", []interface{}{}, \"[]\"},\n\n\t\t// maps\n\t\t{\"empty_string_map\", map[string]string{}, \"map[]\"},\n\t\t{\"string_map\", map[string]string{\"a\": \"1\", \"b\": \"2\"}, \"map[a:1 b:2]\"},\n\t\t{\"empty_interface_map\", map[string]interface{}{}, \"map[]\"},\n\t\t{\"interface_map\", map[string]interface{}{\"a\": 1, \"b\": \"2\"}, \"map[a:1 b:2]\"},\n\n\t\t// edge cases\n\t\t{\"empty_bytes\", []byte{}, \"\"},\n\t\t{\"nil_interface\", interface{}(nil), \"\"},\n\t\t{\"empty_struct\", struct{}{}, \"{}\"},\n\t\t{\"unknown_type\", struct{ foo string }{}, \"\u003cunknown\u003e\"},\n\n\t\t// pointer types\n\t\t{\"nil_string_ptr\", (*string)(nil), \"\"},\n\t\t{\"string_ptr\", \u0026str, \"hello\"},\n\t\t{\"nil_int_ptr\", (*int)(nil), \"\"},\n\t\t{\"int_ptr\", \u0026num, \"42\"},\n\t\t{\"nil_bool_ptr\", (*bool)(nil), \"\"},\n\t\t{\"bool_ptr\", \u0026b, \"true\"},\n\t\t// {\"nil_time_ptr\", (*time.Time)(nil), \"\"}, // TODO: fix this\n\t\t{\"time_ptr\", \u0026now, now.String()},\n\t\t// {\"nil_address_ptr\", (*std.Address)(nil), \"\"}, // TODO: fix this\n\t\t{\"address_ptr\", \u0026addr, string(addr)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := ToString(tt.input)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"%s: ToString(%v) = %q, want %q\", tt.name, tt.input, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestToBool(t *testing.T) {\n\tstr := \"true\"\n\tnum := 42\n\tb := true\n\tnow := time.Now()\n\taddr := std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\tzero := 0\n\tempty := \"\"\n\tfalseVal := false\n\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    interface{}\n\t\texpected bool\n\t}\n\n\ttests := []testCase{\n\t\t// basic types\n\t\t{\"true\", true, true},\n\t\t{\"false\", false, false},\n\t\t{\"nil\", nil, false},\n\n\t\t// strings\n\t\t{\"empty_string\", \"\", false},\n\t\t{\"zero_string\", \"0\", false},\n\t\t{\"false_string\", \"false\", false},\n\t\t{\"f_string\", \"f\", false},\n\t\t{\"no_string\", \"no\", false},\n\t\t{\"n_string\", \"n\", false},\n\t\t{\"off_string\", \"off\", false},\n\t\t{\"space_string\", \" \", false},\n\t\t{\"true_string\", \"true\", true},\n\t\t{\"yes_string\", \"yes\", true},\n\t\t{\"random_string\", \"hello\", true},\n\n\t\t// numbers\n\t\t{\"zero_int\", 0, false},\n\t\t{\"positive_int\", 1, true},\n\t\t{\"negative_int\", -1, true},\n\t\t{\"zero_float\", 0.0, false},\n\t\t{\"positive_float\", 0.1, true},\n\t\t{\"negative_float\", -0.1, true},\n\n\t\t// special types\n\t\t{\"empty_bytes\", []byte{}, false},\n\t\t{\"non_empty_bytes\", []byte{1}, true},\n\t\t/*{\"zero_time\", time.Time{}, false},*/ // TODO: fix this\n\t\t{\"empty_address\", std.Address(\"\"), false},\n\n\t\t// slices\n\t\t{\"empty_slice\", []string{}, false},\n\t\t{\"non_empty_slice\", []string{\"a\"}, true},\n\n\t\t// maps\n\t\t{\"empty_map\", map[string]string{}, false},\n\t\t{\"non_empty_map\", map[string]string{\"a\": \"b\"}, true},\n\n\t\t// pointer types\n\t\t{\"nil_bool_ptr\", (*bool)(nil), false},\n\t\t{\"true_ptr\", \u0026b, true},\n\t\t{\"false_ptr\", \u0026falseVal, false},\n\t\t{\"nil_string_ptr\", (*string)(nil), false},\n\t\t{\"string_ptr\", \u0026str, true},\n\t\t{\"empty_string_ptr\", \u0026empty, false},\n\t\t{\"nil_int_ptr\", (*int)(nil), false},\n\t\t{\"int_ptr\", \u0026num, true},\n\t\t{\"zero_int_ptr\", \u0026zero, false},\n\t\t// {\"nil_time_ptr\", (*time.Time)(nil), false}, // TODO: fix this\n\t\t{\"time_ptr\", \u0026now, true},\n\t\t// {\"nil_address_ptr\", (*std.Address)(nil), false}, // TODO: fix this\n\t\t{\"address_ptr\", \u0026addr, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := ToBool(tt.input)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"%s: ToBool(%v) = %v, want %v\", tt.name, tt.input, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIsZero(t *testing.T) {\n\tstr := \"hello\"\n\tnum := 42\n\tb := true\n\tnow := time.Now()\n\taddr := std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\tzero := 0\n\tempty := \"\"\n\tfalseVal := false\n\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    interface{}\n\t\texpected bool\n\t}\n\n\ttests := []testCase{\n\t\t// basic types\n\t\t{\"true\", true, false},\n\t\t{\"false\", false, true},\n\t\t{\"nil\", nil, true},\n\n\t\t// strings\n\t\t{\"empty_string\", \"\", true},\n\t\t{\"non_empty_string\", \"hello\", false},\n\n\t\t// numbers\n\t\t{\"zero_int\", 0, true},\n\t\t{\"non_zero_int\", 1, false},\n\t\t{\"zero_float\", 0.0, true},\n\t\t{\"non_zero_float\", 0.1, false},\n\n\t\t// special types\n\t\t{\"empty_bytes\", []byte{}, true},\n\t\t{\"non_empty_bytes\", []byte{1}, false},\n\t\t/*{\"zero_time\", time.Time{}, true},*/ // TODO: fix this\n\t\t{\"empty_address\", std.Address(\"\"), true},\n\n\t\t// slices\n\t\t{\"empty_slice\", []string{}, true},\n\t\t{\"non_empty_slice\", []string{\"a\"}, false},\n\n\t\t// maps\n\t\t{\"empty_map\", map[string]string{}, true},\n\t\t{\"non_empty_map\", map[string]string{\"a\": \"b\"}, false},\n\n\t\t// pointer types\n\t\t{\"nil_bool_ptr\", (*bool)(nil), true},\n\t\t{\"false_ptr\", \u0026falseVal, true},\n\t\t{\"true_ptr\", \u0026b, false},\n\t\t{\"nil_string_ptr\", (*string)(nil), true},\n\t\t{\"empty_string_ptr\", \u0026empty, true},\n\t\t{\"string_ptr\", \u0026str, false},\n\t\t{\"nil_int_ptr\", (*int)(nil), true},\n\t\t{\"zero_int_ptr\", \u0026zero, true},\n\t\t{\"int_ptr\", \u0026num, false},\n\t\t// {\"nil_time_ptr\", (*time.Time)(nil), true}, // TODO: fix this\n\t\t{\"time_ptr\", \u0026now, false},\n\t\t// {\"nil_address_ptr\", (*std.Address)(nil), true}, // TODO: fix this\n\t\t{\"address_ptr\", \u0026addr, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := IsZero(tt.input)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"%s: IsZero(%v) = %v, want %v\", tt.name, tt.input, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestToInterfaceSlice(t *testing.T) {\n\tnow := time.Now()\n\taddr := std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\tstr := testStringer{value: \"hello\"}\n\n\ttests := []struct {\n\t\tname     string\n\t\tinput    interface{}\n\t\texpected []interface{}\n\t\tcompare  func([]interface{}, []interface{}) bool\n\t}{\n\t\t{\n\t\t\tname:     \"nil\",\n\t\t\tinput:    nil,\n\t\t\texpected: nil,\n\t\t\tcompare:  compareNil,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty_interface_slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\texpected: []interface{}{},\n\t\t\tcompare:  compareEmpty,\n\t\t},\n\t\t{\n\t\t\tname:     \"interface_slice\",\n\t\t\tinput:    []interface{}{1, \"two\", true},\n\t\t\texpected: []interface{}{1, \"two\", true},\n\t\t\tcompare:  compareInterfaces,\n\t\t},\n\t\t{\n\t\t\tname:     \"string_slice\",\n\t\t\tinput:    []string{\"a\", \"b\", \"c\"},\n\t\t\texpected: []interface{}{\"a\", \"b\", \"c\"},\n\t\t\tcompare:  compareStrings,\n\t\t},\n\t\t{\n\t\t\tname:     \"int_slice\",\n\t\t\tinput:    []int{1, 2, 3},\n\t\t\texpected: []interface{}{1, 2, 3},\n\t\t\tcompare:  compareInts,\n\t\t},\n\t\t{\n\t\t\tname:     \"int32_slice\",\n\t\t\tinput:    []int32{1, 2, 3},\n\t\t\texpected: []interface{}{int32(1), int32(2), int32(3)},\n\t\t\tcompare:  compareInt32s,\n\t\t},\n\t\t{\n\t\t\tname:     \"int64_slice\",\n\t\t\tinput:    []int64{1, 2, 3},\n\t\t\texpected: []interface{}{int64(1), int64(2), int64(3)},\n\t\t\tcompare:  compareInt64s,\n\t\t},\n\t\t{\n\t\t\tname:     \"float32_slice\",\n\t\t\tinput:    []float32{1.1, 2.2, 3.3},\n\t\t\texpected: []interface{}{float32(1.1), float32(2.2), float32(3.3)},\n\t\t\tcompare:  compareFloat32s,\n\t\t},\n\t\t{\n\t\t\tname:     \"float64_slice\",\n\t\t\tinput:    []float64{1.1, 2.2, 3.3},\n\t\t\texpected: []interface{}{1.1, 2.2, 3.3},\n\t\t\tcompare:  compareFloat64s,\n\t\t},\n\t\t{\n\t\t\tname:     \"bool_slice\",\n\t\t\tinput:    []bool{true, false, true},\n\t\t\texpected: []interface{}{true, false, true},\n\t\t\tcompare:  compareBools,\n\t\t},\n\t\t/* {\n\t\t\tname:     \"time_slice\",\n\t\t\tinput:    []time.Time{now},\n\t\t\texpected: []interface{}{now},\n\t\t\tcompare:  compareTimes,\n\t\t}, */ // TODO: fix this\n\t\t/* {\n\t\t\tname:     \"address_slice\",\n\t\t\tinput:    []std.Address{addr},\n\t\t\texpected: []interface{}{addr},\n\t\t\tcompare:  compareAddresses,\n\t\t},*/ // TODO: fix this\n\t\t/* {\n\t\t\tname:     \"bytes_slice\",\n\t\t\tinput:    [][]byte{[]byte(\"hello\"), []byte(\"world\")},\n\t\t\texpected: []interface{}{[]byte(\"hello\"), []byte(\"world\")},\n\t\t\tcompare:  compareBytes,\n\t\t},*/ // TODO: fix this\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := ToInterfaceSlice(tt.input)\n\t\t\tif !tt.compare(got, tt.expected) {\n\t\t\t\tt.Errorf(\"ToInterfaceSlice() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareNil(a, b []interface{}) bool {\n\treturn a == nil \u0026\u0026 b == nil\n}\n\nfunc compareEmpty(a, b []interface{}) bool {\n\treturn len(a) == 0 \u0026\u0026 len(b) == 0\n}\n\nfunc compareInterfaces(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareStrings(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tas, ok1 := a[i].(string)\n\t\tbs, ok2 := b[i].(string)\n\t\tif !ok1 || !ok2 || as != bs {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareInts(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tai, ok1 := a[i].(int)\n\t\tbi, ok2 := b[i].(int)\n\t\tif !ok1 || !ok2 || ai != bi {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareInt32s(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tai, ok1 := a[i].(int32)\n\t\tbi, ok2 := b[i].(int32)\n\t\tif !ok1 || !ok2 || ai != bi {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareInt64s(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tai, ok1 := a[i].(int64)\n\t\tbi, ok2 := b[i].(int64)\n\t\tif !ok1 || !ok2 || ai != bi {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareFloat32s(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tai, ok1 := a[i].(float32)\n\t\tbi, ok2 := b[i].(float32)\n\t\tif !ok1 || !ok2 || ai != bi {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareFloat64s(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tai, ok1 := a[i].(float64)\n\t\tbi, ok2 := b[i].(float64)\n\t\tif !ok1 || !ok2 || ai != bi {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareBools(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tab, ok1 := a[i].(bool)\n\t\tbb, ok2 := b[i].(bool)\n\t\tif !ok1 || !ok2 || ab != bb {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareTimes(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tat, ok1 := a[i].(time.Time)\n\t\tbt, ok2 := b[i].(time.Time)\n\t\tif !ok1 || !ok2 || !at.Equal(bt) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareAddresses(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\taa, ok1 := a[i].(std.Address)\n\t\tba, ok2 := b[i].(std.Address)\n\t\tif !ok1 || !ok2 || aa != ba {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareBytes(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tab, ok1 := a[i].([]byte)\n\t\tbb, ok2 := b[i].([]byte)\n\t\tif !ok1 || !ok2 || string(ab) != string(bb) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// compareStringInterfaceMaps compares two map[string]interface{} for equality\nfunc compareStringInterfaceMaps(a, b map[string]interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor k, v1 := range a {\n\t\tv2, ok := b[k]\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\t// Compare values based on their type\n\t\tswitch val1 := v1.(type) {\n\t\tcase string:\n\t\t\tval2, ok := v2.(string)\n\t\t\tif !ok || val1 != val2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase int:\n\t\t\tval2, ok := v2.(int)\n\t\t\tif !ok || val1 != val2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase float64:\n\t\t\tval2, ok := v2.(float64)\n\t\t\tif !ok || val1 != val2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase bool:\n\t\t\tval2, ok := v2.(bool)\n\t\t\tif !ok || val1 != val2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase []interface{}:\n\t\t\tval2, ok := v2.([]interface{})\n\t\t\tif !ok || len(val1) != len(val2) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor i := range val1 {\n\t\t\t\tif val1[i] != val2[i] {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\tcase map[string]interface{}:\n\t\t\tval2, ok := v2.(map[string]interface{})\n\t\t\tif !ok || !compareStringInterfaceMaps(val1, val2) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestToMapStringInterface(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    interface{}\n\t\texpected map[string]interface{}\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname: \"map[string]interface{}\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"key1\": \"value1\",\n\t\t\t\t\"key2\": 42,\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"key1\": \"value1\",\n\t\t\t\t\"key2\": 42,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[string]string\",\n\t\t\tinput: map[string]string{\n\t\t\t\t\"key1\": \"value1\",\n\t\t\t\t\"key2\": \"value2\",\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"key1\": \"value1\",\n\t\t\t\t\"key2\": \"value2\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[string]int\",\n\t\t\tinput: map[string]int{\n\t\t\t\t\"key1\": 1,\n\t\t\t\t\"key2\": 2,\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"key1\": 1,\n\t\t\t\t\"key2\": 2,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[string]float64\",\n\t\t\tinput: map[string]float64{\n\t\t\t\t\"key1\": 1.1,\n\t\t\t\t\"key2\": 2.2,\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"key1\": 1.1,\n\t\t\t\t\"key2\": 2.2,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[string]bool\",\n\t\t\tinput: map[string]bool{\n\t\t\t\t\"key1\": true,\n\t\t\t\t\"key2\": false,\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"key1\": true,\n\t\t\t\t\"key2\": false,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[string][]string\",\n\t\t\tinput: map[string][]string{\n\t\t\t\t\"key1\": {\"a\", \"b\"},\n\t\t\t\t\"key2\": {\"c\", \"d\"},\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"key1\": []interface{}{\"a\", \"b\"},\n\t\t\t\t\"key2\": []interface{}{\"c\", \"d\"},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested map[string]map[string]string\",\n\t\t\tinput: map[string]map[string]string{\n\t\t\t\t\"key1\": {\"nested1\": \"value1\"},\n\t\t\t\t\"key2\": {\"nested2\": \"value2\"},\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"key1\": map[string]interface{}{\"nested1\": \"value1\"},\n\t\t\t\t\"key2\": map[string]interface{}{\"nested2\": \"value2\"},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsupported type\",\n\t\t\tinput:    42, // not a map\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := ToMapStringInterface(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"ToMapStringInterface() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareStringInterfaceMaps(got, tt.expected) {\n\t\t\t\t\tt.Errorf(\"ToMapStringInterface() = %v, expected %v\", got, tt.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Test error messages\nfunc TestToMapStringInterfaceErrors(t *testing.T) {\n\t_, err := ToMapStringInterface(42)\n\tif err == nil || !strings.Contains(err.Error(), \"unsupported map type\") {\n\t\tt.Errorf(\"Expected error containing 'unsupported map type', got %v\", err)\n\t}\n}\n\n// compareIntInterfaceMaps compares two map[int]interface{} for equality\nfunc compareIntInterfaceMaps(a, b map[int]interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor k, v1 := range a {\n\t\tv2, ok := b[k]\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\t// Compare values based on their type\n\t\tswitch val1 := v1.(type) {\n\t\tcase string:\n\t\t\tval2, ok := v2.(string)\n\t\t\tif !ok || val1 != val2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase int:\n\t\t\tval2, ok := v2.(int)\n\t\t\tif !ok || val1 != val2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase float64:\n\t\t\tval2, ok := v2.(float64)\n\t\t\tif !ok || val1 != val2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase bool:\n\t\t\tval2, ok := v2.(bool)\n\t\t\tif !ok || val1 != val2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase []interface{}:\n\t\t\tval2, ok := v2.([]interface{})\n\t\t\tif !ok || len(val1) != len(val2) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor i := range val1 {\n\t\t\t\tif val1[i] != val2[i] {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\tcase map[string]interface{}:\n\t\t\tval2, ok := v2.(map[string]interface{})\n\t\t\tif !ok || !compareStringInterfaceMaps(val1, val2) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestToMapIntInterface(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    interface{}\n\t\texpected map[int]interface{}\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname: \"map[int]interface{}\",\n\t\t\tinput: map[int]interface{}{\n\t\t\t\t1: \"value1\",\n\t\t\t\t2: 42,\n\t\t\t},\n\t\t\texpected: map[int]interface{}{\n\t\t\t\t1: \"value1\",\n\t\t\t\t2: 42,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[int]string\",\n\t\t\tinput: map[int]string{\n\t\t\t\t1: \"value1\",\n\t\t\t\t2: \"value2\",\n\t\t\t},\n\t\t\texpected: map[int]interface{}{\n\t\t\t\t1: \"value1\",\n\t\t\t\t2: \"value2\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[int]int\",\n\t\t\tinput: map[int]int{\n\t\t\t\t1: 10,\n\t\t\t\t2: 20,\n\t\t\t},\n\t\t\texpected: map[int]interface{}{\n\t\t\t\t1: 10,\n\t\t\t\t2: 20,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[int]float64\",\n\t\t\tinput: map[int]float64{\n\t\t\t\t1: 1.1,\n\t\t\t\t2: 2.2,\n\t\t\t},\n\t\t\texpected: map[int]interface{}{\n\t\t\t\t1: 1.1,\n\t\t\t\t2: 2.2,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[int]bool\",\n\t\t\tinput: map[int]bool{\n\t\t\t\t1: true,\n\t\t\t\t2: false,\n\t\t\t},\n\t\t\texpected: map[int]interface{}{\n\t\t\t\t1: true,\n\t\t\t\t2: false,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[int][]string\",\n\t\t\tinput: map[int][]string{\n\t\t\t\t1: {\"a\", \"b\"},\n\t\t\t\t2: {\"c\", \"d\"},\n\t\t\t},\n\t\t\texpected: map[int]interface{}{\n\t\t\t\t1: []interface{}{\"a\", \"b\"},\n\t\t\t\t2: []interface{}{\"c\", \"d\"},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"map[int]map[string]interface{}\",\n\t\t\tinput: map[int]map[string]interface{}{\n\t\t\t\t1: {\"nested1\": \"value1\"},\n\t\t\t\t2: {\"nested2\": \"value2\"},\n\t\t\t},\n\t\t\texpected: map[int]interface{}{\n\t\t\t\t1: map[string]interface{}{\"nested1\": \"value1\"},\n\t\t\t\t2: map[string]interface{}{\"nested2\": \"value2\"},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsupported type\",\n\t\t\tinput:    42, // not a map\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := ToMapIntInterface(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"ToMapIntInterface() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareIntInterfaceMaps(got, tt.expected) {\n\t\t\t\t\tt.Errorf(\"ToMapIntInterface() = %v, expected %v\", got, tt.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestToStringSlice(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    interface{}\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\tname:     \"nil input\",\n\t\t\tinput:    nil,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []string{},\n\t\t\texpected: []string{},\n\t\t},\n\t\t{\n\t\t\tname:     \"string slice\",\n\t\t\tinput:    []string{\"a\", \"b\", \"c\"},\n\t\t\texpected: []string{\"a\", \"b\", \"c\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"int slice\",\n\t\t\tinput:    []int{1, 2, 3},\n\t\t\texpected: []string{\"1\", \"2\", \"3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"int32 slice\",\n\t\t\tinput:    []int32{1, 2, 3},\n\t\t\texpected: []string{\"1\", \"2\", \"3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"int64 slice\",\n\t\t\tinput:    []int64{1, 2, 3},\n\t\t\texpected: []string{\"1\", \"2\", \"3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"uint slice\",\n\t\t\tinput:    []uint{1, 2, 3},\n\t\t\texpected: []string{\"1\", \"2\", \"3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"uint8 slice\",\n\t\t\tinput:    []uint8{1, 2, 3},\n\t\t\texpected: []string{\"1\", \"2\", \"3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"uint16 slice\",\n\t\t\tinput:    []uint16{1, 2, 3},\n\t\t\texpected: []string{\"1\", \"2\", \"3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"uint32 slice\",\n\t\t\tinput:    []uint32{1, 2, 3},\n\t\t\texpected: []string{\"1\", \"2\", \"3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64 slice\",\n\t\t\tinput:    []uint64{1, 2, 3},\n\t\t\texpected: []string{\"1\", \"2\", \"3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"float32 slice\",\n\t\t\tinput:    []float32{1.1, 2.2, 3.3},\n\t\t\texpected: []string{\"1.1\", \"2.2\", \"3.3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"float64 slice\",\n\t\t\tinput:    []float64{1.1, 2.2, 3.3},\n\t\t\texpected: []string{\"1.1\", \"2.2\", \"3.3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"bool slice\",\n\t\t\tinput:    []bool{true, false, true},\n\t\t\texpected: []string{\"true\", \"false\", \"true\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"[]byte slice\",\n\t\t\tinput:    [][]byte{[]byte(\"hello\"), []byte(\"world\")},\n\t\t\texpected: []string{\"hello\", \"world\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"interface slice\",\n\t\t\tinput:    []interface{}{1, \"hello\", true},\n\t\t\texpected: []string{\"1\", \"hello\", \"true\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"time slice\",\n\t\t\tinput:    []time.Time{time.Time{}, time.Time{}},\n\t\t\texpected: []string{\"0001-01-01 00:00:00 +0000 UTC\", \"0001-01-01 00:00:00 +0000 UTC\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"address slice\",\n\t\t\tinput:    []std.Address{\"addr1\", \"addr2\"},\n\t\t\texpected: []string{\"addr1\", \"addr2\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"non-slice input\",\n\t\t\tinput:    42,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := ToStringSlice(tt.input)\n\t\t\tif !slicesEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"ToStringSlice(%v) = %v, want %v\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare string slices\nfunc slicesEqual(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestToStringAdvanced(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    interface{}\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"slice with mixed basic types\",\n\t\t\tinput: []interface{}{\n\t\t\t\t42,\n\t\t\t\t\"hello\",\n\t\t\t\ttrue,\n\t\t\t\t3.14,\n\t\t\t},\n\t\t\texpected: \"[42 hello true 3.14]\",\n\t\t},\n\t\t{\n\t\t\tname: \"map with basic types\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"int\":   42,\n\t\t\t\t\"str\":   \"hello\",\n\t\t\t\t\"bool\":  true,\n\t\t\t\t\"float\": 3.14,\n\t\t\t},\n\t\t\texpected: \"map[bool:true float:3.14 int:42 str:hello]\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed types map\",\n\t\t\tinput: map[interface{}]interface{}{\n\t\t\t\t42:         \"number\",\n\t\t\t\t\"string\":   123,\n\t\t\t\ttrue:       []int{1, 2, 3},\n\t\t\t\tstruct{}{}: \"empty\",\n\t\t\t},\n\t\t\texpected: \"map[42:number string:123 true:[1 2 3] {}:empty]\",\n\t\t},\n\t\t{\n\t\t\tname: \"nested maps\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"a\": map[string]int{\n\t\t\t\t\t\"x\": 1,\n\t\t\t\t\t\"y\": 2,\n\t\t\t\t},\n\t\t\t\t\"b\": []interface{}{1, \"two\", true},\n\t\t\t},\n\t\t\texpected: \"map[a:map[x:1 y:2] b:[1 two true]]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"empty struct\",\n\t\t\tinput:    struct{}{},\n\t\t\texpected: \"{}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := ToString(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"\\nToString(%v) =\\n%v\\nwant:\\n%v\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"50000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":null,"signature":null}],"memo":""}}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1zulx05q6yt2kwdffau9ztf809rrgtyaw8pqec9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"g/EL4/12hSFmvXsdw3gwxzRTKd/qjTyU8W/crskM64llVEB54OThJB/F7kKoNftSzODIQYTJAeZfHNkWM5UHHw=="}],"memo":""},"metadata":{"timestamp":"1735336880"}}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1zulx05q6yt2kwdffau9ztf809rrgtyaw8pqec9","send":"150000ugnot","pkg_path":"gno.land/r/nemanya/home","func":"SponsorGnoProject","args":["Liberty Bridge"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AyrBV5i0G+EiCaR4z+Jpv7nLOuqYZSDqTu5ZQ2YcEptd"},"signature":"vxuA6GE4pDe+vor4qWEUvcTR7COPfiGNg964FERln9NX3jYrPUct474KIn8vdmlMSUWcsBdS/rri6BKPA3Tkcg=="}],"memo":"Called through gno.studio"},"metadata":{"timestamp":"1735336905"}}
