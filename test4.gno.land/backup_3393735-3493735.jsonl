{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/qux","func":"Transfer","args":["g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","100000000000"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"GrWfjnPJIwHM0/PLydoBdUC8I96KDkzdcu6Go4UFHmEQUMYd24qgrhytP7ewFJTS+qjhOHjl/oNr6jpEFMh2uQ=="}],"memo":""},"blockNum":"3406174"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"1000000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"80JQz5waz9R3TAc/l67kHKPxAvcIQyN84QZAcj0SGLZrgH/5aOVLJKfcdqtAkCwMSuoGk/d51zTYcIiYekfLNQ=="}],"memo":""},"blockNum":"3406532"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z/popo_nft","func":"Mint","args":["g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","4"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"PCijBMBVOzbBOO4F+SW54jaIZQJr9kQR0MXrjvuYW+lGzzXoA+GeYVZ2B0GTMpq41xncuJL/y3moEPu1b1T2nA=="}],"memo":""},"blockNum":"3410425"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z/popo_nft","func":"Mint","args":["g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","4"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"N0W2MguGHEzKo7QYypPXPAAi6nOAOFkMkLQ5074VQ8AqFH4CPZXOsd/3kTGUfqvSKptY5ZzfvwNOBL3ITH6FBQ=="}],"memo":""},"blockNum":"3410449"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z/popo_nft","func":"Mint","args":["g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","5"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"iWxM7ak60kdDZGDgDTHl+r9bMoosiuTyqj557FaF/XVawObgYNMQWOLAXstADFq/BbvUB4pZQeUFRCopDClzDQ=="}],"memo":""},"blockNum":"3410453"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z/popo_nft","func":"Mint","args":["g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","10"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"ApFGZ7gCHsEZbRy247pqm26ahOzHNNcDyZmFxaIyNn07ehVnnCWpGzAsxLR32uo3NhzRW3qZ44bAowHSm6IhFg=="}],"memo":""},"blockNum":"3410457"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/keyboard_worrier/popo_nft","func":"Mint","args":["g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","10"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"mthy2hkkWeGsTTFPU+VPilf9+mkuXS9vrBMYgDnYEWNUf5bkv9VWgNmJCkfaPszWs9GICNwDAEcxQ7zA00ECEA=="}],"memo":""},"blockNum":"3410463"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/keyboard_worrier/popo_nft","func":"SetTokenURI","args":["10","asdf"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"Jkph8M9ZcyL5/HMSQFcUS/bz1KpFwC6igGs/pKWEAkxFPPB1449QVy4NGqiO/Mh1CfoRWhAr1aSKlyFQ2qy64A=="}],"memo":""},"blockNum":"3410490"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/keyboard_worrier/popo_nft","func":"SetTokenURI","args":["10","https://i.namu.wiki/i/17GemERAji6nAOC-hhksETF2VB_KILKo8jv12D7PC6pBh4_Y4BgjOAMfWEaE16nB2wCvKmkINg-MOo0mIVEgqH4KiTDq7Bw43o9Uc8b9xhUXZjxKAzpRRceb6iHGso0mzs2_RLeLtGKnIx7nk0mY3Q.webpf"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"7RJ0SV5mxBC8bWO+q10tbm49CojuTidnu1SokcF/m0JeS9VuiOeKjstrGU+gdGIkx/Gvp9E4gDVOibXb4L5Xvw=="}],"memo":""},"blockNum":"3410527"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/keyboard_worrier/popo_nft","func":"SetTokenURI","args":["10","https://i.namu.wiki/i/17GemERAji6nAOC-hhksETF2VB_KILKo8jv12D7PC6pBh4_Y4BgjOAMfWEaE16nB2wCvKmkINg-MOo0mIVEgqH4KiTDq7Bw43o9Uc8b9xhUXZjxKAzpRRceb6iHGso0mzs2_RLeLtGKnIx7nk0mY3Q1.webp"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"Gp4MhwPpU0ZV3P7ZUwDoiGu7k8920H74g9QvBDCx65dXDubcMNHMXQdfEIx6wwJLdJx2HmqfvS9uxFDHCqFbHQ=="}],"memo":""},"blockNum":"3410546"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/keyboard_worrier/popo_nft","func":"SetTokenURI","args":["10","https://rpc.test4.gno.land/health"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"KavO4xW3vhgbpjyXdwOUcJZ+cqYcRIH8+BZmkn5UhbJ+ZgvNGIoVBwEOj+srDC3t/vzW6TWhBnvjaOUX9UCoGw=="}],"memo":""},"blockNum":"3410563"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jazghxvvgz3egnr2fc8uf72z4g0l03596y9ls7","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["5","YES"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzFdv1Uf9hYAYGR/nDjpuWViwY6oujHVSjOHfnVPnW0a"},"signature":"/ioAvkwwLDd4/gf9qJlEy2PDlFDNgap/lhGxTQ3dBZEQnWVte6R/fREL+XmI5RgpmTCDJuIgrKDO0zkTYSnO9Q=="}],"memo":"Voted using govdao-web!"},"blockNum":"3410626"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jazghxvvgz3egnr2fc8uf72z4g0l03596y9ls7","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["4","YES"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzFdv1Uf9hYAYGR/nDjpuWViwY6oujHVSjOHfnVPnW0a"},"signature":"sx0RLdk3hjYW+29oDP5Knu9sZ0bMxVKpco21DblP+PcBDcrGvba8BOd+ptMJniq/OzDY6Wn//TtCJL7joz2Vww=="}],"memo":"Voted using govdao-web!"},"blockNum":"3410631"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/keyboard_worrier/popo_nft","func":"TransferFrom","args":["g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","10"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"S1PHM9zWrVmFWyzTmUf1Ce0zVq/d+MZayzc8ObT+zMxDHm+WyoC3r8d51gae7VHxPc8AYUBudd1Qi2mnFNxS1g=="}],"memo":"1"},"blockNum":"3410803"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["2","YES"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"9seyzsqIXipPNNmkqf9MGLELLdXjcLZzjR8MWa6yXVcg806hhRQAe775Rp5zfgUNCuy1lM3IIDXNTILzipp88Q=="}],"memo":"Voted using govdao-web!"},"blockNum":"3411639"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["3","YES"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"WF7iG95ViE6LlTITl52fuU8z2ezcXs3eZCM7+7+FfnZzpnOp01/3ORZbvPGYpW/51dnqe9OE2jVoA9CRIEMhEA=="}],"memo":"Voted using govdao-web!"},"blockNum":"3411642"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["4","YES"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"3qoQkDZkb5e5Z02+fBgVnWom3a6HNE1osKZSO6NFJhdXvkarnzH0OlfcnvBpuY0ScftSn7OupbD8vsMeMaZFqg=="}],"memo":"Voted using govdao-web!"},"blockNum":"3411645"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["5","YES"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"SdZh1Zfo5O4uwMDB7eiZc/CjUBQTkglPSqeWv3ARgR9bMk23wX0/3lvDjumfAOLFfwyIzcD0Ljmfj9uLq2IXxw=="}],"memo":"Voted using govdao-web!"},"blockNum":"3411648"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["3","YES"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"szHTQ0YRB4Arl+ytjZAapOnhRARxf13xDObbzVShtVEdyH5Zogb8CwGzYHduBJ8rhuGU6a1V15PbMuf7zaGuqw=="}],"memo":"Voted using govdao-web!"},"blockNum":"3411650"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Transfer","args":["g1dxrtze2j5d4tq2q90gpjde2m52f9ckwr7a06k0","1000000"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"OuU6ObjVEwnWsrUfioO3VcEGYvJP7qyl5cS2g3Wf5dIQtmCecWLBWGgTwDpuzHdsgQjGUDkgEPht3qk2of34+w=="}],"memo":""},"blockNum":"3414537"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1dxrtze2j5d4tq2q90gpjde2m52f9ckwr7a06k0","amount":"1000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"SGUoNnSebDhz8faLGKADCamPbAQHqUUPsg9+/d5ozjRqhS9GyVwu83D0w8eqyo5y5ftnHRSbtYxAZ5289RoRqQ=="}],"memo":""},"blockNum":"3414565"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"123gnot"}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"N+NzNPKGhAJNjgVZ731xlNn+NuUbaCRVOHaCr3xC+VVa1d+upwbyCjrpbqI3xfcv9v1OqpCZDZnuD6ez9hHlEw=="}],"memo":""},"blockNum":"3414895"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","amount":"55250213899ugnot"}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"Yd7KP0HOAbzdIU8Qy37dwk3SD3Rq+19KDiAcjA4u1p1LB7npZFUj0rYyuk5ktFD7A+0gUdtmIBHryDyAe8shZw=="}],"memo":""},"blockNum":"3414912"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g18r06zm5pdhkle0ktea8kkvykf9dk66wjcppmcl","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"+ONdmzDkYpjneMoONuAjUiM3A/8Sog5Eb8S583PsbttPkIiQsIM5StbNjDd6b0ec6SQuefRw1mCQGBnFBQ/kLg=="}],"memo":""},"blockNum":"3414975"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1cpx59z5r8vzeww2fm4ezpz7yvjs7kptywkm864","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["2","YES"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiUkDPOKGgpjkZRc8zxqbwBhgTsQHa2fspi5PvxiZT11"},"signature":"zfNkNDI96zxeGrAY/cRCZUG0+2fHTWcITacuWjqt5GJnDWbMOFQ9P0RKoyFzyjdlononQ0xZBaC71PnWAyRgvQ=="}],"memo":""},"blockNum":"3419321"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1cpx59z5r8vzeww2fm4ezpz7yvjs7kptywkm864","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["3","YES"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiUkDPOKGgpjkZRc8zxqbwBhgTsQHa2fspi5PvxiZT11"},"signature":"Bhrpm/I9ffzpnjMv0gvQelAi0p/05FS7em/kUaICrCJYg8oxloXKuXR4vDXwM2LGsBVB/CtOQ5Jw9AHKosHy/A=="}],"memo":""},"blockNum":"3419340"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1cpx59z5r8vzeww2fm4ezpz7yvjs7kptywkm864","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["4","YES"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiUkDPOKGgpjkZRc8zxqbwBhgTsQHa2fspi5PvxiZT11"},"signature":"Rt8kJFsklYm5jjwcozKW5rSH6qMYxZIk1cPy2+IXGQRibJYEKHr53iTsxyrUbjpRaVTlqA+qGzfoOFldkvZTWg=="}],"memo":""},"blockNum":"3419349"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1cpx59z5r8vzeww2fm4ezpz7yvjs7kptywkm864","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["5","YES"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiUkDPOKGgpjkZRc8zxqbwBhgTsQHa2fspi5PvxiZT11"},"signature":"aIdpBcebFjPiBvSIbU9vNwZ8Cv79rkOrlzmiqpjrCQ4Px1Zfaciw9k5EaWqokvHpCyJfQ77kotu36BFi9n6Jgg=="}],"memo":""},"blockNum":"3419360"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e6gxg5tvc55mwsn7t7dymmlasratv7mkv0rap2","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"ExecuteProposal","args":["2"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqATlb7YPpY03HfModetps7565VdIZNjwguVO3cKmE+K"},"signature":"reoqV0TTWBsfPZXlJFbS4ufKmNKrUf5luU7M++thmi9poNMiiRtCvAYCEhcSxZHaFTDb3vc4nLSBsTZPxUeDXQ=="}],"memo":""},"blockNum":"3419388"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/gov/dao/v2","func":"VoteOnProposal","args":["5","YES"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"HzpT8T3ISKWD62t1tL0zqhzY+5nIwOt1yi+tjJRw0PgHv4AnpkmJ9yLJNgagnPCsO9uZZB0HsXcAklO4EnuqJw=="}],"memo":"Voted using govdao-web!"},"blockNum":"3441069"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g10z8d5n622fh6cckhf0ds5vxdtaw55a7766hupm","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"uV5edYCTJ5nqYiSY0A1+pTViMSD/hz5iNBc6nYiwYNVFeaYudNYvJ9k4lg8qQXP6jVdwxCrPBIiUYjJ2lpafzQ=="}],"memo":""},"blockNum":"3449987"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10z8d5n622fh6cckhf0ds5vxdtaw55a7766hupm","package":{"name":"hello","path":"gno.land/r/g10z8d5n622fh6cckhf0ds5vxdtaw55a7766hupm/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A9Udef2Z4hNzfx2uVtFJ5kaEgkK7J5S1q6ZrnpJUedE/"},"signature":"H46/BbgjOoINgUf+GcIzRkRLTxEbO4PRrq7STfS6yTN4MDBFQmWSNswNMxMT31lm64uIJZWvR6QdkTv4p5o6zg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3449998"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g10z8d5n622fh6cckhf0ds5vxdtaw55a7766hupm","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"Vdh1ISNpK3JlfpqVrN+jmVteR6y5wdDb1Lzd9U5uhZEzS8TPEN2zvFtbz76UGRgXkTlv5Bxbj1BNIPAcrp2Exg=="}],"memo":""},"blockNum":"3450061"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10z8d5n622fh6cckhf0ds5vxdtaw55a7766hupm","package":{"name":"hello","path":"gno.land/r/g10z8d5n622fh6cckhf0ds5vxdtaw55a7766hupm/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World 2!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A9Udef2Z4hNzfx2uVtFJ5kaEgkK7J5S1q6ZrnpJUedE/"},"signature":"oaD8RdJNdxybqRby4yggM0pSWl64cwfmF8+gfgM2r759qlWaYjFnw7mYfr1uCCQr16V7YD3Fqa2w2jnGlG3QiA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3450174"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g10z8d5n622fh6cckhf0ds5vxdtaw55a7766hupm","package":{"name":"hello","path":"gno.land/r/g10z8d5n622fh6cckhf0ds5vxdtaw55a7766hupm/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World 2!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A9Udef2Z4hNzfx2uVtFJ5kaEgkK7J5S1q6ZrnpJUedE/"},"signature":"ZRse4nnISDLe/UhtMi+SnWhEifWWEeAAb8o/Pwy82jsZCqe7zYrAuFoLpx8flPR7Wg0KslTcSb/WSx3QvljsUA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3450234"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","to_address":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","amount":"1000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"DmNpvkgCZLW6wuNPhEubbgJTLKaRNbw61wdeFJzCHflybx2oEomjVGq25qLOgZWL63WogZ3ALJs+scPAwDBEyQ=="}],"memo":""},"blockNum":"3467040"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","package":{"name":"test_nft","path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/test_nft","files":[{"name":"basic_nft.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"blackcows_nft.gno","body":"package TEST_NFT\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh\"\n\tblackcow              = NewNFTWithMetadata(\"TestMint\", \"TEST\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := blackcow.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := blackcow.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn blackcow.Name()\n}\n\nfunc Symbol() string {\n\treturn blackcow.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := blackcow.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := blackcow.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := blackcow.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn blackcow.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := blackcow.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := blackcow.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := blackcow.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := blackcow.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := blackcow.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Alien\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Police Uniform\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Face\",\n\t\tValue:       \"Handsome\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Background\",\n\t\tValue:       \"Very extremely red\",\n\t})\n\n\tblackcow.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"BlackCow\",\n\t\tDescription:     \"A GnoPunk is a 24x24 pixel, 8-bit-style unique avatar that comes in the form of an NFT. Their creation began as an experiment, conducted by software developers Matt Hall and John Watkinson in 2017.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    blackcow.SetTokenURI(tid, \"https://i.namu.wiki/i/yRO1u5KjySi1CtJmt6TQMIqcbXiejx7Tr-OTMv419lYLiCZYBClOxwBY2n0nz06W-9WFg9-tV2DWWPyWZh-PlOb_c1jF7P69_EAOSLuy8cUq3BOVd4o3FniIdckuWGVQFX2s-_m_XBTAMDepZ240eg.webp\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn blackcow.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"errors.gno","body":"package blackcows_nft\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"type.gno","body":"package blackcows_nft\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"GF+gVl+CYrbgwxv7IFqz7bBnEYHPoivSuzSiuCq1/ChIGd8hOrMjr8sWcf3UTYSitl/9zPzNFVgHEuLoWWPo1A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3467366"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","package":{"name":"test_nft","path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/test_nft","files":[{"name":"basic_nft.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package blackcows_nft\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"test_mint.gno","body":"package TEST_NFT\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh\"\n\tblackcow              = NewNFTWithMetadata(\"TestMint\", \"TEST\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := blackcow.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := blackcow.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn blackcow.Name()\n}\n\nfunc Symbol() string {\n\treturn blackcow.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := blackcow.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := blackcow.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := blackcow.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn blackcow.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := blackcow.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := blackcow.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := blackcow.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := blackcow.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := blackcow.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Alien\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Police Uniform\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Face\",\n\t\tValue:       \"Handsome\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Background\",\n\t\tValue:       \"Very extremely red\",\n\t})\n\n\tblackcow.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"BlackCow\",\n\t\tDescription:     \"A GnoPunk is a 24x24 pixel, 8-bit-style unique avatar that comes in the form of an NFT. Their creation began as an experiment, conducted by software developers Matt Hall and John Watkinson in 2017.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    blackcow.SetTokenURI(tid, \"https://i.namu.wiki/i/yRO1u5KjySi1CtJmt6TQMIqcbXiejx7Tr-OTMv419lYLiCZYBClOxwBY2n0nz06W-9WFg9-tV2DWWPyWZh-PlOb_c1jF7P69_EAOSLuy8cUq3BOVd4o3FniIdckuWGVQFX2s-_m_XBTAMDepZ240eg.webp\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn blackcow.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"type.gno","body":"package blackcows_nft\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"3M2ESyWTAh/pVLtA5ItVSsnY06ZaQZJ1FuQ8qXng6poi4Kp4pGmWGtonvEHs0Mfa8p9HuUAmQmxqm6MsOSwJaw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3467374"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","package":{"name":"test_nft","path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/test_nft","files":[{"name":"basic_nft.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package blackcows_nft\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"test_mint.gno","body":"package TEST_NFT\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh\"\n\ttestnew              = NewNFTWithMetadata(\"TestMint\", \"TEST\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := testnew.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := blackcow.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn blackcow.Name()\n}\n\nfunc Symbol() string {\n\treturn blackcow.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := blackcow.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := blackcow.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := blackcow.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn blackcow.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := blackcow.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := blackcow.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := blackcow.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := blackcow.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := blackcow.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Alien\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Police Uniform\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Face\",\n\t\tValue:       \"Handsome\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Background\",\n\t\tValue:       \"Very extremely red\",\n\t})\n\n\tblackcow.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"testnew\",\n\t\tDescription:     \"A GnoPunk is a 24x24 pixel, 8-bit-style unique avatar that comes in the form of an NFT. Their creation began as an experiment, conducted by software developers Matt Hall and John Watkinson in 2017.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    blackcow.SetTokenURI(tid, \"https://i.namu.wiki/i/yRO1u5KjySi1CtJmt6TQMIqcbXiejx7Tr-OTMv419lYLiCZYBClOxwBY2n0nz06W-9WFg9-tV2DWWPyWZh-PlOb_c1jF7P69_EAOSLuy8cUq3BOVd4o3FniIdckuWGVQFX2s-_m_XBTAMDepZ240eg.webp\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn testnew.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"type.gno","body":"package blackcows_nft\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"3ApGswbFD2NDyMlx16Oko8xa7toZT6DDO+XEp5O5nodnUpp0ibalWsxkKhb32YyayfvIvid8I+wwWnX2WFQOBg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3467393"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/demo/foo20","func":"TotalSupply","args":null}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"EIKedh+G5bhB5sF+wBDxeefHbWMVZSBhdLyZbGeAkkMp3/Xj2ZHnu7hKFXJIZwudPIk8XX3ANmRjYVk9AMNpHQ=="}],"memo":""},"blockNum":"3467497"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g18x425qmujg99cfz3q97y4uep5pxjq3z8lmpt25","send":"","pkg_path":"gno.land/r/demo/foo20","func":"TotalSupply","args":null}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoS6uKVPCQ2h+X8y3v/XiC81uDVuV2xoEyjGvm1B+uwF"},"signature":"hrGvaum+xJ3BI2aaS+lP/y+w6T5JLYetfKdMiIwVuV5A4IG9xaAAynpvU0x8ZR4qn/DbjqsGDPKU5r4iJsPU0g=="}],"memo":""},"blockNum":"3467512"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","package":{"name":"nft_test","path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","files":[{"name":"basic_nft.gno","body":"package nft_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"blackcows_nft.gno","body":"package nft_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh\"\n\tblackcow              = NewNFTWithMetadata(\"NFTTEST\", \"TEST\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := blackcow.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := blackcow.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn blackcow.Name()\n}\n\nfunc Symbol() string {\n\treturn blackcow.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := blackcow.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := blackcow.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := blackcow.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn blackcow.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := blackcow.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := blackcow.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := blackcow.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := blackcow.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := blackcow.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := blackcow.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Alien\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Police Uniform\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Face\",\n\t\tValue:       \"Handsome\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Background\",\n\t\tValue:       \"Very extremely red\",\n\t})\n\n\tblackcow.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"BlackCow\",\n\t\tDescription:     \"A GnoPunk is a 24x24 pixel, 8-bit-style unique avatar that comes in the form of an NFT. Their creation began as an experiment, conducted by software developers Matt Hall and John Watkinson in 2017.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    blackcow.SetTokenURI(tid, \"https://i.namu.wiki/i/yRO1u5KjySi1CtJmt6TQMIqcbXiejx7Tr-OTMv419lYLiCZYBClOxwBY2n0nz06W-9WFg9-tV2DWWPyWZh-PlOb_c1jF7P69_EAOSLuy8cUq3BOVd4o3FniIdckuWGVQFX2s-_m_XBTAMDepZ240eg.webp\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn blackcow.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"errors.gno","body":"package nft_test\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package nft_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"type.gno","body":"package nft_test\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package nft_test\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"BQ+GbCIC56ZXbUXBXzZIyznFnkExl4wtN9XiwbzMzjd0pie9y70RC5nri6mWAbpkEyN6dotR/S/oA4plbl2g3Q=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3467537"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","to_address":"g1gtqxswx0sxmjgkxwjjse82t62fk2lt7dgkg3ea","amount":"1000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"fsRq9XmJ2z9jHIZuNTGdCvQzCGbS/LnpudRmNGUSsU0EYefbrHacSY0m0aq12m7fnN9wTWSjogTPAtUHH8FlDA=="}],"memo":""},"blockNum":"3467619"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"Mint","args":["g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","3"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"YzLhriNYnIoFJyJ1OYggSAZA0ukEcjf5lQWNwS3BiF1OJPEv6j0h5E0zHxjM6IFfI71gi4IDkV6C5u3gwmLbPg=="}],"memo":""},"blockNum":"3467673"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"SetTokenURI","args":["2","https://i.namu.wiki/i/17GemERAji6nAOC-hhksETF2VB_KILKo8jv12D7PC6pBh4_Y4BgjOAMfWEaE16nB2wCvKmkINg-MOo0mIVEgqH4KiTDq7Bw43o9Uc8b9xhUXZjxKAzpRRceb6iHGso0mzs2_RLeLtGKnIx7nk0mY3Q.webp"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"iV3WvcisFoOQnA0ufkChvaC2DYiMvco0t9yyxRpPaV0aDywKjZwuAxbxvBl/lBY0Y623+5yiYHQOfHUCORrj8A=="}],"memo":""},"blockNum":"3468153"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"SetTokenURI","args":["2","https://github.com/onbloc/gno-token-resource/blob/main/grc20/images/gno_land_r_gnoswap_v2_gns.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"TiHT014iKdyr007AAGzMRSqgmbHcoU3oy+nlW366fH8PadYYN9GfZnQxo+hwblqHIS/gxv9c9lB/0NVmCO1dtg=="}],"memo":""},"blockNum":"3468219"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"SetTokenURI","args":["2","https://github.com/onbloc/gno-token-resource/blob/main/grc20/images/gno_land_r_gnoswap_v2_gns.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"84X8EaLsHewo9ZzBJZYl62751sVM1cO59fcIXRFhI/p9eUXyDn9qWxcA7zZxkzmdDHgLwhuX9RR0NHauoe70zA=="}],"memo":""},"blockNum":"3468242"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"SetTokenURI","args":["0","https://github.com/onbloc/gno-token-resource/blob/main/grc20/images/gno_land_r_gnoswap_v2_gns.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"m8EFPtKVP43F8r/Etgac+bWUhUeLD5EOgHo3/Jy2WPhUb0NFsw0ZJf94rwH38FuZErWL7LNGzHfnO1RO4UOCMg=="}],"memo":""},"blockNum":"3468284"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"SetTokenURI","args":["3","https://github.com/onbloc/gno-token-resource/blob/main/grc20/images/gno_land_r_gnoswap_v2_gns.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"WnSt6pt7YAb32tW+J/ZCOq0IXHIQLCFwUZTFi8My0H8Hrhork1INVhlJEg2LTRP992a0/NW5uX9P9JtR92BbZA=="}],"memo":""},"blockNum":"3468291"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"SetTokenURI","args":["3","github.com/onbloc/gno-token-resource/main/grc/20/images/gno_land_r_gnoswap_v2_gns.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"5w8dhjqbrzYzGmgiCSxS2j0yPvRFqJfU+r+ZAM1Ys7scFJ84s4t0dTFIhidyZbPgZhA+U3VPXdrYpbFW9daWcA=="}],"memo":""},"blockNum":"3468648"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"SetTokenURI","args":["3","https://raw.githubusercontent.com/onbloc/gno-token-resource/refs/heads/main/grc20/images/gno_land_r_gnoswap_v2_gns.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"pND1IXuML61Jb6m/Robdo3FUaO56mo9znSikqrZrDbwd7zBC9Wh3Rp9dnfVlf5Ih6fCGuYybnxLWQYypkZRdyA=="}],"memo":""},"blockNum":"3468657"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"TransferFrom","args":["g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh","g105mv9pq5uqzfm82vj5caef0s2ddxxa88ha3fa4","3"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ak7LWjvpaRSZUOrlc6qO1uZxC/xFV/ql3tnkqp5Kstkf"},"signature":"WNbm7tZGvbxrLLlUXUAKZ3H7ahi30gSzYPOCDiCkxCIHQM8Xy6S013eUsKeGL0l+9TUpIaxjBRYMdPTbFLZxMA=="}],"memo":""},"blockNum":"3468702"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13qpel38unrma0nyrj29tr903pq7dpeecsmlu8z","send":"","pkg_path":"gno.land/r/keyboard_worrier/popo_nft","func":"SetTokenURI","args":["0","https://raw.githubusercontent.com/onbloc/gno-token-resource/refs/heads/main/grc20/images/gno_land_r_gnoswap_v2_gns.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7HxlAX2DyCuLEaoq+Ru7GKb+u6LqdUhclakS27Jnmwd"},"signature":"vcLwCNqwVKYZ0L4NMnNlYwA3HKfRMeblwa9nMBN8SzgnbosCd5FG4Z2yeUVZHNDgkj5tEQ/yAgsUGeE2awE/JA=="}],"memo":""},"blockNum":"3468985"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/keyboard_worrier/popo_nft","func":"SetTokenURI","args":["10","https://raw.githubusercontent.com/onbloc/gno-token-resource/refs/heads/main/grc20/images/gno_land_r_gnoswap_v2_gns.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"2hA5GBneNFIMyb7DxKN0Dv2adlycshSdLO7mySmZjWg97Ck8NMsgv+CqPgoH1KRGgj4yY9emLI6Td7mIIxKkdg=="}],"memo":""},"blockNum":"3469050"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g17shnq82dqlcffexqw8r678ezwl4cj4s97x6dew","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"5s/MpQM/ek0UqRrGiPiDZEgjvwqWqZgRrg5eWJA9olJqayREt3eRteKQ31zT7kvIYwKZbe0B1XfeH7snrVRLsg=="}],"memo":""},"blockNum":"3469991"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17shnq82dqlcffexqw8r678ezwl4cj4s97x6dew","package":{"name":"hello","path":"gno.land/r/g17shnq82dqlcffexqw8r678ezwl4cj4s97x6dew/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Apo7njStKGSZP5lul6RsMIAt170/li7h/cS10IOjwj+4"},"signature":"kUrt8lUOeMFIWu3xGI9vfJlryx0MlMKvip1u6ZWqgpFB22fpEJ+InGBVor1omQlBtrM1uhzZsLCj655bdXbs3g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3469994"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1smpacl27vcg7x4ysl949u86qazsf0e05qsum6e","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"5qZjoTCrXcghm9nqhqPiduZwxxC2B0lZU9PXn7iKacAAMP/dk1JbuBt64wQ+jFMp802VOInB3CYBOTl9+Ds/Fw=="}],"memo":""},"blockNum":"3472239"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"nk7Hl/u9t6aTkKYPYQxEJsUSPoJ8WhWGCGB3t3pcFtwL/N1id6XG5CNG9IAbEXa7H1ZgDxCyDsD6NjdPzfUoTw=="}],"memo":""},"blockNum":"3472471"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g105mv9pq5uqzfm82vj5caef0s2ddxxa88ha3fa4","send":"","pkg_path":"gno.land/r/g1uuchdac3z7u4m3j3dj6xeph00078u4x5aca5jh/nft_test","func":"TransferFrom","args":["g105mv9pq5uqzfm82vj5caef0s2ddxxa88ha3fa4","g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","3"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxzsvgFPTJgTy9g9aljnm6axA37a6azzEEIXuIsAT1+u"},"signature":"K6R+tOwRtEPQqHuJwjbkLkdCxMl2XrmSnNxLtmuvsa1aS+NSrnNKkeD9b7O2X/ppAWwyvooQQ+izumSLTOA/tg=="}],"memo":""},"blockNum":"3472480"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","package":{"name":"nft_foo","path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/nft_foo","files":[{"name":"basic_nft.gno","body":"package nft_foo\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package nft_foo\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package nft_foo\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"nft_foo.gno","body":"package nft_foo\n\nimport (\n\t\"std\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu\"\n\tnft_foo              = NewNFTWithMetadata(\"nft_foo\", \"FOO\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := nft_foo.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := nft_foo.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn nft_foo.Name()\n}\n\nfunc Symbol() string {\n\treturn nft_foo.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := nft_foo.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := nft_foo.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := nft_foo.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn nft_foo.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := nft_foo.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := nft_foo.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := nft_foo.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := nft_foo.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := nft_foo.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := nft_foo.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := nft_foo.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := nft_foo.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Value1\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Value2\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Face\",\n\t\tValue:       \"Value3\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Background\",\n\t\tValue:       \"Value4\",\n\t})\n\n\tnft_foo.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"nft_foo\",\n\t\tDescription:     \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam nec purus nec nunc tincidunt ultricies. Nullam nec purus nec nunc tincidunt ultricies.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    nft_foo.SetTokenURI(tid, \"https://i.namu.wiki/i/yRO1u5KjySi1CtJmt6TQMIqcbXiejx7Tr-OTMv419lYLiCZYBClOxwBY2n0nz06W-9WFg9-tV2DWWPyWZh-PlOb_c1jF7P69_EAOSLuy8cUq3BOVd4o3FniIdckuWGVQFX2s-_m_XBTAMDepZ240eg.webp\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn nft_foo.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"type.gno","body":"package nft_foo\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package nft_foo\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"QHOAx+Ur5bwaxapjKBC8iKl1LrDOFEClcQABECR/UedDnSL4Xp95M1CBQpFYEYy/6fW62xmJI5DFMo+MDOsRUQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3472670"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/nft_foo","func":"Mint","args":["g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","0"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"GuuLqF0/i71gBVTTRTTqrMOfotoLAOQhGlKxQw5idsYKvy8NcoJaG+Sq9/mFDdFdDNx+cFlt0ODJl83YpzLU8w=="}],"memo":""},"blockNum":"3472741"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","package":{"name":"usdc","path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/usdc","files":[{"name":"basic_nft.gno","body":"package usdc\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package usdc\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package usdc\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"nft_foo.gno","body":"package usdc\n\nimport (\n\t\"std\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu\"\n\tusdc              = NewNFTWithMetadata(\"usdc\", \"usdc\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := usdc.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := usdc.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn usdc.Name()\n}\n\nfunc Symbol() string {\n\treturn usdc.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := usdc.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := usdc.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := usdc.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn usdc.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := usdc.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := usdc.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := usdc.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := usdc.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := usdc.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := usdc.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := usdc.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := usdc.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type1\",\n\t\tValue:       \"Value1\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Typ3\",\n\t\tValue:       \"Value2\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type3\",\n\t\tValue:       \"Value3\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type4\",\n\t\tValue:       \"Value4\",\n\t})\n\n\tusdc.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"usdc\",\n\t\tDescription:     \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam nec purus nec nunc tincidunt ultricies. Nullam nec purus nec nunc tincidunt ultricies.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    usdc.SetTokenURI(tid, \"https://github.com/onbloc/gno-token-resource/blob/main/grc20/images/gno_land_r_onbloc_usdc.svg\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn usdc.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"type.gno","body":"package usdc\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package usdc\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"Mi9xSTUwFXGpWP07QjcujlF8081rWJ5zZeic0vBL9wZPz1lAMXav5Cnj2oRJ6ZLJKsjVIsIB5QHB2kmfcnSuKQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3472833"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/usdc","func":"Mint","args":["g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","0,1,2,3"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"Ng5PYHJ7zAUiUtWnqoacJQ81IMRGnLAUob8wKRe3V18T9Vj1F+KCMJSRWnTUWRK711oPRC7N/1rHtoxBLorYvQ=="}],"memo":""},"blockNum":"3472876"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/usdc","func":"SetTokenURI","args":["0","https://github.com/onbloc/gno-token-resource/blob/main/grc20/images/gno_land_r_onbloc_usdc.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"Nqu48T+j6JnIwzoZQdFi55lycgk6R/u9c+WRwEx58LBZsSHosY3vZQXaYbMSOcClnznSJW/lw17JJBHCc83BWg=="}],"memo":""},"blockNum":"3472932"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/usdc","func":"SetTokenURI","args":["0,1,2,3","https://github.com/onbloc/gno-token-resource/blob/main/grc20/images/gno_land_r_onbloc_usdc.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"Oa+WTZb3B0wGtRdlpVsfYmoOKJQ4owhC8pGqFEW/WkVg7Lw32yiFonVebUmZ5gc2ijgFzotzhqmbvRcKLENiyA=="}],"memo":""},"blockNum":"3472945"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/usdc","func":"SetTokenURI","args":["0,1,2,3","https://raw.githubusercontent.com/onbloc/gno-token-resource/refs/heads/main/grc20/images/gno_land_r_onbloc_usdc.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"U7PaY8u7kL7wG+SJsSFh8eJyO9nbl+6hKY8j1S2Bws9l6e0AtEv4xSAbU2tUy4+jP2lm/Mg8tdylN/D10Hxz+Q=="}],"memo":""},"blockNum":"3473011"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Transfer","args":["g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","10000000000"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"TGP4/5zVdZdYwfZsFQHgFUpzWvL7Sv9F40/VyG1ZAplGkGOq8f41F2b9Tj12UGMAHM2ahRko4J5wfSMuMWXIRQ=="}],"memo":""},"blockNum":"3473238"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/usdc","func":"SetTokenURI","args":["0","https://raw.githubusercontent.com/onbloc/gno-token-resource/refs/heads/main/grc20/images/gno_land_r_onbloc_usdc.svg"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"xwrD7u+Vin8B+o0BPcO01W3ZQeLKZMFwNPz/b5SFNF0iA8T85g6Vd/rHt3A7rw+i2ih7xlc76Gh9NmXMaqsT4Q=="}],"memo":""},"blockNum":"3474233"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","package":{"name":"gno_nft_test","path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/gno_nft_test","files":[{"name":"basic_nft.gno","body":"package gno_nft_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package gno_nft_test\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"gno_nft_test.gno","body":"package gno_nft_test\n\nimport (\n\t\"std\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu\"\n\tgno_nft_test              = NewNFTWithMetadata(\"gno_nft_test\", \"GNT\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := gno_nft_test.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := gno_nft_test.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn gno_nft_test.Name()\n}\n\nfunc Symbol() string {\n\treturn gno_nft_test.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := gno_nft_test.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := gno_nft_test.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := gno_nft_test.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn gno_nft_test.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := gno_nft_test.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := gno_nft_test.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := gno_nft_test.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := gno_nft_test.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := gno_nft_test.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := gno_nft_test.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := gno_nft_test.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := gno_nft_test.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type1\",\n\t\tValue:       \"Value1\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type2\",\n\t\tValue:       \"Value2\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type3\",\n\t\tValue:       \"Value3\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type4\",\n\t\tValue:       \"Value4\",\n\t})\n\n\tgno_nft_test.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"gno_nft_test\",\n\t\tDescription:     \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam nec purus nec nunc tincidunt ultricies. Nullam nec purus nec nunc tincidunt ultricies.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    gno_nft_test.SetTokenURI(tid, \"https://raw.githubusercontent.com/gnolang/branding/3de1fcff368df228d46b87ec476a3e1485e145c9/svg/Logo%20Short%20On%20Black%20Background.svg\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn gno_nft_test.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"grc721_metadata.gno","body":"package gno_nft_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"type.gno","body":"package gno_nft_test\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package gno_nft_test\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"uLJWlWf9Ru5njfZ14vte3anFjes2VY7myceFH8NF36w8NoxYTTnqG8oI6Wtf74rgHnY8AfAFOKhbh0B1/zGTsg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3474621"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/gno_nft_test","func":"Mint","args":["g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","0"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"Nf/t9fIUH/O06NnSffEYAA+e5QB6JYcalaFJH4Jzevt50GDZCKjmldSN50CWt+kHK+dV6sLaODh4/Fi2l7zQHA=="}],"memo":""},"blockNum":"3474641"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/gno_nft_test","func":"Mint","args":["g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","0"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"Tp5L1UHMxfBLBZ5XmgJtj66V5k9G5J6PPPasMa2fwb1Le22MbzMzDUuXWdj9M3zO/FOpqS82FRj2kP05UiMWqg=="}],"memo":""},"blockNum":"3474669"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/gno_nft_test","func":"Mint","args":["g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","1"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"33MO51nnmOlPvqy7ZgBjHG0wlwQytzuaPNwKkmHKzj59fPKrgCAnmawHLTPIVhD4FsD7Z8S6Dm10snmad4cSDQ=="}],"memo":""},"blockNum":"3474673"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","package":{"name":"grc721_test","path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/grc721_test","files":[{"name":"basic_nft.gno","body":"package grc721_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721_test\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"gno_nft_test.gno","body":"package grc721_test\n\nimport (\n\t\"std\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu\"\n\tgrc721_test              = NewNFTWithMetadata(\"grc721_test\", \"GNT\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := grc721_test.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := grc721_test.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn grc721_test.Name()\n}\n\nfunc Symbol() string {\n\treturn grc721_test.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := grc721_test.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := grc721_test.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := grc721_test.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn grc721_test.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := grc721_test.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := grc721_test.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := grc721_test.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := grc721_test.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := grc721_test.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := grc721_test.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := grc721_test.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := grc721_test.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type1\",\n\t\tValue:       \"Value1\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type2\",\n\t\tValue:       \"Value2\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type3\",\n\t\tValue:       \"Value3\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Type4\",\n\t\tValue:       \"Value4\",\n\t})\n\n\tgrc721_test.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"grc721_test\",\n\t\tDescription:     \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam nec purus nec nunc tincidunt ultricies. Nullam nec purus nec nunc tincidunt ultricies.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    grc721_test.SetTokenURI(tid, \"https://raw.githubusercontent.com/gnolang/branding/3de1fcff368df228d46b87ec476a3e1485e145c9/svg/Logo%20Short%20On%20Black%20Background.svg\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn grc721_test.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"type.gno","body":"package grc721_test\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package grc721_test\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"DkEsaC6nUowhAZVXpqSE0q8OAmOxz1ENvq0kTy0KFppITokY/DNbnYw/x8083duBFL7gurwrvYpkrYypnKVC1A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3474752"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","package":{"name":"obl","path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/obl","files":[{"name":"basic_nft.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package blackcows_nft\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"obl.gno","body":"package obl\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu\"\n\tobl              = NewNFTWithMetadata(\"obl\", \"OBL\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := obl.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := obl.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn obl.Name()\n}\n\nfunc Symbol() string {\n\treturn obl.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := obl.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := obl.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := obl.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn obl.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := obl.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := obl.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := obl.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := obl.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := obl.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := obl.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := obl.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := obl.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Alien\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Police Uniform\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Face\",\n\t\tValue:       \"Handsome\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Background\",\n\t\tValue:       \"Very extremely red\",\n\t})\n\n\tobl.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"obl\",\n\t\tDescription:     \"A GnoPunk is a 24x24 pixel, 8-bit-style unique avatar that comes in the form of an NFT. Their creation began as an experiment, conducted by software developers Matt Hall and John Watkinson in 2017.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    obl.SetTokenURI(tid, \"https://raw.githubusercontent.com/gnolang/branding/3de1fcff368df228d46b87ec476a3e1485e145c9/svg/Logo%20Short%20On%20Black%20Background.svg\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn obl.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"type.gno","body":"package blackcows_nft\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package blackcows_nft\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"bWxTvcid8Omu+8LVNcuFQfeZXuMmbXyoeY/PekFoo4wWcZuaoBFaak99zuTSXDvZ6ZZTTNEF0hCco/xnk251Lg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3475016"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","package":{"name":"obl","path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/obl","files":[{"name":"basic_nft.gno","body":"package obl\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid grc721.TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid grc721.TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) (bool, error) {\n\t// check for invalid grc721.TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid grc721.TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid grc721.TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid grc721.TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid grc721.TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid grc721.TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", owner.String(),\n\t\t\"to\", zeroAddress.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tstd.Emit(\n\t\tApprovalForAllEvent,\n\t\t\"owner\", owner.String(),\n\t\t\"to\", operator.String(),\n\t\t\"approved\", ufmt.Sprintf(\"%t\", approved),\n\t)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid grc721.TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", zeroAddress.String(),\n\t\t\"to\", to.String(),\n\t\t\"tid\", string(tid),\n\t)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid grc721.TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid grc721.TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId grc721.TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid grc721.TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package obl\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package obl\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid grc721.TokenID, metadata grc721.Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid grc721.TokenID) (grc721.Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn grc721.Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(grc721.Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid grc721.TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\ts.basicNFT.Mint(to, tid)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"obl.gno","body":"package obl\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu\"\n\tobl              = NewNFTWithMetadata(\"obl\", \"OBL\")\n)\n\nfunc init() {\n}\n\nfunc mintNFT(owner std.Address, n uint64) {\n\tcount := obl.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\terr := mint(owner, tid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := obl.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc Name() string {\n\treturn obl.Name()\n}\n\nfunc Symbol() string {\n\treturn obl.Symbol()\n}\n\nfunc TokenURI(tid grc721.TokenID) string {\n\ttokenURI, err := obl.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn tokenURI\n}\n\nfunc TokenMetadata(tid grc721.TokenID) string {\n\tmetadata, err := obl.TokenMetadata(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmetadataNode := json.ObjectNode(\"\", nil)\n\n\tmetadataNode.AppendObject(\"image\", json.StringNode(\"image\", metadata.Image))\n\tmetadataNode.AppendObject(\"imageData\", json.StringNode(\"imageData\", metadata.ImageData))\n\tmetadataNode.AppendObject(\"externalUrl\", json.StringNode(\"externalUrl\", metadata.ExternalURL))\n\tmetadataNode.AppendObject(\"description\", json.StringNode(\"description\", metadata.Description))\n\tmetadataNode.AppendObject(\"name\", json.StringNode(\"name\", metadata.Name))\n\tmetadataNode.AppendObject(\"backgroundColor\", json.StringNode(\"backgroundColor\", metadata.BackgroundColor))\n\tmetadataNode.AppendObject(\"animationUrl\", json.StringNode(\"animationUrl\", metadata.AnimationURL))\n\tmetadataNode.AppendObject(\"youtubeUrl\", json.StringNode(\"youtubeUrl\", metadata.YoutubeURL))\n\n\tattributesNode := json.ArrayNode(\"attributes\", nil)\n\n\tfor _, trait := range metadata.Attributes {\n\t\ttraitNode := json.ObjectNode(\"\", nil)\n\t\ttraitNode.AppendObject(\"displayType\", json.StringNode(\"displayType\", trait.DisplayType))\n\t\ttraitNode.AppendObject(\"traitType\", json.StringNode(\"traitType\", trait.TraitType))\n\t\ttraitNode.AppendObject(\"value\", json.StringNode(\"value\", trait.Value))\n\n\t\tattributesNode.AppendArray(traitNode)\n\t}\n\n\tmetadataNode.AppendObject(\"attributes\", attributesNode)\n\n\tmetadataStr, err := json.Marshal(metadataNode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(metadataStr)\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := obl.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn obl.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := obl.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := obl.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := obl.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SafeTransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := obl.SafeTransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := obl.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetTokenURI(tid grc721.TokenID, tURI grc721.TokenURI) bool {\n\tresult, err := obl.SetTokenURI(tid, tURI)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}\n\n// Admin\n\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := obl.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mint(to std.Address, tid grc721.TokenID) error {\n\terr := obl.Mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tattributes := []grc721.Trait{}\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Alien\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Race\",\n\t\tValue:       \"Police Uniform\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Face\",\n\t\tValue:       \"Handsome\",\n\t})\n\tattributes = append(attributes, grc721.Trait{\n\t\tDisplayType: \"string\",\n\t\tTraitType:   \"Background\",\n\t\tValue:       \"Very extremely red\",\n\t})\n\n\tobl.SetTokenMetadata(tid, grc721.Metadata{\n\t\tName:            \"obl\",\n\t\tDescription:     \"A GnoPunk is a 24x24 pixel, 8-bit-style unique avatar that comes in the form of an NFT. Their creation began as an experiment, conducted by software developers Matt Hall and John Watkinson in 2017.\",\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: \"#FFFF00\",\n\t})\n\n    obl.SetTokenURI(tid, \"https://raw.githubusercontent.com/gnolang/branding/3de1fcff368df228d46b87ec476a3e1485e145c9/svg/Logo%20Short%20On%20Black%20Background.svg\")\n\n\treturn nil\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn obl.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"},{"name":"type.gno","body":"package obl\n\nconst (\n\tTransferEvent       = \"Transfer\"\n\tApprovalEvent       = \"Approval\"\n\tApprovalForAllEvent = \"ApprovalForAll\"\n)\n"},{"name":"utils.gno","body":"package obl\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"rTMMHiiAMwZcSMDOVBdOqaMez4rR5efcjG61Qpp6ZyQP1cHxEbVJHWsezRcFvVH5dRSF9XeCJXUvW7dAT7cjiQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"3475026"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","send":"","pkg_path":"gno.land/r/g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu/obl","func":"Mint","args":["g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","0"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AiCN43E1Hz0zqozrCrZ3DuZciibbL42+Xdm20I+Bs8Dp"},"signature":"Cz1WhnwmG21daXftD4BR+fmsGG6hURzR1W83D04a65kXJXa1JfQllmqkUdbRu2X0CKW0kwcbCYIPGg0p4tp0Yg=="}],"memo":""},"blockNum":"3475067"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Transfer","args":["g1t9r79z4v4572m6aj2eydj2vs26qjmug8nes4mu","1000000000"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"SkKFOfS7cGhgz6bHs4ZLJJ12osHeWnphV6p25SWjl9N/7t7t9fyreJ2o39M92iKB72Q8lj51KEHqcn0leTWAJw=="}],"memo":""},"blockNum":"3475178"}
