{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"10000000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/gns","10000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/gnoswap/gns:3000","100","2247034"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj1KBG+vwcSyYwukTMGJ9A9ZjwCBthDNYkNiuPXLIy2C"},"signature":"ZbUJTsWVatRO2qkz59M20PJ/kdxfsIkN84NNd64wW09Oz6luvl5yx/ooaxcDRCkCpnMRTfS9uGCUvuYViXFebA=="}],"memo":""},"blockNum":"210075"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"9000000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/gns","9000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/gnoswap/gns:3000","100","2022332"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj1KBG+vwcSyYwukTMGJ9A9ZjwCBthDNYkNiuPXLIy2C"},"signature":"v+zYJDo9dqN2Pp/TtRiZo5Ej48VquweDXsXnTMnc5MtDyB4/proRtPDJQDyow5m50Uri8N875ycngcn8yA/t/g=="}],"memo":""},"blockNum":"210094"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","990000"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","212321"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1y3uyaa63sjxvah2cx3c2usavwvx97kl8m2v7ye","990000"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"990000ugnot","pkg_path":"gno.land/r/gnoswap/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/gns","3000","-22320","-8460","990000","212321","985050","211259","7282571140","g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67"]},{"@type":"/vm.m_call","caller":"g1pf4egmg5zshcmsysd84htvjxsn6t75pdd20r67","send":"","pkg_path":"gno.land/r/gnoswap/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aj1KBG+vwcSyYwukTMGJ9A9ZjwCBthDNYkNiuPXLIy2C"},"signature":"xyhUTCBE5xOR4vo6GGYH5OZ+qPXy7KiLKHWZSDUmbN49wZgBD8q2MlhIMxBQquB+Elqktl6DFQfxrwCPlF5agQ=="}],"memo":""},"blockNum":"210117"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1m5qy5ag36qgt2kmdjptadd7dglw5cq3e0adper","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"qlAGuR74qdrzFXW+AYQHEu05gPWNxgnpVA9J240zzTYY1dQMlV6+9l3Mdz2tVQJO72w7sk56ZtLXSHJj/ulTFg=="}],"memo":""},"blockNum":"210253"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"UMM56RUmnCWGi8PBpzK708kEG8LpvXPYzVcwBrx4ckRQCmVPLqToinSPIkhXfY3fToc1111fsC9h3DaOwOETVQ=="}],"memo":""},"blockNum":"210341"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","package":{"name":"vmt","path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt","files":[{"name":"banker.gno","body":"package grc20\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// Banker implements a token banker with admin privileges.\n//\n// The Banker is intended to be used in two main ways:\n//  1. as a temporary object used to make the initial minting, then deleted.\n//  2. preserved in an unexported variable to support conditional administrative\n//     tasks protected by the contract.\ntype Banker struct {\n\tname        string\n\tsymbol      string\n\tdecimals    uint\n\ttotalSupply uint64\n\tbalances    avl.Tree // std.Address(owner) -\u003e uint64\n\tallowances  avl.Tree // string(owner+\":\"+spender) -\u003e uint64\n\ttoken       *token   // to share the same pointer\n}\n\nfunc NewBanker(name, symbol string, decimals uint) *Banker {\n\tif name == \"\" {\n\t\tpanic(\"name should not be empty\")\n\t}\n\tif symbol == \"\" {\n\t\tpanic(\"symbol should not be empty\")\n\t}\n\t// XXX additional checks (length, characters, limits, etc)\n\n\tb := Banker{\n\t\tname:     name,\n\t\tsymbol:   symbol,\n\t\tdecimals: decimals,\n\t}\n\tt := \u0026token{banker: \u0026b}\n\tb.token = t\n\treturn \u0026b\n}\n\nfunc (b Banker) Token() Token        { return b.token } // Token returns a grc20 safe-object implementation.\nfunc (b Banker) GetName() string     { return b.name }\nfunc (b Banker) GetSymbol() string   { return b.symbol }\nfunc (b Banker) GetDecimals() uint   { return b.decimals }\nfunc (b Banker) TotalSupply() uint64 { return b.totalSupply }\nfunc (b Banker) KnownAccounts() int  { return b.balances.Size() }\n\nfunc (b *Banker) Mint(address std.Address, amount uint64) error {\n\tif !address.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\n\t// TODO: check for overflow\n\n\tb.totalSupply += amount\n\tcurrentBalance := b.BalanceOf(address)\n\tnewBalance := currentBalance + amount\n\n\tb.balances.Set(string(address), newBalance)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", \"\",\n\t\t\"to\", string(address),\n\t\t\"value\", strconv.Itoa(int(amount)),\n\t)\n\n\treturn nil\n}\n\nfunc (b *Banker) Burn(address std.Address, amount uint64) error {\n\tif !address.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\t// TODO: check for overflow\n\n\tcurrentBalance := b.BalanceOf(address)\n\tif currentBalance \u003c amount {\n\t\treturn ErrInsufficientBalance\n\t}\n\n\tb.totalSupply -= amount\n\tnewBalance := currentBalance - amount\n\n\tb.balances.Set(string(address), newBalance)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", string(address),\n\t\t\"to\", \"\",\n\t\t\"value\", strconv.Itoa(int(amount)),\n\t)\n\n\treturn nil\n}\n\nfunc (b Banker) BalanceOf(address std.Address) uint64 {\n\tbalance, found := b.balances.Get(address.String())\n\tif !found {\n\t\treturn 0\n\t}\n\treturn balance.(uint64)\n}\n\nfunc (b *Banker) SpendAllowance(owner, spender std.Address, amount uint64) error {\n\tif !owner.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\tif !spender.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcurrentAllowance := b.Allowance(owner, spender)\n\tif currentAllowance \u003c amount {\n\t\treturn ErrInsufficientAllowance\n\t}\n\n\tkey := allowanceKey(owner, spender)\n\tnewAllowance := currentAllowance - amount\n\n\tif newAllowance == 0 {\n\t\tb.allowances.Remove(key)\n\t} else {\n\t\tb.allowances.Set(key, newAllowance)\n\t}\n\n\treturn nil\n}\n\nfunc (b *Banker) Transfer(from, to std.Address, amount uint64) error {\n\tif !from.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\tif !to.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\ttoBalance := b.BalanceOf(to)\n\tfromBalance := b.BalanceOf(from)\n\n\t// debug.\n\t// println(\"from\", from, \"to\", to, \"amount\", amount, \"fromBalance\", fromBalance, \"toBalance\", toBalance)\n\n\tif fromBalance \u003c amount {\n\t\treturn ErrInsufficientBalance\n\t}\n\n\tnewToBalance := toBalance + amount\n\tnewFromBalance := fromBalance - amount\n\n\tb.balances.Set(string(to), newToBalance)\n\tb.balances.Set(string(from), newFromBalance)\n\n\tstd.Emit(\n\t\tTransferEvent,\n\t\t\"from\", from.String(),\n\t\t\"to\", to.String(),\n\t\t\"value\", strconv.Itoa(int(amount)),\n\t)\n\treturn nil\n}\n\nfunc (b *Banker) TransferFrom(spender, from, to std.Address, amount uint64) error {\n\tif err := b.SpendAllowance(from, spender, amount); err != nil {\n\t\treturn err\n\t}\n\treturn b.Transfer(from, to, amount)\n}\n\nfunc (b *Banker) Allowance(owner, spender std.Address) uint64 {\n\tallowance, found := b.allowances.Get(allowanceKey(owner, spender))\n\tif !found {\n\t\treturn 0\n\t}\n\treturn allowance.(uint64)\n}\n\nfunc (b *Banker) Approve(owner, spender std.Address, amount uint64) error {\n\tif !owner.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\tif !spender.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tb.allowances.Set(allowanceKey(owner, spender), amount)\n\n\tstd.Emit(\n\t\tApprovalEvent,\n\t\t\"owner\", string(owner),\n\t\t\"spender\", string(spender),\n\t\t\"value\", strconv.Itoa(int(amount)),\n\t)\n\n\treturn nil\n}\n\nfunc (b *Banker) RenderHome() string {\n\tstr := \"\"\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", b.name, b.symbol)\n\tstr += ufmt.Sprintf(\"* **Decimals**: %d\\n\", b.decimals)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", b.totalSupply)\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", b.KnownAccounts())\n\treturn str\n}\n\nfunc allowanceKey(owner, spender std.Address) string {\n\treturn owner.String() + \":\" + spender.String()\n}\n"},{"name":"token.gno","body":"package grc20\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/exts\"\n)\n\n// token implements the Token interface.\n//\n// It is generated with Banker.Token().\n// It can safely be explosed publicly.\ntype token struct {\n\tbanker *Banker\n}\n\n// var _ Token = (*token)(nil)\nfunc (t *token) GetName() string     { return t.banker.name }\nfunc (t *token) GetSymbol() string   { return t.banker.symbol }\nfunc (t *token) GetDecimals() uint   { return t.banker.decimals }\nfunc (t *token) TotalSupply() uint64 { return t.banker.totalSupply }\n\nfunc (t *token) BalanceOf(owner std.Address) uint64 {\n\treturn t.banker.BalanceOf(owner)\n}\n\nfunc (t *token) Transfer(to std.Address, amount uint64) error {\n\tcaller := std.PrevRealm().Addr()\n\treturn t.banker.Transfer(caller, to, amount)\n}\n\nfunc (t *token) Allowance(owner, spender std.Address) uint64 {\n\treturn t.banker.Allowance(owner, spender)\n}\n\nfunc (t *token) Approve(spender std.Address, amount uint64) error {\n\tcaller := std.PrevRealm().Addr()\n\treturn t.banker.Approve(caller, spender, amount)\n}\n\nfunc (t *token) TransferFrom(from, to std.Address, amount uint64) error {\n\tspender := std.PrevRealm().Addr()\n\tif err := t.banker.SpendAllowance(from, spender, amount); err != nil {\n\t\treturn err\n\t}\n\treturn t.banker.Transfer(from, to, amount)\n}\n\ntype Token2 interface {\n\texts.TokenMetadata\n\n\t// Returns the amount of tokens in existence.\n\tTotalSupply() uint64\n\n\t// Returns the amount of tokens owned by `account`.\n\tBalanceOf(account std.Address) uint64\n\n\t// Moves `amount` tokens from the caller's account to `to`.\n\t//\n\t// Returns an error if the operation failed.\n\tTransfer(to std.Address, amount uint64) error\n\n\t// Returns the remaining number of tokens that `spender` will be\n\t// allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t// zero by default.\n\t//\n\t// This value changes when {approve} or {transferFrom} are called.\n\tAllowance(owner, spender std.Address) uint64\n\n\t// Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t//\n\t// Returns an error if the operation failed.\n\t//\n\t// IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t// that someone may use both the old and the new allowance by unfortunate\n\t// transaction ordering. One possible solution to mitigate this race\n\t// condition is to first reduce the spender's allowance to 0 and set the\n\t// desired value afterwards:\n\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\tApprove(spender std.Address, amount uint64) error\n\n\t// Moves `amount` tokens from `from` to `to` using the\n\t// allowance mechanism. `amount` is then deducted from the caller's\n\t// allowance.\n\t//\n\t// Returns an error if the operation failed.\n\tTransferFrom(from, to std.Address, amount uint64) error\n}\n"},{"name":"types.gno","body":"package grc20\n\nimport (\n\t\"errors\"\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/exts\"\n)\n\nvar (\n\tErrInsufficientBalance   = errors.New(\"insufficient balance\")\n\tErrInsufficientAllowance = errors.New(\"insufficient allowance\")\n\tErrInvalidAddress        = errors.New(\"invalid address\")\n\tErrCannotTransferToSelf  = errors.New(\"cannot send transfer to self\")\n)\n\ntype Token interface {\n\texts.TokenMetadata\n\n\t// Returns the amount of tokens in existence.\n\tTotalSupply() uint64\n\n\t// Returns the amount of tokens owned by `account`.\n\tBalanceOf(account std.Address) uint64\n\n\t// Moves `amount` tokens from the caller's account to `to`.\n\t//\n\t// Returns an error if the operation failed.\n\tTransfer(to std.Address, amount uint64) error\n\n\t// Returns the remaining number of tokens that `spender` will be\n\t// allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t// zero by default.\n\t//\n\t// This value changes when {approve} or {transferFrom} are called.\n\tAllowance(owner, spender std.Address) uint64\n\n\t// Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t//\n\t// Returns an error if the operation failed.\n\t//\n\t// IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t// that someone may use both the old and the new allowance by unfortunate\n\t// transaction ordering. One possible solution to mitigate this race\n\t// condition is to first reduce the spender's allowance to 0 and set the\n\t// desired value afterwards:\n\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\tApprove(spender std.Address, amount uint64) error\n\n\t// Moves `amount` tokens from `from` to `to` using the\n\t// allowance mechanism. `amount` is then deducted from the caller's\n\t// allowance.\n\t//\n\t// Returns an error if the operation failed.\n\tTransferFrom(from, to std.Address, amount uint64) error\n}\n\nconst (\n\tTransferEvent = \"Transfer\"\n\tApprovalEvent = \"Approval\"\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"Y0Z+E9qpyJ2dYI05hTVzw14nlR59Bxzl+csXKWCZ9BwVXsRO39nW0K2b8UI+esNcjj/aNsVdTTM8fAHfyZI2hQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"210393"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","package":{"name":"vmt","path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt","files":[{"name":"foo20.gno","body":"// foo20 is a GRC20 token contract where all the GRC20 methods are proxified\n// with top-level functions. see also gno.land/r/demo/bar20.\npackage foo20\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbanker *grc20.Banker\n\tadmin  *ownable.Ownable\n\ttoken  grc20.Token\n)\n\nfunc init() {\n\tadmin = ownable.NewWithAddress(\"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8\")\n\tbanker = grc20.NewBanker(\"Varmeta\", \"VMT\", 4)\n\tbanker.Mint(admin.Owner(), 1000000*10000) // @administrator (1M)\n\ttoken = banker.Token()\n}\n\nfunc TotalSupply() uint64 { return token.TotalSupply() }\n\nfunc BalanceOf(owner pusers.AddressOrName) uint64 {\n\townerAddr := users.Resolve(owner)\n\treturn token.BalanceOf(ownerAddr)\n}\n\nfunc Allowance(owner, spender pusers.AddressOrName) uint64 {\n\townerAddr := users.Resolve(owner)\n\tspenderAddr := users.Resolve(spender)\n\treturn token.Allowance(ownerAddr, spenderAddr)\n}\n\nfunc Transfer(to pusers.AddressOrName, amount uint64) {\n\ttoAddr := users.Resolve(to)\n\tcheckErr(token.Transfer(toAddr, amount))\n}\n\nfunc Approve(spender pusers.AddressOrName, amount uint64) {\n\tspenderAddr := users.Resolve(spender)\n\tcheckErr(token.Approve(spenderAddr, amount))\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, amount uint64) {\n\tfromAddr := users.Resolve(from)\n\ttoAddr := users.Resolve(to)\n\tcheckErr(token.TransferFrom(fromAddr, toAddr, amount))\n}\n\n// Faucet is distributing foo20 tokens without restriction (unsafe).\n// For a real token faucet, you should take care of setting limits are asking payment.\nfunc Faucet() {\n\tcaller := std.PrevRealm().Addr()\n\tamount := uint64(1_000 * 10_000) // 1k\n\tcheckErr(banker.Mint(caller, amount))\n}\n\nfunc Mint(to pusers.AddressOrName, amount uint64) {\n\tadmin.AssertCallerIsOwner()\n\ttoAddr := users.Resolve(to)\n\tcheckErr(banker.Mint(toAddr, amount))\n}\n\nfunc Burn(from pusers.AddressOrName, amount uint64) {\n\tadmin.AssertCallerIsOwner()\n\tfromAddr := users.Resolve(from)\n\tcheckErr(banker.Burn(fromAddr, amount))\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn banker.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := pusers.AddressOrName(parts[1])\n\t\townerAddr := users.Resolve(owner)\n\t\tbalance := banker.BalanceOf(ownerAddr)\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"P8LihhZAvu3pyXgfVYXKJPzZrvmIXrLqFW/7MH5/SI8HN2poP65P/P/LZGNrMo+jdWBxNboqnT7wOB6oUAyLSg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"210452"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1q4aw0vtcydtn7lqmkfprm4ncmr4jdj70dx8zke","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"xkMm4Q2nW0DSj3LDFk5RNriI/qsmYkYv0u1vHb6usPpbPwJm1dxkV8Yk7YW8Ax+kJrNLpDn0d+lEiB8f/OYSNA=="}],"memo":""},"blockNum":"211635"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v","package":{"name":"forms","path":"gno.land/p/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2","files":[{"name":"README.md","body":"# Gno forms\n\ngno-forms is a package which demonstrates a form editing and sharing application in gno\n\n## Features\n- **Form Creation**: Create new forms with specified titles, descriptions, and fields.\n- **Form Submission**: Submit answers to forms.\n- **Form Retrieval**: Retrieve existing forms and their submissions.\n- **Form Deadline**: Set a precise time range during which a form can be interacted with.\n\n## Field Types\nThe system supports the following field types:\n\ntype|example\n-|-\nstring|`{\"label\": \"Name\", \"fieldType\": \"string\", \"required\": true}`\nnumber|`{\"label\": \"Age\", \"fieldType\": \"number\", \"required\": true}`\nboolean|`{\"label\": \"Is Student?\", \"fieldType\": \"boolean\", \"required\": false}`\nchoice|`{\"label\": \"Favorite Food\", \"fieldType\": \"['Pizza', 'Schnitzel', 'Burger']\", \"required\": true}`\nmulti-choice|`{\"label\": \"Hobbies\", \"fieldType\": \"{'Reading', 'Swimming', 'Gaming'}\", \"required\": false}`\n\n## Web-app\n\nThe external repo where the initial development took place and where you can find the frontend is [here](https://github.com/agherasie/gno-forms). "},{"name":"create.gno","body":"package forms\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc CreateField(label string, fieldType string, required bool) Field {\n\treturn Field{\n\t\tLabel:     label,\n\t\tFieldType: fieldType,\n\t\tRequired:  required,\n\t}\n}\n\nfunc ParseDates(openAt string, closeAt string) (*time.Time, *time.Time) {\n\tvar openAtTime, closeAtTime *time.Time\n\n\tdateFormat := \"2006-01-02T15:04:05Z\"\n\n\t// Parse openAt if it's not empty\n\tif openAt != \"\" {\n\t\tres, err := time.Parse(dateFormat, openAt)\n\t\tif err != nil {\n\t\t\tpanic(ufmt.Errorf(\"invalid date: %v\", openAt))\n\t\t}\n\t\topenAtTime = \u0026res\n\t}\n\n\t// Parse closeAt if it's not empty\n\tif closeAt != \"\" {\n\t\tres, err := time.Parse(dateFormat, closeAt)\n\t\tif err != nil {\n\t\t\tpanic(ufmt.Errorf(\"invalid date: %v\", closeAt))\n\t\t}\n\t\tcloseAtTime = \u0026res\n\t}\n\n\treturn openAtTime, closeAtTime\n}\n\nfunc (db *FormDatabase) CreateForm(title string, description string, openAt string, closeAt string, data string) string {\n\t// Parsing dates\n\topenAtTime, closeAtTime := ParseDates(openAt, closeAt)\n\n\t// Parsing the json submission\n\tnode, err := json.Unmarshal([]byte(data))\n\tif err != nil {\n\t\tufmt.Errorf(\"invalid json: %v\", err)\n\t}\n\n\tfieldsCount := node.Size()\n\tfields := make([]Field, fieldsCount)\n\t\n\t// Parsing the json submission to create the gno data structures\n\tfor i := 0; i \u003c fieldsCount; i++ {\n\t\tfield, err := node.GetIndex(i)\n\t\tif err != nil {\n\t\t\tufmt.Errorf(\"error: %v\", err)\n\t\t}\n\n\t\tlabelNode, _ := field.GetKey(\"label\")\n\t\tfieldTypeNode, _ := field.GetKey(\"fieldType\")\n\t\trequiredNode, _ := field.GetKey(\"required\")\n\n\t\tlabel, _ := labelNode.GetString()\n\t\tfieldType, _ := fieldTypeNode.GetString()\n\t\trequired, _ := requiredNode.GetBool()\n\n\t\tfields[i] = CreateField(label, fieldType, required)\n\t}\n\n\t// Generating the form ID\n\tid := db.IDCounter.Next().String()\n\n\t// Creating the form\n\tform := Form{\n\t\tID:          id,\n\t\tOwner:       std.PrevRealm().Addr(),\n\t\tTitle:       title,\n\t\tDescription: description,\n\t\tCreatedAt:   time.Now(),\n\t\topenAt:      openAtTime,\n\t\tcloseAt:     closeAtTime,\n\t\tFields:      fields,\n\t}\n\n\t// Adding the form to the database\n\tdb.Forms = append(db.Forms, \u0026form)\n\n\treturn id\n}\n"},{"name":"create_test.gno","body":"package forms\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestCreateForm(t *testing.T) {\n\talice := testutils.TestAddress(\"alice\")\n\tstd.TestSetOrigCaller(alice)\n\n\ttitle := \"Simple Form\"\n\tdescription := \"This is a form\"\n\topenAt := \"2021-01-01T00:00:00Z\"\n\tcloseAt := \"2021-01-02T00:00:00Z\"\n\tdata := `[\n\t\t{\n\t\t\t\"label\": \"Name\",\n\t\t\t\"fieldType\": \"string\",\n\t\t\t\"required\": true\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Age\",\n\t\t\t\"fieldType\": \"number\",\n\t\t\t\"required\": false\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Is this a test?\",\n\t\t\t\"fieldType\": \"boolean\",\n\t\t\t\"required\": false\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Favorite Food\",\n\t\t\t\"fieldType\": \"['Pizza', 'Schnitzel', 'Burger']\",\n\t\t\t\"required\": true\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Favorite Foods\",\n\t\t\t\"fieldType\": \"{'Pizza', 'Schnitzel', 'Burger'}\",\n\t\t\t\"required\": true\n\t\t}\n\t]`\n\tdb := NewDatabase()\n\tid := db.CreateForm(title, description, openAt, closeAt, data)\n\tif id == \"\" {\n\t\tt.Error(\"Form ID is empty\")\n\t}\n\tform := db.GetForm(id)\n\tif form == nil {\n\t\tt.Error(\"Form is nil\")\n\t}\n\tif form.Owner != alice {\n\t\tt.Error(\"Owner is not correct\")\n\t}\n\tif form.Title != title {\n\t\tt.Error(\"Title is not correct\")\n\t}\n\tif form.Description != description {\n\t\tt.Error(\"Description is not correct\")\n\t}\n\tif len(form.Fields) != 5 {\n\t\tt.Error(\"Fields are not correct\")\n\t}\n\tif form.Fields[0].Label != \"Name\" {\n\t\tt.Error(\"Field 0 label is not correct\")\n\t}\n\tif form.Fields[0].FieldType != \"string\" {\n\t\tt.Error(\"Field 0 type is not correct\")\n\t}\n\tif form.Fields[0].Required != true {\n\t\tt.Error(\"Field 0 required is not correct\")\n\t}\n\tif form.Fields[1].Label != \"Age\" {\n\t\tt.Error(\"Field 1 label is not correct\")\n\t}\n\tif form.Fields[1].FieldType != \"number\" {\n\t\tt.Error(\"Field 1 type is not correct\")\n\t}\n}\n"},{"name":"forms.gno","body":"package forms\n\nimport (\n\t\"std\"\n\t\"time\"\n\t\"errors\"\n\n\t\"gno.land/p/demo/seqid\"\n)\n\ntype Field struct {\n\tLabel string\n\n\t/*\n\t\tstring: \"string\";\n\t\tnumber: \"number\";\n\t\tboolean: \"boolean\";\n\t\tchoice: \"['Pizza', 'Schnitzel', 'Burger']\";\n\t\tmulti-choice: \"{'Pizza', 'Schnitzel', 'Burger'}\";\n\t*/\n\tFieldType string\n\n\tRequired bool\n}\n\ntype Form struct {\n\tID    string\n\tOwner std.Address\n\n\tTitle       string\n\tDescription string\n\tFields      []Field\n\n\tCreatedAt time.Time\n\topenAt    *time.Time\n\tcloseAt   *time.Time\n}\n\ntype Submission struct {\n\tFormID string\n\n\tAuthor std.Address\n\n\t/* [\"Alex\", 21, true, 0, [0, 1]] */\n\tAnswers string // json\n\n\tSubmittedAt time.Time\n}\n\ntype FormDatabase struct {\n\tForms []*Form\n\n\tAnswers []*Submission\n\n\tIDCounter seqid.ID\n}\n\nfunc NewDatabase() *FormDatabase {\n\treturn \u0026FormDatabase{\n\t\tForms:   make([]*Form, 0),\n\t\tAnswers: make([]*Submission, 0),\n\t}\n}\n\nfunc (form *Form) IsOpen() bool {\n\topenAt, errOpen := form.OpenAt()\n\tclosedAt, errClose := form.CloseAt()\n\n\tnoOpenDate := errOpen != nil\n\tnoCloseDate := errClose != nil\n\n\tif noOpenDate \u0026\u0026 noCloseDate {\n\t\treturn true\n\t}\n\n\tif noOpenDate \u0026\u0026 !noCloseDate {\n\t\treturn time.Now().Before(closedAt)\n\t}\n\n\tif !noOpenDate \u0026\u0026 noCloseDate {\n\t\treturn time.Now().After(openAt)\n\t}\n\n\treturn time.Now().After(openAt) \u0026\u0026 time.Now().Before(closedAt)\n}\n\nfunc (form *Form) OpenAt() (time.Time, error) {\n\tif form.openAt == nil {\n\t\treturn time.Time{}, errors.New(\"Form has no open date\")\n\t}\n\n\treturn *form.openAt, nil\n}\n\nfunc (form *Form) CloseAt() (time.Time, error) {\n\tif form.closeAt == nil {\n\t\treturn time.Time{}, errors.New(\"Form has no close date\")\n\t}\n\n\treturn *form.closeAt, nil\n}\n\nfunc (db *FormDatabase) GetForm(id string) *Form {\n\tfor _, form := range db.Forms {\n\t\tif form.ID == id {\n\t\t\treturn form\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (db *FormDatabase) GetAnswer(formID string, author std.Address) *Submission {\n\tfor _, answer := range db.Answers {\n\t\tif answer.FormID == formID \u0026\u0026 answer.Author.String() == author.String() {\n\t\t\treturn answer\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (db *FormDatabase) GetSubmissionsByFormID(formID string) []*Submission {\n\tsubmissions := make([]*Submission, 0)\n\n\tfor _, answer := range db.Answers {\n\t\tif answer.FormID == formID {\n\t\t\tsubmissions = append(submissions, answer)\n\t\t}\n\t}\n\n\treturn submissions\n}"},{"name":"submit.gno","body":"package forms\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc (db *FormDatabase) SubmitForm(formID string, answers string) {\n\t// Check if form exists\n\tform := db.GetForm(formID)\n\tif form == nil {\n\t\tpanic(ufmt.Errorf(\"Form not found: %s\", formID))\n\t}\n\n\t// Check if form was already submitted by this user\n\tpreviousAnswer := db.GetAnswer(formID, std.PrevRealm().Addr())\n\tif previousAnswer != nil {\n\t\tpanic(\"You already submitted this form\")\n\t}\n\n\t// Check time restrictions\n\tif !form.IsOpen() {\n\t\tpanic(\"Form is closed\")\n\t}\n\n\t// Check if answers are formatted correctly\n\tif ValidateAnswers(answers, form.Fields) == false {\n\t\tpanic(\"Invalid answers\")\n\t}\n\n\t// Save answers\n\tanswer := Submission{\n\t\tFormID:      formID,\n\t\tAnswers:     answers,\n\t\tAuthor:      std.PrevRealm().Addr(),\n\t\tSubmittedAt: time.Now(),\n\t}\n\tdb.Answers = append(db.Answers, \u0026answer)\n}\n\n"},{"name":"submit_test.gno","body":"package forms\n\nimport (\n\t\"time\"\n\n\t\"testing\"\n)\n\nfunc TestAnswerForm(t *testing.T) {\n\tdb := NewDatabase()\n\n\tdata := `[\n\t\t{\n\t\t\t\"label\": \"Name\",\n\t\t\t\"fieldType\": \"string\",\n\t\t\t\"required\": true\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Age\",\n\t\t\t\"fieldType\": \"number\",\n\t\t\t\"required\": false\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Is this a test?\",\n\t\t\t\"fieldType\": \"boolean\",\n\t\t\t\"required\": false\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Favorite Food\",\n\t\t\t\"fieldType\": \"[Pizza|Schnitzel|Burger]\",\n\t\t\t\"required\": true\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Favorite Foods\",\n\t\t\t\"fieldType\": \"{Pizza|Schnitzel|Burger}\",\n\t\t\t\"required\": true\n\t\t}\n\t]`\n\n\tformID := db.CreateForm(\"Test Form\", \"Test Description\", \"\", \"\", data)\n\tanswers := `[\"Alex\", 21, true, 0, [0, 1]]`\n\n\tdb.SubmitForm(formID, answers)\n\n\tif len(db.Answers) != 1 {\n\t\tt.Errorf(\"Expected 1 answer, got %d\", len(db.Answers))\n\t}\n\n\tif db.Answers[0].FormID != formID {\n\t\tt.Errorf(\"Expected form ID %s, got %s\", formID, db.Answers[0].FormID)\n\t}\n\n\tif db.Answers[0].Answers != answers {\n\t\tt.Errorf(\"Expected answers %s, got %s\", answers, db.Answers[0].Answers)\n\t}\n}\n\nfunc shouldPanic(t *testing.T, f func()) {\n    defer func() {\n        if r := recover(); r == nil {\n            t.Errorf(\"should have panic\")\n        }\n    }()\n    f()\n}\n\nfunc TestAnswerFormDates(t *testing.T) {\n\tdb := NewDatabase()\n\n\tnow := time.Now()\n\ttomorrow := now.AddDate(0, 0, 1).Format(\"2006-01-02T15:04:05Z\")\n\tyesterday := now.AddDate(0, 0, -1).Format(\"2006-01-02T15:04:05Z\")\n\n\tdata := `[\n\t\t{\n\t\t\t\"label\": \"Name\",\n\t\t\t\"fieldType\": \"string\",\n\t\t\t\"required\": true\n\t\t}\n\t]`\n\tanswers := `[\"Test\"]`\n\t\n\tshouldPanic(t, func() {\n\t\tformID := db.CreateForm(\"Test Form\", \"Test Description\", tomorrow, \"\", data)\n\t\tdb.SubmitForm(formID, answers)\n\t})\n\n\tshouldPanic(t, func() {\n\t\tformID := db.CreateForm(\"Test Form\", \"Test Description\", \"\", yesterday, data)\n\t\tdb.SubmitForm(formID, answers)\n\t})\n\n\tformID := db.CreateForm(\"Test Form\", \"Test Description\", yesterday, tomorrow, data)\n\tdb.SubmitForm(formID, answers)\n}\n"},{"name":"validate.gno","body":"package forms\n\nimport (\n\t\"strings\"\n\n\t\"gno.land/p/demo/json\"\n)\n\nfunc ValidateBooleanField(node *json.Node, field Field) bool {\n\tif node.IsBool() == false {\n\t\treturn false\n\t}\n\n\tanswer, err := node.GetBool()\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// If the field is required, checkbox must be checked\n\tif field.Required == true \u0026\u0026 answer == false {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc ValidateStringField(node *json.Node, field Field) bool {\n\tif node.IsString() == false {\n\t\treturn false\n\t}\n\n\tanswer, err := node.GetString()\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// If the field is required, the answer must not be empty\n\tif field.Required == true \u0026\u0026 answer == \"\" {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc ValidateNumberField(node *json.Node, field Field) bool {\n\tif node.IsNumber() == false {\n\t\treturn false\n\t}\n\n\t_, err := node.GetNumeric()\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc ValidateMultiChoiceField(node *json.Node, field Field) bool {\n\tchoices := strings.Split(field.FieldType[1:len(field.FieldType)-1], \"|\")\n\n\tif node.IsArray() == false {\n\t\treturn false\n\t}\n\n\tif field.Required == true \u0026\u0026 node.Size() == 0 {\n\t\treturn false\n\t}\n\n\tif node.Size() \u003e len(choices) {\n\t\treturn false\n\t}\n\n\tfor i := 0; i \u003c node.Size(); i++ {\n\t\tchoiceNode, err := node.GetIndex(i)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tchoiceIdx := choiceNode.MustNumeric()\n\t\tif choiceIdx \u003c 0 || int(choiceIdx) \u003e= len(choices) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc ValideChoiceField(node *json.Node, field Field) bool {\n\tchoices := strings.Split(field.FieldType[1:len(field.FieldType)-1], \"|\")\n\n\tif node.IsNumber() == false {\n\t\treturn false\n\t}\n\n\tchoiceIdx := node.MustNumeric()\n\tif choiceIdx \u003c 0 || int(choiceIdx) \u003e= len(choices) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc ValidateAnswers(answers string, fields []Field) bool {\n\tunmarshalled, err := json.Unmarshal([]byte(answers))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif len(fields) != unmarshalled.Size() {\n\t\treturn false\n\t}\n\n\tfor i, field := range fields {\n\t\tanswer, err := unmarshalled.GetIndex(i)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tif answer.IsNull() \u0026\u0026 !field.Required {\n\t\t\treturn true\n\t\t}\n\n\t\tif field.FieldType == \"boolean\" {\n\t\t\tif ValidateBooleanField(answer, field) == false {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if field.FieldType == \"string\" {\n\t\t\tif ValidateStringField(answer, field) == false {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if field.FieldType == \"number\" {\n\t\t\tif ValidateNumberField(answer, field) == false {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if field.FieldType[0] == '{' \u0026\u0026 field.FieldType[len(field.FieldType)-1] == '}' {\n\t\t\tif ValidateMultiChoiceField(answer, field) == false {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if field.FieldType[0] == '[' \u0026\u0026 field.FieldType[len(field.FieldType)-1] == ']' {\n\t\t\tif ValideChoiceField(answer, field) == false {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n"},{"name":"validate_test.gno","body":"package forms\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAnswerFormInvalidForm(t *testing.T) {\n\tdb := NewDatabase()\n\n\tdataAllTypes := `[\n\t\t{\n\t\t\t\"label\": \"Name\",\n\t\t\t\"fieldType\": \"string\",\n\t\t\t\"required\": true\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Age\",\n\t\t\t\"fieldType\": \"number\",\n\t\t\t\"required\": false\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Is this a test?\",\n\t\t\t\"fieldType\": \"boolean\",\n\t\t\t\"required\": false\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Favorite Food\",\n\t\t\t\"fieldType\": \"[Pizza|Schnitzel|Burger]\",\n\t\t\t\"required\": true\n\t\t},\n\t\t{\n\t\t\t\"label\": \"Favorite Foods\",\n\t\t\t\"fieldType\": \"{Pizza|Schnitzel|Burger}\",\n\t\t\t\"required\": true\n\t\t}\n\t]`\n\tdataOneRequiredText := `[\n\t\t{\n\t\t\t\"label\": \"Name\",\n\t\t\t\"fieldType\": \"string\",\n\t\t\t\"required\": true\n\t\t}\n\t]`\n\n\ttests := []struct {\n\t\tname        string\n\t\tanswer      string\n\t\texpectPanic bool\n\t\tdata \t \tstring\n\t}{\n\t\t{\n\t\t\tname:        \"correct\",\n\t\t\tanswer:      `[\"Alex\", 21, true, 0, [0, 1]]`,\n\t\t\texpectPanic: false,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid string\",\n\t\t\tanswer:      `[0, 21, true, 0, [0, 1]`,\n\t\t\texpectPanic: true,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid number\",\n\t\t\tanswer:      `[\"Alex\", \"21\", true, 0, [0, 1]]`,\n\t\t\texpectPanic: true,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid boolean\",\n\t\t\tanswer:      `[\"Alex\", 21, 1, 0, [0, 1]]`,\n\t\t\texpectPanic: true,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid choice\",\n\t\t\tanswer:      `[\"Alex\", 21, true, 10, [0, 1]]`,\n\t\t\texpectPanic: true,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid multi-choice 1\",\n\t\t\tanswer:      `[\"Alex\", 21, true, 0, [0, 1, 2, 3, 4, 5]]`,\n\t\t\texpectPanic: true,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid multi-choice 2\",\n\t\t\tanswer:      `[\"Alex\", 21, true, 0, [5]]`,\n\t\t\texpectPanic: true,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid multi-choice 3\",\n\t\t\tanswer:      `[\"Alex\", 21, true, 0, 0]`,\n\t\t\texpectPanic: true,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"required string\",\n\t\t\tanswer:      `[\"\", 21, true, 0, [0, 1]]`,\n\t\t\texpectPanic: true,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname:        \"unrequired number\",\n\t\t\tanswer:      `[\"Alex\", null, true, 0, [0, 1]]`,\n\t\t\texpectPanic: false,\n\t\t\tdata: dataAllTypes,\n\t\t},\n\t\t{\n\t\t\tname: \"correct one field\",\n\t\t\tanswer: `[\"Alex\"]`,\n\t\t\texpectPanic: false,\n\t\t\tdata: dataOneRequiredText,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tformID := db.CreateForm(\"Test Form\", \"Test Description\", \"\", \"\", tt.data)\n\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.expectPanic {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"%s panic occurred when not expected: %v\", tt.name, r)\n\t\t\t\t} else if tt.expectPanic {\n\t\t\t\t\tt.Errorf(\"%s expected panic but didn't occur\", tt.name)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdb.SubmitForm(formID, tt.answer)\n\t\t})\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"8500000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7vZMLF9pSIjhABisQL393WTB0WnLBRO3Wg9gctmr60u"},"signature":"Cltt7vHbZkRgGYZdAhAU6XqV2GLR1rCqOkPHNgaqfk9pMpmajo5Vxu9Zpa1xrYxV41xeRnmq+ZFGGqusESoBfA=="}],"memo":""},"blockNum":"214300"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v","package":{"name":"forms","path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2","files":[{"name":"forms.gno","body":"package forms\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2\"\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar db *forms.FormDatabase\n\nfunc init() {\n\tdb = forms.NewDatabase()\n}\n\nfunc CreateForm(title string, description string, openAt string, closeAt string, data string) string {\n\treturn db.CreateForm(title, description, openAt, closeAt, data)\n}\n\nfunc GetForms() string {\n\tformsJson := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, form := range db.Forms {\n\t\tfieldsJson := json.ArrayNode(\"\", []*json.Node{})\n\t\tfor _, field := range form.Fields {\n\t\t\tfieldJson := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\t\"label\":     json.StringNode(\"label\", field.Label),\n\t\t\t\t\"fieldType\": json.StringNode(\"fieldType\", field.FieldType),\n\t\t\t\t\"required\":  json.BoolNode(\"required\", field.Required),\n\t\t\t})\n\t\t\tfieldsJson.AppendArray(fieldJson)\n\t\t}\n\n\t\tformJson := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"id\":          json.StringNode(\"id\", form.ID),\n\t\t\t\"owner\":       json.StringNode(\"owner\", form.Owner.String()),\n\t\t\t\"title\":       json.StringNode(\"title\", form.Title),\n\t\t\t\"description\": json.StringNode(\"description\", form.Description),\n\t\t\t\"createdAt\":   json.StringNode(\"createdAt\", form.CreatedAt.String()),\n\t\t\t\"fields\":      fieldsJson,\n\t\t})\n\t\tformsJson.AppendArray(formJson)\n\t}\n\n\tencoded, err := json.Marshal(formsJson)\n\tif err != nil {\n\t\tpanic(ufmt.Errorf(\"error: %v\", err))\n\t}\n\n\treturn string(encoded)\n}\n\nfunc GetFormByID(id string) string {\n\tform := db.GetForm(id)\n\tif form == nil {\n\t\tpanic(ufmt.Errorf(\"Form not found: %s\", id))\n\t}\n\n\tfieldsJson := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, field := range form.Fields {\n\t\tfieldJson := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"label\":     json.StringNode(\"label\", field.Label),\n\t\t\t\"fieldType\": json.StringNode(\"fieldType\", field.FieldType),\n\t\t\t\"required\":  json.BoolNode(\"required\", field.Required),\n\t\t})\n\t\tfieldsJson.AppendArray(fieldJson)\n\t}\n\n\tformSubmissions := db.GetSubmissionsByFormID(form.ID)\n\tsubmissionsJson := json.ObjectNode(\"\", map[string]*json.Node{})\n\tfor _, submission := range formSubmissions {\n\t\tsubmissionJson := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"submittedAt\": json.StringNode(\"submittedAt\", submission.SubmittedAt.Format(\"2006-01-02 15:04:05\")),\n\t\t\t\"answers\":     json.StringNode(\"answers\", strings.ReplaceAll(submission.Answers, \"\\\"\", \"'\")),\n\t\t})\n\t\tsubmissionsJson.AppendObject(submission.Author.String(), submissionJson)\n\t}\n\n\tjsonRes := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"id\":          json.StringNode(\"id\", form.ID),\n\t\t\"owner\":       json.StringNode(\"owner\", form.Owner.String()),\n\t\t\"title\":       json.StringNode(\"title\", form.Title),\n\t\t\"description\": json.StringNode(\"description\", form.Description),\n\t\t\"createdAt\":   json.StringNode(\"createdAt\", form.CreatedAt.Format(\"2006-01-02 15:04:05\")),\n\t\t\"submissions\": submissionsJson,\n\t\t\"fields\":      fieldsJson,\n\t})\n\n\topenAt, err := form.OpenAt()\n\tif err == nil {\n\t\tjsonRes.AppendObject(\"openAt\", json.StringNode(\"openAt\", openAt.Format(\"2006-01-02 15:04:05\")))\n\t}\n\tcloseAt, err := form.CloseAt()\n\tif err == nil {\n\t\tjsonRes.AppendObject(\"closeAt\", json.StringNode(\"closeAt\", closeAt.Format(\"2006-01-02 15:04:05\")))\n\t}\n\n\tencoded, err := json.Marshal(jsonRes)\n\tif err != nil {\n\t\tpanic(ufmt.Errorf(\"error: %v\", err))\n\t}\n\n\treturn string(encoded)\n}\n\nfunc GetAnswer(formID string, authorID string) string {\n\tform := db.GetForm(formID)\n\tif form == nil {\n\t\tpanic(ufmt.Errorf(\"Form not found: %s\", formID))\n\t}\n\n\tanswer := db.GetAnswer(formID, std.Address(authorID))\n\tif answer == nil {\n\t\tpanic(ufmt.Errorf(\"Answer not found: %s\", authorID))\n\t}\n\n\treturn answer.Answers\n}\n\nfunc SubmitForm(formID string, answers string) {\n\tform := db.GetForm(formID)\n\tif form == nil {\n\t\tpanic(ufmt.Errorf(\"Form not found: %s\", formID))\n\t}\n\n\tdb.SubmitForm(formID, answers)\n}\n\nfunc Render(path string) string {\n\tresponse := \"Forms:\\n\\n\"\n\tfor _, form := range db.Forms {\n\t\tresponse += ufmt.Sprintf(\"- %s\\n\\n\", GetFormByID(form.ID))\n\t}\n\tresponse += \"Answers:\\n\\n\"\n\tfor _, answer := range db.Answers {\n\t\tresponse += ufmt.Sprintf(\"- Form ID: %s\\nAuthor: %s\\nSubmitted At: %s\\n\u003eAnswers: %s\\n\\n\", answer.FormID, answer.Author, answer.SubmittedAt, answer.Answers)\n\t}\n\n\treturn response\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"8500000","gas_fee":"2000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7vZMLF9pSIjhABisQL393WTB0WnLBRO3Wg9gctmr60u"},"signature":"kvXPrIrot6HHNKVtWN9cGMBp5NIlZiRWnQFgXXTVW/B0PRM2vW+zNrjY6La6/r3+ggCAiTzFI0nSzxheXYvryA=="}],"memo":""},"blockNum":"214306"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v","send":"","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2","func":"CreateForm","args":["Test","Form description","","","[{\"fieldType\":\"string\",\"label\":\"Test question\",\"required\":true}]"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7vZMLF9pSIjhABisQL393WTB0WnLBRO3Wg9gctmr60u"},"signature":"nYpp0WopRaj+cxtrErRGn+C3LtlZlyljytVREYQLjIodijrHzcrE33YaeWvcSyDAkGUPJ9EjOVcukxoYgtsfpA=="}],"memo":""},"blockNum":"214403"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v","send":"","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2","func":"SubmitForm","args":["0000001","[\"Test\"]"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7vZMLF9pSIjhABisQL393WTB0WnLBRO3Wg9gctmr60u"},"signature":"w67n9inlRlXQhLcMH6AtlkHC3Y5pYb7XN0DGVYqSXJRIWpND2gW1IAIgYEZJsr9w1muKf7gJ/GUZ6kU/0qZ4+w=="}],"memo":""},"blockNum":"214449"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g185yv4ka7ymn3f6meq7k3g42nxrgfeykj3uk20d","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"2Z6kUm7MM6ZVDuqzLdB8GjxXF2BAyxGXS02SQPwNVPQSFvG0XuxPUq9J11FOJkiGFiVeuOmeUWBCbV0vG243Cw=="}],"memo":""},"blockNum":"214877"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v","send":"","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2","func":"CreateForm","args":["Full form","This is a full form with all field types","","","[{\"fieldType\":\"string\",\"label\":\"What's your name ?\",\"required\":true},{\"fieldType\":\"number\",\"label\":\"How old are you ?\",\"required\":false},{\"fieldType\":\"boolean\",\"label\":\"Do you like gno ?\",\"required\":false},{\"fieldType\":\"[Schnitzel|Pizza|Burger]\",\"label\":\"What is your favorite food ?\",\"required\":true},{\"fieldType\":\"{France|Spain|Germany|England}\",\"label\":\"Which of these countries have you been to ?\",\"required\":true}]"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7vZMLF9pSIjhABisQL393WTB0WnLBRO3Wg9gctmr60u"},"signature":"Jsr6Zc7YSfRl6zO7wwGTlZvn1f7m7+eVZ4OfAAcUyYUiq+vg2qOs8yx116simatRl7YwmwqHoTflXLReUB0YCw=="}],"memo":""},"blockNum":"214884"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v","send":"","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2","func":"SubmitForm","args":["0000002","[\"Alex\",21,true,0,[0,1,2]]"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7vZMLF9pSIjhABisQL393WTB0WnLBRO3Wg9gctmr60u"},"signature":"iMGfg1ICwSluW1uVBKgZ7F+ZuCPrDU21/OzHssrsLI1mrVGGQg3EOUxagQnyjcyC5Sqmlz8bgk5W3gZK/ChJNQ=="}],"memo":""},"blockNum":"215081"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g18lj5pgadp3y98wawweavle2r0677w9z25zmnm0","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"u53LFaKmbfZM8aKyFObQzvQHxzaKw5QR/aFkjoYmmO1fAE4gibwBXeHGijnuTnGH4xOTEqoBALIUtMJkMK9rpg=="}],"memo":""},"blockNum":"215904"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/gov/dao","func":"VoteOnProposal","args":["1","Yes"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"t9IfpRB/n5gVapCe7XDkSnrSUdU8JWbGxYMmSlLJ9983FcBIwCw6ND6REgvdmYjxTe5FyfA2tijHHS54gltRQA=="}],"memo":"Called through gno.studio"},"blockNum":"218418"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1sj0ykeeej73v29qvpqtumyyj2smfklcc92qqmv","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"dlqZTywnH15khX06GKlDVegibQRDcEtsHpSNAfJtKIZG4ysb3UqucDnFYsuZcYTGcpxbR/6fzZpqKdlWmGuP6w=="}],"memo":""},"blockNum":"219400"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1sj0ykeeej73v29qvpqtumyyj2smfklcc92qqmv","send":"","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2","func":"CreateForm","args":["hello","what?","","","[{\"fieldType\":\"string\",\"label\":\"how are you?\",\"required\":true}]"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A1kvMWtvSBrIVsYtE5hwIKuCxDUZjR1DYmAC/Y+0XYxo"},"signature":"w8F5MO+A86Rl7nClU5chgoQagrUHPOSqO65RtxwrNrsse88zuZ3yVJih8Nd8aLQXoPbbEBTfTbRnw6ttM/hFNQ=="}],"memo":""},"blockNum":"219414"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1sj0ykeeej73v29qvpqtumyyj2smfklcc92qqmv","send":"","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms2","func":"SubmitForm","args":["0000003","[\"ljlkj\"]"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A1kvMWtvSBrIVsYtE5hwIKuCxDUZjR1DYmAC/Y+0XYxo"},"signature":"Yc3MDaP++wRlXN/VWGkkDP+LisHaV2O7zIVB1DNAmJBe/7R3Lb3LQ9muTUFKfj/TsQvT5pArvQbxs/DHHYaHfQ=="}],"memo":""},"blockNum":"219446"}
