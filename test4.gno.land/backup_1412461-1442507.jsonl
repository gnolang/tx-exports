{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"domain","path":"gno.land/p/varmeta/domain","files":[{"name":"domain_metadata.gno","body":"package domain\n\nimport (\n\t\"time\"\n)\n\n// Trait represents a key-value pair with an optional display type for metadata attributes\ntype Trait struct {\n\tDisplayType string // Optional display type (e.g., \"date\", \"number\", etc.)\n\tTraitType   string // Type of the trait (e.g., \"age\", \"height\", etc.)\n\tValue       string // Value of the trait\n}\n\n// Metadata represents the metadata associated with a domain\ntype Metadata struct {\n\tAvatar           string    // URL or identifier for an avatar image\n\tRegistrationTime time.Time // The time when the domain was registered\n\tExpirationTime   time.Time // The time when the domain will be expire\n\tAttributes       []Trait   // Additional attributes of the domain\n\tDescription      string    // A description of the domain\n\tContactInfo      string    // Contact information for the domain owner\n\tRenewalFee       string    // The fee required to renew the domain, represented as a string\n}\n\n// NewMetadata creates a new Metadata instance\nfunc NewMetadata(avatar, description, contactInfo, renewalFee string,\n\tregistrationTime, expirationTime time.Time, attributes []Trait,\n) Metadata {\n\treturn Metadata{\n\t\tAvatar:           avatar,\n\t\tRegistrationTime: registrationTime,\n\t\tExpirationTime:   expirationTime,\n\t\tRenewalFee:       renewalFee,\n\t\tAttributes:       attributes,\n\t\tDescription:      description,\n\t\tContactInfo:      contactInfo,\n\t}\n}\n"},{"name":"domain_registry.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// domainRegistry represents a registry for domain names with metadata\ntype domainRegistry struct {\n\tdomains  grc721.IGRC721 // Interface for basic NFT functionality\n\tmetadata *avl.Tree      // AVL tree for storing domain metadata\n\texpDate  time.Time\n}\n\n// DomainRegistry defines the methods for managing domain names and metadata\ntype DomainRegistry interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(domainName string) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, domainName string) error\n\tTransferFrom(from, to std.Address, domainName string) error\n\tApprove(approved std.Address, domainName string) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(domainName string) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, domainName string) error\n\n\tRegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error\n\tSetDomainData(domainName string, metadata Metadata) error\n\tGetDomainData(domainName string, field MetadataField) (Metadata, error)\n\tGetDomainFields(domainName string, fields []MetadataField) (Metadata, error)\n\tRenewDomain(domainName string, additionalDuration time.Duration) error\n\tGetExpirationDate(domainName string) time.Time\n\tSetExpirationDate(domainName string, expDate time.Time) bool\n}\n\n// NewDomainRegistry creates a new domain registry with metadata extensions\nfunc NewDomainRegistry(name, symbol string) *domainRegistry {\n\tregistry := grc721.NewBasicNFT(name, symbol)\n\n\treturn \u0026domainRegistry{\n\t\tdomains:  registry,\n\t\tmetadata: avl.NewTree(),\n\t}\n}\n\n// RegisterDomain registers a new domain with the given metadata\nfunc (d *domainRegistry) RegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error {\n\terr := d.domains.Mint(owner, grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\td.expDate = time.Now().Add(dur)\n\td.metadata.Set(domainName, metadata)\n\n\treturn nil\n}\n\n// RenewDomain extends the expiration time of a domain name\nfunc (d *domainRegistry) RenewDomain(domainName string, additionalDuration time.Duration) error {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn ErrInvalidDomainName\n\t}\n\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\t// set new expiration date\n\td.expDate = d.expDate.Add(additionalDuration)\n\treturn nil\n}\n\n// SetDomainData sets the metadata for a given domain name\nfunc (d *domainRegistry) SetDomainData(domainName string, metadata Metadata) error {\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\td.metadata.Set(domainName, metadata)\n\treturn nil\n}\n\n// GetDomainFields retrieves multiple fields of metadata for a given domain\nfunc (d *domainRegistry) GetDomainFields(domainName string, fields []MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tif len(fields) == 0 {\n\t\treturn metadata, nil\n\t}\n\n\tvar result Metadata\n\tfor _, field := range fields {\n\t\tswitch field {\n\t\tcase FieldAvatar:\n\t\t\tresult.Avatar = metadata.Avatar\n\t\tcase FieldRegistrationTime:\n\t\t\tresult.RegistrationTime = metadata.RegistrationTime\n\t\tcase FieldExpirationTime:\n\t\t\tresult.ExpirationTime = metadata.ExpirationTime\n\t\tcase FieldRenewalFee:\n\t\t\tresult.RenewalFee = metadata.RenewalFee\n\t\tcase FieldAttributes:\n\t\t\tresult.Attributes = metadata.Attributes\n\t\tcase FieldDescription:\n\t\t\tresult.Description = metadata.Description\n\t\tcase FieldContactInfo:\n\t\t\tresult.ContactInfo = metadata.ContactInfo\n\t\tdefault:\n\t\t\treturn Metadata{}, ErrInvalidMetadataField\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// GetDomainData retrieves metadata for a given domain\nfunc (d *domainRegistry) GetDomainData(domainName string, field MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tswitch field {\n\tcase FieldAvatar:\n\t\treturn Metadata{\n\t\t\tAvatar: metadata.Avatar,\n\t\t}, nil\n\tcase FieldRegistrationTime:\n\t\treturn Metadata{\n\t\t\tRegistrationTime: metadata.RegistrationTime,\n\t\t}, nil\n\tcase FieldExpirationTime:\n\t\treturn Metadata{\n\t\t\tExpirationTime: metadata.ExpirationTime,\n\t\t}, nil\n\tcase FieldRenewalFee:\n\t\treturn Metadata{\n\t\t\tRenewalFee: metadata.RenewalFee,\n\t\t}, nil\n\tcase FieldAttributes:\n\t\treturn Metadata{\n\t\t\tAttributes: metadata.Attributes,\n\t\t}, nil\n\tcase FieldDescription:\n\t\treturn Metadata{\n\t\t\tDescription: metadata.Description,\n\t\t}, nil\n\tcase FieldContactInfo:\n\t\treturn Metadata{\n\t\t\tContactInfo: metadata.ContactInfo,\n\t\t}, nil\n\tdefault:\n\t\treturn Metadata{}, ErrInvalidMetadataField\n\t}\n}\n\n// BalanceOf returns the number of domains owned by a given address\nfunc (d *domainRegistry) BalanceOf(owner std.Address) (uint64, error) {\n\treturn d.domains.BalanceOf(owner)\n}\n\n// OwnerOf returns the owner of a given domain name\nfunc (d *domainRegistry) OwnerOf(domainName string) (std.Address, error) {\n\treturn d.domains.OwnerOf(grc721.TokenID(domainName))\n}\n\n// SafeTransferFrom safely transfers a domain from one address to another\nfunc (d *domainRegistry) SafeTransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.SafeTransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// TransferFrom transfers a domain from one address to another\nfunc (d *domainRegistry) TransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.TransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// Approve grants approval to another address to manage a specific domain\nfunc (d *domainRegistry) Approve(approved std.Address, domainName string) error {\n\treturn d.domains.Approve(approved, grc721.TokenID(domainName))\n}\n\n// SetApprovalForAll sets approval for an operator to manage all domains of the owner\nfunc (d *domainRegistry) SetApprovalForAll(operator std.Address, approved bool) error {\n\treturn d.domains.SetApprovalForAll(operator, approved)\n}\n\n// GetApproved returns the approved address for a specific domain\nfunc (d *domainRegistry) GetApproved(domainName string) (std.Address, error) {\n\treturn d.domains.GetApproved(grc721.TokenID(domainName))\n}\n\n// IsApprovedForAll checks if an operator is approved to manage all domains of the owner\nfunc (d *domainRegistry) IsApprovedForAll(owner, operator std.Address) bool {\n\treturn d.domains.IsApprovedForAll(owner, operator)\n}\n\n// Mint creates a new domain for a given address\nfunc (d *domainRegistry) Mint(to std.Address, domainName string) error {\n\treturn d.domains.Mint(to, grc721.TokenID(domainName))\n}\n\nfunc (d *domainRegistry) GetExpirationDate(domainName string) time.Time {\n\treturn d.expDate\n}\n\nfunc (d *domainRegistry) SetExpirationDate(domainName string, expDate time.Time) bool {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn false\n\t}\n\td.expDate = expDate\n\treturn true\n}\n"},{"name":"errors.gno","body":"package domain\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnauthorized         = errors.New(\"caller is not domain owner\")\n\tErrInvalidDomainName    = errors.New(\"invalid domain name\")\n\tErrInvalidMetadataField = errors.New(\"invalid metadata field\")\n\tErrInsufficientFunds    = errors.New(\"insufficient funds for renewal\")\n)\n"},{"name":"gno.mod","body":"module gno.land/p/varmeta/demo/domain\n\nrequire (\n\tgno.land/p/demo/avl v0.0.0-latest\n\tgno.land/p/demo/grc/grc721 v0.0.0-latest\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/urequire v0.0.0-latest\n)\n"},{"name":"util.gno","body":"package domain\n\ntype MetadataField int\n\nconst (\n\tFieldAvatar MetadataField = iota\n\tFieldRegistrationTime\n\tFieldRenewalFee\n\tFieldExpirationTime\n\tFieldAttributes\n\tFieldDescription\n\tFieldContactInfo\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"WfOXG0A9dBtWdSqpeLynQoN+VD3trSdxmczZoBDGqbgaYNChWLqGim3rQ3kxvk3v0mh2LO2S2iZfBpnZlOqRbA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1412739"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"gno.mod","body":"module gno.land/p/varmeta/demo1/grc/grc721\n\nrequire (\n\tgno.land/p/demo/avl v0.0.0-latest\n\tgno.land/p/demo/testutils v0.0.0-latest\n\tgno.land/p/demo/uassert v0.0.0-latest\n\tgno.land/p/demo/ufmt v0.0.0-latest\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"IzSp9OjUDzsaKq3vKWEB+VbjTOx9QpBf3vpB8U/t9xhXcXHQR8cCm2oF9WBV812uPRal2uu2sGGWl2GmN4u8NQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1412858"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"CDdAsQ9FMFo5PwzojlEATjToGmm7djhsL3VmnxjOU30ipvQQ2iPxIkxhvI0AQ4TNmHVW2Bq+As9B59VDyMQTbQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1412963"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"NkQXlQFSjf880cjeUUgOq/IaxJbhDRNFQ60iXrMm9CZuU8TEPcA8tSCmyeT/86a91U+GLv4N2HMQv+/zCuutgQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1413150"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"U3wmRGjwWI4qgRDeCiwy1BupX+9ht/Vvj1N3NhAW0m4D/5HLK0T/0LgT9Teg+HfzCIwk4HwvFCRfoLn+Pr4zMA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1413239"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"cyVncsYsYC2QlJ2GU3LKXifFPyGsmXsNuwBEFVFtceMhJKGi/yFnhLFWxjxRD09Blo/db5KRsNrtPNTCbSL71w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1415682"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/r/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"9waP9P0Dj2/aElrElRCoOYPp0lzt+FIwZmrZ3l6eeDlWwPdHS3FsZAiYKS15pBueWGCJiWwZnwDCJ9aUDIVSAQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1416065"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"qlhy4sAYGLxSbC0Aiq1bJpwaeoQpGq870yANdDpBq7Fyd6GfYoYlYhiVdsoRmllS2dpig+7IvVMVItTmsRASYw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1416072"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"XJaOCWrq54F6BJMLEvVIxFlqkAEge+uXph3BrylLhlcTR9ZyN4gcQWpCupOg3kUr27ATyxY5ICBCxKm+HxFpZQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1416104"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"IDqdCT5/djevAk2jSSjhmxaTaBYIDBVrtFaUUo/4x7V9Rr95MeJsxowy2xMH8kIQysx21w52xGw731l6VmTzYQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1416221"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"80000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"25mQAAf1yoFN6sAQm6nupQ5M6YNdwosffhgsK8U8toEsldy9w6AuaM0Gl9T4AXzAQPRhPFrciplAlRZGhjA8RA=="}],"memo":""},"blockNum":"1416481"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"PDwIZH/z0gi2cTBAkTVmbHAUj+XqtAAMzhyS56Rn8MVS4iD1Xaa4AoIaGisYvEbq7JdKHJmVHCqY5LcaA8AgOQ=="}],"memo":""},"blockNum":"1416508"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","to_address":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","amount":"9999999ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"a+xDjzzZrmhv7eD241ZiyHoHGogFjsiLCo2YfTnVy3FfoEfneL5sl7UyNiOGY1XbgPSo05u9dNi0aThXRzUF+w=="}],"memo":""},"blockNum":"1416514"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo1/grc/grc721","files":[{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"YLeyFK/SOlFmjPp4LFwUTaMNq4J2YjCuRvKfYaB/npV7f5KeF7/tHzbfeNjoQ4J+lqJ0LBD21UgsKcaklEE3Rw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1416530"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"vmt","path":"gno.land/r/varmeta/demo1/domain/vmt","files":[{"name":"token.gno","body":"// foo20 is a GRC20 token contract where all the GRC20 methods are proxified\n// with top-level functions. see also gno.land/r/demo/bar20.\npackage vmt\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbanker *grc20.Banker\n\tadmin  *ownable.Ownable\n\ttoken  grc20.Token\n)\n\nfunc init() {\n\tadmin = ownable.NewWithAddress(\"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\") // @thinhnx\n\tbanker = grc20.NewBanker(\"varmeta\", \"VMT\", 1)\n\tbanker.Mint(admin.Owner(), 1000000*10000) // @administrator (1M)\n\ttoken = banker.Token()\n}\n\nfunc TotalSupply() uint64 { return token.TotalSupply() }\n\nfunc BalanceOf(owner pusers.AddressOrName) uint64 {\n\townerAddr := users.Resolve(owner)\n\treturn token.BalanceOf(ownerAddr)\n}\n\nfunc Allowance(owner, spender pusers.AddressOrName) uint64 {\n\townerAddr := users.Resolve(owner)\n\tspenderAddr := users.Resolve(spender)\n\treturn token.Allowance(ownerAddr, spenderAddr)\n}\n\nfunc Transfer(to pusers.AddressOrName, amount uint64) {\n\ttoAddr := users.Resolve(to)\n\tcheckErr(token.Transfer(toAddr, amount))\n}\n\nfunc Approve(spender pusers.AddressOrName, amount uint64) {\n\tspenderAddr := users.Resolve(spender)\n\tcheckErr(token.Approve(spenderAddr, amount))\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, amount uint64) {\n\tfromAddr := users.Resolve(from)\n\ttoAddr := users.Resolve(to)\n\tcheckErr(token.TransferFrom(fromAddr, toAddr, amount))\n}\n\n// Faucet is distributing foo20 tokens without restriction (unsafe).\n// For a real token faucet, you should take care of setting limits are asking payment.\nfunc Faucet() {\n\tcaller := std.PrevRealm().Addr()\n\tamount := uint64(1_000 * 10_000) // 1k\n\tcheckErr(banker.Mint(caller, amount))\n}\n\nfunc Mint(to pusers.AddressOrName, amount uint64) {\n\tadmin.AssertCallerIsOwner()\n\ttoAddr := users.Resolve(to)\n\tcheckErr(banker.Mint(toAddr, amount))\n}\n\nfunc Burn(from pusers.AddressOrName, amount uint64) {\n\tadmin.AssertCallerIsOwner()\n\tfromAddr := users.Resolve(from)\n\tcheckErr(banker.Burn(fromAddr, amount))\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn banker.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := pusers.AddressOrName(parts[1])\n\t\townerAddr := users.Resolve(owner)\n\t\tbalance := banker.BalanceOf(ownerAddr)\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tcaller := std.PrevRealm().Addr()\n\t\tufmt.Println(caller.String())\n\t\tufmt.Println(err.Error())\n\t\tpanic(err)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"80000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"z0+izBP4NfEYKNTuLRjcDXENLqjulNPZJRswGJSOf7d9RmeXqEu+iKxIS+j6pJ7v+VaGwcfJdNZHLQjxusd8Yw=="}],"memo":""},"blockNum":"1418713"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/varmeta/demo1/domain/vmt","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/varmeta/demo1/domain/vmt\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/varmeta/demo1/domain/vmt\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/varmeta/demo1/domain/vmt\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/varmeta/demo1/domain/vmt\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/varmeta/demo1/domain/vmt\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/varmeta/demo1/domain/vmt\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"XIGwpO/sQnAET50W6+zvIkUFNxKY+4Va+2UdbJJGIsxrePCYMcGyN5giiGlRUZfaQOQtdH9Y13SARy3yOJ4ung=="}],"memo":""},"blockNum":"1418714"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"domain","path":"gno.land/r/varmeta/demo1/domain","files":[{"name":"domain_metadata.gno","body":"package domain\n\nimport (\n\t\"time\"\n)\n\n// Trait represents a key-value pair with an optional display type for metadata attributes\ntype Trait struct {\n\tDisplayType string // Optional display type (e.g., \"date\", \"number\", etc.)\n\tTraitType   string // Type of the trait (e.g., \"age\", \"height\", etc.)\n\tValue       string // Value of the trait\n}\n\n// Metadata represents the metadata associated with a domain\ntype Metadata struct {\n\tAvatar           string    // URL or identifier for an avatar image\n\tRegistrationTime time.Time // The time when the domain was registered\n\tExpirationTime   time.Time // The time when the domain will be expire\n\tAttributes       []Trait   // Additional attributes of the domain\n\tDescription      string    // A description of the domain\n\tContactInfo      string    // Contact information for the domain owner\n\tRenewalFee       string    // The fee required to renew the domain, represented as a string\n}\n\n// NewMetadata creates a new Metadata instance\nfunc NewMetadata(avatar, description, contactInfo, renewalFee string,\n\tregistrationTime, expirationTime time.Time, attributes []Trait,\n) Metadata {\n\treturn Metadata{\n\t\tAvatar:           avatar,\n\t\tRegistrationTime: registrationTime,\n\t\tExpirationTime:   expirationTime,\n\t\tRenewalFee:       renewalFee,\n\t\tAttributes:       attributes,\n\t\tDescription:      description,\n\t\tContactInfo:      contactInfo,\n\t}\n}\n"},{"name":"domain_registry.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo1/grc/grc721\"\n)\n\n// domainRegistry represents a registry for domain names with metadata\ntype domainRegistry struct {\n\tdomains  grc721.IGRC721 // Interface for basic NFT functionality\n\tmetadata *avl.Tree      // AVL tree for storing domain metadata\n\texpDate  time.Time\n}\n\n// DomainRegistry defines the methods for managing domain names and metadata\ntype DomainRegistry interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(domainName string) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, domainName string) error\n\tTransferFrom(from, to std.Address, domainName string) error\n\tApprove(approved std.Address, domainName string) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(domainName string) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, domainName string) error\n\n\tRegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error\n\tSetDomainData(domainName string, metadata Metadata) error\n\tGetDomainData(domainName string, field MetadataField) (Metadata, error)\n\tGetDomainFields(domainName string, fields []MetadataField) (Metadata, error)\n\tRenewDomain(domainName string, additionalDuration time.Duration) error\n\tGetExpirationDate(domainName string) time.Time\n\tSetExpirationDate(domainName string, expDate time.Time) bool\n}\n\n// NewDomainRegistry creates a new domain registry with metadata extensions\nfunc NewDomainRegistry(name, symbol string) *domainRegistry {\n\tregistry := grc721.NewBasicNFT(name, symbol)\n\n\treturn \u0026domainRegistry{\n\t\tdomains:  registry,\n\t\tmetadata: avl.NewTree(),\n\t}\n}\n\n// RegisterDomain registers a new domain with the given metadata\nfunc (d *domainRegistry) RegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error {\n\terr := d.domains.Mint(owner, grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\td.expDate = time.Now().Add(dur)\n\td.metadata.Set(domainName, metadata)\n\n\treturn nil\n}\n\n// RenewDomain extends the expiration time of a domain name\nfunc (d *domainRegistry) RenewDomain(domainName string, additionalDuration time.Duration) error {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn ErrInvalidDomainName\n\t}\n\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\t// set new expiration date\n\td.expDate = d.expDate.Add(additionalDuration)\n\treturn nil\n}\n\n// SetDomainData sets the metadata for a given domain name\nfunc (d *domainRegistry) SetDomainData(domainName string, metadata Metadata) error {\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\td.metadata.Set(domainName, metadata)\n\treturn nil\n}\n\n// GetDomainFields retrieves multiple fields of metadata for a given domain\nfunc (d *domainRegistry) GetDomainFields(domainName string, fields []MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tif len(fields) == 0 {\n\t\treturn metadata, nil\n\t}\n\n\tvar result Metadata\n\tfor _, field := range fields {\n\t\tswitch field {\n\t\tcase FieldAvatar:\n\t\t\tresult.Avatar = metadata.Avatar\n\t\tcase FieldRegistrationTime:\n\t\t\tresult.RegistrationTime = metadata.RegistrationTime\n\t\tcase FieldExpirationTime:\n\t\t\tresult.ExpirationTime = metadata.ExpirationTime\n\t\tcase FieldRenewalFee:\n\t\t\tresult.RenewalFee = metadata.RenewalFee\n\t\tcase FieldAttributes:\n\t\t\tresult.Attributes = metadata.Attributes\n\t\tcase FieldDescription:\n\t\t\tresult.Description = metadata.Description\n\t\tcase FieldContactInfo:\n\t\t\tresult.ContactInfo = metadata.ContactInfo\n\t\tdefault:\n\t\t\treturn Metadata{}, ErrInvalidMetadataField\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// GetDomainData retrieves metadata for a given domain\nfunc (d *domainRegistry) GetDomainData(domainName string, field MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tswitch field {\n\tcase FieldAvatar:\n\t\treturn Metadata{\n\t\t\tAvatar: metadata.Avatar,\n\t\t}, nil\n\tcase FieldRegistrationTime:\n\t\treturn Metadata{\n\t\t\tRegistrationTime: metadata.RegistrationTime,\n\t\t}, nil\n\tcase FieldExpirationTime:\n\t\treturn Metadata{\n\t\t\tExpirationTime: metadata.ExpirationTime,\n\t\t}, nil\n\tcase FieldRenewalFee:\n\t\treturn Metadata{\n\t\t\tRenewalFee: metadata.RenewalFee,\n\t\t}, nil\n\tcase FieldAttributes:\n\t\treturn Metadata{\n\t\t\tAttributes: metadata.Attributes,\n\t\t}, nil\n\tcase FieldDescription:\n\t\treturn Metadata{\n\t\t\tDescription: metadata.Description,\n\t\t}, nil\n\tcase FieldContactInfo:\n\t\treturn Metadata{\n\t\t\tContactInfo: metadata.ContactInfo,\n\t\t}, nil\n\tdefault:\n\t\treturn Metadata{}, ErrInvalidMetadataField\n\t}\n}\n\n// BalanceOf returns the number of domains owned by a given address\nfunc (d *domainRegistry) BalanceOf(owner std.Address) (uint64, error) {\n\treturn d.domains.BalanceOf(owner)\n}\n\n// OwnerOf returns the owner of a given domain name\nfunc (d *domainRegistry) OwnerOf(domainName string) (std.Address, error) {\n\treturn d.domains.OwnerOf(grc721.TokenID(domainName))\n}\n\n// SafeTransferFrom safely transfers a domain from one address to another\nfunc (d *domainRegistry) SafeTransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.SafeTransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// TransferFrom transfers a domain from one address to another\nfunc (d *domainRegistry) TransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.TransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// Approve grants approval to another address to manage a specific domain\nfunc (d *domainRegistry) Approve(approved std.Address, domainName string) error {\n\treturn d.domains.Approve(approved, grc721.TokenID(domainName))\n}\n\n// SetApprovalForAll sets approval for an operator to manage all domains of the owner\nfunc (d *domainRegistry) SetApprovalForAll(operator std.Address, approved bool) error {\n\treturn d.domains.SetApprovalForAll(operator, approved)\n}\n\n// GetApproved returns the approved address for a specific domain\nfunc (d *domainRegistry) GetApproved(domainName string) (std.Address, error) {\n\treturn d.domains.GetApproved(grc721.TokenID(domainName))\n}\n\n// IsApprovedForAll checks if an operator is approved to manage all domains of the owner\nfunc (d *domainRegistry) IsApprovedForAll(owner, operator std.Address) bool {\n\treturn d.domains.IsApprovedForAll(owner, operator)\n}\n\n// Mint creates a new domain for a given address\nfunc (d *domainRegistry) Mint(to std.Address, domainName string) error {\n\treturn d.domains.Mint(to, grc721.TokenID(domainName))\n}\n\nfunc (d *domainRegistry) GetExpirationDate(domainName string) time.Time {\n\treturn d.expDate\n}\n\nfunc (d *domainRegistry) SetExpirationDate(domainName string, expDate time.Time) bool {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn false\n\t}\n\td.expDate = expDate\n\treturn true\n}\n"},{"name":"domain_registry_test.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo1/grc/grc721\"\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/urequire\"\n)\n\nvar (\n\taddr1 = testutils.TestAddress(\"bob\")\n\taddr2 = testutils.TestAddress(\"alice\")\n)\n\nfunc TestRegisterDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Successful Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"contact@registered.com\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Duplicate Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\terr := registry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.owner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr1,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr2,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\t\t\terr := registry.SetDomainData(c.domainName, c.metadata)\n\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\tretrievedMetadata, err := registry.GetDomainData(c.domainName, FieldAvatar)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.metadata.Avatar, retrievedMetadata.Avatar)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRenewDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname           string\n\t\towner          std.Address\n\t\tcaller         std.Address\n\t\tdomainName     string\n\t\tadditionalTime time.Duration\n\t\texpectError    bool\n\t\texpectedExpiry time.Time\n\t}{\n\t\t{\n\t\t\tname:           \"Successful Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr1,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"Non-Owner Attempts Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr2,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A renewable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.RenewDomain(c.domainName, c.additionalTime)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\trenewedMetadata, err := registry.GetDomainData(c.domainName, FieldExpirationTime)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\t// urequire.True(t, renewedMetadata.ExpirationTime.After(metadata.ExpirationTime))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfield       MetadataField\n\t\texpectError bool\n\t\texpectedVal string\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Avatar\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: false,\n\t\t\texpectedVal: \"avatar_url\",\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain Name\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t_, err := registry.GetDomainData(c.domainName, c.field)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainFields(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfields      []MetadataField\n\t\texpectError bool\n\t\texpected    Metadata\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Multiple Fields\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar, FieldDescription, FieldContactInfo},\n\t\t\texpectError: false,\n\t\t\texpected: Metadata{\n\t\t\t\tAvatar:      \"avatar_url\",\n\t\t\t\tDescription: \"A test domain\",\n\t\t\t\tContactInfo: \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tretrievedMetadata, err := registry.GetDomainFields(c.domainName, c.fields)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.expected.Avatar, retrievedMetadata.Avatar)\n\t\t\t\turequire.Equal(t, c.expected.Description, retrievedMetadata.Description)\n\t\t\t\turequire.Equal(t, c.expected.ContactInfo, retrievedMetadata.ContactInfo)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTransferDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tnewOwner    std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"Successful Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr1,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Non-Owner Attempts Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr2,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A transferable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.TransferFrom(c.owner, c.newOwner, c.domainName)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), grc721.ErrTransferFromIncorrectOwner.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.newOwner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"errors.gno","body":"package domain\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnauthorized         = errors.New(\"caller is not domain owner\")\n\tErrInvalidDomainName    = errors.New(\"invalid domain name\")\n\tErrInvalidMetadataField = errors.New(\"invalid metadata field\")\n\tErrInsufficientFunds    = errors.New(\"insufficient funds for renewal\")\n)\n"},{"name":"utils.gno","body":"package domain\n\ntype MetadataField int\n\nconst (\n\tFieldAvatar MetadataField = iota\n\tFieldRegistrationTime\n\tFieldRenewalFee\n\tFieldExpirationTime\n\tFieldAttributes\n\tFieldDescription\n\tFieldContactInfo\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"8000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"0RgpwNFkcNK/DHkgAVK8a/THq2+e6uoKhMm5Rd7LjSg7ITlYeRXST+usXrkA6bvYV9PN+LKxIFU1RyF90DEDVw=="}],"memo":""},"blockNum":"1418904"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"domain","path":"gno.land/p/varmeta/demo1/domain","files":[{"name":"domain_metadata.gno","body":"package domain\n\nimport (\n\t\"time\"\n)\n\n// Trait represents a key-value pair with an optional display type for metadata attributes\ntype Trait struct {\n\tDisplayType string // Optional display type (e.g., \"date\", \"number\", etc.)\n\tTraitType   string // Type of the trait (e.g., \"age\", \"height\", etc.)\n\tValue       string // Value of the trait\n}\n\n// Metadata represents the metadata associated with a domain\ntype Metadata struct {\n\tAvatar           string    // URL or identifier for an avatar image\n\tRegistrationTime time.Time // The time when the domain was registered\n\tExpirationTime   time.Time // The time when the domain will be expire\n\tAttributes       []Trait   // Additional attributes of the domain\n\tDescription      string    // A description of the domain\n\tContactInfo      string    // Contact information for the domain owner\n\tRenewalFee       string    // The fee required to renew the domain, represented as a string\n}\n\n// NewMetadata creates a new Metadata instance\nfunc NewMetadata(avatar, description, contactInfo, renewalFee string,\n\tregistrationTime, expirationTime time.Time, attributes []Trait,\n) Metadata {\n\treturn Metadata{\n\t\tAvatar:           avatar,\n\t\tRegistrationTime: registrationTime,\n\t\tExpirationTime:   expirationTime,\n\t\tRenewalFee:       renewalFee,\n\t\tAttributes:       attributes,\n\t\tDescription:      description,\n\t\tContactInfo:      contactInfo,\n\t}\n}\n"},{"name":"domain_registry.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo1/grc/grc721\"\n)\n\n// domainRegistry represents a registry for domain names with metadata\ntype domainRegistry struct {\n\tdomains  grc721.IGRC721 // Interface for basic NFT functionality\n\tmetadata *avl.Tree      // AVL tree for storing domain metadata\n\texpDate  time.Time\n}\n\n// DomainRegistry defines the methods for managing domain names and metadata\ntype DomainRegistry interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(domainName string) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, domainName string) error\n\tTransferFrom(from, to std.Address, domainName string) error\n\tApprove(approved std.Address, domainName string) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(domainName string) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, domainName string) error\n\n\tRegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error\n\tSetDomainData(domainName string, metadata Metadata) error\n\tGetDomainData(domainName string, field MetadataField) (Metadata, error)\n\tGetDomainFields(domainName string, fields []MetadataField) (Metadata, error)\n\tRenewDomain(domainName string, additionalDuration time.Duration) error\n\tGetExpirationDate(domainName string) time.Time\n\tSetExpirationDate(domainName string, expDate time.Time) bool\n}\n\n// NewDomainRegistry creates a new domain registry with metadata extensions\nfunc NewDomainRegistry(name, symbol string) *domainRegistry {\n\tregistry := grc721.NewBasicNFT(name, symbol)\n\n\treturn \u0026domainRegistry{\n\t\tdomains:  registry,\n\t\tmetadata: avl.NewTree(),\n\t}\n}\n\n// RegisterDomain registers a new domain with the given metadata\nfunc (d *domainRegistry) RegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error {\n\terr := d.domains.Mint(owner, grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\td.expDate = time.Now().Add(dur)\n\td.metadata.Set(domainName, metadata)\n\n\treturn nil\n}\n\n// RenewDomain extends the expiration time of a domain name\nfunc (d *domainRegistry) RenewDomain(domainName string, additionalDuration time.Duration) error {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn ErrInvalidDomainName\n\t}\n\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\t// set new expiration date\n\td.expDate = d.expDate.Add(additionalDuration)\n\treturn nil\n}\n\n// SetDomainData sets the metadata for a given domain name\nfunc (d *domainRegistry) SetDomainData(domainName string, metadata Metadata) error {\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\td.metadata.Set(domainName, metadata)\n\treturn nil\n}\n\n// GetDomainFields retrieves multiple fields of metadata for a given domain\nfunc (d *domainRegistry) GetDomainFields(domainName string, fields []MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tif len(fields) == 0 {\n\t\treturn metadata, nil\n\t}\n\n\tvar result Metadata\n\tfor _, field := range fields {\n\t\tswitch field {\n\t\tcase FieldAvatar:\n\t\t\tresult.Avatar = metadata.Avatar\n\t\tcase FieldRegistrationTime:\n\t\t\tresult.RegistrationTime = metadata.RegistrationTime\n\t\tcase FieldExpirationTime:\n\t\t\tresult.ExpirationTime = metadata.ExpirationTime\n\t\tcase FieldRenewalFee:\n\t\t\tresult.RenewalFee = metadata.RenewalFee\n\t\tcase FieldAttributes:\n\t\t\tresult.Attributes = metadata.Attributes\n\t\tcase FieldDescription:\n\t\t\tresult.Description = metadata.Description\n\t\tcase FieldContactInfo:\n\t\t\tresult.ContactInfo = metadata.ContactInfo\n\t\tdefault:\n\t\t\treturn Metadata{}, ErrInvalidMetadataField\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// GetDomainData retrieves metadata for a given domain\nfunc (d *domainRegistry) GetDomainData(domainName string, field MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tswitch field {\n\tcase FieldAvatar:\n\t\treturn Metadata{\n\t\t\tAvatar: metadata.Avatar,\n\t\t}, nil\n\tcase FieldRegistrationTime:\n\t\treturn Metadata{\n\t\t\tRegistrationTime: metadata.RegistrationTime,\n\t\t}, nil\n\tcase FieldExpirationTime:\n\t\treturn Metadata{\n\t\t\tExpirationTime: metadata.ExpirationTime,\n\t\t}, nil\n\tcase FieldRenewalFee:\n\t\treturn Metadata{\n\t\t\tRenewalFee: metadata.RenewalFee,\n\t\t}, nil\n\tcase FieldAttributes:\n\t\treturn Metadata{\n\t\t\tAttributes: metadata.Attributes,\n\t\t}, nil\n\tcase FieldDescription:\n\t\treturn Metadata{\n\t\t\tDescription: metadata.Description,\n\t\t}, nil\n\tcase FieldContactInfo:\n\t\treturn Metadata{\n\t\t\tContactInfo: metadata.ContactInfo,\n\t\t}, nil\n\tdefault:\n\t\treturn Metadata{}, ErrInvalidMetadataField\n\t}\n}\n\n// BalanceOf returns the number of domains owned by a given address\nfunc (d *domainRegistry) BalanceOf(owner std.Address) (uint64, error) {\n\treturn d.domains.BalanceOf(owner)\n}\n\n// OwnerOf returns the owner of a given domain name\nfunc (d *domainRegistry) OwnerOf(domainName string) (std.Address, error) {\n\treturn d.domains.OwnerOf(grc721.TokenID(domainName))\n}\n\n// SafeTransferFrom safely transfers a domain from one address to another\nfunc (d *domainRegistry) SafeTransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.SafeTransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// TransferFrom transfers a domain from one address to another\nfunc (d *domainRegistry) TransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.TransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// Approve grants approval to another address to manage a specific domain\nfunc (d *domainRegistry) Approve(approved std.Address, domainName string) error {\n\treturn d.domains.Approve(approved, grc721.TokenID(domainName))\n}\n\n// SetApprovalForAll sets approval for an operator to manage all domains of the owner\nfunc (d *domainRegistry) SetApprovalForAll(operator std.Address, approved bool) error {\n\treturn d.domains.SetApprovalForAll(operator, approved)\n}\n\n// GetApproved returns the approved address for a specific domain\nfunc (d *domainRegistry) GetApproved(domainName string) (std.Address, error) {\n\treturn d.domains.GetApproved(grc721.TokenID(domainName))\n}\n\n// IsApprovedForAll checks if an operator is approved to manage all domains of the owner\nfunc (d *domainRegistry) IsApprovedForAll(owner, operator std.Address) bool {\n\treturn d.domains.IsApprovedForAll(owner, operator)\n}\n\n// Mint creates a new domain for a given address\nfunc (d *domainRegistry) Mint(to std.Address, domainName string) error {\n\treturn d.domains.Mint(to, grc721.TokenID(domainName))\n}\n\nfunc (d *domainRegistry) GetExpirationDate(domainName string) time.Time {\n\treturn d.expDate\n}\n\nfunc (d *domainRegistry) SetExpirationDate(domainName string, expDate time.Time) bool {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn false\n\t}\n\td.expDate = expDate\n\treturn true\n}\n"},{"name":"domain_registry_test.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo1/grc/grc721\"\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/urequire\"\n)\n\nvar (\n\taddr1 = testutils.TestAddress(\"bob\")\n\taddr2 = testutils.TestAddress(\"alice\")\n)\n\nfunc TestRegisterDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Successful Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"contact@registered.com\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Duplicate Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\terr := registry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.owner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr1,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr2,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\t\t\terr := registry.SetDomainData(c.domainName, c.metadata)\n\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\tretrievedMetadata, err := registry.GetDomainData(c.domainName, FieldAvatar)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.metadata.Avatar, retrievedMetadata.Avatar)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRenewDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname           string\n\t\towner          std.Address\n\t\tcaller         std.Address\n\t\tdomainName     string\n\t\tadditionalTime time.Duration\n\t\texpectError    bool\n\t\texpectedExpiry time.Time\n\t}{\n\t\t{\n\t\t\tname:           \"Successful Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr1,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"Non-Owner Attempts Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr2,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A renewable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.RenewDomain(c.domainName, c.additionalTime)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\trenewedMetadata, err := registry.GetDomainData(c.domainName, FieldExpirationTime)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\t// urequire.True(t, renewedMetadata.ExpirationTime.After(metadata.ExpirationTime))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfield       MetadataField\n\t\texpectError bool\n\t\texpectedVal string\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Avatar\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: false,\n\t\t\texpectedVal: \"avatar_url\",\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain Name\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t_, err := registry.GetDomainData(c.domainName, c.field)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainFields(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfields      []MetadataField\n\t\texpectError bool\n\t\texpected    Metadata\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Multiple Fields\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar, FieldDescription, FieldContactInfo},\n\t\t\texpectError: false,\n\t\t\texpected: Metadata{\n\t\t\t\tAvatar:      \"avatar_url\",\n\t\t\t\tDescription: \"A test domain\",\n\t\t\t\tContactInfo: \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tretrievedMetadata, err := registry.GetDomainFields(c.domainName, c.fields)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.expected.Avatar, retrievedMetadata.Avatar)\n\t\t\t\turequire.Equal(t, c.expected.Description, retrievedMetadata.Description)\n\t\t\t\turequire.Equal(t, c.expected.ContactInfo, retrievedMetadata.ContactInfo)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTransferDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tnewOwner    std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"Successful Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr1,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Non-Owner Attempts Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr2,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A transferable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.TransferFrom(c.owner, c.newOwner, c.domainName)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), grc721.ErrTransferFromIncorrectOwner.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.newOwner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"errors.gno","body":"package domain\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnauthorized         = errors.New(\"caller is not domain owner\")\n\tErrInvalidDomainName    = errors.New(\"invalid domain name\")\n\tErrInvalidMetadataField = errors.New(\"invalid metadata field\")\n\tErrInsufficientFunds    = errors.New(\"insufficient funds for renewal\")\n)\n"},{"name":"utils.gno","body":"package domain\n\ntype MetadataField int\n\nconst (\n\tFieldAvatar MetadataField = iota\n\tFieldRegistrationTime\n\tFieldRenewalFee\n\tFieldExpirationTime\n\tFieldAttributes\n\tFieldDescription\n\tFieldContactInfo\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"8000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"YksmVYceDSOHwip6YC4rOcbEVANkVdNP1cCZfS5V1VARokiuP36umTSPNRQ/BuhbjmMrITyzDtOp4yMwwWy3Hg=="}],"memo":""},"blockNum":"1418911"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo1/domain/registrar","files":[{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(2)\n\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(\"unauthorize\")\n\t}\n}\n\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc MetadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     10,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// not need to revertFee because if the registering is failed, then the coin is not deducted.\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\t// revertTransfer(requestInfo.Caller)\n\t\t// return regResult.ResultDetails.Error()\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := MetadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"std\"\n\t\"time\"\n)\n\nvar (\n\tdefaultExpireTime             = time.Hour // 30 days\n\treName                        = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorize\")\n\t}\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"8000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"XukIf7n8R5rhEiJrHBhaDj9JHK1V/VLFCGCkIz+BjTVVC1eKZ1D08qWXMReSm+orwnH18++pylVqHTX8/A1VMQ=="}],"memo":""},"blockNum":"1418996"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo1/domain/registrar","files":[{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(2)\n\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(\"unauthorize\")\n\t}\n}\n\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc MetadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     10,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// not need to revertFee because if the registering is failed, then the coin is not deducted.\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\t// revertTransfer(requestInfo.Caller)\n\t\t// return regResult.ResultDetails.Error()\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := MetadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"std\"\n\t\"time\"\n)\n\nvar (\n\tdefaultExpireTime             = time.Hour // 30 days\n\treName                        = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorize\")\n\t}\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"9000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"IXhERCKROeNLZPSjO5auDkkMs2FA02evWMq9xCzDjOoYflUbtdVHnshZBNahOyzlmExa6nZvpdxwTmMoCXKTUQ=="}],"memo":""},"blockNum":"1419003"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo1/domain/registrar","files":[{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(2)\n\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(\"unauthorize\")\n\t}\n}\n\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc MetadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     10,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// not need to revertFee because if the registering is failed, then the coin is not deducted.\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\t// revertTransfer(requestInfo.Caller)\n\t\t// return regResult.ResultDetails.Error()\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := MetadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"std\"\n\t\"time\"\n)\n\nvar (\n\tdefaultExpireTime             = time.Hour // 30 days\n\treName                        = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorize\")\n\t}\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"wx0V+mZZXLr3MtvFofYhiVJs8HWvPNKTsis8r0eOeKFp/xEP1XNfbg+aUzp2TTTQd1voTosEvsKinO96BZ+ksA=="}],"memo":""},"blockNum":"1419009"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo1/domain/registrar","files":[{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(2)\n\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(\"unauthorize\")\n\t}\n}\n\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc MetadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     10,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// not need to revertFee because if the registering is failed, then the coin is not deducted.\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\t// revertTransfer(requestInfo.Caller)\n\t\t// return regResult.ResultDetails.Error()\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := MetadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"std\"\n\t\"time\"\n)\n\nvar (\n\tdefaultExpireTime             = time.Hour // 30 days\n\treName                        = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorize\")\n\t}\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"80000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"nkUso0mOCDzwca4PlZ/TbXFDLjMZWO54NimUi0QiDT9aC0x07HOAhGxcQ6NuH86wNiKP2HkEAMdur0xaCR5xbA=="}],"memo":""},"blockNum":"1419018"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"resolver","path":"gno.land/r/varmeta/demo1/domain/resolver","files":[{"name":"checks_resolver.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage resolver\n\nimport (\n\t\"regexp\"\n\t\"time\"\n\n\t\"gno.land/r/varmeta/demo1/domain/registrar\"\n)\n\n// const (\n// \tadmin std.Address = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\" // -\u003e @thinhnx\n// )\n\nvar reName = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc isExpired(dName string) bool {\n\texpDate := registrar.GetExpirationDate(dName)\n\treturn expDate.Before(time.Now())\n}\n"},{"name":"errors.gno","body":"package resolver\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrNotFound          = errors.New(\"not found\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"invalid domain name to register\")\n)\n"},{"name":"resolver.gno","body":"/*\nThe goal of the Resolver contract is keep track of the address for each ICNS name in a stateful manner.\nIt serves the purpose of \"resolving\" the ICNS Name\nto the correct address (e.g \"alice.gno\" -\u003e g1xxx).\n*/\n// changelogs: move Register feature into this resolver package\n// changelogs2: Removed local storage of resolver as cache, and every querires we query to registrar to get the result\n\npackage resolver\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/varmeta/demo1/domain/registrar\"\n)\n\ntype Record struct {\n\tOwner    std.Address\n\tIsValid  bool\n\tMemo     string // no more need this\n\tPriority int\n}\n\n// retrieve the record list to get the onchain address\nfunc Resolve(domainName string) *Record {\n\tif !isValidDomain(domainName) {\n\t\tpanic(\"bad domain name\")\n\t}\n\trecord := \u0026Record{}\n\n\towner := getOwnerFromDomainStorage(domainName)\n\tif owner == \"\" {\n\t\trecord.Memo = \"not found\"\n\t\trecord.IsValid = false\n\t\treturn record\n\t}\n\n\tif !isExpired(domainName) {\n\t\trecord.IsValid = true\n\t\trecord.Owner = owner\n\t} else {\n\t\trecord.IsValid = false\n\t}\n\treturn record\n}\n\nfunc GetDomainName(addr string) []string {\n\treturn registrar.GetDomainName(addr)\n}\n\n/*\nIf query in local storage not found\nQuery to DomainStorage by domainName -\u003e get the registry -\u003e use that registry to get the Owner()\nand check the validation time?\n*/\n\nfunc existedInDomainStorage(domainName string) bool {\n\treturn registrar.AlreadyRegistered(domainName)\n}\n\nfunc getOwnerFromDomainStorage(domainName string) std.Address {\n\treturn registrar.GetOwner(domainName)\n}\n"},{"name":"resolver_metadata.gno","body":"package resolver\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo1/domain\"\n)\n\n// Metadata wrapper\nfunc MetadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcrrTime := time.Now()\n\texpTime := crrTime.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", crrTime, expTime, []domain.Trait{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"tte3ged4935d7oA5Y9jaTJCpYh4PT7g1SWSZlgFOYo0fvlnhLJo0OSFTtc1j95Z2EHppeV3BXi0kw8D5dFkoZg=="}],"memo":""},"blockNum":"1419053"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"S7adD7QVgdmKe/GbUUNzUknW8iDZ89ArF/qzVb8ISV85L2OHZfp8BMHdHoVQ8OEux7HKZ8ImmnhWAEBWfVwgtw=="}],"memo":""},"blockNum":"1419171"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/demo/domain/registrar","func":"Register","args":["thinhnx.gno","gnot"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"B9tJO6BkiKh7chsYMm2T/dkfK6DftM6MiP432MFFPtt9TUqrwcUkhy3AFX3HodExJjigTdD6GvAosk1VwmtUfg=="}],"memo":""},"blockNum":"1419397"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/demo/domain/registrar","func":"Register","args":["thinhnx.gno","gnot"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"bXNiesoDteEdct+iaKivA6/S7wi2oU2wu6fzV2cmAGh9ng+HKraCumHSZlwAxDdYkwG96SilMh3FMxEg+Eh/Ag=="}],"memo":""},"blockNum":"1420227"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo1/domain/registrar","func":"Register","args":["ngoc.gno","gnot"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"NlZdMlH/EOfjRK0ydryFTKq4dRtSIVEwIgSGORrZeFMxX4PNmz1buY+UNrDSnivvxkHHQdRPbW1ESDZobHFQNg=="}],"memo":""},"blockNum":"1420579"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"Bm3mgk/KltfUYjpHOJlC59+Rlgyke7x3Qmj5rO3G6eUwLcU0hds1/vABMcIiBKLykhEhOSZO60+ZEn2sOHoXog=="}],"memo":""},"blockNum":"1420664"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"3R73WGYZ4hZhRq8XjA9GZzWv6ZELFDL70rNBOyZ7QUlesfqYtrdtqR/glK6nZN5IRSONE7l7OQKOzZVCy91FpA=="}],"memo":""},"blockNum":"1420669"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"10000ugnot","pkg_path":"gno.land/r/varmeta/demo1/domain/registrar","func":"Register","args":["thinhnx","native"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"YDvf/G3w3VsYV3oOdbrmv7fY4Tin8YCG9k+RWV33LbEX09zk9Gs6qnHHvcPB5M5DKK3lOVsB2gq6rWImK0mSBw=="}],"memo":"Called through gno.studio"},"blockNum":"1421267"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"10000ugnot","pkg_path":"gno.land/r/varmeta/demo1/domain/registrar","func":"Register","args":["thinhnx.gno","native"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"8hljPI2la/YFyhI4S+jNTdgf2xpmh4Ei1sksLij9LTNgP48h01wm4l7Wz+flb4YRHGm/l1/RQyNk5GOAkGVBGA=="}],"memo":"Called through gno.studio"},"blockNum":"1421284"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo1/domain/registrar","func":"AdminSetFee","args":["99","1000"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"HmnHYExX+VCUTm/x/nVQKS1WVMnD4wK6whJ9KXKs8O17N8GfeY+E4m0S6F+ZnzWMaal0uETbHTlHgRJUq0x+jA=="}],"memo":"Called through gno.studio"},"blockNum":"1421512"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo1/domain/registrar","func":"Register","args":["ngoc2.gno","gnot"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"RKFvTaNl2WllmMnUgvP4upHL+aNoV6QUb/9CkECqXI1TKAuymCXOfMPZPDhNkpePaQGQbi8sNImNM+GgALesQg=="}],"memo":""},"blockNum":"1421587"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo/v1/grc/grc721","files":[{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"80000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"vg3RgCF7Ftc/Pd9Fk6oYMmyfOvXLPr6IDINdkHwPhyN6lKbdGBGj/4pNpP5dRs41ww8bVplRKFQVQEBBhmMVtg=="}],"memo":""},"blockNum":"1422235"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"domain","path":"gno.land/p/varmeta/demo/v1/domain","files":[{"name":"domain_metadata.gno","body":"package domain\n\nimport (\n\t\"time\"\n)\n\n// Trait represents a key-value pair with an optional display type for metadata attributes\ntype Trait struct {\n\tDisplayType string // Optional display type (e.g., \"date\", \"number\", etc.)\n\tTraitType   string // Type of the trait (e.g., \"age\", \"height\", etc.)\n\tValue       string // Value of the trait\n}\n\n// Metadata represents the metadata associated with a domain\ntype Metadata struct {\n\tAvatar           string    // URL or identifier for an avatar image\n\tRegistrationTime time.Time // The time when the domain was registered\n\tExpirationTime   time.Time // The time when the domain will be expire\n\tAttributes       []Trait   // Additional attributes of the domain\n\tDescription      string    // A description of the domain\n\tContactInfo      string    // Contact information for the domain owner\n\tRenewalFee       string    // The fee required to renew the domain, represented as a string\n}\n\n// NewMetadata creates a new Metadata instance\nfunc NewMetadata(avatar, description, contactInfo, renewalFee string,\n\tregistrationTime, expirationTime time.Time, attributes []Trait,\n) Metadata {\n\treturn Metadata{\n\t\tAvatar:           avatar,\n\t\tRegistrationTime: registrationTime,\n\t\tExpirationTime:   expirationTime,\n\t\tRenewalFee:       renewalFee,\n\t\tAttributes:       attributes,\n\t\tDescription:      description,\n\t\tContactInfo:      contactInfo,\n\t}\n}\n"},{"name":"domain_registry.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v1/grc/grc721\"\n)\n\n// domainRegistry represents a registry for domain names with metadata\ntype domainRegistry struct {\n\tdomains  grc721.IGRC721 // Interface for basic NFT functionality\n\tmetadata *avl.Tree      // AVL tree for storing domain metadata\n\texpDate  time.Time\n}\n\n// DomainRegistry defines the methods for managing domain names and metadata\ntype DomainRegistry interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(domainName string) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, domainName string) error\n\tTransferFrom(from, to std.Address, domainName string) error\n\tApprove(approved std.Address, domainName string) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(domainName string) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, domainName string) error\n\n\tRegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error\n\tSetDomainData(domainName string, metadata Metadata) error\n\tGetDomainData(domainName string, field MetadataField) (Metadata, error)\n\tGetDomainFields(domainName string, fields []MetadataField) (Metadata, error)\n\tRenewDomain(domainName string, additionalDuration time.Duration) error\n\tGetExpirationDate(domainName string) time.Time\n\tSetExpirationDate(domainName string, expDate time.Time) bool\n}\n\n// NewDomainRegistry creates a new domain registry with metadata extensions\nfunc NewDomainRegistry(name, symbol string) *domainRegistry {\n\tregistry := grc721.NewBasicNFT(name, symbol)\n\n\treturn \u0026domainRegistry{\n\t\tdomains:  registry,\n\t\tmetadata: avl.NewTree(),\n\t}\n}\n\n// RegisterDomain registers a new domain with the given metadata\nfunc (d *domainRegistry) RegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error {\n\terr := d.domains.Mint(owner, grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\td.expDate = time.Now().Add(dur)\n\td.metadata.Set(domainName, metadata)\n\n\treturn nil\n}\n\n// RenewDomain extends the expiration time of a domain name\nfunc (d *domainRegistry) RenewDomain(domainName string, additionalDuration time.Duration) error {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn ErrInvalidDomainName\n\t}\n\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\t// set new expiration date\n\td.expDate = d.expDate.Add(additionalDuration)\n\treturn nil\n}\n\n// SetDomainData sets the metadata for a given domain name\nfunc (d *domainRegistry) SetDomainData(domainName string, metadata Metadata) error {\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\td.metadata.Set(domainName, metadata)\n\treturn nil\n}\n\n// GetDomainFields retrieves multiple fields of metadata for a given domain\nfunc (d *domainRegistry) GetDomainFields(domainName string, fields []MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tif len(fields) == 0 {\n\t\treturn metadata, nil\n\t}\n\n\tvar result Metadata\n\tfor _, field := range fields {\n\t\tswitch field {\n\t\tcase FieldAvatar:\n\t\t\tresult.Avatar = metadata.Avatar\n\t\tcase FieldRegistrationTime:\n\t\t\tresult.RegistrationTime = metadata.RegistrationTime\n\t\tcase FieldExpirationTime:\n\t\t\tresult.ExpirationTime = metadata.ExpirationTime\n\t\tcase FieldRenewalFee:\n\t\t\tresult.RenewalFee = metadata.RenewalFee\n\t\tcase FieldAttributes:\n\t\t\tresult.Attributes = metadata.Attributes\n\t\tcase FieldDescription:\n\t\t\tresult.Description = metadata.Description\n\t\tcase FieldContactInfo:\n\t\t\tresult.ContactInfo = metadata.ContactInfo\n\t\tdefault:\n\t\t\treturn Metadata{}, ErrInvalidMetadataField\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// GetDomainData retrieves metadata for a given domain\nfunc (d *domainRegistry) GetDomainData(domainName string, field MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tswitch field {\n\tcase FieldAvatar:\n\t\treturn Metadata{\n\t\t\tAvatar: metadata.Avatar,\n\t\t}, nil\n\tcase FieldRegistrationTime:\n\t\treturn Metadata{\n\t\t\tRegistrationTime: metadata.RegistrationTime,\n\t\t}, nil\n\tcase FieldExpirationTime:\n\t\treturn Metadata{\n\t\t\tExpirationTime: metadata.ExpirationTime,\n\t\t}, nil\n\tcase FieldRenewalFee:\n\t\treturn Metadata{\n\t\t\tRenewalFee: metadata.RenewalFee,\n\t\t}, nil\n\tcase FieldAttributes:\n\t\treturn Metadata{\n\t\t\tAttributes: metadata.Attributes,\n\t\t}, nil\n\tcase FieldDescription:\n\t\treturn Metadata{\n\t\t\tDescription: metadata.Description,\n\t\t}, nil\n\tcase FieldContactInfo:\n\t\treturn Metadata{\n\t\t\tContactInfo: metadata.ContactInfo,\n\t\t}, nil\n\tdefault:\n\t\treturn Metadata{}, ErrInvalidMetadataField\n\t}\n}\n\n// BalanceOf returns the number of domains owned by a given address\nfunc (d *domainRegistry) BalanceOf(owner std.Address) (uint64, error) {\n\treturn d.domains.BalanceOf(owner)\n}\n\n// OwnerOf returns the owner of a given domain name\nfunc (d *domainRegistry) OwnerOf(domainName string) (std.Address, error) {\n\treturn d.domains.OwnerOf(grc721.TokenID(domainName))\n}\n\n// SafeTransferFrom safely transfers a domain from one address to another\nfunc (d *domainRegistry) SafeTransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.SafeTransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// TransferFrom transfers a domain from one address to another\nfunc (d *domainRegistry) TransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.TransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// Approve grants approval to another address to manage a specific domain\nfunc (d *domainRegistry) Approve(approved std.Address, domainName string) error {\n\treturn d.domains.Approve(approved, grc721.TokenID(domainName))\n}\n\n// SetApprovalForAll sets approval for an operator to manage all domains of the owner\nfunc (d *domainRegistry) SetApprovalForAll(operator std.Address, approved bool) error {\n\treturn d.domains.SetApprovalForAll(operator, approved)\n}\n\n// GetApproved returns the approved address for a specific domain\nfunc (d *domainRegistry) GetApproved(domainName string) (std.Address, error) {\n\treturn d.domains.GetApproved(grc721.TokenID(domainName))\n}\n\n// IsApprovedForAll checks if an operator is approved to manage all domains of the owner\nfunc (d *domainRegistry) IsApprovedForAll(owner, operator std.Address) bool {\n\treturn d.domains.IsApprovedForAll(owner, operator)\n}\n\n// Mint creates a new domain for a given address\nfunc (d *domainRegistry) Mint(to std.Address, domainName string) error {\n\treturn d.domains.Mint(to, grc721.TokenID(domainName))\n}\n\nfunc (d *domainRegistry) GetExpirationDate(domainName string) time.Time {\n\treturn d.expDate\n}\n\nfunc (d *domainRegistry) SetExpirationDate(domainName string, expDate time.Time) bool {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn false\n\t}\n\td.expDate = expDate\n\treturn true\n}\n"},{"name":"domain_registry_test.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo1/grc/grc721\"\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/urequire\"\n)\n\nvar (\n\taddr1 = testutils.TestAddress(\"bob\")\n\taddr2 = testutils.TestAddress(\"alice\")\n)\n\nfunc TestRegisterDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Successful Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"contact@registered.com\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Duplicate Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\terr := registry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.owner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr1,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr2,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\t\t\terr := registry.SetDomainData(c.domainName, c.metadata)\n\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\tretrievedMetadata, err := registry.GetDomainData(c.domainName, FieldAvatar)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.metadata.Avatar, retrievedMetadata.Avatar)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRenewDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname           string\n\t\towner          std.Address\n\t\tcaller         std.Address\n\t\tdomainName     string\n\t\tadditionalTime time.Duration\n\t\texpectError    bool\n\t\texpectedExpiry time.Time\n\t}{\n\t\t{\n\t\t\tname:           \"Successful Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr1,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"Non-Owner Attempts Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr2,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A renewable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.RenewDomain(c.domainName, c.additionalTime)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\trenewedMetadata, err := registry.GetDomainData(c.domainName, FieldExpirationTime)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\t// urequire.True(t, renewedMetadata.ExpirationTime.After(metadata.ExpirationTime))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfield       MetadataField\n\t\texpectError bool\n\t\texpectedVal string\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Avatar\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: false,\n\t\t\texpectedVal: \"avatar_url\",\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain Name\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t_, err := registry.GetDomainData(c.domainName, c.field)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainFields(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfields      []MetadataField\n\t\texpectError bool\n\t\texpected    Metadata\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Multiple Fields\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar, FieldDescription, FieldContactInfo},\n\t\t\texpectError: false,\n\t\t\texpected: Metadata{\n\t\t\t\tAvatar:      \"avatar_url\",\n\t\t\t\tDescription: \"A test domain\",\n\t\t\t\tContactInfo: \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tretrievedMetadata, err := registry.GetDomainFields(c.domainName, c.fields)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.expected.Avatar, retrievedMetadata.Avatar)\n\t\t\t\turequire.Equal(t, c.expected.Description, retrievedMetadata.Description)\n\t\t\t\turequire.Equal(t, c.expected.ContactInfo, retrievedMetadata.ContactInfo)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTransferDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tnewOwner    std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"Successful Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr1,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Non-Owner Attempts Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr2,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A transferable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.TransferFrom(c.owner, c.newOwner, c.domainName)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), grc721.ErrTransferFromIncorrectOwner.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.newOwner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"errors.gno","body":"package domain\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnauthorized         = errors.New(\"caller is not domain owner\")\n\tErrInvalidDomainName    = errors.New(\"invalid domain name\")\n\tErrInvalidMetadataField = errors.New(\"invalid metadata field\")\n\tErrInsufficientFunds    = errors.New(\"insufficient funds for renewal\")\n)\n"},{"name":"utils.gno","body":"package domain\n\ntype MetadataField int\n\nconst (\n\tFieldAvatar MetadataField = iota\n\tFieldRegistrationTime\n\tFieldRenewalFee\n\tFieldExpirationTime\n\tFieldAttributes\n\tFieldDescription\n\tFieldContactInfo\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"8000000","gas_fee":"1000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"0LNTCD1KwgHIUMqoGAD2H9qIsy7sDQ3+tbmNds0y0kUM/bteM8EIbXwZWiJaPn91Oo8d4J/Eo43TrPrgZO4iow=="}],"memo":""},"blockNum":"1422249"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo/v1/domain/registrar","files":[{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\n// Admin set register fee and renewal fee\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(3)\n\terr := ufmt.Sprintf(\"unauthorize with caller: %s\\n\", caller)\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo/v1/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc MetadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v1/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     10,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v1/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// not need to revertFee because if the registering is failed, then the coin is not deducted.\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\t// revertTransfer(requestInfo.Caller)\n\t\t// return regResult.ResultDetails.Error()\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := MetadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"time\"\n)\n\nvar (\n\tdefaultExpireTime             = time.Hour // 30 days\n\treName                        = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tassertIsAdmin()\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"80000000","gas_fee":"1000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"ZegyCowUSPvQFq9M7LlGoEMP8TA1K0m6wby6q9WTmak70ndjYN6lC0IyltEi+lj4rew2Iq/v3G7ca1V7I7qDKA=="}],"memo":""},"blockNum":"1422262"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"resolver","path":"gno.land/r/varmeta/demo/v1/domain/resolver","files":[{"name":"checks_resolver.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage resolver\n\nimport (\n\t\"regexp\"\n\t\"time\"\n\n\t\"gno.land/r/varmeta/demo/v1/domain/registrar\"\n)\n\n// const (\n// \tadmin std.Address = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\" // -\u003e @thinhnx\n// )\n\nvar reName = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc isExpired(dName string) bool {\n\texpDate := registrar.GetExpirationDate(dName)\n\treturn expDate.Before(time.Now())\n}\n"},{"name":"errors.gno","body":"package resolver\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrNotFound          = errors.New(\"not found\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"invalid domain name to register\")\n)\n"},{"name":"resolver.gno","body":"/*\nThe goal of the Resolver contract is keep track of the address for each ICNS name in a stateful manner.\nIt serves the purpose of \"resolving\" the ICNS Name\nto the correct address (e.g \"alice.gno\" -\u003e g1xxx).\n*/\n// changelogs: move Register feature into this resolver package\n// changelogs2: Removed local storage of resolver as cache, and every querires we query to registrar to get the result\n\npackage resolver\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/varmeta/demo/v1/domain/registrar\"\n)\n\ntype Record struct {\n\tOwner    std.Address\n\tIsValid  bool\n\tMemo     string // no more need this\n\tPriority int\n}\n\n// retrieve the record list to get the onchain address\nfunc Resolve(domainName string) *Record {\n\tif !isValidDomain(domainName) {\n\t\tpanic(\"bad domain name\")\n\t}\n\trecord := \u0026Record{}\n\n\towner := getOwnerFromDomainStorage(domainName)\n\tif owner == \"\" {\n\t\trecord.Memo = \"not found\"\n\t\trecord.IsValid = false\n\t\treturn record\n\t}\n\n\tif !isExpired(domainName) {\n\t\trecord.IsValid = true\n\t\trecord.Owner = owner\n\t} else {\n\t\trecord.IsValid = false\n\t}\n\treturn record\n}\n\nfunc GetDomainName(addr string) []string {\n\treturn registrar.GetDomainName(addr)\n}\n\n/*\nIf query in local storage not found\nQuery to DomainStorage by domainName -\u003e get the registry -\u003e use that registry to get the Owner()\nand check the validation time?\n*/\n\nfunc existedInDomainStorage(domainName string) bool {\n\treturn registrar.AlreadyRegistered(domainName)\n}\n\nfunc getOwnerFromDomainStorage(domainName string) std.Address {\n\treturn registrar.GetOwner(domainName)\n}\n"},{"name":"resolver_metadata.gno","body":"package resolver\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v1/domain\"\n)\n\n// Metadata wrapper\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcrrTime := time.Now()\n\texpTime := crrTime.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", crrTime, expTime, []domain.Trait{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"w1Dl5+ivpUfygO1jj7S/vbHObD6qaO592AMhBE3kUO1AnhFb7J2FIGNmM4XqyYuFOnHT/bQMW8pRWxBIq0ml9Q=="}],"memo":""},"blockNum":"1422268"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v1/domain/registrar","func":"AdminSetFee","args":["99","10"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"OpReXhGFHguOzKx8mkOB+qKPDWw9iVHS0WtuqXuRRB4NM7TM2F3CsrGk6CrI0j1bCqGizldQtjJrw+CwYNVwLQ=="}],"memo":"Called through gno.studio"},"blockNum":"1422286"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v1/domain/registrar","func":"Register","args":["thinhnx.gno","native"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"lbXpjNk/owa4pvsfGwGQPvz5ncr//PUitx/B6g6HqEJprwG2Qy8dxqBHk+5AJMQbXgOoRiDUbb9t/ptSADT0Gg=="}],"memo":"Called through gno.studio"},"blockNum":"1422328"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"LZfCUOk6mHVvRe1WoENTtyxOEVw/GcPDG3jz+EwmSs8H7PRKD2lKnffbWdTLO0ExNG3cM8q/3kcnonfx9KESTQ=="}],"memo":""},"blockNum":"1422472"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v1/domain/resolver","func":"GetDomainName","args":["g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"nN4XMKRBDrIp11Pj1i7ElZ3JFwddAYOwu7DFvxELiYUSsunRKxQ5zVrZkHUZWZQgWJuxNMsX8VzEH93vnLmOXg=="}],"memo":"Called through gno.studio"},"blockNum":"1422655"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp","package":{"name":"hello","path":"gno.land/r/g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3SL/KbkKFGc1Y4jvzfQKtUHJxVebp7ZO15NqvbqWAog"},"signature":"9GOqKiQFJDe8GzPTu1kjVP/1uXj8z1x5mLuXnK2/ur9Catl+aEEMcJT5fdEydK94SeqBPw+gJ0eQ6s+0HDpsnA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"1424624"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp","send":"","pkg_path":"gno.land/r/sys/users","func":"IsAuthorizedAddressForName","args":["g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp","g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3SL/KbkKFGc1Y4jvzfQKtUHJxVebp7ZO15NqvbqWAog"},"signature":"uOdSKd8aBAHnV4iiyYhvpdVd3enZE5S66svxgKQxHk0R/9HwWFsxRP9tHsXm3i9Jct+dVSscrXnOBp6gg1zTvQ=="}],"memo":"Called through gno.studio"},"blockNum":"1424658"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp","send":"","pkg_path":"gno.land/r/sys/users","func":"IsAuthorizedAddressForName","args":["g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp","g14n0zsnsk054uxwvnwmmqyrq6e87ynk5vq98qqp"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3SL/KbkKFGc1Y4jvzfQKtUHJxVebp7ZO15NqvbqWAog"},"signature":"Niti6tnSfNQ0ia905Qbrkql3a6gH1FoJ6KlgZ5f8cjR1+5ZTSAXT7ty/qBLWo5V/ltwEUDgAnz/8fZIssPe7dA=="}],"memo":"Called through gno.studio"},"blockNum":"1424694"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/onbloc/pepe","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/onbloc/pepe\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"Yya7jgygz6qaCT6oteBvY6CTeqam8y8xTZ/fz81svQtoJ4cT3L4tvZ02dy1Im/ffDrA/pIUaPvQ398aHeEDSSw=="}],"memo":""},"blockNum":"1427056"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/onbloc/pepe","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/onbloc/pepe\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"47lL4LRb4lToiQeLqv5EPuZhwoKRjsIdVl2+LU59HFR8TtNuuwVdLxHl7YEh9zB6BPyDPr2sUpaym3J0O6B1bQ=="}],"memo":""},"blockNum":"1427057"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/blake_lee/blake","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/blake_lee/blake\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"RvP4N+bSigNgByYFw2UJwLfV1QywV6ZG41RUrkTaYBthG5JvF/eeS+UmpTykt+lEpfgmuJPAcYyxXL6+hUW3dA=="}],"memo":""},"blockNum":"1427088"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/blake_lee/blake20","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/blake_lee/blake20\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"LZkQVs5V35Q12o3nrwIgxL9Qxh+ms58LVVirie3keeNMf671GURS4/uK6xLeVyUMwZMk1a5hNZ7vkO85DXCl2A=="}],"memo":""},"blockNum":"1427089"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"jNawu8TeSaODhqCY4q0vD00hqJgsze6gp2lfYV0tRY9Eq01qjGzHnRzLlTEIXvnmO3RecBXaoiQj9+6S8juIHQ=="}],"memo":""},"blockNum":"1427103"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"JXA32Fi13Kxqdk4tRhy0MiybyoBH0Nf4RXUs/v6Qb2dgiNBMxn4Ilj350cOo6XL7S5FM5EnhGLDR8R02jzqf1g=="}],"memo":""},"blockNum":"1427105"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"FZqoAsjaPAZZJUViEfVlb3qKBJ+U0tIKAslQih+l0HYlO9vKmKBRHLoB2ccwPAayU6eTy7hNoPrVDFqhIT4k2w=="}],"memo":""},"blockNum":"1427107"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"eZU9exLpYYScU+bEHxBLmtitLwgcI1ax64NXGpimnh9D4hTkeAqr4yaADkW0BMClDKZRDe6iTgMNBJErbAzKxQ=="}],"memo":""},"blockNum":"1427108"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"Cl7fN2xCgoBvwZFb5illZnTp1VY/C4ygnWqpuA+iB5B9zm0zNqcDa01unx1m0vVcKxZoP2FcSD9gylzBwCPjbA=="}],"memo":""},"blockNum":"1427136"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/grc20_launchpad","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/grc20_launchpad\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"mhArVRgKu5qqY/zNlEQqPXRTENzmJO203UFVRNfaKQxu3c2zmmZ2bS/XZzhBG4eVPVIrp02oDfkBQA48sjcgeg=="}],"memo":""},"blockNum":"1427141"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/lunc","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/lunc\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"xi0Cf7L1oWNaCf7y0dhkX0Q7N+3PYWCKHNM9sWNSpHVOhbVWbFb/kfB+DXpWM1m6Zr/+Rv1CZa/R0qL/A7NHSQ=="}],"memo":""},"blockNum":"1427142"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/wif","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/wif\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"GD+SUkWItnyQTNpVNOdn8XdxNKqacdx+hB7B9gGT7PcolP7DufuSeyySrGcbFp0QsCawHLI42ZkWm6jQ1dqdtQ=="}],"memo":""},"blockNum":"1427157"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/tofu","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/tofu\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"KCAG3r1Wn+hXmVZ9knXOKG00klFNhDMAZekYKpbG3V4gN8DSMcn6wwb9vvHfkXMH9D5u1xUG3ZclNQTWeKzaaQ=="}],"memo":""},"blockNum":"1427158"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"Gq2xvMtKotJisvvdDo4sznaKIp4f8e+6D3hvzLDWvRwBx2vLFO/iBrrS9Yex0cxCHv7SFW/g0UqriYtDbNfbAQ=="}],"memo":""},"blockNum":"1427263"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"6pdRoEdPpw9xqkLSJIigQkH7wOhInt9orkWfQ1skvXwsb1Q6jvZJvMOQK6wmWugVbUghKPANDM4zivp2nAjEpg=="}],"memo":""},"blockNum":"1427264"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"GkXcad+Apu2cOAM0hJwR5P+VIko6iqdtzpqJyWwfbbYAspWoAROHClw616PC/m34B943x07XHjsjZMpx0tBv1Q=="}],"memo":""},"blockNum":"1427266"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"1WkcKBdEdrK6dU19ZoTo0BJV8D2xsu4Ozb3mH74ZJwUsT+h2RVtwebYTR9saQ7Ls8P0dStlKMKW7fPfuddoD+w=="}],"memo":""},"blockNum":"1427320"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"zjqcF4d+GkCPGFaKuCXMTAOiwQUJjgZg3HD7Mv2gfnhUf6tk51IMlTRNmQM/2t1rpwUy86hEtN9cW30Fk6QBVA=="}],"memo":""},"blockNum":"1427323"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","package":{"name":"diceroller","path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v1/diceroller","files":[{"name":"diceroller.gno","body":"package diceroller\n\nimport (\n\t\"errors\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/entropy\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\ntype (\n\t// game represents a Dice Roller game between two players\n\tgame struct {\n\t\tplayer1, player2 std.Address\n\t\troll1, roll2     int\n\t}\n\n\t// player holds the information about each player including their stats\n\tplayer struct {\n\t\taddr                              std.Address\n\t\twins, losses, draws, points, rank int\n\t}\n\n\t// leaderBoard is a slice of players, used to sort players by rank\n\tleaderBoard []player\n)\n\nconst (\n\t// Constants to represent game result outcomes\n\tempty = iota\n\twin\n\tdraw\n\tlose\n)\n\nvar (\n\tgames  avl.Tree // AVL tree for storing game states\n\tgameId seqid.ID // Sequence ID for games\n\n\tplayers avl.Tree // AVL tree for storing player data\n\n\tseed = uint64(entropy.New().Seed())\n)\n\nfunc init() {\n\t// Pre-define two players for initial setup\n\taddr1 := std.Address(\"g1y490harzjqmdngmmaw4tyc4qdm5ma5k0fv3w6p\")\n\taddr2 := std.Address(\"g1z4dfj9dvknvahykg3rhjrpsexhp4vl8gnde27q\")\n\n\t// Initialize two players and their initial game stats\n\tplayers.Set(addr1.String(), \u0026player{\n\t\taddr:   addr1,\n\t\twins:   1,\n\t\tpoints: 3, // Wins give 3 points\n\t})\n\n\tplayers.Set(addr2.String(), \u0026player{\n\t\taddr:   addr2,\n\t\tlosses: 1,\n\t\tpoints: 0, // Losses give 0 points\n\t})\n\n\tgames.Set(gameId.Next().String(), \u0026game{\n\t\tplayer1: addr1,\n\t\tplayer2: addr2,\n\t\troll1:   6,\n\t\troll2:   5,\n\t})\n}\n\n// rollDice generates a random dice roll between 1 and 6\nfunc rollDice() int {\n\tr := rand.New(rand.NewPCG(seed, 0xdeadbeef))\n\treturn r.IntN(6) + 1\n}\n\n// NewGame initializes a new game with the provided opponent's address\nfunc NewGame(addr std.Address) int {\n\tif !addr.IsValid() {\n\t\tpanic(\"invalid opponent's address\")\n\t}\n\n\tgames.Set(gameId.Next().String(), \u0026game{\n\t\tplayer1: std.PrevRealm().Addr(),\n\t\tplayer2: addr,\n\t})\n\n\treturn int(gameId)\n}\n\n// Play allows a player to roll the dice and updates the game state accordingly\nfunc Play(idx int) int {\n\tg, err := getGame(idx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\troll := rollDice() // Random the player's dice roll\n\n\t// Play the game and update the player's roll\n\tif err := g.play(std.PrevRealm().Addr(), roll); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// If both players have rolled, update the results and leaderboard\n\tif g.roll1 != 0 \u0026\u0026 g.roll2 != 0 {\n\t\t// If the player is playing against themselves, no points are awarded\n\t\tif g.player1 == g.player2 {\n\t\t\treturn roll\n\t\t}\n\n\t\tplayer1 := getPlayer(g.player1)\n\t\tplayer2 := getPlayer(g.player2)\n\n\t\tif g.roll1 \u003e g.roll2 {\n\t\t\tplayer1.updateResult(win)\n\t\t\tplayer2.updateResult(lose)\n\t\t} else if g.roll2 \u003e g.roll1 {\n\t\t\tplayer2.updateResult(win)\n\t\t\tplayer1.updateResult(lose)\n\t\t} else {\n\t\t\tplayer1.updateResult(draw)\n\t\t\tplayer2.updateResult(draw)\n\t\t}\n\t}\n\n\treturn roll\n}\n\n// play processes a player's roll and updates their score\nfunc (g *game) play(player std.Address, roll int) error {\n\tif player != g.player1 \u0026\u0026 player != g.player2 {\n\t\treturn errors.New(\"invalid player\")\n\t}\n\n\tif g.roll1 != 0 \u0026\u0026 g.roll2 != 0 {\n\t\treturn errors.New(\"game over\")\n\t}\n\n\tif player == g.player1 \u0026\u0026 g.roll1 == 0 {\n\t\tg.roll1 = roll\n\t\treturn nil\n\t}\n\n\tif player == g.player2 \u0026\u0026 g.roll2 == 0 {\n\t\tg.roll2 = roll\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"already played\")\n}\n\n// winner determines the winner based on scores\nfunc (g *game) winner() string {\n\tif g.roll1 == 0 || g.roll2 == 0 {\n\t\treturn \"Game still in progress\"\n\t}\n\n\tif g.roll1 \u003e g.roll2 {\n\t\treturn \"Player 1 wins!\"\n\t} else if g.roll2 \u003e g.roll1 {\n\t\treturn \"Player 2 wins!\"\n\t} else {\n\t\treturn \"It's a draw!\"\n\t}\n}\n\n// diceIcon returns an icon of the dice roll\nfunc diceIcon(roll int) string {\n\tswitch roll {\n\tcase 1:\n\t\treturn \"1\"\n\tcase 2:\n\t\treturn \"2\"\n\tcase 3:\n\t\treturn \"3\"\n\tcase 4:\n\t\treturn \"4\"\n\tcase 5:\n\t\treturn \"5\"\n\tcase 6:\n\t\treturn \"6\"\n\tdefault:\n\t\treturn strconv.Itoa(roll)\n\t}\n}\n\n// Render provides a summary of the current state of games and leader board\nfunc Render(path string) string {\n\toutput := `#  Dice Roller\n\n## Game Rules:\nDice Roller is a two-player game where each player rolls a dice once.\n1. **Create a game** with an opponent using [NewGame](diceroller?help\u0026__func=NewGame)\n2. **Play** using [Play](diceroller?help\u0026__func=Play), where each player rolls a dice\n\n## Scoring:\n- Playing against yourself? No points or stats changes for you\n- **Win:** 3 points\n- **Loss:** 0 points\n- **Draw:** 1 point each\n\n## Actions:\n* [NewGame](diceroller?help\u0026__func=NewGame) opponentAddress\n  - **opponentAddress**: The address of the opponent player\n* [Play](diceroller?help\u0026__func=Play) gameIndex\n  - **gameIndex**: The unique index of the game you want to play\n\n## Recent Games:\nDisplays a summary of the most recent games. Up to 10 recent games are shown\n\n| Game | Player 1 | Roll 1 | Player 2 | Roll 2 | Winner |\n|------|----------|--------|----------|--------|--------|\n`\n\n\t// Display up to 10 recent games\n\tmaxGames := 10\n\tfor n := int(gameId); n \u003e 0 \u0026\u0026 int(gameId)-n \u003c maxGames; n-- {\n\t\tg, err := getGame(n)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\toutput += strconv.Itoa(n) + \" | \" +\n\t\t\tshortName(g.player1) + \" | \" + diceIcon(g.roll1) + \" | \" +\n\t\t\tshortName(g.player2) + \" | \" + diceIcon(g.roll2) + \" | \" +\n\t\t\tg.winner() + \"\\n\"\n\t}\n\n\t// Display the leader board\n\toutput += `\n## Leader board:\nDisplays the current ranking of players based on their performance in Dice Roller\n\n| Rank | Player                | Wins | Losses | Draws | Points |\n|------|-----------------------|------|--------|-------|--------|\n`\n\n\tfor i, player := range getLeaderBoard() {\n\t\trankIcon := strconv.Itoa(i)\n\n\t\tif i == 0 {\n\t\t\trankIcon = \"\"\n\t\t} else if i == 1 {\n\t\t\trankIcon = \"\"\n\t\t} else if i == 2 {\n\t\t\trankIcon = \"\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"| %s   | %s | %d | %d | %d | %d |\\n\",\n\t\t\trankIcon,\n\t\t\tshortName(player.addr),\n\t\t\tplayer.wins,\n\t\t\tplayer.losses,\n\t\t\tplayer.draws,\n\t\t\tplayer.points,\n\t\t)\n\t}\n\n\treturn output\n}\n\n// shortName returns a shortened name for the given address\nfunc shortName(addr std.Address) string {\n\tuser := users.GetUserByAddress(addr)\n\tif user != nil {\n\t\treturn user.Name\n\t}\n\tif len(addr) \u003c 10 {\n\t\treturn string(addr)\n\t}\n\treturn string(addr)[:10] + \"...\"\n}\n\n// getGame retrieves the game state by its ID\nfunc getGame(idx int) (*game, error) {\n\tv, ok := games.Get(seqid.ID(idx).String())\n\tif !ok {\n\t\treturn nil, errors.New(\"game not found\")\n\t}\n\treturn v.(*game), nil\n}\n\n// updateResult updates the player's result and points based on the game outcome\nfunc (p *player) updateResult(result int) {\n\tswitch result {\n\tcase win:\n\t\tp.wins++\n\t\tp.points += 3\n\tcase lose:\n\t\tp.losses++\n\tcase draw:\n\t\tp.draws++\n\t\tp.points++\n\t}\n}\n\n// getPlayer retrieves a player or initializes a new one if they don't exist\nfunc getPlayer(addr std.Address) *player {\n\tv, ok := players.Get(addr.String())\n\tif !ok {\n\t\tplayer := \u0026player{\n\t\t\taddr: addr,\n\t\t}\n\t\tplayers.Set(addr.String(), player)\n\t\treturn player\n\t}\n\n\treturn v.(*player)\n}\n\n// getLeaderBoard generates a leaderboard sorted by points\nfunc getLeaderBoard() leaderBoard {\n\tboard := leaderBoard{}\n\tplayers.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tplayer := value.(*player)\n\t\tboard = append(board, *player)\n\t\treturn false\n\t})\n\n\tsort.Sort(board)\n\n\treturn board\n}\n\n// Methods for sorting the leaderboard\nfunc (r leaderBoard) Len() int {\n\treturn len(r)\n}\n\nfunc (r leaderBoard) Less(i, j int) bool {\n\treturn r[i].points \u003e r[j].points\n}\n\nfunc (r leaderBoard) Swap(i, j int) {\n\tr[i].points, r[j].points = r[j].points, r[i].points\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"D7QysJPt2vUY+/wErmK/h2tWT4QknhwETNo5CBI9Imw9x+4wmYTMZ/JBsuWTZSktkrjjBjTZWa+nLCjWhkJFWg=="}],"memo":""},"blockNum":"1429974"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","package":{"name":"entropy","path":"gno.land/p/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/entropy","files":[{"name":"entropy.gno","body":"// Entropy generates fully deterministic, cost-effective, and hard to guess\n// numbers.\n//\n// It is designed both for single-usage, like seeding math/rand or for being\n// reused which increases the entropy and its cost effectiveness.\n//\n// Disclaimer: this package is unsafe and won't prevent others to guess values\n// in advance.\n//\n// It uses the Bernstein's hash djb2 to be CPU-cycle efficient.\npackage entropy\n\nimport (\n\t\"math\"\n\t\"std\"\n\t\"time\"\n)\n\ntype Instance struct {\n\tvalue uint32\n}\n\nfunc New() *Instance {\n\tr := Instance{value: 5381}\n\tr.addEntropy()\n\treturn \u0026r\n}\n\nfunc FromSeed(seed uint32) *Instance {\n\tr := Instance{value: seed}\n\tr.addEntropy()\n\treturn \u0026r\n}\n\nfunc (i *Instance) Seed() uint32 {\n\treturn i.value\n}\n\nfunc (i *Instance) djb2String(input string) {\n\tfor _, c := range input {\n\t\ti.djb2Uint32(uint32(c))\n\t}\n}\n\n// super fast random algorithm.\n// http://www.cse.yorku.ca/~oz/hash.html\nfunc (i *Instance) djb2Uint32(input uint32) {\n\ti.value = (i.value \u003c\u003c 5) + i.value + input\n}\n\n// AddEntropy uses various runtime variables to add entropy to the existing seed.\nfunc (i *Instance) addEntropy() {\n\t// FIXME: reapply the 5381 initial value?\n\n\t// inherit previous entropy\n\t// nothing to do\n\n\t// handle callers\n\t{\n\t\tcaller1 := std.GetCallerAt(1).String()\n\t\ti.djb2String(caller1)\n\t\tcaller2 := std.GetCallerAt(2).String()\n\t\ti.djb2String(caller2)\n\t}\n\n\t// height\n\t{\n\t\theight := std.GetHeight()\n\t\tif height \u003e= math.MaxUint32 {\n\t\t\theight -= math.MaxUint32\n\t\t}\n\t\ti.djb2Uint32(uint32(height))\n\t}\n\n\t// time\n\t{\n\t\tsecs := time.Now().Second()\n\t\ti.djb2Uint32(uint32(secs))\n\t\tnsecs := time.Now().Nanosecond()\n\t\ti.djb2Uint32(uint32(nsecs))\n\t}\n\n\t// FIXME: compute other hard-to-guess but deterministic variables, like real gas?\n}\n\nfunc (i *Instance) Value() uint32 {\n\ti.addEntropy()\n\treturn i.value\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"pAlkwgUTVKOta9woMktv8nSHBcyKIdgXd4dZxX1voeAgFvozryGLYNA7uyhhUVpy5dzx+oO3KSGsoFWDig/xmQ=="}],"memo":""},"blockNum":"1430099"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","package":{"name":"diceroller","path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v1/diceroller","files":[{"name":"diceroller.gno","body":"package diceroller\n\nimport (\n\t\"errors\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/entropy\"\n\t\"gno.land/r/demo/users\"\n)\n\ntype (\n\t// game represents a Dice Roller game between two players\n\tgame struct {\n\t\tplayer1, player2 std.Address\n\t\troll1, roll2     int\n\t}\n\n\t// player holds the information about each player including their stats\n\tplayer struct {\n\t\taddr                              std.Address\n\t\twins, losses, draws, points, rank int\n\t}\n\n\t// leaderBoard is a slice of players, used to sort players by rank\n\tleaderBoard []player\n)\n\nconst (\n\t// Constants to represent game result outcomes\n\tempty = iota\n\twin\n\tdraw\n\tlose\n)\n\nvar (\n\tgames  avl.Tree // AVL tree for storing game states\n\tgameId seqid.ID // Sequence ID for games\n\n\tplayers avl.Tree // AVL tree for storing player data\n\n\tseed = uint64(entropy.New().Seed())\n)\n\nfunc init() {\n\t// Pre-define two players for initial setup\n\taddr1 := std.Address(\"g1y490harzjqmdngmmaw4tyc4qdm5ma5k0fv3w6p\")\n\taddr2 := std.Address(\"g1z4dfj9dvknvahykg3rhjrpsexhp4vl8gnde27q\")\n\n\t// Initialize two players and their initial game stats\n\tplayers.Set(addr1.String(), \u0026player{\n\t\taddr:   addr1,\n\t\twins:   1,\n\t\tpoints: 3, // Wins give 3 points\n\t})\n\n\tplayers.Set(addr2.String(), \u0026player{\n\t\taddr:   addr2,\n\t\tlosses: 1,\n\t\tpoints: 0, // Losses give 0 points\n\t})\n\n\tgames.Set(gameId.Next().String(), \u0026game{\n\t\tplayer1: addr1,\n\t\tplayer2: addr2,\n\t\troll1:   6,\n\t\troll2:   5,\n\t})\n}\n\n// rollDice generates a random dice roll between 1 and 6\nfunc rollDice() int {\n\tr := rand.New(rand.NewPCG(seed, 0xdeadbeef))\n\treturn r.IntN(6) + 1\n}\n\n// NewGame initializes a new game with the provided opponent's address\nfunc NewGame(addr std.Address) int {\n\tif !addr.IsValid() {\n\t\tpanic(\"invalid opponent's address\")\n\t}\n\n\tgames.Set(gameId.Next().String(), \u0026game{\n\t\tplayer1: std.PrevRealm().Addr(),\n\t\tplayer2: addr,\n\t})\n\n\treturn int(gameId)\n}\n\n// Play allows a player to roll the dice and updates the game state accordingly\nfunc Play(idx int) int {\n\tg, err := getGame(idx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\troll := rollDice() // Random the player's dice roll\n\n\t// Play the game and update the player's roll\n\tif err := g.play(std.PrevRealm().Addr(), roll); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// If both players have rolled, update the results and leaderboard\n\tif g.roll1 != 0 \u0026\u0026 g.roll2 != 0 {\n\t\t// If the player is playing against themselves, no points are awarded\n\t\tif g.player1 == g.player2 {\n\t\t\treturn roll\n\t\t}\n\n\t\tplayer1 := getPlayer(g.player1)\n\t\tplayer2 := getPlayer(g.player2)\n\n\t\tif g.roll1 \u003e g.roll2 {\n\t\t\tplayer1.updateResult(win)\n\t\t\tplayer2.updateResult(lose)\n\t\t} else if g.roll2 \u003e g.roll1 {\n\t\t\tplayer2.updateResult(win)\n\t\t\tplayer1.updateResult(lose)\n\t\t} else {\n\t\t\tplayer1.updateResult(draw)\n\t\t\tplayer2.updateResult(draw)\n\t\t}\n\t}\n\n\treturn roll\n}\n\n// play processes a player's roll and updates their score\nfunc (g *game) play(player std.Address, roll int) error {\n\tif player != g.player1 \u0026\u0026 player != g.player2 {\n\t\treturn errors.New(\"invalid player\")\n\t}\n\n\tif g.roll1 != 0 \u0026\u0026 g.roll2 != 0 {\n\t\treturn errors.New(\"game over\")\n\t}\n\n\tif player == g.player1 \u0026\u0026 g.roll1 == 0 {\n\t\tg.roll1 = roll\n\t\treturn nil\n\t}\n\n\tif player == g.player2 \u0026\u0026 g.roll2 == 0 {\n\t\tg.roll2 = roll\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"already played\")\n}\n\n// winner determines the winner based on scores\nfunc (g *game) winner() string {\n\tif g.roll1 == 0 || g.roll2 == 0 {\n\t\treturn \"Game still in progress\"\n\t}\n\n\tif g.roll1 \u003e g.roll2 {\n\t\treturn \"Player 1 wins!\"\n\t} else if g.roll2 \u003e g.roll1 {\n\t\treturn \"Player 2 wins!\"\n\t} else {\n\t\treturn \"It's a draw!\"\n\t}\n}\n\n// diceIcon returns an icon of the dice roll\nfunc diceIcon(roll int) string {\n\tswitch roll {\n\tcase 1:\n\t\treturn \"1\"\n\tcase 2:\n\t\treturn \"2\"\n\tcase 3:\n\t\treturn \"3\"\n\tcase 4:\n\t\treturn \"4\"\n\tcase 5:\n\t\treturn \"5\"\n\tcase 6:\n\t\treturn \"6\"\n\tdefault:\n\t\treturn strconv.Itoa(roll)\n\t}\n}\n\n// Render provides a summary of the current state of games and leader board\nfunc Render(path string) string {\n\toutput := `#  Dice Roller\n\n## Game Rules:\nDice Roller is a two-player game where each player rolls a dice once.\n1. **Create a game** with an opponent using [NewGame](diceroller?help\u0026__func=NewGame)\n2. **Play** using [Play](diceroller?help\u0026__func=Play), where each player rolls a dice\n\n## Scoring:\n- Playing against yourself? No points or stats changes for you\n- **Win:** 3 points\n- **Loss:** 0 points\n- **Draw:** 1 point each\n\n## Actions:\n* [NewGame](diceroller?help\u0026__func=NewGame) opponentAddress\n  - **opponentAddress**: The address of the opponent player\n* [Play](diceroller?help\u0026__func=Play) gameIndex\n  - **gameIndex**: The unique index of the game you want to play\n\n## Recent Games:\nDisplays a summary of the most recent games. Up to 10 recent games are shown\n\n| Game | Player 1 | Roll 1 | Player 2 | Roll 2 | Winner |\n|------|----------|--------|----------|--------|--------|\n`\n\n\t// Display up to 10 recent games\n\tmaxGames := 10\n\tfor n := int(gameId); n \u003e 0 \u0026\u0026 int(gameId)-n \u003c maxGames; n-- {\n\t\tg, err := getGame(n)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\toutput += strconv.Itoa(n) + \" | \" +\n\t\t\tshortName(g.player1) + \" | \" + diceIcon(g.roll1) + \" | \" +\n\t\t\tshortName(g.player2) + \" | \" + diceIcon(g.roll2) + \" | \" +\n\t\t\tg.winner() + \"\\n\"\n\t}\n\n\t// Display the leader board\n\toutput += `\n## Leader board:\nDisplays the current ranking of players based on their performance in Dice Roller\n\n| Rank | Player                | Wins | Losses | Draws | Points |\n|------|-----------------------|------|--------|-------|--------|\n`\n\n\tfor i, player := range getLeaderBoard() {\n\t\trankIcon := strconv.Itoa(i)\n\n\t\tif i == 0 {\n\t\t\trankIcon = \"\"\n\t\t} else if i == 1 {\n\t\t\trankIcon = \"\"\n\t\t} else if i == 2 {\n\t\t\trankIcon = \"\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"| %s   | %s | %d | %d | %d | %d |\\n\",\n\t\t\trankIcon,\n\t\t\tshortName(player.addr),\n\t\t\tplayer.wins,\n\t\t\tplayer.losses,\n\t\t\tplayer.draws,\n\t\t\tplayer.points,\n\t\t)\n\t}\n\n\treturn output\n}\n\n// shortName returns a shortened name for the given address\nfunc shortName(addr std.Address) string {\n\tuser := users.GetUserByAddress(addr)\n\tif user != nil {\n\t\treturn user.Name\n\t}\n\tif len(addr) \u003c 10 {\n\t\treturn string(addr)\n\t}\n\treturn string(addr)[:10] + \"...\"\n}\n\n// getGame retrieves the game state by its ID\nfunc getGame(idx int) (*game, error) {\n\tv, ok := games.Get(seqid.ID(idx).String())\n\tif !ok {\n\t\treturn nil, errors.New(\"game not found\")\n\t}\n\treturn v.(*game), nil\n}\n\n// updateResult updates the player's result and points based on the game outcome\nfunc (p *player) updateResult(result int) {\n\tswitch result {\n\tcase win:\n\t\tp.wins++\n\t\tp.points += 3\n\tcase lose:\n\t\tp.losses++\n\tcase draw:\n\t\tp.draws++\n\t\tp.points++\n\t}\n}\n\n// getPlayer retrieves a player or initializes a new one if they don't exist\nfunc getPlayer(addr std.Address) *player {\n\tv, ok := players.Get(addr.String())\n\tif !ok {\n\t\tplayer := \u0026player{\n\t\t\taddr: addr,\n\t\t}\n\t\tplayers.Set(addr.String(), player)\n\t\treturn player\n\t}\n\n\treturn v.(*player)\n}\n\n// getLeaderBoard generates a leaderboard sorted by points\nfunc getLeaderBoard() leaderBoard {\n\tboard := leaderBoard{}\n\tplayers.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tplayer := value.(*player)\n\t\tboard = append(board, *player)\n\t\treturn false\n\t})\n\n\tsort.Sort(board)\n\n\treturn board\n}\n\n// Methods for sorting the leaderboard\nfunc (r leaderBoard) Len() int {\n\treturn len(r)\n}\n\nfunc (r leaderBoard) Less(i, j int) bool {\n\treturn r[i].points \u003e r[j].points\n}\n\nfunc (r leaderBoard) Swap(i, j int) {\n\tr[i].points, r[j].points = r[j].points, r[i].points\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"PO3RpEsUsIxshoicS8GQwqD8lE/w3/h0niVSIjMoLdJCzbJy3KbG2UGmfIQkXphOYttRxEbdbbnijyzltUYmZA=="}],"memo":""},"blockNum":"1430100"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v1/diceroller","func":"NewGame","args":["g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"MCrtuQd7gAt+QgmoBgywU+on2qAsIFVRhUs4l1KBdd0dauCZayOfGrihfBsFmh9R/3xs2utTDXyeBfA6AmZp/g=="}],"memo":""},"blockNum":"1430135"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v1/diceroller","func":"Play","args":["2"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"XlKGswA6JGvCRsh5+nsfNgTXYo6zbKijcXOwDQoptxYcNuAGC2cLI+ccNLVbZLNfzBsWza3o1tcvifdedBGT4w=="}],"memo":""},"blockNum":"1430147"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v1/diceroller","func":"Play","args":["2"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"IdJpKElw3qaTiLa1qe1VQgq4K9IKHe9IUFa/XShEUFMgBw2ICGbFBxHHAoDbzAvshWV0svQbOK4ySAjTAF/fIw=="}],"memo":""},"blockNum":"1430149"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","package":{"name":"diceroller","path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v2/diceroller","files":[{"name":"diceroller.gno","body":"package diceroller\n\nimport (\n\t\"errors\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/entropy\"\n\t\"gno.land/r/demo/users\"\n)\n\ntype (\n\t// game represents a Dice Roller game between two players\n\tgame struct {\n\t\tplayer1, player2 std.Address\n\t\troll1, roll2     int\n\t}\n\n\t// player holds the information about each player including their stats\n\tplayer struct {\n\t\taddr                              std.Address\n\t\twins, losses, draws, points, rank int\n\t}\n\n\t// leaderBoard is a slice of players, used to sort players by rank\n\tleaderBoard []player\n)\n\nconst (\n\t// Constants to represent game result outcomes\n\tempty = iota\n\twin\n\tdraw\n\tlose\n)\n\nvar (\n\tgames  avl.Tree // AVL tree for storing game states\n\tgameId seqid.ID // Sequence ID for games\n\n\tplayers avl.Tree // AVL tree for storing player data\n\n\tseed = uint64(entropy.New().Seed())\n)\n\n// rollDice generates a random dice roll between 1 and 6\nfunc rollDice() int {\n\tr := rand.New(rand.NewPCG(seed, 0xdeadbeef))\n\treturn r.IntN(6) + 1\n}\n\n// NewGame initializes a new game with the provided opponent's address\nfunc NewGame(addr std.Address) int {\n\tif !addr.IsValid() {\n\t\tpanic(\"invalid opponent's address\")\n\t}\n\n\tgames.Set(gameId.Next().String(), \u0026game{\n\t\tplayer1: std.PrevRealm().Addr(),\n\t\tplayer2: addr,\n\t})\n\n\treturn int(gameId)\n}\n\n// Play allows a player to roll the dice and updates the game state accordingly\nfunc Play(idx int) int {\n\tg, err := getGame(idx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\troll := rollDice() // Random the player's dice roll\n\n\t// Play the game and update the player's roll\n\tif err := g.play(std.PrevRealm().Addr(), roll); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// If both players have rolled, update the results and leaderboard\n\tif g.roll1 != 0 \u0026\u0026 g.roll2 != 0 {\n\t\t// If the player is playing against themselves, no points are awarded\n\t\tif g.player1 == g.player2 {\n\t\t\treturn roll\n\t\t}\n\n\t\tplayer1 := getPlayer(g.player1)\n\t\tplayer2 := getPlayer(g.player2)\n\n\t\tif g.roll1 \u003e g.roll2 {\n\t\t\tplayer1.updateResult(win)\n\t\t\tplayer2.updateResult(lose)\n\t\t} else if g.roll2 \u003e g.roll1 {\n\t\t\tplayer2.updateResult(win)\n\t\t\tplayer1.updateResult(lose)\n\t\t} else {\n\t\t\tplayer1.updateResult(draw)\n\t\t\tplayer2.updateResult(draw)\n\t\t}\n\t}\n\n\treturn roll\n}\n\n// play processes a player's roll and updates their score\nfunc (g *game) play(player std.Address, roll int) error {\n\tif player != g.player1 \u0026\u0026 player != g.player2 {\n\t\treturn errors.New(\"invalid player\")\n\t}\n\n\tif g.roll1 != 0 \u0026\u0026 g.roll2 != 0 {\n\t\treturn errors.New(\"game over\")\n\t}\n\n\tif player == g.player1 \u0026\u0026 g.roll1 == 0 {\n\t\tg.roll1 = roll\n\t\treturn nil\n\t}\n\n\tif player == g.player2 \u0026\u0026 g.roll2 == 0 {\n\t\tg.roll2 = roll\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"already played\")\n}\n\n// winner determines the winner based on scores\nfunc (g *game) winner() string {\n\tif g.roll1 == 0 || g.roll2 == 0 {\n\t\treturn \"Game still in progress\"\n\t}\n\n\tif g.roll1 \u003e g.roll2 {\n\t\treturn \"Player 1 wins!\"\n\t} else if g.roll2 \u003e g.roll1 {\n\t\treturn \"Player 2 wins!\"\n\t} else {\n\t\treturn \"It's a draw!\"\n\t}\n}\n\n// diceIcon returns an icon of the dice roll\nfunc diceIcon(roll int) string {\n\tswitch roll {\n\tcase 1:\n\t\treturn \"1\"\n\tcase 2:\n\t\treturn \"2\"\n\tcase 3:\n\t\treturn \"3\"\n\tcase 4:\n\t\treturn \"4\"\n\tcase 5:\n\t\treturn \"5\"\n\tcase 6:\n\t\treturn \"6\"\n\tdefault:\n\t\treturn strconv.Itoa(roll)\n\t}\n}\n\n// Render provides a summary of the current state of games and leader board\nfunc Render(path string) string {\n\toutput := `#  Dice Roller\n\n## Game Rules:\nDice Roller is a two-player game where each player rolls a dice once\n1. **Create a game** with an opponent using [NewGame](diceroller?help\u0026__func=NewGame)\n2. **Play** using [Play](diceroller?help\u0026__func=Play), where each player rolls a dice\n\n## Scoring:\n- Playing against yourself? No points or stats changes for you\n- **Win:** 3 points\n- **Loss:** 0 points\n- **Draw:** 1 point each\n\n## Actions:\n* [NewGame](diceroller?help\u0026__func=NewGame) opponentAddress\n  - **opponentAddress**: The address of the opponent player\n* [Play](diceroller?help\u0026__func=Play) gameIndex\n  - **gameIndex**: The unique index of the game you want to play\n\n## Recent Games:\nDisplays a summary of the most recent games. Up to 10 recent games are shown\n\n| Game | Player 1 | Roll 1 | Player 2 | Roll 2 | Winner |\n|------|----------|--------|----------|--------|--------|\n`\n\n\t// Display up to 10 recent games\n\tmaxGames := 10\n\tfor n := int(gameId); n \u003e 0 \u0026\u0026 int(gameId)-n \u003c maxGames; n-- {\n\t\tg, err := getGame(n)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\toutput += strconv.Itoa(n) + \" | \" +\n\t\t\tshortName(g.player1) + \" | \" + diceIcon(g.roll1) + \" | \" +\n\t\t\tshortName(g.player2) + \" | \" + diceIcon(g.roll2) + \" | \" +\n\t\t\tg.winner() + \"\\n\"\n\t}\n\n\t// Display the leader board\n\toutput += `\n## Leader board:\nDisplays the current ranking of players based on their performance in Dice Roller\n\n| Rank | Player                | Wins | Losses | Draws | Points |\n|------|-----------------------|------|--------|-------|--------|\n`\n\n\tfor i, player := range getLeaderBoard() {\n\t\trankIcon := strconv.Itoa(i)\n\n\t\tif i == 0 {\n\t\t\trankIcon = \"\"\n\t\t} else if i == 1 {\n\t\t\trankIcon = \"\"\n\t\t} else if i == 2 {\n\t\t\trankIcon = \"\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"| %s   | %s | %d | %d | %d | %d |\\n\",\n\t\t\trankIcon,\n\t\t\tshortName(player.addr),\n\t\t\tplayer.wins,\n\t\t\tplayer.losses,\n\t\t\tplayer.draws,\n\t\t\tplayer.points,\n\t\t)\n\t}\n\n\treturn output\n}\n\n// shortName returns a shortened name for the given address\nfunc shortName(addr std.Address) string {\n\tuser := users.GetUserByAddress(addr)\n\tif user != nil {\n\t\treturn user.Name\n\t}\n\tif len(addr) \u003c 10 {\n\t\treturn string(addr)\n\t}\n\treturn string(addr)[:10] + \"...\"\n}\n\n// getGame retrieves the game state by its ID\nfunc getGame(idx int) (*game, error) {\n\tv, ok := games.Get(seqid.ID(idx).String())\n\tif !ok {\n\t\treturn nil, errors.New(\"game not found\")\n\t}\n\treturn v.(*game), nil\n}\n\n// updateResult updates the player's result and points based on the game outcome\nfunc (p *player) updateResult(result int) {\n\tswitch result {\n\tcase win:\n\t\tp.wins++\n\t\tp.points += 3\n\tcase lose:\n\t\tp.losses++\n\tcase draw:\n\t\tp.draws++\n\t\tp.points++\n\t}\n}\n\n// getPlayer retrieves a player or initializes a new one if they don't exist\nfunc getPlayer(addr std.Address) *player {\n\tv, ok := players.Get(addr.String())\n\tif !ok {\n\t\tplayer := \u0026player{\n\t\t\taddr: addr,\n\t\t}\n\t\tplayers.Set(addr.String(), player)\n\t\treturn player\n\t}\n\n\treturn v.(*player)\n}\n\n// getLeaderBoard generates a leaderboard sorted by points\nfunc getLeaderBoard() leaderBoard {\n\tboard := leaderBoard{}\n\tplayers.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tplayer := value.(*player)\n\t\tboard = append(board, *player)\n\t\treturn false\n\t})\n\n\tsort.Sort(board)\n\n\treturn board\n}\n\n// Methods for sorting the leaderboard\nfunc (r leaderBoard) Len() int {\n\treturn len(r)\n}\n\nfunc (r leaderBoard) Less(i, j int) bool {\n\treturn r[i].points \u003e r[j].points\n}\n\nfunc (r leaderBoard) Swap(i, j int) {\n\tr[i].points, r[j].points = r[j].points, r[i].points\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"HnkfM6SrqslltbuARNpNbCDr9Uqg8t+GxsPd7JGhyrl/KhocjTLVKqCID71BpyZSvSX/iAiLSLpWCInhB3CrVg=="}],"memo":""},"blockNum":"1430225"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v2/diceroller","func":"NewGame","args":["g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"b/PyxB+yJZLx08xakOYfefRC1DmC9vaR6Yb8HzoauSMJ4g+MR9g4isLQG0RKRChpTfQ8JBrAmTfHRUHMMEzTBg=="}],"memo":""},"blockNum":"1430253"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v2/diceroller","func":"Play","args":["1"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"+VYhBhYP9jWT3QTfp/3+UDH/O2uRT6Vi8CCUWpDlKplGUfL0s9aVLnMSR+Kv7TfNI2LcCykdVp4K4Q1ze9qabA=="}],"memo":""},"blockNum":"1430263"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v2/diceroller","func":"Play","args":["1"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"7lurRiNIhO5DXDl8BY7kzDbST4fbJBaPqBhSTn7VrQQ7MOwkTrcM0v5JH7qxvodazA5B847zvZP4pHMToWYlOw=="}],"memo":""},"blockNum":"1430265"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v2/diceroller","func":"NewGame","args":["g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"ZbjJJ4BDpqiJXgs7PgZYe9V4Yj4f6goPv2flSin50zNcj3YK3FWCrgbEnmiOnkPyOeAoQ0eN1RE1BPKfmRda+A=="}],"memo":""},"blockNum":"1430300"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v2/diceroller","func":"Play","args":["2"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"nloBAnr7pmUuLnMf48CTiiugEFPK1JkAryYoW7pNstt00if49Z/xWu9WLanCHcgTjF19Vl08toHMqebNtwj2mQ=="}],"memo":""},"blockNum":"1430305"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/v2/diceroller","func":"Play","args":["2"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"4g//diq/fhdiTDPJ2p9oTiPW1iAXh96H1mCXoKjesItQxYA+E+ljBokHg/9DBKXeXSOgG39yKztcMz9749c0ZQ=="}],"memo":""},"blockNum":"1430307"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","package":{"name":"diceroller","path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","files":[{"name":"diceroller.gno","body":"package diceroller\n\nimport (\n\t\"errors\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/seqid\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/entropy\"\n\t\"gno.land/r/demo/users\"\n)\n\ntype (\n\t// game represents a Dice Roller game between two players\n\tgame struct {\n\t\tplayer1, player2 std.Address\n\t\troll1, roll2     int\n\t}\n\n\t// player holds the information about each player including their stats\n\tplayer struct {\n\t\taddr                              std.Address\n\t\twins, losses, draws, points, rank int\n\t}\n\n\t// leaderBoard is a slice of players, used to sort players by rank\n\tleaderBoard []player\n)\n\nconst (\n\t// Constants to represent game result outcomes\n\tempty = iota\n\twin\n\tdraw\n\tlose\n)\n\nvar (\n\tgames  avl.Tree // AVL tree for storing game states\n\tgameId seqid.ID // Sequence ID for games\n\n\tplayers avl.Tree // AVL tree for storing player data\n\n\tseed = uint64(entropy.New().Seed())\n\tr    = rand.New(rand.NewPCG(seed, 0xdeadbeef))\n)\n\n// rollDice generates a random dice roll between 1 and 6\nfunc rollDice() int {\n\treturn r.IntN(6) + 1\n}\n\n// NewGame initializes a new game with the provided opponent's address\nfunc NewGame(addr std.Address) int {\n\tif !addr.IsValid() {\n\t\tpanic(\"invalid opponent's address\")\n\t}\n\n\tgames.Set(gameId.Next().String(), \u0026game{\n\t\tplayer1: std.PrevRealm().Addr(),\n\t\tplayer2: addr,\n\t})\n\n\treturn int(gameId)\n}\n\n// Play allows a player to roll the dice and updates the game state accordingly\nfunc Play(idx int) int {\n\tg, err := getGame(idx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\troll := rollDice() // Random the player's dice roll\n\n\t// Play the game and update the player's roll\n\tif err := g.play(std.PrevRealm().Addr(), roll); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// If both players have rolled, update the results and leaderboard\n\tif g.roll1 != 0 \u0026\u0026 g.roll2 != 0 {\n\t\t// If the player is playing against themselves, no points are awarded\n\t\tif g.player1 == g.player2 {\n\t\t\treturn roll\n\t\t}\n\n\t\tplayer1 := getPlayer(g.player1)\n\t\tplayer2 := getPlayer(g.player2)\n\n\t\tif g.roll1 \u003e g.roll2 {\n\t\t\tplayer1.updateResult(win)\n\t\t\tplayer2.updateResult(lose)\n\t\t} else if g.roll2 \u003e g.roll1 {\n\t\t\tplayer2.updateResult(win)\n\t\t\tplayer1.updateResult(lose)\n\t\t} else {\n\t\t\tplayer1.updateResult(draw)\n\t\t\tplayer2.updateResult(draw)\n\t\t}\n\t}\n\n\treturn roll\n}\n\n// play processes a player's roll and updates their score\nfunc (g *game) play(player std.Address, roll int) error {\n\tif player != g.player1 \u0026\u0026 player != g.player2 {\n\t\treturn errors.New(\"invalid player\")\n\t}\n\n\tif g.roll1 != 0 \u0026\u0026 g.roll2 != 0 {\n\t\treturn errors.New(\"game over\")\n\t}\n\n\tif player == g.player1 \u0026\u0026 g.roll1 == 0 {\n\t\tg.roll1 = roll\n\t\treturn nil\n\t}\n\n\tif player == g.player2 \u0026\u0026 g.roll2 == 0 {\n\t\tg.roll2 = roll\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"already played\")\n}\n\n// winner determines the winner based on scores\nfunc (g *game) winner() string {\n\tif g.roll1 == 0 || g.roll2 == 0 {\n\t\treturn \"Game still in progress\"\n\t}\n\n\tif g.roll1 \u003e g.roll2 {\n\t\treturn \"Player 1 wins!\"\n\t} else if g.roll2 \u003e g.roll1 {\n\t\treturn \"Player 2 wins!\"\n\t} else {\n\t\treturn \"It's a draw!\"\n\t}\n}\n\n// diceIcon returns an icon of the dice roll\nfunc diceIcon(roll int) string {\n\tswitch roll {\n\tcase 1:\n\t\treturn \"1\"\n\tcase 2:\n\t\treturn \"2\"\n\tcase 3:\n\t\treturn \"3\"\n\tcase 4:\n\t\treturn \"4\"\n\tcase 5:\n\t\treturn \"5\"\n\tcase 6:\n\t\treturn \"6\"\n\tdefault:\n\t\treturn strconv.Itoa(roll)\n\t}\n}\n\n// Render provides a summary of the current state of games and leader board\nfunc Render(path string) string {\n\toutput := `#  Dice Roller\n\n## Game Rules:\nDice Roller is a two-player game where each player rolls a dice once\n1. **Create a game** with an opponent using [NewGame](diceroller?help\u0026__func=NewGame)\n2. **Play** using [Play](diceroller?help\u0026__func=Play), where each player rolls a dice\n\n## Scoring:\n- Playing against yourself? No points or stats changes for you\n- **Win:** 3 points\n- **Loss:** 0 points\n- **Draw:** 1 point each\n\n## Actions:\n* [NewGame](diceroller?help\u0026__func=NewGame) opponentAddress\n  - **opponentAddress**: The address of the opponent player\n* [Play](diceroller?help\u0026__func=Play) gameIndex\n  - **gameIndex**: The unique index of the game you want to play\n\n## Recent Games:\nDisplays a summary of the most recent games. Up to 10 recent games are shown\n\n| Game | Player 1 | Roll 1 | Player 2 | Roll 2 | Winner |\n|------|----------|--------|----------|--------|--------|\n`\n\n\t// Display up to 10 recent games\n\tmaxGames := 10\n\tfor n := int(gameId); n \u003e 0 \u0026\u0026 int(gameId)-n \u003c maxGames; n-- {\n\t\tg, err := getGame(n)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\toutput += strconv.Itoa(n) + \" | \" +\n\t\t\tshortName(g.player1) + \" | \" + diceIcon(g.roll1) + \" | \" +\n\t\t\tshortName(g.player2) + \" | \" + diceIcon(g.roll2) + \" | \" +\n\t\t\tg.winner() + \"\\n\"\n\t}\n\n\t// Display the leader board\n\toutput += `\n## Leader board:\nDisplays the current ranking of players based on their performance in Dice Roller\n\n| Rank | Player                | Wins | Losses | Draws | Points |\n|------|-----------------------|------|--------|-------|--------|\n`\n\n\tfor i, player := range getLeaderBoard() {\n\t\trankIcon := strconv.Itoa(i)\n\n\t\tif i == 0 {\n\t\t\trankIcon = \"\"\n\t\t} else if i == 1 {\n\t\t\trankIcon = \"\"\n\t\t} else if i == 2 {\n\t\t\trankIcon = \"\"\n\t\t}\n\n\t\toutput += ufmt.Sprintf(\"| %s   | %s | %d | %d | %d | %d |\\n\",\n\t\t\trankIcon,\n\t\t\tshortName(player.addr),\n\t\t\tplayer.wins,\n\t\t\tplayer.losses,\n\t\t\tplayer.draws,\n\t\t\tplayer.points,\n\t\t)\n\t}\n\n\treturn output\n}\n\n// shortName returns a shortened name for the given address\nfunc shortName(addr std.Address) string {\n\tuser := users.GetUserByAddress(addr)\n\tif user != nil {\n\t\treturn user.Name\n\t}\n\tif len(addr) \u003c 10 {\n\t\treturn string(addr)\n\t}\n\treturn string(addr)[:10] + \"...\"\n}\n\n// getGame retrieves the game state by its ID\nfunc getGame(idx int) (*game, error) {\n\tv, ok := games.Get(seqid.ID(idx).String())\n\tif !ok {\n\t\treturn nil, errors.New(\"game not found\")\n\t}\n\treturn v.(*game), nil\n}\n\n// updateResult updates the player's result and points based on the game outcome\nfunc (p *player) updateResult(result int) {\n\tswitch result {\n\tcase win:\n\t\tp.wins++\n\t\tp.points += 3\n\tcase lose:\n\t\tp.losses++\n\tcase draw:\n\t\tp.draws++\n\t\tp.points++\n\t}\n}\n\n// getPlayer retrieves a player or initializes a new one if they don't exist\nfunc getPlayer(addr std.Address) *player {\n\tv, ok := players.Get(addr.String())\n\tif !ok {\n\t\tplayer := \u0026player{\n\t\t\taddr: addr,\n\t\t}\n\t\tplayers.Set(addr.String(), player)\n\t\treturn player\n\t}\n\n\treturn v.(*player)\n}\n\n// getLeaderBoard generates a leaderboard sorted by points\nfunc getLeaderBoard() leaderBoard {\n\tboard := leaderBoard{}\n\tplayers.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tplayer := value.(*player)\n\t\tboard = append(board, *player)\n\t\treturn false\n\t})\n\n\tsort.Sort(board)\n\n\treturn board\n}\n\n// Methods for sorting the leaderboard\nfunc (r leaderBoard) Len() int {\n\treturn len(r)\n}\n\nfunc (r leaderBoard) Less(i, j int) bool {\n\treturn r[i].points \u003e r[j].points\n}\n\nfunc (r leaderBoard) Swap(i, j int) {\n\tr[i].points, r[j].points = r[j].points, r[i].points\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"7Hfm9P1qtxTWJXomEOgZHdFtKvmyNCkJNAskSSfcUZULe9odf6q4cjuNgFUZsNrWiWVnoYYQwoc5voyo9fltPQ=="}],"memo":""},"blockNum":"1430400"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1whzkakk4hzjkvy60d5pwfk484xu67ar2cl62h2","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"1ZkUBvTZ0dtzCWKtMZWHQABzau5YvLQT66KTTmamWvwEhhy9g5Ux5h/lZho8egE9Aq+Y4TKYnfYUgL+Ub/HqgQ=="}],"memo":""},"blockNum":"1430549"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"NewGame","args":["g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"R7a/9IlQPAWmxsAmrGc59CaKKl1vmJrQjWsWD9MtfI1FBVkfGkaohO+1uDgAv9U7U+/aKDqo29IvmMU71LkN4Q=="}],"memo":""},"blockNum":"1430624"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"NewGame","args":["g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"Ml959qZ9l7sY04e8i7GCitPRjvyH6/4uim1/Dcu0h25Gw28ObPvfE04QvMJPbiaweUKAd1TEGMLdMDbTGXvKQA=="}],"memo":""},"blockNum":"1430626"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"Play","args":["1"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"FXJsXpy3rI0Cxi5BkeZgWsx2mtcdVFAxVgMU6/h3LKBfG3fBfGJqc4bLoga4lW5FI3AHRm1x/mHmItA0madwrw=="}],"memo":""},"blockNum":"1430639"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"Play","args":["1"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"YwmUiHH5JvRMDBljuD43xf+LZkBppf9uOJpFD+6zS9ockJibYurkL4JZO3GYm+29RI3TNvBPswWp9Tej/9TmcA=="}],"memo":""},"blockNum":"1430641"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"Play","args":["2"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"bi5AwE5d+QyTuCXmImrxmwVDMZCmpOQYFD+utpyvcmRQlo1NzzjEQ/1Y3rS3/zgLgtDq7aioIx3swzymXbNGEw=="}],"memo":""},"blockNum":"1430670"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"Play","args":["2"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"GO0oXuZIfNh75Fyv44U7JDftrf2OGrZthsMI3j6c6KoRuDcCmkI3wSlUQaP4ywFboB11HMOH530L09honqHWbQ=="}],"memo":""},"blockNum":"1430672"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"NewGame","args":["g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"sqIumdcRzsvwJwhZH3Wp9sjqI/jf3dr0y45X2Pdh4CpSufSX4f8027ZAK8SIyL9b0dWHVkdAgT8aPEcrCF11cQ=="}],"memo":""},"blockNum":"1430736"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"Play","args":["3"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"jrV27/CT7YNRV7VEt3LyhS5EMwzFIYCuQsenwNuzFZdvgetp/JeXaN3QqLipuvjG40H4DwtdilirzryBD41w+w=="}],"memo":""},"blockNum":"1430744"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8","send":"","pkg_path":"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/games/diceroller","func":"NewGame","args":["g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A07GwgEh8o++7Ka7JSCX5yC6NLA22rwckYKbx5V47CFl"},"signature":"HDl92XZTFl0SDXhMtu2J2DAfuxAS1ZrHM7mH+WDOW0UacQ28guypLd80BolChKAsFbfe8pc40j1oddN7d1vKpQ=="}],"memo":""},"blockNum":"1430985"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"SFeJaZb3zAFBQcBBq+rBz0hU2FFq2azU+CZjmfhyL6psPbhk1/rQyEyN/0G9D/WzBO1KDhnbHUJdlzJfiIlHmw=="}],"memo":""},"blockNum":"1432136"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"2000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","2000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","2001291"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5AUjFIdvgvvYPCszkBSj4LyyQVI/uczvuxzbg5IRDB3"},"signature":"qngb1I7lcGm8/QPqtuc/iviFN0efkIoiLP5CRvep+r0y4ctxYUmEgg/USqdcKJHLicroINl+bfQTK7vDbM2VDQ=="}],"memo":""},"blockNum":"1432145"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","2000000"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","2026366"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","2000000"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"2000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/v2/gns","3000","-6840","7020","2000000","2026366","1990000","2016234","7282571140","g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5AUjFIdvgvvYPCszkBSj4LyyQVI/uczvuxzbg5IRDB3"},"signature":"MN8WZdXFSoCCwYyxQyj2ZRV5JDpRZWVYVVkJIchXtZVtaURBC5m/JhSEbDGE12EjZDOFRzC5+0G2TjYLdonKRw=="}],"memo":""},"blockNum":"1432154"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v1/domain/registrar","func":"Register","args":["ngoc.gno","gnot"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"2VkkWFvYQ6RTMB8m41MxnQWgGXvMPy/Z3VqjNBb5aWhhnTQj9Kgl/8QvR03erUy8Qi0jAhb8qZmGH4JQo0v+Pg=="}],"memo":""},"blockNum":"1441834"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1ejx4xzmgvs5sa0zm52qqyj6dx2jzhvj64t2z5p","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"UX/WB9x1dHpTDAP+zC98SsDONtBowIvLbbGdVJzTsVk/V/olVbIaHTzmw92Ktvtm9UksZAx1iVdVY2wXraubBg=="}],"memo":""},"blockNum":"1441982"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ejx4xzmgvs5sa0zm52qqyj6dx2jzhvj64t2z5p","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v1/domain/registrar","func":"Register","args":["ngoc2.gno","gnot"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4/pXSTVaSt9eR1TDs3hRRNTGYuoanyBu9cNYjpTPl+s"},"signature":"Cs8MgFmbBGeV/6+6mFs8f2PljSqA2JAdJXh7WYx742RqMcDKUIv6I9YhmThrt19adS9hyaeuvy13jMvg2/hqJw=="}],"memo":""},"blockNum":"1441990"}
