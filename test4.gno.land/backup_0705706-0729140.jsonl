{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/grc20_launchpad","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/grc20_launchpad\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/pool\"\n\trr \"gno.land/r/gnoswap/router\"\n\tsr \"gno.land/r/gnoswap/staker\"\n\tpf \"gno.land/r/gnoswap/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"ehHTCQfThFD8f3NWBtZ1xLxSD5kynzp+8dQ7Ax878/4n1XSgte43Z9+mJgFN4y5mAmYohIuR1zz6Tu2wd3Wmmg=="}],"memo":""},"blockNum":"706085"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/grc20_launchpad","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/grc20_launchpad\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/pool\"\n\trr \"gno.land/r/gnoswap/router\"\n\tsr \"gno.land/r/gnoswap/staker\"\n\tpf \"gno.land/r/gnoswap/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"dJcJ78qyyzTixLy/huBS70N1V150UxwVl5WSiSyp1YpeL0jtkdjV89yma014h1GfVuwLe8hB+ytA3t1H5sLLeA=="}],"memo":""},"blockNum":"706561"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"xvxh+Cf9M42PmFIsVMizXYeYVXLBeU2/G0XPma20/O9eAL0J45GQjbgte6dyqwmhBfPaPF7MFpIVU9KjyenFlw=="}],"memo":""},"blockNum":"706632"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"3000000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/gns","3000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000","100","894682"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A59lQ+v9GpYiVCEfFopTwKxmfemNw+4AdAxzFl+/o2rD"},"signature":"3FCf4REGGtpcYgv6GvBUi6jZuGjtwnRSh1a1UhEfZmFYuSgyUGfr7Lcyido5woL7yCf6VypoAtBSusfvAcIPHQ=="}],"memo":""},"blockNum":"706659"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"500000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/baz","500000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000*POOL*gno.land/r/gnoswap/gns:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/baz:3000","100","1576567"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A59lQ+v9GpYiVCEfFopTwKxmfemNw+4AdAxzFl+/o2rD"},"signature":"PrdQtYhBVfxihZItFa81Kb19QNFXSRUuR4FmhtOtY1Q2gswhN9SITLhMG0iftiTAB6dK/lgV5Cq5PHm9wcjnpQ=="}],"memo":""},"blockNum":"706666"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"500000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/bar","500000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000*POOL*gno.land/r/gnoswap/gns:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/bar:3000","100","1335748"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A59lQ+v9GpYiVCEfFopTwKxmfemNw+4AdAxzFl+/o2rD"},"signature":"X3Q/08IG+HTXoTqquSiflNzcP8368FLHPmkAHe1rMOUT5s5xeFH+j4crneH4bupTwomTMcgc5/ON9XTY2FUe1Q=="}],"memo":""},"blockNum":"706673"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/onbloc/qux","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"500000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/qux","500000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000*POOL*gno.land/r/gnoswap/gns:gno.land/r/onbloc/qux:3000","100","15025129"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A59lQ+v9GpYiVCEfFopTwKxmfemNw+4AdAxzFl+/o2rD"},"signature":"2Xd67POhFAh1d7C2voDLfBIqEpS3sP53HcekSrPRJgdROSdfF9RWv8VlHPPtKKeDsbF8sf/RcbGKAmuNEJXjBQ=="}],"memo":""},"blockNum":"706687"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/onbloc/qux","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"500000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/qux","500000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000*POOL*gno.land/r/gnoswap/gns:gno.land/r/onbloc/qux:3000","100","15025129"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A59lQ+v9GpYiVCEfFopTwKxmfemNw+4AdAxzFl+/o2rD"},"signature":"4PsZi81QEGAgXwPC72GKtCBHJQdzwhV0yxg/1a3FLfp5fuYJK18l2p1eEKtowCBzFyib5MdxIoKV6jb+YUAEUg=="}],"memo":""},"blockNum":"706694"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"500000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/usdc","500000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000*POOL*gno.land/r/gnoswap/gns:gno.land/r/onbloc/foo:500*POOL*gno.land/r/onbloc/foo:gno.land/r/onbloc/usdc:3000","100","13615909"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A59lQ+v9GpYiVCEfFopTwKxmfemNw+4AdAxzFl+/o2rD"},"signature":"6kye99FLoLPoAz++aUqKTe1hJWFVCuwgbUB+OZeFFmYf/Gswx+K9d+g/3pF1ymEin8eJMERYx73l9iODjJidBA=="}],"memo":""},"blockNum":"706702"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1gg6mvefmdk3wn5072w9jkhksp5zj4stv4s5u52","send":"500000ugnot","pkg_path":"gno.land/r/demo/wugnot","func":"Deposit","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A59lQ+v9GpYiVCEfFopTwKxmfemNw+4AdAxzFl+/o2rD"},"signature":"MDvpFimDgiWQ1NOB7Lb2VjXfCUdbU/frMqQ3TEQoP2lqtMJscklWdMfRfN5oxGMDGxMZdhPGdlM1Z+3fhpkTmA=="}],"memo":""},"blockNum":"706709"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/grc20_launchpad","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/grc20_launchpad\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/pool\"\n\trr \"gno.land/r/gnoswap/router\"\n\tsr \"gno.land/r/gnoswap/staker\"\n\tpf \"gno.land/r/gnoswap/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"lWL6UYtxK5wx/6p9ew/uKilLCWHmTpCT6N0ITuIAKnAk6wYpmCwTfB7681pY6uPba5otZFRpjH/ECqihFUPc6w=="}],"memo":""},"blockNum":"706998"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/grc20_launchpad","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/grc20_launchpad\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/pool\"\n\trr \"gno.land/r/gnoswap/router\"\n\tsr \"gno.land/r/gnoswap/staker\"\n\tpf \"gno.land/r/gnoswap/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"qTuLpdzWefmvOu9BN4g/MUaj9BYpCaG6/mlmGozm+jR9gP84MZWHBXnr5tY+9209XCipQIH0I8nnb/wXCE0KfA=="}],"memo":""},"blockNum":"707338"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"name":"testhellodeploy","path":"gno.land/r/g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7/testhellodeploy","files":[{"name":"package.gno","body":"package testhellodeploy\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"KbiaJitiu+3u7RbLXIA8lVPwr2lYkAWvZj8jTp9gD8ZFYslD8mS+gHMVOmmBeI4uM+BAfRSjPOJKuLUhrQz5Xg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"707738"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"name":"hellotest","path":"gno.land/r/g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7/hellotest","files":[{"name":"package.gno","body":"package hellotest\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"mEujPTYlnkMZfihJUmtbav5gIdfLQwSky/YxYIq9Tx57vpOSpw9zrNpFAICwrRNNQ4s4IUOhK3zhdWbwuzpm/w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"707788"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"name":"hellotesting","path":"gno.land/r/g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7/hellotesting","files":[{"name":"package.gno","body":"package hellotesting\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"CuRkPLlZUIJ00vxed+1BisKopoelvE/RmxOmEERqQgc+vNY27nV3vJpXLdcfaPNQFfPMyXWRAeatmutGF5AFgw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"707981"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1uz0pn536ynfst9hfta63e3l8c7pgv8yl807mcp","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"AtJ19JAMXF7n2xy2YBpc53WgPekItvfRhEiZNMl28SYnEmRY6HUjLag66sgJ60qUOq1WQpiZAIRVRbMUjyrIkQ=="}],"memo":""},"blockNum":"710653"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1uz0pn536ynfst9hfta63e3l8c7pgv8yl807mcp","package":{"name":"hello","path":"gno.land/r/g1uz0pn536ynfst9hfta63e3l8c7pgv8yl807mcp/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A8MtfDnzSAt26YZxHzeiO5+MNwNtoszqfZq8RG27d+SN"},"signature":"BrTGXJ2FyHzDsbZuGdhAPwQMLzUGTGyotqNx83KOGABdafwLm6frJJ047Mpxdmt0ghMphzaJkrvvDJ5QxsFaBQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"710678"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1uz0pn536ynfst9hfta63e3l8c7pgv8yl807mcp","to_address":"g1uz0pn536ynfst9hfta63e3l8c7pgv8yl807mcp","amount":"4000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A8MtfDnzSAt26YZxHzeiO5+MNwNtoszqfZq8RG27d+SN"},"signature":"VHfi1Uij4Ivf4nfHXg0htTh0eOJ9uW46xJbdxJGNMrkAUwm6Hgr1WllwpwBc24GNTVrCRZrKSojpT4D3JNmdUw=="}],"memo":""},"blockNum":"710690"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/grc20_launchpad","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/grc20_launchpad\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/pool\"\n\trr \"gno.land/r/gnoswap/router\"\n\tsr \"gno.land/r/gnoswap/staker\"\n\tpf \"gno.land/r/gnoswap/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"NjdCJtZMs7DLVUyljxa970g3zpmPVw1i9RrAYIpJsRFfXn8YNDfUkrdQFNSYchfT0umAeTaOzaSiuZYjhgyAgg=="}],"memo":""},"blockNum":"713932"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"iX/kBXCWKCuSRdNUeSdxjpIMxrMA2Yti3fYCNFYSzUp1XEBqbfq/x+XaSkrC44VrinBuhnVj6fO6QbvFBr/zUQ=="}],"memo":""},"blockNum":"714539"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","amount":"5000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"3tL8GS3yTLm/7pY5D53DMsCpm/djU+me/gSF0iHMMu9ACoEDSq+CUYzGcjI9XgjsUFqLIIrs8/Ka/lQTkzxMEg=="}],"memo":""},"blockNum":"714559"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"3000000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/gns","3000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000","100","894678"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A02ygHb7m0eaMFBFZRyKpgeoUlMc8m5grNZyB4tMM1ri"},"signature":"21P0BZi0pDMdhKbBgzNbxdCLSkvSQykMMw4kqxzILH4UyNpgt3QPpzdgv0l4kp+47XyKfej5+dr53XlWg8j/yg=="}],"memo":""},"blockNum":"714623"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"3000000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/bar","3000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000*POOL*gno.land/r/gnoswap/gns:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/bar:3000","100","8012349"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A02ygHb7m0eaMFBFZRyKpgeoUlMc8m5grNZyB4tMM1ri"},"signature":"nA0rCgl6bc4kLIpM8zx6ODZnsYDydYzhc3Ui0UkCd7J27FBAb/2GpVD5DetoWbCC5SbirOD1ocj82vOP85oLnw=="}],"memo":""},"blockNum":"714635"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/gnoswap/pool","func":"CreatePool","args":["gno.land/r/demo/wugnot","gno.land/r/onbloc/bar","3000","112203526612144856034728115458"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","1000000"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","2000036"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1y3uyaa63sjxvah2cx3c2usavwvx97kl8m2v7ye","1000000"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/position","func":"Mint","args":["gnot","gno.land/r/onbloc/bar","3000","0","13860","1000000","2000036","995000","1990036","7282571140","g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/gnoswap/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A02ygHb7m0eaMFBFZRyKpgeoUlMc8m5grNZyB4tMM1ri"},"signature":"04kXBdEx4F4dAP/AHpKGEym2utAz0ZIOaVnOqfiwkKA2xIKayorhnMrPV4ijsr4+oPG/cyh9YpA/hyNBG5twuQ=="}],"memo":""},"blockNum":"714683"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/gnoswap/pool","func":"CreatePool","args":["gno.land/r/demo/wugnot","gno.land/r/onbloc/bar","3000","112203526612144856034728115458"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","1000000"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","2000036"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1y3uyaa63sjxvah2cx3c2usavwvx97kl8m2v7ye","1000000"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/position","func":"Mint","args":["gnot","gno.land/r/onbloc/bar","3000","0","13860","1000000","2000036","995000","1990036","7282571140","g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46"]},{"@type":"/vm.m_call","caller":"g13mvq7rxpucyx0cj732a2jzs8q37emcf6vfyw46","send":"","pkg_path":"gno.land/r/gnoswap/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A02ygHb7m0eaMFBFZRyKpgeoUlMc8m5grNZyB4tMM1ri"},"signature":"/pEyoJk00JlbEvBscnGSyQ+ZpFtU9mc6hQYfBEMq3uEOQltWoK5dG9WE6Qw7AmEIsgWMHJhv0a8hjM4WimDSBA=="}],"memo":""},"blockNum":"714687"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"B/d8dpXz3/Yygh9dKQokgB/RpaEOSu4Zxcl8MyUo0q9uSPvh/NGHaTiaBR7urgbhybl3SjixzdTPWgPSdagWUQ=="}],"memo":""},"blockNum":"714791"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"iH7gXnldl4F0mf/820HbR5f7vpaqmOvxihKTjHM5SXQ5lRgkYDDRNzUv6qWxLqvTLAZzeYXKScV14rW1AXZRGA=="}],"memo":""},"blockNum":"714804"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","to_address":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","amount":"5000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Av0a+dv+B65sP719+3LL4p+wt9CGaipvgn33xalL28Ys"},"signature":"3wtJwosFwZ5s875+Hlx/zqFs8/hJwPKtzUVOzyX1w2s70WjFEqBTwbpOB7Ne64s3FYA247iWd5Npk7T0sw89mw=="}],"memo":""},"blockNum":"714890"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"3000000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/gns","3000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000","100","894674"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Av0a+dv+B65sP719+3LL4p+wt9CGaipvgn33xalL28Ys"},"signature":"+x4l1ZbQ0Q6Ct5pwoFu/fY6I9Ag39ew0SYD3AGNapr9HCIbOYRVMR6IQ4gPya7iveaRhNYRaS8w2xg+3RXp2fw=="}],"memo":""},"blockNum":"715234"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1vc883gshu5z7ytk5cdynhc8c2dh67pdp4cszkp","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"4000ugnot","pkg_path":"gno.land/r/gnoswap/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/gns","4000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/gns:3000","100","1192"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Av0a+dv+B65sP719+3LL4p+wt9CGaipvgn33xalL28Ys"},"signature":"jeqPzUmMdmTXL8P1eTlMCGeJwhjQowe3Ciah6rlHeaINtnK7/VEj56w6j67B/6GunHzbvE+GPKqs5uvgGhC5ng=="}],"memo":""},"blockNum":"715248"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/pool","func":"CreatePool","args":["gno.land/r/demo/wugnot","gno.land/r/gnoswap/gns","3000","5015182510717043696104321797"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","4000"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","15"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1y3uyaa63sjxvah2cx3c2usavwvx97kl8m2v7ye","4000"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"4000ugnot","pkg_path":"gno.land/r/gnoswap/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/gns","3000","-62160","-48300","4000","15","3980","15","7282571140","g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Av0a+dv+B65sP719+3LL4p+wt9CGaipvgn33xalL28Ys"},"signature":"XYBTcrek0xEGVBtLKympmkuXYoAR4myUtoOEOZcl0HYZTPIeOKX3qWqKfogbQBNN0/XhFqHnr7TxKra77UZXqQ=="}],"memo":""},"blockNum":"715259"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/pool","func":"CreatePool","args":["gno.land/r/demo/wugnot","gno.land/r/gnoswap/gns","3000","5015182510717043696104321797"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","4000"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Approve","args":["g1dexaf6aqkkyr9yfy9d5up69lsn7ra80af34g5v","15"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1y3uyaa63sjxvah2cx3c2usavwvx97kl8m2v7ye","4000"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"4000ugnot","pkg_path":"gno.land/r/gnoswap/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/gns","3000","-62160","-48300","4000","15","3980","15","7282571140","g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Av0a+dv+B65sP719+3LL4p+wt9CGaipvgn33xalL28Ys"},"signature":"Kl0h5O3R7nS7OS3E5hfOidmb/Wdzt4LxuyR2APaHaqRRCU6W7+3z+A67w4VJesWftUm+5/fh7FgUQtm6bSm0zw=="}],"memo":""},"blockNum":"715262"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/pool","func":"CreatePool","args":["gno.land/r/demo/wugnot","gno.land/r/gnoswap/gns","3000","79228162514264337593543950336"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1y3uyaa63sjxvah2cx3c2usavwvx97kl8m2v7ye","0"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/gns","3000","-887272","887272","0","0","0","0","7282571140","g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve"]},{"@type":"/vm.m_call","caller":"g1ja0206uug3g3kakwem0atkpeucgtrtr9vagvve","send":"","pkg_path":"gno.land/r/gnoswap/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Av0a+dv+B65sP719+3LL4p+wt9CGaipvgn33xalL28Ys"},"signature":"kxzNWIK4wWmp9Y27inC7lkaxMKUMxO0IgUcjOJcqKRorlatTw8EVDWWX+NpydlWkCz4ANhvVG1mBVB1KToRjLA=="}],"memo":""},"blockNum":"715271"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"consts","path":"gno.land/r/gnoswap/v2/consts","files":[{"name":"consts.gno","body":"package consts\n\nimport (\n\t\"std\"\n)\n\n// GNOSWAP SERVICE\nconst (\n\tGNOSWAP_ADMIN std.Address = \"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c\" // GSA\n\tDEV_OPS       std.Address = \"g1mjvd83nnjee3z2g7683er55me9f09688pd4mj9\" // DevOps\n\n\tTOKEN_REGISTER std.Address = \"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5\"\n\n\tBLOCK_GENERATION_INTERVAL int64 = 2 // 2 seconds\n)\n\n// WRAP \u0026 UNWRAP\nconst (\n\tGNOT           string = \"gnot\"\n\tWRAPPED_WUGNOT string = \"gno.land/r/demo/wugnot\"\n\n\tUGNOT_MIN_DEPOSIT_TO_WRAP uint64 = 1000 // defined in gno.land/r/demo/wugnot\n)\n\n// CONTRACT PATH \u0026 ADDRESS\nconst (\n\tPOOL_PATH string      = \"gno.land/r/gnoswap/v2/pool\"\n\tPOOL_ADDR std.Address = \"g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8\"\n\n\tPOSITION_PATH string      = \"gno.land/r/gnoswap/v2/position\"\n\tPOSITION_ADDR std.Address = \"g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2\"\n\n\tROUTER_PATH string      = \"gno.land/r/gnoswap/v2/router\"\n\tROUTER_ADDR std.Address = \"g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5\"\n\n\tSTAKER_PATH string      = \"gno.land/r/gnoswap/v2/staker\"\n\tSTAKER_ADDR std.Address = \"g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l\"\n\n\tGOV_PATH string      = \"gno.land/r/gnoswap/v2/gov\"\n\tGOV_ADDR std.Address = \"g1cu4dufdlzu0l9pekkqhw6mjnrxkp3z7ykst09d\"\n\n\tGNS_PATH string      = \"gno.land/r/gnoswap/v2/gns\"\n\tGNS_ADDR std.Address = \"g1ttcyeq0u5f6npysfxvew7tzucvwqy0qjp04p95\"\n\n\tGNFT_PATH string      = \"gno.land/r/gnoswap/v2/gnft\"\n\tGNFT_ADDR std.Address = \"g1rn4pederer0qlw2f7k72ddywde6pv3v3vl69nc\"\n\n\tWUGNOT_PATH string      = \"gno.land/r/demo/wugnot\"\n\tWUGNOT_ADDR std.Address = \"g1pf6dv9fjk3rn0m4jjcne306ga4he3mzmupfjl6\"\n\n\tEMISSION_PATH string      = \"gno.land/r/gnoswap/v2/emission\"\n\tEMISSION_ADDR std.Address = \"g1mfvpsj55gssep3wkt2t04d6dc3yfs9py5qquft\"\n\n\tPROTOCOL_FEE_PATH string      = \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tPROTOCOL_FEE_ADDR std.Address = \"g1397dea8xlfv5858xzhsly7k998xm2zlvrm93t2\"\n\n\tCOMMUNITY_POOL_PATH string      = \"gno.land/r/gnoswap/v2/community_pool\"\n\tCOMMUNITY_POOL_ADDR std.Address = \"g1r79m0scwztcdvk3c6sy4rjrtv3rnnzrs9ddh9w\"\n\n\tX_GNS_PATH string      = \"gno.land/r/gnoswap/v2/x_gns\"\n\tX_GNS_ADDR std.Address = \"g1dd0t56nqh5a468chr7vkgp5ftzmquvpja5l7qh\"\n)\n\n// NUMBER\nconst (\n\t// calculated by https://mathiasbynens.be/demo/integer-range\n\tMAX_UINT8 string = \"255\"\n\tUINT8_MAX uint8  = 255\n\n\tMAX_UINT16 string = \"65535\"\n\tUINT16_MAX uint16 = 65535\n\n\tMAX_UINT32 string = \"4294967295\"\n\tUINT32_MAX uint32 = 4294967295\n\n\tMAX_UINT64 string = \"18446744073709551615\"\n\tUINT64_MAX uint64 = 18446744073709551615\n\n\tMAX_UINT128 string = \"340282366920938463463374607431768211455\"\n\n\tMAX_UINT160 string = \"1461501637330902918203684832716283019655932542975\"\n\n\tMAX_UINT256 string = \"115792089237316195423570985008687907853269984665640564039457584007913129639935\"\n\n\t// Tick Related\n\tMIN_TICK int32 = -887272\n\tMAX_TICK int32 = 887272\n\n\tMIN_SQRT_RATIO string = \"4295128739\"                                        // same as TickMathGetSqrtRatioAtTick(MIN_TICK)\n\tMAX_SQRT_RATIO string = \"1461446703485210103287273052203988822378723970342\" // same as TickMathGetSqrtRatioAtTick(MAX_TICK)\n\n\tMIN_PRICE string = \"4295128740\"                                        // MIN_SQRT_RATIO + 1\n\tMAX_PRICE string = \"1461446703485210103287273052203988822378723970341\" // MAX_SQRT_RATIO - 1\n\n\t// ETC\n\tQ64  string = \"18446744073709551616\"                    // 2 ** 64\n\tQ96  string = \"79228162514264337593543950336\"           // 2 ** 96\n\tQ128 string = \"340282366920938463463374607431768211456\" // 2 ** 128\n\n)\n\n// ETCs\nconst (\n\t// REF: https://github.com/gnolang/gno/pull/2401#discussion_r1648064219\n\tZERO_ADDRESS std.Address = \"g100000000000000000000000000000000dnmcnx\"\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"4bzRyyevSMwX0PV2wuTVykIBy24R60Q2aP1PV/PZbE0Sr5Xebaq7FTYoXVOccnZ2szGBVb6pmdHcpMakrajQKg=="}],"memo":""},"blockNum":"716166"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"common","path":"gno.land/r/gnoswap/v2/common","files":[{"name":"allow_non_gnoswap_contracts.gno","body":"package common\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nvar (\n\tlimitCaller bool = true\n)\n\nfunc GetLimitCaller() bool {\n\treturn limitCaller\n}\n\nfunc SetLimitCaller(v bool) {\n\tMustCallFromAdmin()\n\tlimitCaller = v\n}\n\nfunc MustCallFromAdmin() {\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.GNOSWAP_ADMIN {\n\t\tpanic(\"must be called by admin\")\n\t}\n}\n\nfunc DisallowCallFromUser() {\n\tprevRealmPath := std.PrevRealm().PkgPath()\n\tif prevRealmPath == \"\" {\n\t\tpanic(\"must be called by realm, not user\")\n\t}\n}\n\nfunc AllowCallFromOnly(allowPath string) {\n\tif !limitCaller {\n\t\tprevPath := std.PrevRealm().PkgPath()\n\n\t\tif prevPath != allowPath {\n\t\t\tpanic(\"caller is not allowed to call this function\")\n\t\t}\n\t}\n}\n"},{"name":"liquidity_amounts.gno","body":"package common\n\nimport (\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// toAscendingOrder checkes if the first value is greater than\n// the second then swaps two values.\nfunc toAscendingOrder(a, b *u256.Uint) (*u256.Uint, *u256.Uint) {\n\tif a.Gt(b) {\n\t\treturn b, a\n\t}\n\n\treturn a, b\n}\n\n// computeLiquidityForAmount0 calculates liquidity for a given amount of token 0.\nfunc computeLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0 *u256.Uint) *u256.Uint {\n\tsqrtRatioAX96, sqrtRatioBX96 = toAscendingOrder(sqrtRatioAX96, sqrtRatioBX96)\n\n\tintermediate := u256.MulDiv(sqrtRatioAX96, sqrtRatioBX96, u256.MustFromDecimal(consts.Q96))\n\n\tdiff := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)\n\n\tres := u256.MulDiv(amount0, intermediate, diff)\n\treturn res\n}\n\n// computeLiquidityForAmount1 calculates liquidity for a given amount of token 1.\nfunc computeLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1 *u256.Uint) *u256.Uint {\n\tsqrtRatioAX96, sqrtRatioBX96 = toAscendingOrder(sqrtRatioAX96, sqrtRatioBX96)\n\n\tdiff := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)\n\n\tres := u256.MulDiv(amount1, u256.MustFromDecimal(consts.Q96), diff)\n\treturn res\n}\n\n// GetLiquidityForAmounts calculates the liquidity for given amounts od token 0 and token 1.\nfunc GetLiquidityForAmounts(sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1 *u256.Uint) *u256.Uint {\n\tsqrtRatioAX96, sqrtRatioBX96 = toAscendingOrder(sqrtRatioAX96, sqrtRatioBX96)\n\tvar liquidity *u256.Uint\n\n\tif sqrtRatioX96.Lte(sqrtRatioAX96) {\n\t\tliquidity = computeLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0)\n\t} else if sqrtRatioX96.Lt(sqrtRatioBX96) {\n\t\tliquidity0 := computeLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0)\n\t\tliquidity1 := computeLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1)\n\n\t\tif liquidity0.Lt(liquidity1) {\n\t\t\tliquidity = liquidity0\n\t\t} else {\n\t\t\tliquidity = liquidity1\n\t\t}\n\n\t} else {\n\t\tliquidity = computeLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1)\n\t}\n\n\treturn liquidity\n}\n\n// computeAmount0ForLiquidity calculates the amount of token0 for a given liquidity.\nfunc computeAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity *u256.Uint) *u256.Uint {\n\tsqrtRatioAX96, sqrtRatioBX96 = toAscendingOrder(sqrtRatioAX96, sqrtRatioBX96)\n\n\tval1 := new(u256.Uint).Lsh(liquidity, 96)\n\tval2 := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)\n\n\tres := u256.MulDiv(val1, val2, sqrtRatioBX96)\n\n\tres = res.Div(res, sqrtRatioAX96)\n\n\treturn res\n}\n\n// computeAmount1ForLiquidity calculates the amount of token1 for a given liquidity.\nfunc computeAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity *u256.Uint) *u256.Uint {\n\tsqrtRatioAX96, sqrtRatioBX96 = toAscendingOrder(sqrtRatioAX96, sqrtRatioBX96)\n\n\tval2 := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)\n\n\tres := u256.MulDiv(liquidity, val2, u256.MustFromDecimal(consts.Q96))\n\treturn res\n}\n\n// GetAmountsForLiquidity calculates the amounts of token0 and token1 for a given liquidity.\n// FROM [POOL] position_modify.gno\nfunc GetAmountsForLiquidity(sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96 *u256.Uint, liquidity *i256.Int) (string, string) {\n\tvar amount0, amount1 *i256.Int\n\n\tif !(liquidity.IsZero()) {\n\t\tif sqrtRatioX96.Lt(sqrtRatioAX96) { // currentTick \u003c tickLower\n\t\t\t_amount0Str := SqrtPriceMathGetAmount0DeltaStr(\n\t\t\t\tsqrtRatioAX96,\n\t\t\t\tsqrtRatioBX96,\n\t\t\t\tliquidity,\n\t\t\t)\n\t\t\tamount0 = i256.MustFromDecimal(_amount0Str)\n\n\t\t} else if sqrtRatioX96.Lt(sqrtRatioBX96) { // currentTick \u003c tickUpper\n\t\t\t_amount0Str := SqrtPriceMathGetAmount0DeltaStr(\n\t\t\t\tsqrtRatioX96,\n\t\t\t\tsqrtRatioBX96,\n\t\t\t\tliquidity,\n\t\t\t)\n\t\t\tamount0 = i256.MustFromDecimal(_amount0Str)\n\n\t\t\t_amount1Str := SqrtPriceMathGetAmount1DeltaStr(\n\t\t\t\tsqrtRatioAX96,\n\t\t\t\tsqrtRatioX96,\n\t\t\t\tliquidity,\n\t\t\t)\n\t\t\tamount1 = i256.MustFromDecimal(_amount1Str)\n\n\t\t} else {\n\t\t\t_amount1Str := SqrtPriceMathGetAmount1DeltaStr(\n\t\t\t\tsqrtRatioAX96,\n\t\t\t\tsqrtRatioBX96,\n\t\t\t\tliquidity,\n\t\t\t)\n\t\t\tamount1 = i256.MustFromDecimal(_amount1Str)\n\t\t}\n\n\t}\n\n\t// if position is out of range, one of amount0 or amount1 can be nil\n\t// \u003e handle as 0\n\tamount0 = amount0.NilToZero()\n\tamount1 = amount1.NilToZero()\n\n\treturn amount0.ToString(), amount1.ToString()\n}\n"},{"name":"sqrt_price_math.gno","body":"package common\n\nimport (\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nfunc sqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(\n\tsqrtPX96 *u256.Uint, // uint160\n\tliquidity *u256.Uint, // uint128\n\tamount *u256.Uint, // uint256\n\tadd bool,\n) *u256.Uint { // uint160\n\tif amount.IsZero() {\n\t\treturn sqrtPX96\n\t}\n\n\tnumerator1 := new(u256.Uint).Lsh(liquidity, 96)\n\tproduct := new(u256.Uint).Mul(amount, sqrtPX96)\n\n\tif add {\n\t\tif new(u256.Uint).Div(product, amount).Eq(sqrtPX96) {\n\t\t\tdenominator := new(u256.Uint).Add(numerator1, product)\n\n\t\t\tif denominator.Gte(numerator1) {\n\t\t\t\treturn u256.MulDivRoundingUp(numerator1, sqrtPX96, denominator)\n\t\t\t}\n\t\t}\n\n\t\tdiv := new(u256.Uint).Div(numerator1, sqrtPX96)\n\t\tadd := new(u256.Uint).Add(div, amount)\n\t\treturn u256.DivRoundingUp(numerator1, add)\n\t} else {\n\t\tcond1 := new(u256.Uint).Div(product, amount).Eq(sqrtPX96)\n\t\tcond2 := numerator1.Gt(product)\n\n\t\tif !(cond1 \u0026\u0026 cond2) {\n\t\t\tpanic(\"common_sqrt price math #1\")\n\t\t}\n\n\t\tdenominator := new(u256.Uint).Sub(numerator1, product)\n\t\treturn u256.MulDivRoundingUp(numerator1, sqrtPX96, denominator)\n\t}\n}\n\nfunc sqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(\n\tsqrtPX96 *u256.Uint, // uint160\n\tliquidity *u256.Uint, // uint1288\n\tamount *u256.Uint, // uint256\n\tadd bool,\n) *u256.Uint { // uint160\n\tquotient := u256.Zero()\n\n\tif add {\n\t\tif amount.Lte(u256.MustFromDecimal(consts.MAX_UINT160)) {\n\t\t\tvalue1 := new(u256.Uint).Lsh(amount, 96)\n\t\t\tquotient = new(u256.Uint).Div(value1, liquidity)\n\t\t} else {\n\t\t\tquotient = u256.MulDiv(amount, u256.MustFromDecimal(consts.Q96), liquidity)\n\t\t}\n\n\t\treturn new(u256.Uint).Add(sqrtPX96, quotient)\n\t} else {\n\t\tif amount.Lte(u256.MustFromDecimal(consts.MAX_UINT160)) {\n\t\t\tvalue1 := new(u256.Uint).Lsh(amount, 96)\n\t\t\tquotient = u256.DivRoundingUp(value1, liquidity)\n\t\t} else {\n\t\t\tquotient = u256.MulDivRoundingUp(amount, u256.MustFromDecimal(consts.Q96), liquidity)\n\t\t}\n\n\t\tif !(sqrtPX96.Gt(quotient)) {\n\t\t\tpanic(\"common_sqrt price math #2\")\n\t\t}\n\n\t\treturn new(u256.Uint).Sub(sqrtPX96, quotient)\n\t}\n}\n\nfunc sqrtPriceMathGetNextSqrtPriceFromInput(\n\tsqrtPX96 *u256.Uint, // uint160\n\tliquidity *u256.Uint, // uint128\n\tamountIn *u256.Uint, // uint256\n\tzeroForOne bool, // bool\n) *u256.Uint { // uint160\n\tif zeroForOne {\n\t\treturn sqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n\t}\n\treturn sqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true)\n}\n\nfunc sqrtPriceMathGetNextSqrtPriceFromOutput(\n\tsqrtPX96 *u256.Uint, // uint160\n\tliquidity *u256.Uint, // uint128\n\tamountOut *u256.Uint, // uint256\n\tzeroForOne bool, // bool\n) *u256.Uint { // uint160\n\tif zeroForOne {\n\t\treturn sqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n\t}\n\n\treturn sqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false)\n}\n\nfunc sqrtPriceMathGetAmount0DeltaHelper(\n\tsqrtRatioAX96 *u256.Uint, // uint160\n\tsqrtRatioBX96 *u256.Uint, // uint160\n\tliquidity *u256.Uint, // uint160\n\troundUp bool,\n) *u256.Uint { // uint256\n\tif sqrtRatioAX96.Gt(sqrtRatioBX96) {\n\t\tsqrtRatioAX96, sqrtRatioBX96 = sqrtRatioBX96, sqrtRatioAX96\n\t}\n\n\tnumerator1 := new(u256.Uint).Lsh(liquidity, 96)\n\tnumerator2 := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)\n\n\tif !(sqrtRatioAX96.Gt(u256.Zero())) {\n\t\tpanic(\"common_sqrt price math #3\")\n\t}\n\n\tif roundUp {\n\t\tvalue1 := u256.MulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96)\n\t\treturn u256.DivRoundingUp(value1, sqrtRatioAX96)\n\t} else {\n\t\tvalue1 := u256.MulDiv(numerator1, numerator2, sqrtRatioBX96)\n\t\treturn new(u256.Uint).Div(value1, sqrtRatioAX96)\n\t}\n}\n\nfunc sqrtPriceMathGetAmount1DeltaHelper(\n\tsqrtRatioAX96 *u256.Uint, // uint160\n\tsqrtRatioBX96 *u256.Uint, // uint160\n\tliquidity *u256.Uint, // uint160\n\troundUp bool,\n) *u256.Uint { // uint256\n\tif sqrtRatioAX96.Gt(sqrtRatioBX96) {\n\t\tsqrtRatioAX96, sqrtRatioBX96 = sqrtRatioBX96, sqrtRatioAX96\n\t}\n\n\tif roundUp {\n\t\tdiff := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)\n\t\treturn u256.MulDivRoundingUp(liquidity, diff, u256.MustFromDecimal(consts.Q96))\n\t} else {\n\t\tdiff := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)\n\t\treturn u256.MulDiv(liquidity, diff, u256.MustFromDecimal(consts.Q96))\n\t}\n}\n\nfunc SqrtPriceMathGetAmount0DeltaStr(\n\tsqrtRatioAX96 *u256.Uint, // uint160\n\tsqrtRatioBX96 *u256.Uint, // uint160\n\tliquidity *i256.Int, // int128\n) string { // int256\n\tif liquidity.IsNeg() {\n\t\tu := sqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity.Abs(), false)\n\t\ti := i256.FromUint256(u)\n\t\treturn i256.Zero().Neg(i).ToString()\n\t}\n\n\tu := sqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity.Abs(), true)\n\treturn i256.FromUint256(u).ToString()\n}\n\nfunc SqrtPriceMathGetAmount1DeltaStr(\n\tsqrtRatioAX96 *u256.Uint, // uint160\n\tsqrtRatioBX96 *u256.Uint, // uint160\n\tliquidity *i256.Int, // int128\n) string { // int256\n\tif liquidity.IsNeg() {\n\t\tu := sqrtPriceMathGetAmount1DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity.Abs(), false)\n\t\ti := i256.FromUint256(u)\n\t\treturn i256.Zero().Neg(i).ToString()\n\t}\n\n\tu := sqrtPriceMathGetAmount1DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity.Abs(), true)\n\treturn i256.FromUint256(u).ToString()\n}\n"},{"name":"tick_math.gno","body":"package common\n\nimport (\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nvar tickRatioMap = map[int32]*u256.Uint{\n\t0x1:     u256.MustFromDecimal(\"340265354078544963557816517032075149313\"), // 0xfffcb933bd6fad37aa2d162d1a594001,\n\t0x2:     u256.MustFromDecimal(\"340248342086729790484326174814286782778\"), // 0xfff97272373d413259a46990580e213a,\n\t0x4:     u256.MustFromDecimal(\"340214320654664324051920982716015181260\"), // 0xfff2e50f5f656932ef12357cf3c7fdcc,\n\t0x8:     u256.MustFromDecimal(\"340146287995602323631171512101879684304\"), // 0xffe5caca7e10e4e61c3624eaa0941cd0,\n\t0x10:    u256.MustFromDecimal(\"340010263488231146823593991679159461444\"), // 0xffcb9843d60f6159c9db58835c926644,\n\t0x20:    u256.MustFromDecimal(\"339738377640345403697157401104375502016\"), // 0xff973b41fa98c081472e6896dfb254c0,\n\t0x40:    u256.MustFromDecimal(\"339195258003219555707034227454543997025\"), // 0xff2ea16466c96a3843ec78b326b52861,\n\t0x80:    u256.MustFromDecimal(\"338111622100601834656805679988414885971\"), // 0xfe5dee046a99a2a811c461f1969c3053,\n\t0x100:   u256.MustFromDecimal(\"335954724994790223023589805789778977700\"), // 0xfcbe86c7900a88aedcffc83b479aa3a4,\n\t0x200:   u256.MustFromDecimal(\"331682121138379247127172139078559817300\"), // 0xf987a7253ac413176f2b074cf7815e54,\n\t0x400:   u256.MustFromDecimal(\"323299236684853023288211250268160618739\"), // 0xf3392b0822b70005940c7a398e4b70f3,\n\t0x800:   u256.MustFromDecimal(\"307163716377032989948697243942600083929\"), // 0xe7159475a2c29b7443b29c7fa6e889d9,\n\t0x1000:  u256.MustFromDecimal(\"277268403626896220162999269216087595045\"), // 0xd097f3bdfd2022b8845ad8f792aa5825,\n\t0x2000:  u256.MustFromDecimal(\"225923453940442621947126027127485391333\"), // 0xa9f746462d870fdf8a65dc1f90e061e5,\n\t0x4000:  u256.MustFromDecimal(\"149997214084966997727330242082538205943\"), // 0x70d869a156d2a1b890bb3df62baf32f7,\n\t0x8000:  u256.MustFromDecimal(\"66119101136024775622716233608466517926\"),  // 0x31be135f97d08fd981231505542fcfa6,\n\t0x10000: u256.MustFromDecimal(\"12847376061809297530290974190478138313\"),  // 0x9aa508b5b7a84e1c677de54f3e99bc9,\n\t0x20000: u256.MustFromDecimal(\"485053260817066172746253684029974020\"),    // 0x5d6af8dedb81196699c329225ee604,\n\t0x40000: u256.MustFromDecimal(\"691415978906521570653435304214168\"),       // 0x2216e584f5fa1ea926041bedfe98,\n\t0x80000: u256.MustFromDecimal(\"1404880482679654955896180642\"),            // 0x48a170391f7dc42444e8fa2,\n}\n\nvar binaryLogConsts = [8]*u256.Uint{\n\tu256.MustFromDecimal(\"0\"),                                       // 0x0,\n\tu256.MustFromDecimal(\"3\"),                                       // 0x3,\n\tu256.MustFromDecimal(\"15\"),                                      // 0xF,\n\tu256.MustFromDecimal(\"255\"),                                     // 0xFF,\n\tu256.MustFromDecimal(\"65535\"),                                   // 0xFFFF,\n\tu256.MustFromDecimal(\"4294967295\"),                              // 0xFFFFFFFF,\n\tu256.MustFromDecimal(\"18446744073709551615\"),                    // 0xFFFFFFFFFFFFFFFF,\n\tu256.MustFromDecimal(\"340282366920938463463374607431768211455\"), // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,\n}\n\nvar (\n\tshift1By32Left = u256.MustFromDecimal(\"4294967296\") // (1 \u003c\u003c 32)\n)\n\nfunc TickMathGetSqrtRatioAtTick(tick int32) *u256.Uint { // uint160 sqrtPriceX96\n\tabsTick := abs(tick)\n\tratio := u256.MustFromDecimal(\"340282366920938463463374607431768211456\") // consts.Q128\n\n\tfor mask, value := range tickRatioMap {\n\t\tif absTick\u0026mask != 0 {\n\t\t\t// ratio = (ratio * value) \u003e\u003e 128\n\t\t\tratio = ratio.Mul(ratio, value)\n\t\t\tratio = ratio.Rsh(ratio, 128)\n\t\t}\n\t}\n\n\tif tick \u003e 0 {\n\t\t_maxUint256 := u256.MustFromDecimal(\"115792089237316195423570985008687907853269984665640564039457584007913129639935\") // consts.MAX_UINT256\n\t\t_tmp := new(u256.Uint).Div(_maxUint256, ratio)\n\t\tratio = _tmp.Clone()\n\t}\n\n\tshifted := ratio.Rsh(ratio, 32).Clone()\n\n\tremainder := ratio.Mod(ratio, shift1By32Left)\n\n\tif new(u256.Uint).Add(shifted.Clone(), remainder.Clone()).IsZero() {\n\t\treturn shifted\n\t}\n\n\treturn new(u256.Uint).Add(shifted, u256.One())\n}\n\nfunc TickMathGetTickAtSqrtRatio(sqrtPriceX96 *u256.Uint) int32 {\n\n\tratio := new(u256.Uint).Lsh(sqrtPriceX96, 32)\n\n\tmsb, adjustedRatio := findMSB(ratio)\n\tadjustedRatio = adjustRatio(ratio, msb)\n\n\tlog2 := calculateLog2(msb, adjustedRatio)\n\ttick := getTickValue(log2, sqrtPriceX96)\n\n\treturn tick\n}\n\n// findMSB computes the MSB (most significant bit) of the given ratio.\nfunc findMSB(ratio *u256.Uint) (*u256.Uint, *u256.Uint) {\n\tmsb := u256.Zero()\n\n\tfor i := 7; i \u003e= 1; i-- {\n\t\tf := new(u256.Uint).Lsh(gt(ratio, binaryLogConsts[i]), uint(i))\n\t\tmsb = new(u256.Uint).Or(msb, f)\n\t\tratio = new(u256.Uint).Rsh(ratio, uint(f.Uint64()))\n\t}\n\n\t// handle the remaining bits\n\t{\n\t\tf := gt(ratio, u256.One()) // 0x1\n\t\t// msb = msb | f\n\t\tmsb = new(u256.Uint).Or(msb, f)\n\t}\n\n\treturn msb, ratio\n}\n\n// adjustRatio adjusts the given ratio based on the MSB found.\n//\n// This adjustment ensures that the ratio falls within the specific range.\nfunc adjustRatio(ratio, msb *u256.Uint) *u256.Uint {\n\tif msb.Gte(u256.NewUint(128)) {\n\t\treturn new(u256.Uint).Rsh(ratio, uint(msb.Uint64()-127))\n\t}\n\n\treturn new(u256.Uint).Lsh(ratio, uint(127-msb.Uint64()))\n}\n\n// calculateLog2 calculates the binary logarith, of the adjusted ratio using a fixed-point arithmetic.\n//\n// This function iteratively squares the ratio and adjusts the result to compute the log base 2, which will determine the tick value.\nfunc calculateLog2(msb, ratio *u256.Uint) *i256.Int {\n\t_msb := i256.FromUint256(msb)\n\t_128 := i256.NewInt(128)\n\n\tlog_2 := i256.Zero().Sub(_msb, _128)\n\tlog_2 = log_2.Lsh(log_2, 64)\n\n\tfor i := 63; i \u003e= 51; i-- {\n\t\tratio = new(u256.Uint).Mul(ratio, ratio)\n\t\tratio = ratio.Rsh(ratio, 127)\n\n\t\tf := i256.FromUint256(new(u256.Uint).Rsh(ratio, 128))\n\n\t\t// log_2 = log_2 | (f \u003c\u003c i)\n\t\tlog_2 = i256.Zero().Or(log_2, i256.Zero().Lsh(f, uint(i)))\n\n\t\t// ratio = ratio \u003e\u003e uint64(f)\n\t\tratio = ratio.Rsh(ratio, uint(f.Uint64()))\n\t}\n\n\t// handle the remaining bits\n\t{\n\t\t// ratio = ratio * ratio \u003e\u003e 127\n\t\tratio = new(u256.Uint).Mul(ratio, ratio)\n\t\tratio = new(u256.Uint).Rsh(ratio, 127)\n\n\t\tf := i256.FromUint256(new(u256.Uint).Rsh(ratio, 128))\n\n\t\tlog_2 = i256.Zero().Or(log_2, i256.Zero().Lsh(f, 50))\n\t}\n\n\treturn log_2\n}\n\n// getTickValue determines the tick value corresponding to a given sqrtPriveX96.\n//\n// It calculates the upper and lower bounds for each tick, and selects the appropriate tock value\n// based on the given sqrtPriceX96.\nfunc getTickValue(log2 *i256.Int, sqrtPriceX96 *u256.Uint) int32 {\n\t// ref: https://github.com/Uniswap/v3-core/issues/500\n\t// 2^64 / log2 (√1.0001) = 255738958999603826347141\n\tlog_sqrt10001 := i256.Zero().Mul(log2, i256.MustFromDecimal(\"255738958999603826347141\"))\n\n\t// ref: https://ethereum.stackexchange.com/questions/113844/how-does-uniswap-v3s-logarithm-library-tickmath-sol-work/113912#113912\n\t// 0.010000497 x 2^128 = 3402992956809132418596140100660247210\n\ttickLow256 := i256.Zero().Sub(log_sqrt10001, i256.MustFromDecimal(\"3402992956809132418596140100660247210\"))\n\ttickLow256 = tickLow256.Rsh(tickLow256, 128)\n\ttickLow := int32(tickLow256.Int64())\n\n\t// ref: https://ethereum.stackexchange.com/questions/113844/how-does-uniswap-v3s-logarithm-library-tickmath-sol-work/113912#113912\n\t// 0.856 x 2^128 = 291339464771989622907027621153398088495\n\ttickHi256 := i256.Zero().Add(log_sqrt10001, i256.MustFromDecimal(\"291339464771989622907027621153398088495\"))\n\ttickHi256 = tickHi256.Rsh(tickHi256, 128)\n\ttickHi := int32(tickHi256.Int64())\n\n\tvar tick int32\n\tif tickLow == tickHi {\n\t\ttick = tickLow\n\t} else if TickMathGetSqrtRatioAtTick(tickHi).Lte(sqrtPriceX96) {\n\t\ttick = tickHi\n\t} else {\n\t\ttick = tickLow\n\t}\n\n\treturn tick\n}\n\nfunc gt(x, y *u256.Uint) *u256.Uint {\n\tif x.Gt(y) {\n\t\treturn u256.One()\n\t}\n\n\treturn u256.Zero()\n}\n\nfunc abs(x int32) int32 {\n\tif x \u003c 0 {\n\t\treturn -x\n\t}\n\n\treturn x\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"ca3vhegINKQvnRRALBk27hNcYzAQzrFwT+BbwlPsmxA7oJFXK6kjnbFTW2tv7NOFiRe2YzX5VaTprPK9e/3HpA=="}],"memo":""},"blockNum":"716168"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"gns","path":"gno.land/r/gnoswap/v2/gns","files":[{"name":"gns.gno","body":"package gns\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ownable\"\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/r/demo/users\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nconst MAXIMUM_SUPPLY = uint64(1_000_000_000_000_000) // 1B\n\nvar (\n\tbanker *grc20.Banker\n\tadmin  *ownable.Ownable\n\ttoken  grc20.Token\n)\n\nvar (\n\tlastMintedHeight int64\n\tamountToEmission uint64\n)\n\nfunc init() {\n\tadmin = ownable.NewWithAddress(\"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c\") // GNOSWAP_ADMIN\n\tbanker = grc20.NewBanker(\"Gnoswap\", \"GNS\", 6)\n\n\tbanker.Mint(admin.Owner(), 100_000_000_000_000) // 100_000_000 GNS ≈ 0.1B\n\ttoken = banker.Token()\n\n\tamountToEmission = MAXIMUM_SUPPLY - uint64(100_000_000_000_000)\n\n\tlastMintedHeight = std.GetHeight()\n}\n\nfunc TotalSupply() uint64 { return token.TotalSupply() }\n\nfunc TotalMinted() uint64 { return token.TotalSupply() - uint64(100_000_000_000_000) }\n\nfunc BalanceOf(owner pusers.AddressOrName) uint64 {\n\townerAddr := users.Resolve(owner)\n\treturn token.BalanceOf(ownerAddr)\n}\n\nfunc Allowance(owner, spender pusers.AddressOrName) uint64 {\n\townerAddr := users.Resolve(owner)\n\tspenderAddr := users.Resolve(spender)\n\treturn token.Allowance(ownerAddr, spenderAddr)\n}\n\nfunc Transfer(to pusers.AddressOrName, amount uint64) {\n\ttoAddr := users.Resolve(to)\n\tcheckErr(token.Transfer(toAddr, amount))\n}\n\nfunc Approve(spender pusers.AddressOrName, amount uint64) {\n\tspenderAddr := users.Resolve(spender)\n\tcheckErr(token.Approve(spenderAddr, amount))\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, amount uint64) {\n\tfromAddr := users.Resolve(from)\n\ttoAddr := users.Resolve(to)\n\tcheckErr(token.TransferFrom(fromAddr, toAddr, amount))\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn banker.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := pusers.AddressOrName(parts[1])\n\t\townerAddr := users.Resolve(owner)\n\t\tbalance := banker.BalanceOf(ownerAddr)\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Mint\nfunc Mint(address pusers.AddressOrName) {\n\t// only emission contract can call Mint\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.EMISSION_ADDR {\n\t\tpanic(\"only emission contract can call Mint\")\n\t}\n\n\t// if not yet initialized, mint 0 amount\n\tif initialized == false {\n\t\tprintln(\"GNS_not yet initialized\")\n\t\treturn\n\t}\n\n\t// calculate gns emission amount for every block, and send by single call\n\t// for this case, we assume that inside of block range gnoswap state hasn't changed.\n\tnowHeight := std.GetHeight()\n\tamountToMint := uint64(0)\n\n\tprintln(\"GNS_lastMintedHeight\", lastMintedHeight)\n\tprintln(\"GNS_lastMintedHeight + 1\", lastMintedHeight+1)\n\tprintln(\"GNS_nowHeight\", nowHeight)\n\tprintln(\"GNS_now-lastMint\", nowHeight-lastMintedHeight)\n\n\tif lastMintedHeight \u003e= nowHeight {\n\t\tprintln(\"GNS_only one mint for each block\")\n\t\treturn\n\t}\n\n\tfor i := lastMintedHeight + 1; i \u003c= nowHeight; i++ {\n\t\tamount := GetAmountByHeight(i)\n\t\tamountToMint += amount\n\n\t\tyear := GetHalvingYearByHeight(i)\n\t\thalvingYearMintAmount[year] += amount\n\n\t\tlastBlock := halvingYearBlock[year]\n\t\tif i == lastBlock {\n\t\t\t// halvingYearAmount[year] = amountToMint\n\t\t\t// halvingYearMintAmount[year] = amountToMint\n\t\t\tprintln(\" \u003e GNS_LAST_year:\", year)\n\t\t\tprintln(\" \u003e GNS_LAST_processing height:\", i)\n\t\t\tprintln(\" \u003e GNS_LAST_halvingYearAmount[1]:\\t\", halvingYearAmount[1])\n\t\t\tprintln(\" \u003e GNS_LAST_halvingYearMintAmount[1]:\\t\", halvingYearMintAmount[1])\n\t\t\tleftForThisYear := halvingYearAmount[year] - halvingYearMintAmount[year]\n\t\t\tprintln(\" \u003e GNS_LAST_leftForThisYear:\", leftForThisYear)\n\t\t\tprintln()\n\n\t\t\tamountToMint += leftForThisYear\n\t\t\thalvingYearMintAmount[year] += leftForThisYear\n\t\t}\n\t}\n\terr := banker.Mint(users.Resolve(address), amountToMint)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tlastMintedHeight = nowHeight\n\tprintln(\"GNS_lastMintedHeight:\", lastMintedHeight)\n\tprintln(\"GNS_amountToMint:\", amountToMint)\n}\n\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n"},{"name":"halving.gno","body":"package gns\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// init 12 years halving tier block\n/*\n\tNOTE: assume block will be created every 2 second by default\n\t2 second = 1 block\n\t1 minute = 30 block\n\t1 hour = 1800 block\n\t1 day = 43200 block\n\t(365 days) 1 year = 15768000 block\n\n\t2 year = +31536000 block\n\t4 year = +63072000 block\n\t6 year = +94608000 block\n\t8 year = +126144000 block\n\t12 year = +189216000 block\n*/\nconst YEAR_BLOCK int64 = 15768000\n\nconst TIMESTAMP_365DAYS int64 = 31536000\n\nvar avgBlockTimeMs int64 = 2000 // 2000s = 2s for default\n\nvar (\n\tinitialized    bool\n\tstartHeight    int64\n\tstartTimestamp int64\n)\n\nvar halvingYearBlock = make(map[int64]int64)     // year =\u003e block\nvar halvingYearTimestamp = make(map[int64]int64) // year =\u003e timestamp\n\nvar halvingYearAmount = make(map[int64]uint64)     // year =\u003e mintAmount\nvar halvingYearMintAmount = make(map[int64]uint64) // year =\u003e (actual) mintAmount\nvar halvingYearAccuAmount = make(map[int64]uint64) // year =\u003e accuAmount\nfunc init() {\n\t// yearly mint amount\n\thalvingYearAmount[1] = 18_750_000_000_000 * 12 // 225000000000000\n\thalvingYearAmount[2] = 18_750_000_000_000 * 12 // 225000000000000\n\thalvingYearAmount[3] = 9_375_000_000_000 * 12  // 112500000000000\n\thalvingYearAmount[4] = 9_375_000_000_000 * 12  // 112500000000000\n\thalvingYearAmount[5] = 4_687_500_000_000 * 12  // 56250000000000\n\thalvingYearAmount[6] = 4_687_500_000_000 * 12  // 56250000000000\n\thalvingYearAmount[7] = 2_343_750_000_000 * 12  // 28125000000000\n\thalvingYearAmount[8] = 2_343_750_000_000 * 12  // 28125000000000\n\thalvingYearAmount[9] = 1_171_875_000_000 * 12  // 14062500000000\n\thalvingYearAmount[10] = 1_171_875_000_000 * 12 // 14062500000000\n\thalvingYearAmount[11] = 1_171_875_000_000 * 12 // 14062500000000\n\thalvingYearAmount[12] = 1_171_875_000_000 * 12 // 14062500000000\n\n\t// yearly accumulated mint amount\n\thalvingYearAccuAmount[1] = halvingYearAmount[1]\n\thalvingYearAccuAmount[2] = halvingYearAccuAmount[1] + halvingYearAmount[2]\n\thalvingYearAccuAmount[3] = halvingYearAccuAmount[2] + halvingYearAmount[3]\n\thalvingYearAccuAmount[4] = halvingYearAccuAmount[3] + halvingYearAmount[4]\n\thalvingYearAccuAmount[5] = halvingYearAccuAmount[4] + halvingYearAmount[5]\n\thalvingYearAccuAmount[6] = halvingYearAccuAmount[5] + halvingYearAmount[6]\n\thalvingYearAccuAmount[7] = halvingYearAccuAmount[6] + halvingYearAmount[7]\n\thalvingYearAccuAmount[8] = halvingYearAccuAmount[7] + halvingYearAmount[8]\n\thalvingYearAccuAmount[9] = halvingYearAccuAmount[8] + halvingYearAmount[9]\n\thalvingYearAccuAmount[10] = halvingYearAccuAmount[9] + halvingYearAmount[10]\n\thalvingYearAccuAmount[11] = halvingYearAccuAmount[10] + halvingYearAmount[11]\n\thalvingYearAccuAmount[12] = halvingYearAccuAmount[11] + halvingYearAmount[12]\n}\n\nvar amountPerBlockPerHalvingYear = make(map[int64]uint64) // year =\u003e reward per block\n\nfunc init() {\n\t// caller := std.PrevRealm().Addr()\n\t// if caller != consts.STAKER_ADDR {\n\t// \tpanic(\n\t// \t\tufmt.Sprintf(\n\t// \t\t\t\"only staker(%s) can init start height, start timestamp, called from %s\",\n\t// \t\t\tconsts.STAKER_ADDR,\n\t// \t\t\tcaller,\n\t// \t\t),\n\t// \t)\n\t// }\n\n\theight := std.GetHeight()\n\n\tstartHeight = height\n\tstartTimestamp = time.Now().Unix()\n\n\tinitialized = true\n\n\tfor i := int64(1); i \u003c 13; i++ {\n\t\thalvingYearBlock[i] = height + YEAR_BLOCK*i\n\t\thalvingYearTimestamp[i] = startTimestamp + (TIMESTAMP_365DAYS * i)\n\n\t\tamountPerYear := halvingYearAmount[i]  // amount per year\n\t\tamountPerDay := amountPerYear / 365    // amount per day\n\t\tamountPerBlock := amountPerDay / 43200 // amount per block ( 1 day = 43200 block (2s/block) )\n\n\t\tamountPerBlockPerHalvingYear[i] = uint64(amountPerBlock)\n\t}\n}\n\nfunc SetAvgBlockTimeInMs(ms int64) {\n\t// admin or governance or staker only\n\tcaller := std.PrevRealm().Addr()\n\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR \u0026\u0026 caller != consts.STAKER_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"only admin(%s) or governance(%s) or staker(%s) can set avg block time, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tconsts.STAKER_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\tavgBlockTimeMs = ms\n\n\t// which year current time is in\n\tnow := time.Now().Unix()\n\tprintln(\"GNS_HALVING__now_time:\", now)\n\tprintln(\"GNS_HALVING__now_height:\", std.GetHeight())\n\tyear, endTimestamp := GetHalvingYearByTimestamp(now)\n\tprintln(\"GNS_HALVING__year:\", year, \"endTimestamp:\", endTimestamp)\n\n\t// how much time left to next halving\n\ttimeLeft := endTimestamp - now\n\tprintln(\"GNS_HALVING__timeLeft:\", timeLeft)\n\n\t// how many block left to next halving\n\ttimeLeftMs := timeLeft * 1000\n\tprintln(\"GNS_HALVING__timeLeftMs:\", timeLeftMs)\n\tblockLeft := timeLeftMs / avgBlockTimeMs\n\tprintln(\"GNS_HALVING__blockLeft:\", blockLeft)\n\n\t// how many reward left to next halving\n\tminted := TotalMinted()\n\tprintln(\"GNS_HALVING__minted:\", minted)\n\tamountLeft := halvingYearAccuAmount[year] - minted\n\tprintln(\"GNS_HALVING__amountLeft:\", amountLeft)\n\n\t// how much reward per block\n\tadjustedAmountPerBlock := amountLeft / uint64(blockLeft)\n\tprintln(\"GNS_HALVING__adjustedAmountPerBlock:\", adjustedAmountPerBlock)\n\n\t// update it\n\tamountPerBlockPerHalvingYear[year] = adjustedAmountPerBlock\n\tprintln(\"GNS_HALVING__amountPerBlockPerHalvingYear[year]:\", amountPerBlockPerHalvingYear[year])\n\n\t// adjust halving block\n\tfor year, block := range halvingYearBlock {\n\t\tprintln(\"GNS_HALVING__ \u003e year:\\t\\t\", year)\n\n\t\tyearEnd := halvingYearTimestamp[year]\n\t\tprintln(\"GNS_HALVING__ \u003e endTime:\\t\", yearEnd)\n\n\t\tdiff := yearEnd - now\n\t\tprintln(\"GNS_HALVING__ \u003e diff:\\t\\t\", diff)\n\n\t\tnumBlock := diff * 1000 / avgBlockTimeMs\n\t\tprintln(\"GNS_HALVING__ \u003e numBlock:\\t\", numBlock)\n\n\t\thalvingYearBlock[year] = std.GetHeight() + numBlock\n\t\tprintln(\"GNS_HALVING__ \u003e origBlock:\\t\", block)\n\t\tprintln(\"GNS_HALVING__ \u003e newBlock:\\t\", halvingYearBlock[year])\n\n\t\tprintln()\n\t}\n\n\tprintln()\n\n}\n\nfunc GetAmountByHeight(height int64) uint64 {\n\thalvingYear := GetHalvingYearByHeight(height)\n\n\treturn amountPerBlockPerHalvingYear[halvingYear]\n}\n\nfunc GetHalvingYearByHeight(height int64) int64 {\n\t// determine which halving year block is in\n\tfor year, block := range halvingYearBlock {\n\t\tif height \u003c= block {\n\t\t\treturn year\n\t\t}\n\t}\n\n\treturn 0\n}\n\nfunc GetHalvingYearByTimestamp(timestamp int64) (int64, int64) {\n\t// determine which halving tier block is in\n\tfor tier, ts := range halvingYearTimestamp {\n\t\tif timestamp \u003c= ts {\n\t\t\treturn tier, ts\n\t\t}\n\t}\n\n\treturn 0, 0\n}\n\nfunc getYearlyBlockForTimestampMs(ms int64) int64 {\n\tyearMs := TIMESTAMP_365DAYS * 1000 // how much millisecond in a year\n\treturn yearMs / ms                 // how many block in a year\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"PfPd3L92EcJM1ukOUmivA9XwKqqlD5lKOm7OpjorhvVoNmwB6HXZ99MfSZVGTdfL+H2Kmq/fZzJ9lGzpK6a6qw=="}],"memo":""},"blockNum":"716170"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"gnft","path":"gno.land/r/gnoswap/v2/gnft","files":[{"name":"gnft.gno","body":"package gnft\n\nimport (\n\t\"math/rand\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/r/demo/users\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nvar (\n\tadmin std.Address = \"g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2\" // deployed position contract\n\tgnft              = grc721.NewBasicNFT(\"GNOSWAP NFT\", \"GNFT\")\n)\n\nvar userMinted = make(map[std.Address][]grc721.TokenID)\n\nfunc init() {}\n\n// Getters\nfunc TotalSupply() uint64 {\n\treturn gnft.TokenCount()\n}\n\nfunc GetTokenURI(tid grc721.TokenID) string {\n\turi, err := gnft.TokenURI(tid)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\treturn string(uri)\n}\n\nfunc BalanceOf(user pusers.AddressOrName) uint64 {\n\tbalance, err := gnft.BalanceOf(users.Resolve(user))\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := gnft.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user pusers.AddressOrName) bool {\n\treturn gnft.IsApprovedForAll(users.Resolve(owner), users.Resolve(user))\n}\n\nfunc GetApproved(tid grc721.TokenID) (std.Address, bool) {\n\taddr, err := gnft.GetApproved(tid)\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\n\treturn addr, true\n}\n\n// Setters\n\nfunc Approve(user pusers.AddressOrName, tid grc721.TokenID) {\n\terr := gnft.Approve(users.Resolve(user), tid)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc SetApprovalForAll(user pusers.AddressOrName, approved bool) {\n\terr := gnft.SetApprovalForAll(users.Resolve(user), approved)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc TransferFrom(from, to pusers.AddressOrName, tid grc721.TokenID) {\n\terr := gnft.TransferFrom(users.Resolve(from), users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\n// Admin\nfunc Mint(to pusers.AddressOrName, tid grc721.TokenID) grc721.TokenID {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\n\terr := gnft.Mint(users.Resolve(to), tid)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tuserMinted[users.Resolve(to)] = append(userMinted[users.Resolve(to)], tid)\n\treturn tid\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := gnft.Burn(tid)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc SetAdmin(newAdmin pusers.AddressOrName) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\tadmin = users.Resolve(newAdmin)\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn gnft.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"gnft_assertIsAdmin_restricted access\")\n\t}\n}\n\nfunc Exists(tid grc721.TokenID) bool {\n\t_, err := gnft.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc SetTokenURI(tid grc721.TokenID) {\n\t// rand instance\n\tseed1 := uint64(time.Now().Unix())\n\tseed2 := uint64(time.Now().UnixNano())\n\tpcg := rand.NewPCG(seed1, seed2)\n\tr := rand.New(pcg)\n\n\ttokenURI := genImageURI(r)\n\n\tok, err := gnft.SetTokenURI(tid, grc721.TokenURI(tokenURI))\n\tif !ok {\n\t\tpanic(err.Error())\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_origCaller\", std.GetOrigCaller().String(),\n\t\t\"m_prevRealm\", std.PrevRealm().PkgPath(),\n\t\t\"p_tokenId\", string(tid),\n\t\t\"tokenURI\", tokenURI,\n\t\t\"SetTokenURI\", \"SetTokenURI\",\n\t)\n}\n\nfunc SetTokenURILast() {\n\torigCaller := std.GetOrigCaller()\n\n\t// rand instance\n\tseed1 := uint64(time.Now().Unix())\n\tseed2 := uint64(time.Now().UnixNano())\n\tpcg := rand.NewPCG(seed1, seed2)\n\tr := rand.New(pcg)\n\n\tusersNFT := userMinted[origCaller]\n\tfor _, tid := range usersNFT {\n\t\ttokenURI := genImageURI(r)\n\n\t\tok, err := gnft.SetTokenURI(tid, grc721.TokenURI(tokenURI))\n\t\tif !ok {\n\t\t\tpanic(err.Error())\n\t\t}\n\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP\",\n\t\t\t\"m_origCaller\", std.GetOrigCaller().String(),\n\t\t\t\"m_prevRealm\", std.PrevRealm().PkgPath(),\n\t\t\t\"p_tokenId\", string(tid),\n\t\t\t\"tokenURI\", tokenURI,\n\t\t\t\"SetTokenURILast\", \"SetTokenURILast\",\n\t\t)\n\t}\n\n\tdelete(userMinted, origCaller)\n}\n"},{"name":"svg_generator.gno","body":"package gnft\n\nimport (\n\tb64 \"encoding/base64\"\n\t\"math/rand\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar baseTempalte = `\u003csvg width=\"135\" height=\"135\" viewBox=\"0 0 135 135\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\n\u003cg clip-path=\"url(#clip0_7698_56846)\"\u003e\n\u003ccircle cx=\"67.5\" cy=\"67.5\" r=\"67.5\" fill=\"url(#paint0_linear_7698_56846)\"/\u003e\n\u003cpath d=\"M51.2905 42.9449L66.4895 33L97 52.8061L81.8241 62.7425L51.2905 42.9449Z\" fill=\"white\"/\u003e\n\u003cpath d=\"M51.6055 67.5059L66.8044 57.561L97 77.0657L82.1046 87.1793L51.6055 67.5059Z\" fill=\"white\" fill-opacity=\"0.4\"/\u003e\n\u003cpath d=\"M36.0464 81.7559L51.2905 71.811L81.7336 91.6547L66.4895 101.508L36.0464 81.7559Z\" fill=\"white\" fill-opacity=\"0.6\"/\u003e\n\u003cpath d=\"M36.001 52.8055L51.2884 42.9177L51.2884 71.8145L36.001 81.779L36.001 52.8055Z\" fill=\"white\"/\u003e\n\u003cpath d=\"M82.1051 87.1797L97.0016 77.0662L97.0016 81.7029L81.7896 91.629L82.1051 87.1797Z\" fill=\"white\" fill-opacity=\"0.5\"/\u003e\n\u003cpath d=\"M51.2905 42.9449L66.4895 33L97 52.8061L81.8241 62.7425L51.2905 42.9449Z\" fill=\"white\"/\u003e\n\u003cpath d=\"M51.6055 67.5059L66.8044 57.561L97 77.0657L82.1046 87.1793L51.6055 67.5059Z\" fill=\"white\" fill-opacity=\"0.4\"/\u003e\n\u003cpath d=\"M36.0464 81.7559L51.2905 71.811L81.7336 91.6547L66.4895 101.508L36.0464 81.7559Z\" fill=\"white\" fill-opacity=\"0.6\"/\u003e\n\u003cpath d=\"M36.001 52.8055L51.2884 42.9177L51.2884 71.8145L36.001 81.779L36.001 52.8055Z\" fill=\"white\"/\u003e\n\u003cpath d=\"M82.1051 87.1797L97.0016 77.0662L97.0016 81.7029L81.7896 91.629L82.1051 87.1797Z\" fill=\"white\" fill-opacity=\"0.5\"/\u003e\n\u003c/g\u003e\n\u003cdefs\u003e\n\u003clinearGradient id=\"paint0_linear_7698_56846\" x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" gradientUnits=\"userSpaceOnUse\"\u003e\n\u003cstop stop-color=\"%s\"/\u003e\n\u003cstop offset=\"1\" stop-color=\"%s\"/\u003e\n\u003c/linearGradient\u003e\n\u003cclipPath id=\"clip0_7698_56846\"\u003e\n\u003crect width=\"135\" height=\"135\" fill=\"white\"/\u003e\n\u003c/clipPath\u003e\n\u003c/defs\u003e\n\u003c/svg\u003e\n`\n\n// range for hex color\nconst charset = \"0123456789ABCDEF\"\n\nfunc genImageURI(r *rand.Rand) string {\n\timageRaw := genImageRaw(r)\n\tsEnc := b64.StdEncoding.EncodeToString([]byte(imageRaw))\n\n\treturn \"data:image/svg+xml;base64,\" + sEnc\n}\n\nfunc genImageRaw(r *rand.Rand) string {\n\tx1 := 7 + r.Uint64N(7)\n\ty1 := 7 + r.Uint64N(7)\n\n\tx2 := 121 + r.Uint64N(6)\n\ty2 := 121 + r.Uint64N(6)\n\n\tvar color1, color2 strings.Builder\n\tcolor1.Grow(7)\n\tcolor2.Grow(7)\n\tcolor1.WriteByte('#')\n\tcolor2.WriteByte('#')\n\n\tfor i := 0; i \u003c 6; i++ {\n\t\tcolor1.WriteByte(charset[r.IntN(16)])\n\t\tcolor2.WriteByte(charset[r.IntN(16)])\n\t}\n\n\trandImage := ufmt.Sprintf(baseTempalte, x1, y1, x2, y2, color1.String(), color2.String())\n\treturn randImage\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"raFig1GznfI9W8g9ACO3PnYh+A6dx9jzjFRuGb24WecRBO9Xyme5Dm84MWrfP/8hWR04HBWtldVW0m7R+rQccA=="}],"memo":""},"blockNum":"716172"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"emission","path":"gno.land/r/gnoswap/v2/emission","files":[{"name":"distribution.gno","body":"package emission\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\t\"gno.land/r/gnoswap/v2/gns\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// emissionTarget represents different targets for token emission.\ntype emissionTarget int\n\n// distributionPctMap maps emission targets to their respective distribution percentages.\ntype distributionPctMap map[emissionTarget]uint64\n\nconst (\n\tLIQUIDITY_STAKING emissionTarget = iota + 1\n\tDEVOPS\n\tCOMMUNITY_POOL\n\tXGNS\n)\n\n// distributionPct defines the distribution percentages.\nvar distributionPct distributionPctMap = distributionPctMap{\n\tLIQUIDITY_STAKING: 7500, // 75%\n\tDEVOPS:            2000, // 20%\n\tCOMMUNITY_POOL:    500,  // 5%\n\tXGNS:              0,    // 0%\n}\n\nvar (\n\ttoStaker        uint64\n\ttoDevOps        uint64\n\ttoCommunityPool uint64\n\ttoXGNS          uint64\n\n\ttoStakerAccu        uint64\n\ttoDevOpsAccu        uint64\n\ttoCommunityPoolAccu uint64\n\ttoXGNSAccu          uint64\n)\n\n// GetDistributionPct returns the distribution percentage for the given target.\nfunc GetDistributionPct(target emissionTarget) uint64 {\n\treturn distributionPct[target]\n}\n\n// ChangeDistributionPct01 changes the distribution percentage for the given single target.\nfunc ChangeDistributionPct01(target01 emissionTarget, pct01 uint64) {\n\tchangeDistributionPct(target01, pct01)\n\n\tcheckSumDistributionPct()\n}\n\n// ChangeDistributionPct02 changes the distribution percentage for the given two targets.\nfunc ChangeDistributionPct02(\n\ttarget01 emissionTarget, pct01 uint64,\n\ttarget02 emissionTarget, pct02 uint64,\n) {\n\tchangeDistributionPct(target01, pct01)\n\tchangeDistributionPct(target02, pct02)\n\n\tcheckSumDistributionPct()\n}\n\n// ChangeDistributionPct03 changes the distribution percentage for the given three targets.\nfunc ChangeDistributionPct03(\n\ttarget01 emissionTarget, pct01 uint64,\n\ttarget02 emissionTarget, pct02 uint64,\n\ttarget03 emissionTarget, pct03 uint64,\n) {\n\tchangeDistributionPct(target01, pct01)\n\tchangeDistributionPct(target02, pct02)\n\tchangeDistributionPct(target03, pct03)\n\n\tcheckSumDistributionPct()\n}\n\n// ChangeDistributionPct04 changes the distribution percentage for the given four targets.\nfunc ChangeDistributionPct04(\n\ttarget01 emissionTarget, pct01 uint64,\n\ttarget02 emissionTarget, pct02 uint64,\n\ttarget03 emissionTarget, pct03 uint64,\n\ttarget04 emissionTarget, pct04 uint64,\n) {\n\tchangeDistributionPct(target01, pct01)\n\tchangeDistributionPct(target02, pct02)\n\tchangeDistributionPct(target03, pct03)\n\tchangeDistributionPct(target04, pct04)\n\n\tcheckSumDistributionPct()\n}\n\n// distributeToTarget distributes the specified amount to different targets based on their percentages.\nfunc distributeToTarget(amount uint64) {\n\ttotalSent := uint64(0)\n\tfor target, pct := range distributionPct {\n\t\tdistAmount := calculateAmount(amount, pct)\n\t\ttotalSent += distAmount\n\n\t\ttransferToTarget(target, distAmount)\n\t}\n\n\t// `amount-totalSent` can be left due to rounding\n\t// it will be distributed next time\n}\n\n// calculateAmount calculates the amount based on the given percentage in basis points.\nfunc calculateAmount(amount, bptPct uint64) uint64 {\n\treturn amount * bptPct / 10000\n}\n\n// transferToTarget transfers the specified amount to the given addresses.\nfunc transferToTarget(target emissionTarget, amount uint64) {\n\tswitch target {\n\tcase LIQUIDITY_STAKING:\n\t\t// transfer to staker contract\n\t\tgns.Transfer(a2u(consts.STAKER_ADDR), amount)\n\t\ttoStaker = amount\n\t\ttoStakerAccu += amount\n\tcase DEVOPS:\n\t\t// transfer to devops\n\t\tgns.Transfer(a2u(consts.DEV_OPS), amount)\n\t\ttoDevOps = amount\n\t\ttoDevOpsAccu += amount\n\tcase COMMUNITY_POOL:\n\t\tgns.Transfer(a2u(consts.COMMUNITY_POOL_ADDR), amount)\n\t\ttoCommunityPool = amount\n\t\ttoCommunityPoolAccu += amount\n\tcase XGNS:\n\t\tgns.Transfer(a2u(consts.X_GNS_ADDR), amount)\n\t\ttoXGNS = amount\n\t\ttoXGNSAccu += amount\n\tdefault:\n\t\tpanic(\"invalid target\")\n\t}\n}\n\n// changeDistributionPct changes the distribution percentage for the given target.\nfunc changeDistributionPct(target emissionTarget, pct uint64) {\n\t// only admin or governance can change\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\"only admin or governance can change distribution percentages\")\n\t}\n\n\t// cannot add new target\n\tif target != LIQUIDITY_STAKING \u0026\u0026 target != DEVOPS \u0026\u0026 target != COMMUNITY_POOL \u0026\u0026 target != XGNS {\n\t\tpanic(\"invalid target\")\n\t}\n\n\t// Maximum pct for a single target is 10000 basis points (100%)\n\tif pct \u003e 10000 {\n\t\tpanic(\"percentage too high\")\n\t}\n\n\tdistributionPct[target] = pct\n}\n\n// checkSumDistributionPct ensures the sum of all distribution percentages is 100%\nfunc checkSumDistributionPct() {\n\tsum := uint64(0)\n\tfor _, pct := range distributionPct {\n\t\tsum += pct\n\t}\n\n\tif sum != 10000 {\n\t\tpanic(ufmt.Sprintf(\"sum of all pct should be 100%% (10000 bps), got %d\\n\", sum))\n\t}\n}\n\nfunc GetLastDistributedAmount() (int64, uint64, uint64, uint64, uint64, uint64, uint64) {\n\treturn lastExecutedHeight, lastStakerGnsBalance, emissionGnsBalance, toStaker, toDevOps, toCommunityPool, toXGNS\n}\n\nfunc GetAccuDistributedAmount() (uint64, uint64, uint64, uint64) {\n\treturn toStaker, toDevOps, toCommunityPool, toXGNS\n}\n\nfunc GetLastDistributeToStaker() uint64 {\n\treturn toStaker\n}\n"},{"name":"emission.gno","body":"package emission\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\n// lastExecutedHeight is a flag to prevent multiple calling MintAndDistributeGns in the same block height\nvar lastExecutedHeight int64\n\n// lastStakerGnsBalance is history of staker GNS balance\nvar lastStakerGnsBalance uint64\n\n// emissionGnsBalance is balance of emission address\nvar emissionGnsBalance uint64\n\n// MintAndDistributeGns mints GNS and distributes to target\nfunc MintAndDistributeGns() {\n\tlastStakerGnsBalance = gnsBalance(consts.STAKER_ADDR)\n\n\theight := std.GetHeight()\n\tif lastExecutedHeight \u003e= height {\n\t\t// do not panic here, we don't want to panic entire transaction that calls this function\n\t\treturn\n\t}\n\n\tmintGns()\n\n\temissionGnsBalance = gnsBalance(emissionAddr)\n\tdistributeToTarget(emissionGnsBalance)\n\n\t// XXX TODO: REMOVE AFTER EMISSION QA\n\tprintln(\"EM_emissionGnsBalance:\\t\\t\\t\", emissionGnsBalance)\n\tprintln(\"EM_emissionGnsBalance(75%):\\t\\t\", emissionGnsBalance*75/100)\n\n\tlastExecutedHeight = height\n}\n\nfunc GetLastExecutedHeight() int64 {\n\treturn lastExecutedHeight\n}\n\nfunc GetLastStakerGnsBalance() uint64 {\n\treturn lastStakerGnsBalance\n}\n"},{"name":"mint_gns.gno","body":"package emission\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\t\"gno.land/r/gnoswap/v2/gns\"\n)\n\nvar emissionAddr std.Address = consts.EMISSION_ADDR\n\n// mintGns mints GNS to emission address\nfunc mintGns() {\n\tgns.Mint(a2u(emissionAddr))\n}\n"},{"name":"utils.gno","body":"package emission\n\nimport (\n\t\"std\"\n\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/gnoswap/v2/gns\"\n)\n\nfunc a2u(addr std.Address) pusers.AddressOrName {\n\treturn pusers.AddressOrName(addr)\n}\n\nfunc gnsBalance(addr std.Address) uint64 {\n\ta2u := pusers.AddressOrName(addr)\n\n\treturn gns.BalanceOf(a2u)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"olAaliAgUQ6SmCadg18tlJtiIWobz9Mn4nhZ0x3ggSIPH0Wueq1Z3GJZCBnfb/nx42AM2tnY6h+joq57hMUSBQ=="}],"memo":""},"blockNum":"716181"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"pool","path":"gno.land/r/gnoswap/v2/pool","files":[{"name":"_GET_no_receiver.gno","body":"package pool\n\nimport (\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc PoolGetSlot0Tick(poolPath string) int32 {\n\tpool, exist := pools[poolPath]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[POOL] _GET_no_receiver.gno__PoolGetSlot0Tick() || pool(%s) does not exist\", poolPath))\n\t}\n\n\treturn pool.slot0.tick\n}\n\nfunc PoolGetLiquidity(poolPath string) string {\n\tpool, exist := pools[poolPath]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[POOL] _GET_no_receiver.gno__PoolGetLiquidity() || pool(%s) does not exist\", poolPath))\n\t}\n\n\treturn pool.liquidity.ToString()\n}\n"},{"name":"_GET_receiver.gno","body":"package pool\n\nimport (\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// PoolGetPoolList returns a list of all pool paths\nfunc PoolGetPoolList() []string {\n\tpoolPaths := []string{}\n\tfor poolPath, _ := range pools {\n\t\tpoolPaths = append(poolPaths, poolPath)\n\t}\n\n\treturn poolPaths\n}\n\nfunc (pool *Pool) PoolGetSlot0() Slot0 {\n\treturn pool.slot0\n}\n\nfunc (pool *Pool) PoolGetSlot0SqrtPriceX96() *u256.Uint {\n\treturn pool.slot0.sqrtPriceX96\n}\n\nfunc (pool *Pool) PoolGetSlot0Tick() int32 {\n\treturn pool.slot0.tick\n}\n\nfunc (pool *Pool) PoolGetPositionFeeGrowthInside0LastX128(key string) *u256.Uint {\n\tposition, exist := pool.positions[key]\n\tif !exist {\n\t\treturn u256.Zero()\n\t}\n\n\treturn position.feeGrowthInside0LastX128\n}\n\nfunc (pool *Pool) PoolGetPositionFeeGrowthInside1LastX128(key string) *u256.Uint {\n\tposition, exist := pool.positions[key]\n\tif !exist {\n\t\treturn u256.Zero()\n\t}\n\n\treturn position.feeGrowthInside1LastX128\n}\n\nfunc (pool *Pool) PoolGetTickFeeGrowthOutside0X128(x int32) *u256.Uint {\n\ttick, exist := pool.ticks[x]\n\tif !exist {\n\t\treturn u256.Zero()\n\t}\n\n\treturn tick.feeGrowthOutside0X128\n}\n\nfunc (pool *Pool) PoolGetTickFeeGrowthOutside1X128(x int32) *u256.Uint {\n\ttick, exist := pool.ticks[x]\n\tif !exist {\n\t\treturn u256.Zero()\n\t}\n\n\treturn tick.feeGrowthOutside1X128\n}\n\nfunc (pool *Pool) PoolGetToken0Path() string {\n\treturn pool.token0Path\n}\n\nfunc (pool *Pool) PoolGetToken1Path() string {\n\treturn pool.token1Path\n}\n\nfunc (pool *Pool) PoolGetFee() uint32 {\n\treturn pool.fee\n}\n\nfunc (pool *Pool) PoolGetFeeGrowthGlobal0X128() *u256.Uint {\n\treturn pool.feeGrowthGlobal0X128\n}\n\nfunc (pool *Pool) PoolGetFeeGrowthGlobal1X128() *u256.Uint {\n\treturn pool.feeGrowthGlobal1X128\n}\n\nfunc (pool *Pool) PoolGetLiquidity() *u256.Uint {\n\treturn pool.liquidity\n}\n"},{"name":"_RPC_api.gno","body":"package pool\n\nimport (\n\tb64 \"encoding/base64\"\n\n\t\"gno.land/p/demo/json\"\n\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype RpcPool struct {\n\tPoolPath string `json:\"poolPath\"`\n\n\tToken0Path string `json:\"token0Path\"`\n\tToken1Path string `json:\"token1Path\"`\n\n\tToken0Balance string `json:\"token0Balance\"`\n\tToken1Balance string `json:\"token1Balance\"`\n\n\tFee uint32 `json:\"fee\"`\n\n\tTickSpacing int32 `json:\"tickSpacing\"`\n\n\tMaxLiquidityPerTick string `json:\"maxLiquidityPerTick\"`\n\n\tSlot0SqrtPriceX96 string `json:\"sqrtPriceX96\"`\n\tSlot0Tick         int32  `json:\"tick\"`\n\tSlot0FeeProtocol  uint8  `json:\"feeProtocol\"`\n\tSlot0Unlocked     bool   `json:\"unlocked\"`\n\n\tFeeGrowthGlobal0X128 string `json:\"feeGrowthGlobal0X128\"`\n\tFeeGrowthGlobal1X128 string `json:\"feeGrowthGlobal1X128\"`\n\n\tToken0ProtocolFee string `json:\"token0ProtocolFee\"`\n\tToken1ProtocolFee string `json:\"token1ProtocolFee\"`\n\n\tLiquidity string `json:\"liquidity\"`\n\n\tTicks RpcTicks `json:\"ticks\"`\n\n\tTickBitmaps RpcTickBitmaps `json:\"tickBitmaps\"`\n\n\tPositions []RpcPosition `json:\"positions\"`\n}\n\ntype RpcTickBitmaps map[int16]string // tick(wordPos) =\u003e bitmap(tickWord ^ mask)\n\ntype RpcTicks map[int32]RpcTickInfo // tick =\u003e RpcTickInfo\n\ntype RpcTickInfo struct {\n\tLiquidityGross string `json:\"liquidityGross\"`\n\tLiquidityNet   string `json:\"liquidityNet\"`\n\n\tFeeGrowthOutside0X128 string `json:\"feeGrowthOutside0X128\"`\n\tFeeGrowthOutside1X128 string `json:\"feeGrowthOutside1X128\"`\n\n\tTickCumulativeOutside int64 `json:\"tickCumulativeOutside\"`\n\n\tSecondsPerLiquidityOutsideX string `json:\"secondsPerLiquidityOutsideX\"`\n\tSecondsOutside              uint32 `json:\"secondsOutside\"`\n\n\tInitialized bool `json:\"initialized\"`\n}\n\ntype RpcPosition struct {\n\tOwner string `json:\"owner\"`\n\n\tTickLower int32 `json:\"tickLower\"`\n\tTickUpper int32 `json:\"tickUpper\"`\n\n\tLiquidity string `json:\"liquidity\"`\n\n\tToken0Owed string `json:\"token0Owed\"`\n\tToken1Owed string `json:\"token1Owed\"`\n}\n\nfunc ApiGetPools() string {\n\trpcPools := []RpcPool{}\n\tfor poolPath, _ := range pools {\n\t\trpcPool := rpcMakePool(poolPath)\n\t\trpcPools = append(rpcPools, rpcPool)\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, pool := range rpcPools {\n\t\t_poolNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"poolPath\":             json.StringNode(\"poolPath\", pool.PoolPath),\n\t\t\t\"token0Path\":           json.StringNode(\"token0Path\", pool.Token0Path),\n\t\t\t\"token1Path\":           json.StringNode(\"token1Path\", pool.Token1Path),\n\t\t\t\"token0Balance\":        json.StringNode(\"token0Balance\", pool.Token0Balance),\n\t\t\t\"token1Balance\":        json.StringNode(\"token1Balance\", pool.Token1Balance),\n\t\t\t\"fee\":                  json.NumberNode(\"fee\", float64(pool.Fee)),\n\t\t\t\"tickSpacing\":          json.NumberNode(\"tickSpacing\", float64(pool.TickSpacing)),\n\t\t\t\"maxLiquidityPerTick\":  json.StringNode(\"maxLiquidityPerTick\", pool.MaxLiquidityPerTick),\n\t\t\t\"sqrtPriceX96\":         json.StringNode(\"sqrtPriceX96\", pool.Slot0SqrtPriceX96),\n\t\t\t\"tick\":                 json.NumberNode(\"tick\", float64(pool.Slot0Tick)),\n\t\t\t\"feeProtocol\":          json.NumberNode(\"feeProtocol\", float64(pool.Slot0FeeProtocol)),\n\t\t\t\"unlocked\":             json.BoolNode(\"unlocked\", pool.Slot0Unlocked),\n\t\t\t\"feeGrowthGlobal0X128\": json.StringNode(\"feeGrowthGlobal0X128\", pool.FeeGrowthGlobal0X128),\n\t\t\t\"feeGrowthGlobal1X128\": json.StringNode(\"feeGrowthGlobal1X128\", pool.FeeGrowthGlobal1X128),\n\t\t\t\"token0ProtocolFee\":    json.StringNode(\"token0ProtocolFee\", pool.Token0ProtocolFee),\n\t\t\t\"token1ProtocolFee\":    json.StringNode(\"token1ProtocolFee\", pool.Token1ProtocolFee),\n\t\t\t\"liquidity\":            json.StringNode(\"liquidity\", pool.Liquidity),\n\t\t\t\"ticks\":                json.ObjectNode(\"ticks\", makeTicksJson(pool.Ticks)),\n\t\t\t\"tickBitmaps\":          json.ObjectNode(\"tickBitmaps\", makeRpcTickBitmapsJson(pool.TickBitmaps)),\n\t\t\t\"positions\":            json.ArrayNode(\"positions\", makeRpcPositionsArray(pool.Positions)),\n\t\t})\n\t\tresponses.AppendArray(_poolNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[POOL] _RPC_api.gno__ApiGetPools() || %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetPool(poolPath string) string {\n\t_, exist := pools[poolPath]\n\tif !exist {\n\t\treturn \"\"\n\t}\n\trpcPool := rpcMakePool(poolPath)\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE NODE\n\tresponseNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"poolPath\":             json.StringNode(\"poolPath\", rpcPool.PoolPath),\n\t\t\"token0Path\":           json.StringNode(\"token0Path\", rpcPool.Token0Path),\n\t\t\"token1Path\":           json.StringNode(\"token1Path\", rpcPool.Token1Path),\n\t\t\"token0Balance\":        json.StringNode(\"token0Balance\", rpcPool.Token0Balance),\n\t\t\"token1Balance\":        json.StringNode(\"token1Balance\", rpcPool.Token1Balance),\n\t\t\"fee\":                  json.NumberNode(\"fee\", float64(rpcPool.Fee)),\n\t\t\"tickSpacing\":          json.NumberNode(\"tickSpacing\", float64(rpcPool.TickSpacing)),\n\t\t\"maxLiquidityPerTick\":  json.StringNode(\"maxLiquidityPerTick\", rpcPool.MaxLiquidityPerTick),\n\t\t\"sqrtPriceX96\":         json.StringNode(\"sqrtPriceX96\", rpcPool.Slot0SqrtPriceX96),\n\t\t\"tick\":                 json.NumberNode(\"tick\", float64(rpcPool.Slot0Tick)),\n\t\t\"feeProtocol\":          json.NumberNode(\"feeProtocol\", float64(rpcPool.Slot0FeeProtocol)),\n\t\t\"unlocked\":             json.BoolNode(\"unlocked\", rpcPool.Slot0Unlocked),\n\t\t\"feeGrowthGlobal0X128\": json.StringNode(\"feeGrowthGlobal0X128\", rpcPool.FeeGrowthGlobal0X128),\n\t\t\"feeGrowthGlobal1X128\": json.StringNode(\"feeGrowthGlobal1X128\", rpcPool.FeeGrowthGlobal1X128),\n\t\t\"token0ProtocolFee\":    json.StringNode(\"token0ProtocolFee\", rpcPool.Token0ProtocolFee),\n\t\t\"token1ProtocolFee\":    json.StringNode(\"token1ProtocolFee\", rpcPool.Token1ProtocolFee),\n\t\t\"liquidity\":            json.StringNode(\"liquidity\", rpcPool.Liquidity),\n\t\t\"ticks\":                json.ObjectNode(\"ticks\", makeTicksJson(rpcPool.Ticks)),\n\t\t\"tickBitmaps\":          json.ObjectNode(\"tickBitmaps\", makeRpcTickBitmapsJson(rpcPool.TickBitmaps)),\n\t\t\"positions\":            json.ArrayNode(\"positions\", makeRpcPositionsArray(rpcPool.Positions)),\n\t})\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responseNode,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[POOL] _RPC_api.gno__ApiGetPool(%s) || %s\", poolPath, err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc rpcMakePool(poolPath string) RpcPool {\n\trpcPool := RpcPool{}\n\tpool := GetPoolFromPoolPath(poolPath)\n\n\trpcPool.PoolPath = poolPath\n\n\trpcPool.Token0Path = pool.token0Path\n\trpcPool.Token1Path = pool.token1Path\n\n\trpcPool.Token0Balance = pool.balances.token0.ToString()\n\trpcPool.Token1Balance = pool.balances.token1.ToString()\n\n\trpcPool.Fee = pool.fee\n\n\trpcPool.TickSpacing = pool.tickSpacing\n\n\trpcPool.MaxLiquidityPerTick = pool.maxLiquidityPerTick.ToString()\n\n\trpcPool.Slot0SqrtPriceX96 = pool.slot0.sqrtPriceX96.ToString()\n\trpcPool.Slot0Tick = pool.slot0.tick\n\trpcPool.Slot0FeeProtocol = pool.slot0.feeProtocol\n\trpcPool.Slot0Unlocked = pool.slot0.unlocked\n\n\trpcPool.FeeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128.ToString()\n\trpcPool.FeeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128.ToString()\n\n\trpcPool.Token0ProtocolFee = pool.protocolFees.token0.ToString()\n\trpcPool.Token1ProtocolFee = pool.protocolFees.token1.ToString()\n\n\trpcPool.Liquidity = pool.liquidity.ToString()\n\n\trpcPool.Ticks = RpcTicks{}\n\tfor tick, tickInfo := range pool.ticks {\n\t\trpcPool.Ticks[tick] = RpcTickInfo{\n\t\t\tLiquidityGross:              tickInfo.liquidityGross.ToString(),\n\t\t\tLiquidityNet:                tickInfo.liquidityNet.ToString(),\n\t\t\tFeeGrowthOutside0X128:       tickInfo.feeGrowthOutside0X128.ToString(),\n\t\t\tFeeGrowthOutside1X128:       tickInfo.feeGrowthOutside1X128.ToString(),\n\t\t\tTickCumulativeOutside:       tickInfo.tickCumulativeOutside,\n\t\t\tSecondsPerLiquidityOutsideX: tickInfo.secondsPerLiquidityOutsideX128.ToString(),\n\t\t\tSecondsOutside:              tickInfo.secondsOutside,\n\t\t\tInitialized:                 tickInfo.initialized,\n\t\t}\n\t}\n\n\trpcPool.TickBitmaps = RpcTickBitmaps{}\n\tfor tick, tickBitmap := range pool.tickBitmaps {\n\t\trpcPool.TickBitmaps[tick] = tickBitmap.ToString()\n\t}\n\n\tPositions := pool.positions\n\trpcPositions := []RpcPosition{}\n\tfor posKey, posInfo := range Positions {\n\t\towner, tickLower, tickUpper := posKeyDivide(posKey)\n\n\t\trpcPositions = append(rpcPositions, RpcPosition{\n\t\t\tOwner:      owner,\n\t\t\tTickLower:  tickLower,\n\t\t\tTickUpper:  tickUpper,\n\t\t\tLiquidity:  posInfo.liquidity.ToString(),\n\t\t\tToken0Owed: posInfo.tokensOwed0.ToString(),\n\t\t\tToken1Owed: posInfo.tokensOwed1.ToString(),\n\t\t})\n\t}\n\trpcPool.Positions = rpcPositions\n\n\treturn rpcPool\n}\n\nfunc posKeyDivide(posKey string) (string, int32, int32) {\n\t// base64 decode\n\tkDec, _ := b64.StdEncoding.DecodeString(posKey)\n\tposKey = string(kDec)\n\n\tres := strings.Split(posKey, \"__\")\n\tif len(res) != 3 {\n\t\tpanic(ufmt.Sprintf(\"[POOL] _RPC_api.gno__posKeyDivide() || invalid posKey(%s)\", posKey))\n\t}\n\n\towner, _tickLower, _tickUpper := res[0], res[1], res[2]\n\n\ttickLower, _ := strconv.Atoi(_tickLower)\n\ttickUpper, _ := strconv.Atoi(_tickUpper)\n\n\treturn owner, int32(tickLower), int32(tickUpper)\n}\n\nfunc makeTicksJson(ticks RpcTicks) map[string]*json.Node {\n\tticksJson := map[string]*json.Node{}\n\n\tfor tick, tickInfo := range ticks {\n\t\tticksJson[strconv.Itoa(int(tick))] = json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"liquidityGross\":              json.StringNode(\"liquidityGross\", tickInfo.LiquidityGross),\n\t\t\t\"liquidityNet\":                json.StringNode(\"liquidityNet\", tickInfo.LiquidityNet),\n\t\t\t\"feeGrowthOutside0X128\":       json.StringNode(\"feeGrowthOutside0X128\", tickInfo.FeeGrowthOutside0X128),\n\t\t\t\"feeGrowthOutside1X128\":       json.StringNode(\"feeGrowthOutside1X128\", tickInfo.FeeGrowthOutside1X128),\n\t\t\t\"tickCumulativeOutside\":       json.NumberNode(\"tickCumulativeOutside\", float64(tickInfo.TickCumulativeOutside)),\n\t\t\t\"secondsPerLiquidityOutsideX\": json.StringNode(\"secondsPerLiquidityOutsideX\", tickInfo.SecondsPerLiquidityOutsideX),\n\t\t\t\"secondsOutside\":              json.NumberNode(\"secondsOutside\", float64(tickInfo.SecondsOutside)),\n\t\t\t\"initialized\":                 json.BoolNode(\"initialized\", tickInfo.Initialized),\n\t\t})\n\t}\n\n\treturn ticksJson\n}\n\nfunc makeRpcTickBitmapsJson(tickBitmaps RpcTickBitmaps) map[string]*json.Node {\n\ttickBitmapsJson := map[string]*json.Node{}\n\n\tfor tick, tickBitmap := range tickBitmaps {\n\t\ttickBitmapsJson[strconv.Itoa(int(tick))] = json.StringNode(\"\", tickBitmap)\n\t}\n\n\treturn tickBitmapsJson\n}\n\nfunc makeRpcPositionsArray(positions []RpcPosition) []*json.Node {\n\tpositionsJson := make([]*json.Node, len(positions))\n\n\tfor i, pos := range positions {\n\t\tpositionsJson[i] = json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"owner\":      json.StringNode(\"owner\", pos.Owner),\n\t\t\t\"tickLower\":  json.NumberNode(\"tickLower\", float64(pos.TickLower)),\n\t\t\t\"tickUpper\":  json.NumberNode(\"tickUpper\", float64(pos.TickUpper)),\n\t\t\t\"liquidity\":  json.StringNode(\"liquidity\", pos.Liquidity),\n\t\t\t\"token0Owed\": json.StringNode(\"token0Owed\", pos.Token0Owed),\n\t\t\t\"token1Owed\": json.StringNode(\"token1Owed\", pos.Token1Owed),\n\t\t})\n\t}\n\n\treturn positionsJson\n}\n"},{"name":"_RPC_dry.gno","body":"package pool\n\nimport (\n\t\"gno.land/r/gnoswap/v2/common\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\tplp \"gno.land/p/gnoswap/pool\" // pool package\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// DrySwap simulates a swap and returns the amount0, amount1 that would be received and a boolean indicating if the swap is possible\nfunc DrySwap(\n\ttoken0Path string,\n\ttoken1Path string,\n\tfee uint32,\n\tzeroForOne bool,\n\t_amountSpecified string,\n\t_sqrtPriceLimitX96 string,\n) (string, string, bool) {\n\n\tif _amountSpecified == \"0\" {\n\t\treturn \"0\", \"0\", false\n\t}\n\n\tamountSpecified := i256.MustFromDecimal(_amountSpecified)\n\tsqrtPriceLimitX96 := u256.MustFromDecimal(_sqrtPriceLimitX96)\n\n\tpool := GetPool(token0Path, token1Path, fee)\n\tslot0Start := pool.slot0\n\n\tvar feeProtocol uint8\n\tvar feeGrowthGlobalX128 *u256.Uint\n\n\tif zeroForOne {\n\t\tminSqrtRatio := u256.MustFromDecimal(consts.MIN_SQRT_RATIO)\n\n\t\tcond1 := sqrtPriceLimitX96.Lt(slot0Start.sqrtPriceX96)\n\t\tcond2 := sqrtPriceLimitX96.Gt(minSqrtRatio)\n\t\tif !(cond1 \u0026\u0026 cond2) {\n\t\t\treturn \"0\", \"0\", false\n\t\t}\n\n\t\tfeeProtocol = slot0Start.feeProtocol % 16\n\t\tfeeGrowthGlobalX128 = pool.feeGrowthGlobal0X128\n\t} else {\n\t\tmaxSqrtRatio := u256.MustFromDecimal(consts.MAX_SQRT_RATIO)\n\n\t\tcond1 := sqrtPriceLimitX96.Gt(slot0Start.sqrtPriceX96)\n\t\tcond2 := sqrtPriceLimitX96.Lt(maxSqrtRatio)\n\t\tif !(cond1 \u0026\u0026 cond2) {\n\t\t\treturn \"0\", \"0\", false\n\t\t}\n\n\t\tfeeProtocol = slot0Start.feeProtocol / 16\n\t\tfeeGrowthGlobalX128 = pool.feeGrowthGlobal1X128\n\t}\n\n\tpool.slot0.unlocked = false\n\tcache := newSwapCache(feeProtocol, pool.liquidity)\n\tstate := pool.newSwapState(amountSpecified, feeGrowthGlobalX128, cache.liquidityStart) // TODO: feeGrowthGlobalX128.Clone() or NOT\n\n\texactInput := amountSpecified.Gt(i256.Zero())\n\n\t// continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n\tfor !(state.amountSpecifiedRemaining.IsZero()) \u0026\u0026 !(state.sqrtPriceX96.Eq(sqrtPriceLimitX96)) {\n\t\tvar step StepComputations\n\t\tstep.sqrtPriceStartX96 = state.sqrtPriceX96\n\n\t\tstep.tickNext, step.initialized = pool.tickBitmapNextInitializedTickWithInOneWord(\n\t\t\tstate.tick,\n\t\t\tpool.tickSpacing,\n\t\t\tzeroForOne,\n\t\t)\n\n\t\t// ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n\t\tif step.tickNext \u003c consts.MIN_TICK {\n\t\t\tstep.tickNext = consts.MIN_TICK\n\t\t} else if step.tickNext \u003e consts.MAX_TICK {\n\t\t\tstep.tickNext = consts.MAX_TICK\n\t\t}\n\n\t\t// get the price for the next tick\n\t\tstep.sqrtPriceNextX96 = common.TickMathGetSqrtRatioAtTick(step.tickNext)\n\n\t\tisLower := step.sqrtPriceNextX96.Lt(sqrtPriceLimitX96)\n\t\tisHigher := step.sqrtPriceNextX96.Gt(sqrtPriceLimitX96)\n\n\t\tvar sqrtRatioTargetX96 *u256.Uint\n\t\tif (zeroForOne \u0026\u0026 isLower) || (!zeroForOne \u0026\u0026 isHigher) {\n\t\t\tsqrtRatioTargetX96 = sqrtPriceLimitX96\n\t\t} else {\n\t\t\tsqrtRatioTargetX96 = step.sqrtPriceNextX96\n\t\t}\n\n\t\t_sqrtPriceX96Str, _amountInStr, _amountOutStr, _feeAmountStr := plp.SwapMathComputeSwapStepStr(\n\t\t\tstate.sqrtPriceX96,\n\t\t\tsqrtRatioTargetX96,\n\t\t\tstate.liquidity,\n\t\t\tstate.amountSpecifiedRemaining,\n\t\t\tuint64(pool.fee),\n\t\t)\n\t\tstate.sqrtPriceX96 = u256.MustFromDecimal(_sqrtPriceX96Str)\n\t\tstep.amountIn = u256.MustFromDecimal(_amountInStr)\n\t\tstep.amountOut = u256.MustFromDecimal(_amountOutStr)\n\t\tstep.feeAmount = u256.MustFromDecimal(_feeAmountStr)\n\n\t\tamountInWithFee := i256.FromUint256(new(u256.Uint).Add(step.amountIn, step.feeAmount))\n\t\tif exactInput {\n\t\t\tstate.amountSpecifiedRemaining = i256.Zero().Sub(state.amountSpecifiedRemaining, amountInWithFee)\n\t\t\tstate.amountCalculated = i256.Zero().Sub(state.amountCalculated, i256.FromUint256(step.amountOut))\n\t\t} else {\n\t\t\tstate.amountSpecifiedRemaining = i256.Zero().Add(state.amountSpecifiedRemaining, i256.FromUint256(step.amountOut))\n\t\t\tstate.amountCalculated = i256.Zero().Add(state.amountCalculated, amountInWithFee)\n\t\t}\n\n\t\t// if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n\t\tif cache.feeProtocol \u003e 0 {\n\t\t\tdelta := new(u256.Uint).Div(step.feeAmount, u256.NewUint(uint64(cache.feeProtocol)))\n\t\t\tstep.feeAmount = new(u256.Uint).Sub(step.feeAmount, delta)\n\t\t\tstate.protocolFee = new(u256.Uint).Add(state.protocolFee, delta)\n\t\t}\n\n\t\t// update global fee tracker\n\t\tif state.liquidity.Gt(u256.Zero()) {\n\t\t\t// OBS if `DrySwap()` update its state, next ACTUAL `Swap()` gets affect\n\n\t\t\t// value1 := new(u256.Uint).Mul(step.feeAmount, u256.MustFromDecimal(consts.Q128))\n\t\t\t// value2 := new(u256.Uint).Div(value1, state.liquidity)\n\n\t\t\t// state.feeGrowthGlobalX128 = new(u256.Uint).Add(state.feeGrowthGlobalX128, value2)\n\t\t}\n\n\t\t// shift tick if we reached the next price\n\t\tif state.sqrtPriceX96.Eq(step.sqrtPriceNextX96) {\n\t\t\t// if the tick is initialized, run the tick transition\n\t\t\tif step.initialized {\n\t\t\t\tvar fee0, fee1 *u256.Uint\n\n\t\t\t\t// check for the placeholder value, which we replace with the actual value the first time the swap crosses an initialized tick\n\t\t\t\tif zeroForOne {\n\t\t\t\t\tfee0 = state.feeGrowthGlobalX128\n\t\t\t\t\tfee1 = pool.feeGrowthGlobal1X128\n\t\t\t\t} else {\n\t\t\t\t\tfee0 = pool.feeGrowthGlobal0X128\n\t\t\t\t\tfee1 = state.feeGrowthGlobalX128\n\t\t\t\t}\n\n\t\t\t\tliquidityNet := pool.tickCross(\n\t\t\t\t\tstep.tickNext,\n\t\t\t\t\tfee0,\n\t\t\t\t\tfee1,\n\t\t\t\t)\n\n\t\t\t\t// if we're moving leftward, we interpret liquidityNet as the opposite sign\n\t\t\t\tif zeroForOne {\n\t\t\t\t\tliquidityNet = i256.Zero().Neg(liquidityNet)\n\t\t\t\t}\n\n\t\t\t\tstate.liquidity = liquidityMathAddDelta(state.liquidity, liquidityNet)\n\t\t\t}\n\n\t\t\tif zeroForOne {\n\t\t\t\tstate.tick = step.tickNext - 1\n\t\t\t} else {\n\t\t\t\tstate.tick = step.tickNext\n\t\t\t}\n\t\t} else if !(state.sqrtPriceX96.Eq(step.sqrtPriceStartX96)) {\n\t\t\t// recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n\t\t\tstate.tick = common.TickMathGetTickAtSqrtRatio(state.sqrtPriceX96)\n\t\t}\n\t}\n\t// END LOOP\n\n\tvar amount0, amount1 *i256.Int\n\tif zeroForOne == exactInput {\n\t\tamount0 = i256.Zero().Sub(amountSpecified, state.amountSpecifiedRemaining)\n\t\tamount1 = state.amountCalculated\n\t} else {\n\t\tamount0 = state.amountCalculated\n\t\tamount1 = i256.Zero().Sub(amountSpecified, state.amountSpecifiedRemaining)\n\t}\n\n\tpool.slot0.unlocked = true\n\n\tif zeroForOne {\n\t\tif pool.balances.token1.Lt(amount1.Abs()) {\n\t\t\t// NOT ENOUGH BALANCE for output token1\n\t\t\treturn \"0\", \"0\", false\n\t\t}\n\t} else {\n\t\tif pool.balances.token0.Lt(amount0.Abs()) {\n\t\t\t// NOT ENOUGH BALANCE for output token0\n\t\t\treturn \"0\", \"0\", false\n\t\t}\n\t}\n\n\t// JUST NOT ENOUGH BALANCE\n\tif amount0.IsZero() || amount1.IsZero() {\n\t\treturn \"0\", \"0\", false\n\t}\n\n\treturn amount0.ToString(), amount1.ToString(), true\n}\n"},{"name":"emergency_halt.gno","body":"package pool\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nvar (\n\t// flagHalt is set to true when the emergency halt proposal is passed\n\t// when this flag is set to true, all public functions in this package will panic\n\tflagHalt bool\n)\n\nfunc init() {\n\tflagHalt = false\n}\n\nfunc assertCalledByGovRealm() {\n\tif std.PrevRealm().PkgPath() != consts.GOV_PATH {\n\t\tpanic(ufmt.Sprintf(\"[POOL] emergency_halt.gno__assertCalledByGovRealm() || only gov(%s) can call, but called from(%s)\", consts.GOV_PATH, std.PrevRealm().PkgPath()))\n\t}\n}\n\nfunc halt() {\n\tassertCalledByGovRealm()\n\tflagHalt = true\n}\n\nfunc assertNotHalt() {\n\tif flagHalt {\n\t\tpanic(\"[POOL] emergency_halt.gno__assertNotHalt() || emergency halt\")\n\t}\n}\n"},{"name":"liquidity_math.gno","body":"package pool\n\nimport (\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nfunc liquidityMathAddDelta(x *u256.Uint, y *i256.Int) *u256.Uint {\n\tif y.Lt(i256.Zero()) {\n\t\tz := new(u256.Uint).Sub(x, y.Abs())\n\n\t\tif !(z.Lt(x)) {\n\t\t\tpanic(\"LS\")\n\t\t}\n\t\treturn z // z \u003c x\n\t}\n\n\tz := new(u256.Uint).Add(x, y.Abs())\n\n\tif !(z.Gte(x)) {\n\t\tpanic(\"LA\")\n\t}\n\treturn z // z \u003e= x\n}\n"},{"name":"pool.gno","body":"package pool\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tplp \"gno.land/p/gnoswap/pool\"\n\n\t\"gno.land/r/gnoswap/v2/common\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// Mint creates a new position and mints liquidity tokens then return amount0, amount1 in string\n//\n// Panics:\n//   - The caller is user\n//   - Caller does not have enough token0 or token1\nfunc Mint(\n\ttoken0Path string,\n\ttoken1Path string,\n\tfee uint32,\n\trecipient string,\n\ttickLower int32,\n\ttickUpper int32,\n\t_liquidityAmount string, // uint128\n) (string, string) { // uint256 x2\n\tcommon.DisallowCallFromUser()\n\tcommon.AllowCallFromOnly(consts.POSITION_PATH)\n\n\tliquidityAmount := u256.MustFromDecimal(_liquidityAmount)\n\n\tpool := GetPool(token0Path, token1Path, fee)\n\t_, amount0, amount1 := pool.modifyPosition( // int256 x2\n\t\tModifyPositionParams{\n\t\t\tstd.Address(recipient),            // owner\n\t\t\ttickLower,                         // tickLower\n\t\t\ttickUpper,                         // tickUpper\n\t\t\ti256.FromUint256(liquidityAmount), // liquidityDelta\n\t\t},\n\t)\n\n\tif amount0.Gt(i256.Zero()) {\n\t\tpool.transferFromAndVerify(std.GetOrigCaller(), consts.POOL_ADDR, pool.token0Path, amount0, true)\n\t}\n\n\tif amount1.Gt(i256.Zero()) {\n\t\tpool.transferFromAndVerify(std.GetOrigCaller(), consts.POOL_ADDR, pool.token1Path, amount1, false)\n\t}\n\n\t/*\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP\",\n\t\t\t\"m_callType\", callType(),\n\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\"p_poolPath\", GetPoolPath(token0Path, token1Path, fee),\n\t\t\t\"p_tickLower\", int32ToStr(tickLower),\n\t\t\t\"p_tickUpper\", int32ToStr(tickUpper),\n\t\t\t\"p_liquidityAmount\", _liquidityAmount,\n\t\t\t\"amount0\", amount0.ToString(),\n\t\t\t\"amount1\", amount1.ToString(),\n\t\t)\n\t*/\n\n\treturn amount0.ToString(), amount1.ToString()\n}\n\n// Burn removes liquidity from the caller and account tokens owed for the liquidity to the position\n// If liquidity of 0 is burned, it recalculates fees owed to a position\n//\n// Panics:\n//   - The caller is not the position contract\nfunc Burn(\n\ttoken0Path string,\n\ttoken1Path string,\n\tfee uint32,\n\ttickLower int32,\n\ttickUpper int32,\n\t_liquidityAmount string, // uint128\n) (string, string) { // uint256 x2\n\tcommon.DisallowCallFromUser()\n\tcommon.AllowCallFromOnly(consts.POSITION_PATH)\n\n\tliquidityAmount := u256.MustFromDecimal(_liquidityAmount)\n\n\tpool := GetPool(token0Path, token1Path, fee)\n\n\tposition, amount0Int, amount1Int := pool.modifyPosition( // in256 x2\n\t\tModifyPositionParams{\n\t\t\tstd.PrevRealm().Addr(), // msg.sender\n\t\t\ttickLower,\n\t\t\ttickUpper,\n\t\t\ti256.Zero().Neg(i256.FromUint256(liquidityAmount)),\n\t\t},\n\t)\n\n\tamount0 := amount0Int.Abs()\n\tamount1 := amount1Int.Abs()\n\n\tif amount0.Gt(u256.Zero()) || amount1.Gt(u256.Zero()) {\n\t\tposition.tokensOwed0 = new(u256.Uint).Add(position.tokensOwed0, amount0)\n\t\tposition.tokensOwed1 = new(u256.Uint).Add(position.tokensOwed1, amount1)\n\t}\n\n\tpositionKey := positionGetKey(std.PrevRealm().Addr(), tickLower, tickUpper)\n\tpool.positions[positionKey] = position\n\n\t/*\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP\",\n\t\t\t\"m_callType\", callType(),\n\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\"p_poolPath\", GetPoolPath(token0Path, token1Path, fee),\n\t\t\t\"p_tickLower\", int32ToStr(tickLower),\n\t\t\t\"p_tickUpper\", int32ToStr(tickUpper),\n\t\t\t\"p_liquidityAmount\", _liquidityAmount,\n\t\t\t\"amount0\", amount0.ToString(),\n\t\t\t\"amount1\", amount1.ToString(),\n\t\t)\n\t*/\n\n\t// actual token transfer happens in Collect()\n\treturn amount0.ToString(), amount1.ToString()\n}\n\n// Collect collects tokens owed to a position\n//\n// Panics:\n// - The caller is not the position contract\n// - The position does not exist\nfunc Collect(\n\ttoken0Path string,\n\ttoken1Path string,\n\tfee uint32,\n\t_recipient string,\n\ttickLower int32,\n\ttickUpper int32,\n\t_amount0Requested string, // uint128\n\t_amount1Requested string, // uint128\n) (string, string) { // uint128 x2\n\tcommon.DisallowCallFromUser()\n\tcommon.AllowCallFromOnly(consts.POSITION_PATH)\n\n\tamount0Requested := u256.MustFromDecimal(_amount0Requested)\n\tamount1Requested := u256.MustFromDecimal(_amount1Requested)\n\n\trecipient := std.Address(_recipient)\n\n\tpool := GetPool(token0Path, token1Path, fee)\n\n\tpositionKey := positionGetKey(std.PrevRealm().Addr(), tickLower, tickUpper)\n\tposition, exist := pool.positions[positionKey]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool.gno__Collect() || positionKey(%s) does not exist\", positionKey))\n\t}\n\n\t// Smallest of three: amount0Requested, position.tokensOwed0, pool.balances.token0\n\tamount0 := u256Min(amount0Requested, position.tokensOwed0)\n\tamount0 = u256Min(amount0, pool.balances.token0)\n\n\t// Update state first then transfer\n\tposition.tokensOwed0 = new(u256.Uint).Sub(position.tokensOwed0, amount0)\n\tpool.balances.token0 = new(u256.Uint).Sub(pool.balances.token0, amount0)\n\ttransferByRegisterCall(pool.token0Path, recipient, amount0.Uint64())\n\n\t// Smallest of three: amount0Requested, position.tokensOwed0, pool.balances.token0\n\tamount1 := u256Min(amount1Requested, position.tokensOwed1)\n\tamount1 = u256Min(amount1, pool.balances.token1)\n\n\t// Update state first then transfer\n\tposition.tokensOwed1 = new(u256.Uint).Sub(position.tokensOwed1, amount1)\n\tpool.balances.token1 = new(u256.Uint).Sub(pool.balances.token1, amount1)\n\ttransferByRegisterCall(pool.token1Path, recipient, amount1.Uint64())\n\n\tpool.positions[positionKey] = position\n\n\t/*\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP\",\n\t\t\t\"m_callType\", callType(),\n\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\"p_poolPath\", GetPoolPath(token0Path, token1Path, fee),\n\t\t\t\"p_tickLower\", int32ToStr(tickLower),\n\t\t\t\"p_tickUpper\", int32ToStr(tickUpper),\n\t\t\t\"p_recipient\", _recipient,\n\t\t\t\"amount0\", amount0.ToString(),\n\t\t\t\"amount1\", amount1.ToString(),\n\t\t)\n\t*/\n\n\treturn amount0.ToString(), amount1.ToString()\n}\n\n// Swap swaps token0 for token1, or token1 for token0\n//\n// Panics:\n//   - The caller is not the router contract\n//   - Target pool is being used by another transaction\n//   - The amountSpecified is 0\n//   - The SqrtPriceLimit is not within the range\nfunc Swap(\n\ttoken0Path string,\n\ttoken1Path string,\n\tfee uint32,\n\t_recipient string,\n\tzeroForOne bool,\n\t_amountSpecified string, // int256\n\t_sqrtPriceLimitX96 string, // uint160\n\t_payer string, // router\n) (string, string) { // int256 x2\n\tcommon.DisallowCallFromUser()\n\tcommon.AllowCallFromOnly(consts.ROUTER_PATH)\n\n\tif _amountSpecified == \"0\" {\n\t\tpanic(\"[POOL] pool.gno__Swap() || _amountSpecified == 0\")\n\t}\n\n\tamountSpecified := i256.MustFromDecimal(_amountSpecified)\n\tsqrtPriceLimitX96 := u256.MustFromDecimal(_sqrtPriceLimitX96)\n\n\trecipient := std.Address(_recipient)\n\tpayer := std.Address(_payer)\n\n\tpool := GetPool(token0Path, token1Path, fee)\n\tslot0Start := pool.slot0\n\n\tif !(slot0Start.unlocked) {\n\t\tpanic(\"[POOL] pool.gno__Swap() || slot0Start.unlocked must be unlocked(true)\")\n\t}\n\n\tvar feeProtocol uint8\n\tvar feeGrowthGlobalX128 *u256.Uint\n\n\tif zeroForOne {\n\t\tminSqrtRatio := u256.MustFromDecimal(consts.MIN_SQRT_RATIO)\n\n\t\tcond1 := sqrtPriceLimitX96.Lt(slot0Start.sqrtPriceX96)\n\t\tcond2 := sqrtPriceLimitX96.Gt(minSqrtRatio)\n\t\tif !(cond1 \u0026\u0026 cond2) {\n\t\t\tpanic(ufmt.Sprintf(\"[POOL] pool.gno__Swap() || sqrtPriceLimitX96(%s) \u003c slot0Start.sqrtPriceX96(%s) \u0026\u0026 sqrtPriceLimitX96(%s) \u003e consts.MIN_SQRT_RATIO(%s)\", sqrtPriceLimitX96.ToString(), slot0Start.sqrtPriceX96.ToString(), sqrtPriceLimitX96.ToString(), consts.MIN_SQRT_RATIO))\n\t\t}\n\t\tfeeProtocol = slot0Start.feeProtocol % 16\n\t\tfeeGrowthGlobalX128 = pool.feeGrowthGlobal0X128\n\n\t} else {\n\t\tmaxSqrtRatio := u256.MustFromDecimal(consts.MAX_SQRT_RATIO)\n\n\t\tcond1 := sqrtPriceLimitX96.Gt(slot0Start.sqrtPriceX96)\n\t\tcond2 := sqrtPriceLimitX96.Lt(maxSqrtRatio)\n\t\tif !(cond1 \u0026\u0026 cond2) {\n\t\t\tpanic(ufmt.Sprintf(\"[POOL] pool.gno__Swap() || sqrtPriceLimitX96(%s) \u003e slot0Start.sqrtPriceX96(%s) \u0026\u0026 sqrtPriceLimitX96(%s) \u003c consts.MAX_SQRT_RATIO(%s)\", sqrtPriceLimitX96.ToString(), slot0Start.sqrtPriceX96.ToString(), sqrtPriceLimitX96.ToString(), consts.MAX_SQRT_RATIO))\n\t\t}\n\n\t\tfeeProtocol = slot0Start.feeProtocol / 16\n\t\tfeeGrowthGlobalX128 = pool.feeGrowthGlobal1X128\n\t}\n\n\tpool.slot0.unlocked = false\n\tcache := newSwapCache(feeProtocol, pool.liquidity)\n\tstate := pool.newSwapState(amountSpecified, feeGrowthGlobalX128, cache.liquidityStart)\n\n\texactInput := amountSpecified.Gt(i256.Zero())\n\n\t// continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n\tswapFee := u256.Zero()\n\tfor !(state.amountSpecifiedRemaining.IsZero()) \u0026\u0026 !(state.sqrtPriceX96.Eq(sqrtPriceLimitX96)) {\n\t\tvar step StepComputations\n\t\tstep.sqrtPriceStartX96 = state.sqrtPriceX96\n\n\t\tstep.tickNext, step.initialized = pool.tickBitmapNextInitializedTickWithInOneWord(\n\t\t\tstate.tick,\n\t\t\tpool.tickSpacing,\n\t\t\tzeroForOne,\n\t\t)\n\n\t\t// ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n\t\tif step.tickNext \u003c consts.MIN_TICK {\n\t\t\tstep.tickNext = consts.MIN_TICK\n\t\t} else if step.tickNext \u003e consts.MAX_TICK {\n\t\t\tstep.tickNext = consts.MAX_TICK\n\t\t}\n\n\t\t// get the price for the next tick\n\t\tstep.sqrtPriceNextX96 = common.TickMathGetSqrtRatioAtTick(step.tickNext)\n\n\t\tisLower := step.sqrtPriceNextX96.Lt(sqrtPriceLimitX96)\n\t\tisHigher := step.sqrtPriceNextX96.Gt(sqrtPriceLimitX96)\n\n\t\tvar sqrtRatioTargetX96 *u256.Uint\n\t\tif (zeroForOne \u0026\u0026 isLower) || (!zeroForOne \u0026\u0026 isHigher) {\n\t\t\tsqrtRatioTargetX96 = sqrtPriceLimitX96\n\t\t} else {\n\t\t\tsqrtRatioTargetX96 = step.sqrtPriceNextX96\n\t\t}\n\n\t\t_sqrtPriceX96Str, _amountInStr, _amountOutStr, _feeAmountStr := plp.SwapMathComputeSwapStepStr(\n\t\t\tstate.sqrtPriceX96,\n\t\t\tsqrtRatioTargetX96,\n\t\t\tstate.liquidity,\n\t\t\tstate.amountSpecifiedRemaining,\n\t\t\tuint64(pool.fee),\n\t\t)\n\t\tstate.sqrtPriceX96 = u256.MustFromDecimal(_sqrtPriceX96Str)\n\t\tstep.amountIn = u256.MustFromDecimal(_amountInStr)\n\t\tstep.amountOut = u256.MustFromDecimal(_amountOutStr)\n\t\tstep.feeAmount = u256.MustFromDecimal(_feeAmountStr)\n\n\t\tamountInWithFee := i256.FromUint256(new(u256.Uint).Add(step.amountIn, step.feeAmount))\n\t\tif exactInput {\n\t\t\tstate.amountSpecifiedRemaining = i256.Zero().Sub(state.amountSpecifiedRemaining, amountInWithFee)\n\t\t\tstate.amountCalculated = i256.Zero().Sub(state.amountCalculated, i256.FromUint256(step.amountOut))\n\t\t} else {\n\t\t\tstate.amountSpecifiedRemaining = i256.Zero().Add(state.amountSpecifiedRemaining, i256.FromUint256(step.amountOut))\n\t\t\tstate.amountCalculated = i256.Zero().Add(state.amountCalculated, amountInWithFee)\n\t\t}\n\n\t\t// if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n\t\tif cache.feeProtocol \u003e 0 {\n\t\t\tdelta := new(u256.Uint).Div(step.feeAmount, u256.NewUint(uint64(cache.feeProtocol)))\n\t\t\tstep.feeAmount = new(u256.Uint).Sub(step.feeAmount, delta)\n\t\t\tstate.protocolFee = new(u256.Uint).Add(state.protocolFee, delta)\n\t\t}\n\n\t\t// update global fee tracker\n\t\tif state.liquidity.Gt(u256.Zero()) {\n\t\t\tupdate := u256.MulDiv(step.feeAmount, u256.MustFromDecimal(consts.Q128), state.liquidity)\n\t\t\tstate.feeGrowthGlobalX128 = new(u256.Uint).Add(state.feeGrowthGlobalX128, update)\n\t\t}\n\t\tswapFee = new(u256.Uint).Add(swapFee, step.feeAmount)\n\n\t\t// shift tick if we reached the next price\n\t\tif state.sqrtPriceX96.Eq(step.sqrtPriceNextX96) {\n\t\t\t// if the tick is initialized, run the tick transition\n\t\t\tif step.initialized {\n\t\t\t\tvar fee0, fee1 *u256.Uint\n\n\t\t\t\t// check for the placeholder value, which we replace with the actual value the first time the swap crosses an initialized tick\n\t\t\t\tif zeroForOne {\n\t\t\t\t\tfee0 = state.feeGrowthGlobalX128\n\t\t\t\t\tfee1 = pool.feeGrowthGlobal1X128\n\t\t\t\t} else {\n\t\t\t\t\tfee0 = pool.feeGrowthGlobal0X128\n\t\t\t\t\tfee1 = state.feeGrowthGlobalX128\n\t\t\t\t}\n\n\t\t\t\tliquidityNet := pool.tickCross(\n\t\t\t\t\tstep.tickNext,\n\t\t\t\t\tfee0,\n\t\t\t\t\tfee1,\n\t\t\t\t)\n\n\t\t\t\t// if we're moving leftward, we interpret liquidityNet as the opposite sign\n\t\t\t\tif zeroForOne {\n\t\t\t\t\tliquidityNet = i256.Zero().Neg(liquidityNet)\n\t\t\t\t}\n\n\t\t\t\tstate.liquidity = liquidityMathAddDelta(state.liquidity, liquidityNet)\n\t\t\t}\n\n\t\t\tif zeroForOne {\n\t\t\t\tstate.tick = step.tickNext - 1\n\t\t\t} else {\n\t\t\t\tstate.tick = step.tickNext\n\t\t\t}\n\t\t} else if !(state.sqrtPriceX96.Eq(step.sqrtPriceStartX96)) {\n\t\t\t// recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n\t\t\tstate.tick = common.TickMathGetTickAtSqrtRatio(state.sqrtPriceX96)\n\t\t}\n\t}\n\t// END LOOP\n\n\t// update pool sqrtPrice\n\tpool.slot0.sqrtPriceX96 = state.sqrtPriceX96\n\n\t// update tick if it changed\n\tif state.tick != slot0Start.tick {\n\t\tpool.slot0.tick = state.tick\n\t}\n\n\t// update liquidity if it changed\n\tif !(cache.liquidityStart.Eq(state.liquidity)) {\n\t\tpool.liquidity = state.liquidity\n\t}\n\n\t// update fee growth global and, if necessary, protocol fees\n\t// overflow is acceptable, protocol has to withdraw before it hits MAX_UINT256 fees\n\tif zeroForOne {\n\t\tpool.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128\n\t\tif state.protocolFee.Gt(u256.Zero()) {\n\t\t\tpool.protocolFees.token0 = new(u256.Uint).Add(pool.protocolFees.token0, state.protocolFee)\n\t\t}\n\t} else {\n\t\tpool.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128\n\t\tif state.protocolFee.Gt(u256.Zero()) {\n\t\t\tpool.protocolFees.token1 = new(u256.Uint).Add(pool.protocolFees.token1, state.protocolFee)\n\t\t}\n\t}\n\n\tvar amount0, amount1 *i256.Int\n\tif zeroForOne == exactInput {\n\t\tamount0 = i256.Zero().Sub(amountSpecified, state.amountSpecifiedRemaining)\n\t\tamount1 = state.amountCalculated\n\t} else {\n\t\tamount0 = state.amountCalculated\n\t\tamount1 = i256.Zero().Sub(amountSpecified, state.amountSpecifiedRemaining)\n\t}\n\n\t// actual swap\n\tif zeroForOne {\n\t\t// payer \u003e POOL\n\t\tpool.transferFromAndVerify(payer, consts.POOL_ADDR, pool.token0Path, amount0, true)\n\n\t\t// POOL \u003e recipient\n\t\tpool.transferAndVerify(recipient, pool.token1Path, amount1, false)\n\n\t} else {\n\t\t// payer \u003e POOL\n\t\tpool.transferFromAndVerify(payer, consts.POOL_ADDR, pool.token1Path, amount1, false)\n\n\t\t// POOL \u003e recipient\n\t\tpool.transferAndVerify(recipient, pool.token0Path, amount0, true)\n\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_poolPath\", GetPoolPath(token0Path, token1Path, fee),\n\t\t\"p_zeroForOne\", boolToStr(zeroForOne),\n\t\t\"p_amountSpecified\", _amountSpecified,\n\t\t\"p_sqrtPriceLimitX96\", _sqrtPriceLimitX96,\n\t\t\"p_payer\", _payer,\n\t\t\"p_recipient\", _recipient,\n\t\t\"amount0\", amount0.ToString(),\n\t\t\"amount1\", amount1.ToString(),\n\t\t\"protocol_fee0\", pool.protocolFees.token0.ToString(),\n\t\t\"protocol_fee1\", pool.protocolFees.token1.ToString(),\n\t\t\"swap_fee\", swapFee.ToString(),\n\t)\n\n\tpool.slot0.unlocked = true\n\treturn amount0.ToString(), amount1.ToString()\n}\n\n// SetFeeProtocol sets the denominator of the protocol fee\n//\n// Panics:\n// - The caller is not an admin\n// - The feeProtocol0 or feeProtocol1 is not in the range of 0 or 4-10\nfunc SetFeeProtocol(\n\tfeeProtocol0 uint8,\n\tfeeProtocol1 uint8,\n) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[POOL] pool.gno__SetFeeProtocol() || only admin(%s) or governance(%s) can set fee protocol, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\tfee0Cond := feeProtocol0 == 0 || (feeProtocol0 \u003e= 4 \u0026\u0026 feeProtocol0 \u003c= 10)\n\tfee1Cond := feeProtocol1 == 0 || (feeProtocol1 \u003e= 4 \u0026\u0026 feeProtocol1 \u003c= 10)\n\tif !(fee0Cond \u0026\u0026 fee1Cond) {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool.gno__SetFeeProtocol() || expected (feeProtocol0(%d) == 0 || (feeProtocol0(%d) \u003e= 4 \u0026\u0026 feeProtocol0(%d) \u003c= 10)) \u0026\u0026 (feeProtocol1(%d) == 0 || (feeProtocol1(%d) \u003e= 4 \u0026\u0026 feeProtocol1(%d) \u003c= 10))\", feeProtocol0, feeProtocol0, feeProtocol0, feeProtocol1, feeProtocol1, feeProtocol1))\n\t}\n\n\tnewFee := feeProtocol0 + (feeProtocol1 \u003c\u003c 4) // ( \u003c\u003c 4 ) = ( * 16 )\n\n\t// iterate all pool\n\tfor _, pool := range pools {\n\t\tpool.slot0.feeProtocol = newFee\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_feeProtocol0\", uint8ToStr(feeProtocol0),\n\t\t\"p_feeProtocol1\", uint8ToStr(feeProtocol1),\n\t\t\"newFee\", uint8ToStr(newFee),\n\t)\n}\n\n// CollectProtocol collects protocol fees from the pool\n//\n// Panics:\n// - The caller is not an admin\n// - The recipient is the zero address\n// - The amount0Requested or amount1Requested is greater than the protocol fees\nfunc CollectProtocol(\n\ttoken0Path string,\n\ttoken1Path string,\n\tfee uint32,\n\t_recipient string,\n\t_amount0Requested string, // uint128\n\t_amount1Requested string, // uint128\n) (string, string) { // uint128 x2\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[POOL] pool.gno__CollectFeeProtocol() || only admin(%s) or governance(%s) can collect fee protocol, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\trecipient := std.Address(_recipient)\n\n\tamount0Requested := u256.MustFromDecimal(_amount0Requested)\n\tamount1Requested := u256.MustFromDecimal(_amount1Requested)\n\n\tpool := GetPool(token0Path, token1Path, fee)\n\n\tamount0 := u256Min(amount0Requested, pool.protocolFees.token0)\n\tamount1 := u256Min(amount1Requested, pool.protocolFees.token1)\n\n\tamount0, amount1 = pool.saveProtocolFees(amount0, amount1)\n\tuAmount0 := amount0.Uint64()\n\tuAmount1 := amount1.Uint64()\n\n\tok := transferByRegisterCall(pool.token0Path, recipient, uAmount0)\n\tif !ok {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool.gno__CollectProtocol() || transferByRegisterCall(pool.token0Path(%s), recipient(%s), uAmount0)(%d) failed\", pool.token0Path, recipient.String(), uAmount0))\n\t}\n\tstd.Emit(\n\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"poolPath\", GetPoolPath(token0Path, token1Path, fee),\n\t\t\"reason\", \"pool_protocol_fee\",\n\t\t\"token\", pool.token0Path,\n\t\t\"amount\", strconv.FormatUint(uAmount0, 10),\n\t)\n\n\tok = transferByRegisterCall(pool.token1Path, recipient, uAmount1)\n\tif !ok {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool.gno__CollectProtocol() || transferByRegisterCall(pool.token1Path(%s), recipient(%s), uAmount1)(%d) failed\", pool.token1Path, recipient.String(), uAmount1))\n\t}\n\tstd.Emit(\n\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"poolPath\", GetPoolPath(token0Path, token1Path, fee),\n\t\t\"reason\", \"pool_protocol_fee\",\n\t\t\"token\", pool.token1Path,\n\t\t\"amount\", strconv.FormatUint(uAmount1, 10),\n\t)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_poolPath\", GetPoolPath(token0Path, token1Path, fee),\n\t\t\"p_recipient\", _recipient,\n\t\t\"amount0\", amount0.ToString(),\n\t\t\"amount1\", amount1.ToString(),\n\t)\n\n\treturn amount0.ToString(), amount1.ToString()\n}\n\nfunc (pool *Pool) saveProtocolFees(amount0, amount1 *u256.Uint) (*u256.Uint, *u256.Uint) {\n\tcond01 := amount0.Gt(u256.Zero())\n\tcond02 := amount0.Eq(pool.protocolFees.token0)\n\tif cond01 \u0026\u0026 cond02 {\n\t\tamount0 = new(u256.Uint).Sub(amount0, u256.One())\n\t}\n\n\tcond11 := amount1.Gt(u256.Zero())\n\tcond12 := amount1.Eq(pool.protocolFees.token1)\n\tif cond11 \u0026\u0026 cond12 {\n\t\tamount1 = new(u256.Uint).Sub(amount1, u256.One())\n\t}\n\n\tpool.protocolFees.token0 = new(u256.Uint).Sub(pool.protocolFees.token0, amount0)\n\tpool.protocolFees.token1 = new(u256.Uint).Sub(pool.protocolFees.token1, amount1)\n\n\t// return rest fee\n\treturn amount0, amount1\n}\n\nfunc (pool *Pool) transferAndVerify(\n\tto std.Address,\n\ttokenPath string,\n\tamount *i256.Int,\n\tisToken0 bool,\n) {\n\tif amount.IsZero() {\n\t\treturn\n\t}\n\n\t// must be negative to send token from pool to user\n\t// as point of view from pool, it is negative\n\tif !amount.IsNeg() {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool.transferAndVerify() || amount(%s) must be negative\", amount.ToString())) // TODO: panic or just pass\n\t}\n\n\t// check pool.balances\n\tif isToken0 {\n\t\tif pool.balances.token0.Lt(amount.Abs()) {\n\t\t\tpanic(ufmt.Sprintf(\"[POOL] pool.transferAndVerify() || pool.balances.token0(%s) \u003e= amount.Abs(%s)\", pool.balances.token0.ToString(), amount.Abs().ToString()))\n\t\t}\n\t} else {\n\t\tif pool.balances.token1.Lt(amount.Abs()) {\n\t\t\tpanic(ufmt.Sprintf(\"[POOL] pool.transferAndVerify() || pool.balances.token1(%s) \u003e= amount.Abs(%s)\", pool.balances.token1.ToString(), amount.Abs().ToString()))\n\t\t}\n\t}\n\n\tamountUint64 := checkAmountRange(amount)\n\n\t// try sending\n\t// will panic if following conditions are met:\n\t// - POOL does not have enough balance\n\t// - token is not registered\n\tok := transferByRegisterCall(tokenPath, to, amountUint64)\n\tif !ok {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool.transferAndVerify() || transferByRegisterCall(tokenPath(%s), to(%s), amountUint64(%d)) failed\", tokenPath, to.String(), amountUint64))\n\t}\n\n\t// update pool.balances\n\tvar overflow bool\n\tif isToken0 {\n\t\tpool.balances.token0, overflow = new(u256.Uint).SubOverflow(pool.balances.token0, amount.Abs())\n\t\tif overflow {\n\t\t\tpanic(ufmt.Sprintf(\"[POOL] pool.transferAndVerify() || cannot decrease, pool.balances.token0(%s) - amount(%s)\", pool.balances.token0.ToString(), amount.Abs().ToString()))\n\t\t}\n\t} else {\n\t\tpool.balances.token1, overflow = new(u256.Uint).SubOverflow(pool.balances.token1, amount.Abs())\n\t\tif pool.balances.token1.Lt(u256.Zero()) {\n\t\t\tpanic(ufmt.Sprintf(\"[POOL] pool.transferAndVerify() || cannot decrease, pool.balances.token1(%s) - amount(%s)\", pool.balances.token1.ToString(), amount.Abs().ToString()))\n\t\t}\n\t}\n}\n\nfunc (pool *Pool) transferFromAndVerify(\n\tfrom, to std.Address,\n\ttokenPath string,\n\tamount *i256.Int,\n\tisToken0 bool,\n) {\n\tamountUint64 := checkAmountRange(amount)\n\n\t// try sending\n\t// will panic if following conditions are met:\n\t// - POOL does not have enough approved amount\n\t// - from does not have enough balance\n\t// - token is not registered\n\tok := transferFromByRegisterCall(tokenPath, from, to, amountUint64)\n\tif !ok {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool.transferFromAndVerify() || transferFromByRegisterCall(tokenPath(%s), from(%s), to(%s), amountUint64(%d)) failed\", tokenPath, from.String(), to.String(), amountUint64))\n\t}\n\n\t// update pool.balances\n\tif isToken0 {\n\t\tpool.balances.token0 = new(u256.Uint).Add(pool.balances.token0, amount.Abs())\n\t} else {\n\t\tpool.balances.token1 = new(u256.Uint).Add(pool.balances.token1, amount.Abs())\n\t}\n}\n\nfunc checkAmountRange(amount *i256.Int) uint64 {\n\t// check amount is in uint64 range\n\tamountAbs := amount.Abs()\n\tamountUint64, overflow := amountAbs.Uint64WithOverflow()\n\tif overflow {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool.checkAmount() || amountAbs(%s) overflows uint64 range\", amountAbs.ToString()))\n\t}\n\n\treturn amountUint64\n}\n"},{"name":"pool_manager.gno","body":"package pool\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/r/gnoswap/v2/common\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\ten \"gno.land/r/gnoswap/v2/emission\"\n\n\t\"gno.land/r/gnoswap/v2/gns\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nvar (\n\tfeeAmountTickSpacing map[uint32]int32 = make(map[uint32]int32) // maps fee to tickSpacing || map[feeAmount]tick_spacing\n\tpools                map[string]*Pool = make(map[string]*Pool) // maps poolPath to pool || map[poolPath]*Pool\n)\n\nfunc init() {\n\tfeeAmountTickSpacing[100] = 1     // 0.01%\n\tfeeAmountTickSpacing[500] = 10    // 0.05%\n\tfeeAmountTickSpacing[3000] = 60   // 0.3%\n\tfeeAmountTickSpacing[10000] = 200 // 1%\n}\n\n// CreatePool creates a new concentrated liquidity pool with the given parameters.\n// It mints and distributes GNS tokens, validates the input parameters, and creates a new pool.\n// If GNOT is used as one of the tokens, it is automatically wrapped to WUGNOT.\n// The function ensures that token0Path is lexicographically smaller than token1Path.\n//\n// Parameters:\n//   - token0Path: The path of the first token\n//   - token1Path: The path of the second token\n//   - fee: The fee tier for the pool\n//   - _sqrtPriceX96: The initial square root price of the pool as a decimal string\n//\n// Panics:\n//   - If token0Path equals token1Path\n//   - If the pool already exists\n//   - If the fee amount is invalid\nfunc CreatePool(\n\ttoken0Path string,\n\ttoken1Path string,\n\tfee uint32,\n\t_sqrtPriceX96 string, // uint256\n) {\n\ten.MintAndDistributeGns()\n\n\tif token0Path == token1Path {\n\t\tpanic(ufmt.Sprintf(\"[POOl] pool_manager.gno__CreatePool() || expected token0Path(%s) != token1Path(%s)\", token0Path, token1Path))\n\t}\n\n\tif token0Path == consts.GNOT {\n\t\ttoken0Path = consts.WRAPPED_WUGNOT\n\t} else if token1Path == consts.GNOT {\n\t\ttoken1Path = consts.WRAPPED_WUGNOT\n\t}\n\n\tsqrtPriceX96 := u256.MustFromDecimal(_sqrtPriceX96)\n\n\tif token1Path \u003c token0Path {\n\t\ttoken0Path, token1Path = token1Path, token0Path\n\t\ttick := -(common.TickMathGetTickAtSqrtRatio(sqrtPriceX96))\n\t\tsqrtPriceX96 = common.TickMathGetSqrtRatioAtTick(tick)\n\t}\n\n\t// check tickSpacing for fee\n\ttickSpacing := feeAmountTickSpacing[fee]\n\t// calculate poolPath\n\tpoolPath := GetPoolPath(token0Path, token1Path, fee)\n\n\t// check whether the pool already exist\n\tpool, exist := pools[poolPath]\n\tif exist {\n\t\tpanic(ufmt.Sprintf(\"[POOl] pool_manager.gno__CreatePool() || expected poolPath(%s) not to exist\", poolPath))\n\t}\n\n\tif !exist {\n\t\tgns.TransferFrom(a2u(std.GetOrigCaller()), a2u(consts.PROTOCOL_FEE_ADDR), poolCreationFee)\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\t\"m_callType\", callType(),\n\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\"poolPath\", poolPath,\n\t\t\t\"reason\", \"pool_creation\",\n\t\t\t\"token\", consts.GNS_PATH,\n\t\t\t\"amount\", strconv.FormatUint(poolCreationFee, 10),\n\t\t)\n\n\t\tpool = newPool(token0Path, token1Path, fee, tickSpacing, sqrtPriceX96)\n\t\tpools[poolPath] = pool\n\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP\",\n\t\t\t\"m_callType\", callType(),\n\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\"p_poolPath\", poolPath,\n\t\t)\n\t}\n}\n\n// DoesPoolPathExist checks if a pool exists for the given poolPath.\n//\n// The poolPath is a unique identifier for a pool, combining token paths and fee.\nfunc DoesPoolPathExist(poolPath string) bool {\n\t_, exist := pools[poolPath]\n\treturn exist\n}\n\n// GetPool retrieves the pool for the given token paths and fee.\n// It constructs the poolPath from the given parameters and returns the corresponding pool.\n//\n// Panics:\n//   - If the pool does not exist\nfunc GetPool(token0Path, token1Path string, fee uint32) *Pool {\n\tpoolPath := GetPoolPath(token0Path, token1Path, fee)\n\tpool, exist := pools[poolPath]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool_manager.gno__GetPool() || expected poolPath(%s) to exist\", poolPath))\n\t}\n\n\treturn pool\n}\n\n// GetPoolFromPoolPath retrieves the pool for the given poolPath.\n//\n// Panics:\n//   - If the pool does not exist\nfunc GetPoolFromPoolPath(poolPath string) *Pool {\n\tpool, exist := pools[poolPath]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[POOL] pool_manager.gno__GetPoolFromPoolPath() || expected poolPath(%s) to exist\", poolPath))\n\t}\n\n\treturn pool\n}\n\n// GetPoolPath generates a poolPath from the given token paths and fee.\n// The poolPath is constructed by joining the token paths and fee with colons.\n//\n// For example, if token0Path is \"A\" and token1Path is \"B\" with a fee of 500, the poolPath will be:\n//\n//\t\"A:B:500\"\n//\n// If token0Path is lexicographically greater than token1Path, the paths are swapped before constructing the poolPath.\n//\n//\t\"B:A:500\"\n//\n// It ensures that the token paths are in lexicographic order.\n//\n// Parameters:\n//   - token0Path: The path of the first token\n//   - token1Path: The path of the second token\n//   - fee: The fee tier of the pool\n//\n// Returns:\n//   - string: The constructed poolPath\nfunc GetPoolPath(token0Path, token1Path string, fee uint32) string {\n\tif token1Path \u003c token0Path {\n\t\ttoken0Path, token1Path = token1Path, token0Path\n\t}\n\n\tvar s strings.Builder\n\ts.WriteString(token0Path)\n\ts.WriteString(\":\")\n\ts.WriteString(token1Path)\n\ts.WriteString(\":\")\n\ts.WriteString(strconv.FormatUint(uint64(fee), 10))\n\n\treturn s.String()\n}\n\nfunc newPool(\n\ttoken0Path string,\n\ttoken1Path string,\n\tfee uint32,\n\ttickSpacing int32,\n\tsqrtPriceX96 *u256.Uint,\n) *Pool {\n\tmaxLiquidityPerTick := tickTickSpacingToMaxLiquidityPerTick(tickSpacing)\n\ttick := common.TickMathGetTickAtSqrtRatio(sqrtPriceX96)\n\n\tslot0 := Slot0{\n\t\tsqrtPriceX96: sqrtPriceX96,\n\t\ttick:         tick,\n\t\tfeeProtocol:  0,\n\t\tunlocked:     true,\n\t}\n\n\tbalances := Balances{\n\t\ttoken0: u256.Zero(),\n\t\ttoken1: u256.Zero(),\n\t}\n\n\tprotocolFees := ProtocolFees{\n\t\ttoken0: u256.Zero(),\n\t\ttoken1: u256.Zero(),\n\t}\n\n\treturn \u0026Pool{\n\t\ttoken0Path:           token0Path,\n\t\ttoken1Path:           token1Path,\n\t\tbalances:             balances,\n\t\tfee:                  fee,\n\t\ttickSpacing:          tickSpacing,\n\t\tmaxLiquidityPerTick:  maxLiquidityPerTick,\n\t\tslot0:                slot0,\n\t\tfeeGrowthGlobal0X128: u256.Zero(),\n\t\tfeeGrowthGlobal1X128: u256.Zero(),\n\t\tprotocolFees:         protocolFees,\n\t\tliquidity:            u256.Zero(),\n\t\tticks:                Ticks{},\n\t\ttickBitmaps:          TickBitmaps{},\n\t\tpositions:            Positions{},\n\t}\n}\n"},{"name":"position.gno","body":"package pool\n\nimport (\n\t\"encoding/base64\"\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// positionGetKey generates a unique key for a position based on the owner's address and the tick range.\nfunc positionGetKey(\n\towner std.Address,\n\ttickLower int32,\n\ttickUpper int32,\n) string {\n\tpositionKey := ufmt.Sprintf(\"%s__%d__%d\", owner.String(), tickLower, tickUpper)\n\n\tencoded := base64.StdEncoding.EncodeToString([]byte(positionKey))\n\treturn encoded\n}\n\n// positionUpdateWithKey updates a position in the pool and returns the updated position.\nfunc (pool *Pool) positionUpdateWithKey(\n\tpositionKey string,\n\tliquidityDelta *i256.Int, // int128\n\tfeeGrowthInside0X128 *u256.Uint, // uint256\n\tfeeGrowthInside1X128 *u256.Uint, // uint256\n) PositionInfo {\n\t// PARAM INIT\n\tliquidityDelta = liquidityDelta.NilToZero()\n\tfeeGrowthInside0X128 = feeGrowthInside0X128.NilToZero()\n\tfeeGrowthInside1X128 = feeGrowthInside1X128.NilToZero()\n\n\tpositionToUpdate := pool.positions[positionKey]\n\tpositionAfterUpdate := positionUpdate(positionToUpdate, liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128)\n\tpool.positions[positionKey] = positionAfterUpdate\n\n\treturn positionAfterUpdate\n}\n\n// positionUpdate calculates and returns an updated PositionInfo.\nfunc positionUpdate(\n\tself PositionInfo,\n\tliquidityDelta *i256.Int, // int128\n\tfeeGrowthInside0X128 *u256.Uint, // uint256\n\tfeeGrowthInside1X128 *u256.Uint, // uint256\n) PositionInfo {\n\tself.init()\n\n\tvar liquidityNext *u256.Uint\n\tif liquidityDelta.IsZero() {\n\t\tliquidityNext = self.liquidity\n\t} else {\n\t\tliquidityNext = liquidityMathAddDelta(self.liquidity, liquidityDelta)\n\t}\n\n\ttokensOwed0 := u256.Zero()\n\t{\n\t\tdiff := new(u256.Uint).Sub(feeGrowthInside0X128, self.feeGrowthInside0LastX128)\n\t\ttokensOwed0 = u256.MulDiv(diff, self.liquidity, u256.MustFromDecimal(consts.Q128))\n\t}\n\n\ttokensOwed1 := u256.Zero()\n\t{\n\t\tdiff := new(u256.Uint).Sub(feeGrowthInside1X128, self.feeGrowthInside1LastX128)\n\t\ttokensOwed1 = u256.MulDiv(diff, self.liquidity, u256.MustFromDecimal(consts.Q128))\n\t}\n\n\tif !(liquidityDelta.IsZero()) {\n\t\tself.liquidity = liquidityNext\n\t}\n\n\tself.feeGrowthInside0LastX128 = feeGrowthInside0X128\n\tself.feeGrowthInside1LastX128 = feeGrowthInside1X128\n\tif tokensOwed0.Gt(u256.Zero()) || tokensOwed1.Gt(u256.Zero()) {\n\t\tself.tokensOwed0 = self.tokensOwed0.Add(self.tokensOwed0, tokensOwed0)\n\t\tself.tokensOwed1 = self.tokensOwed1.Add(self.tokensOwed1, tokensOwed1)\n\t}\n\n\treturn self\n}\n"},{"name":"position_modify.gno","body":"package pool\n\nimport (\n\t\"gno.land/r/gnoswap/v2/common\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\n\tplp \"gno.land/p/gnoswap/pool\" // pool package\n)\n\n// modifyPosition updates a position in the pool and calculates the amount of tokens to be added or removed.\n//\n// This function performs the following operations:\n// 1. Updates the position based on the given parameters.\n// 2. Calculates the amount of token0 and token1 to be added or removed based on the current tick and the position's tick range.\n// 3. Updates the pool's liquidity if the position is within the current tick range.\n//\n// Note:\n//   - If the position is out of the current price range, either amount0 or amount1 may be zero.\n//   - The function handles nil values for amount0 and amount1 by converting them to zero.\nfunc (pool *Pool) modifyPosition(params ModifyPositionParams) (PositionInfo, *i256.Int, *i256.Int) {\n\tposition := pool.updatePosition(\n\t\tparams.owner,\n\t\tparams.tickLower,\n\t\tparams.tickUpper,\n\t\tparams.liquidityDelta,\n\t\tpool.slot0.tick,\n\t)\n\n\tvar amount0, amount1 *i256.Int\n\n\tif !(params.liquidityDelta.IsZero()) {\n\t\tif pool.slot0.tick \u003c params.tickLower {\n\t\t\t_amount0Str := plp.SqrtPriceMathGetAmount0DeltaStr(\n\t\t\t\tcommon.TickMathGetSqrtRatioAtTick(params.tickLower),\n\t\t\t\tcommon.TickMathGetSqrtRatioAtTick(params.tickUpper),\n\t\t\t\tparams.liquidityDelta,\n\t\t\t)\n\t\t\tamount0 = i256.MustFromDecimal(_amount0Str)\n\t\t} else if pool.slot0.tick \u003c params.tickUpper {\n\t\t\tliquidityBefore := pool.liquidity\n\n\t\t\t_amount0Str := plp.SqrtPriceMathGetAmount0DeltaStr(\n\t\t\t\tpool.slot0.sqrtPriceX96,\n\t\t\t\tcommon.TickMathGetSqrtRatioAtTick(params.tickUpper),\n\t\t\t\tparams.liquidityDelta,\n\t\t\t)\n\t\t\tamount0 = i256.MustFromDecimal(_amount0Str)\n\n\t\t\t_amount1Str := plp.SqrtPriceMathGetAmount1DeltaStr(\n\t\t\t\tcommon.TickMathGetSqrtRatioAtTick(params.tickLower),\n\t\t\t\tpool.slot0.sqrtPriceX96,\n\t\t\t\tparams.liquidityDelta,\n\t\t\t)\n\t\t\tamount1 = i256.MustFromDecimal(_amount1Str)\n\n\t\t\tpool.liquidity = liquidityMathAddDelta(liquidityBefore, params.liquidityDelta)\n\n\t\t} else {\n\t\t\t_amount1Str := plp.SqrtPriceMathGetAmount1DeltaStr(\n\t\t\t\tcommon.TickMathGetSqrtRatioAtTick(params.tickLower),\n\t\t\t\tcommon.TickMathGetSqrtRatioAtTick(params.tickUpper),\n\t\t\t\tparams.liquidityDelta,\n\t\t\t)\n\t\t\tamount1 = i256.MustFromDecimal(_amount1Str)\n\t\t}\n\t}\n\n\t// if position is out of range, one of amount0 or amount1 can be nil\n\t// \u003e handle as 0\n\tamount0 = amount0.NilToZero()\n\tamount1 = amount1.NilToZero()\n\n\treturn position, amount0, amount1\n}\n"},{"name":"position_update.gno","body":"package pool\n\nimport (\n\t\"std\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nfunc (pool *Pool) updatePosition(\n\towner std.Address,\n\ttickLower int32,\n\ttickUpper int32,\n\tliquidityDelta *i256.Int, // int128\n\ttick int32,\n) PositionInfo {\n\t_feeGrowthGlobal0X128 := u256.MustFromDecimal(pool.feeGrowthGlobal0X128.ToString())\n\t_feeGrowthGlobal1X128 := u256.MustFromDecimal(pool.feeGrowthGlobal1X128.ToString())\n\n\tvar flippedLower, flippedUpper bool\n\tif !(liquidityDelta.IsZero()) {\n\t\tflippedLower = pool.tickUpdate(\n\t\t\ttickLower,\n\t\t\ttick,\n\t\t\tliquidityDelta,\n\t\t\t_feeGrowthGlobal0X128,\n\t\t\t_feeGrowthGlobal1X128,\n\t\t\tfalse,\n\t\t\tpool.maxLiquidityPerTick,\n\t\t)\n\n\t\tflippedUpper = pool.tickUpdate(\n\t\t\ttickUpper,\n\t\t\ttick,\n\t\t\tliquidityDelta,\n\t\t\t_feeGrowthGlobal0X128,\n\t\t\t_feeGrowthGlobal1X128,\n\t\t\ttrue,\n\t\t\tpool.maxLiquidityPerTick,\n\t\t)\n\n\t\tif flippedLower {\n\t\t\tpool.tickBitmapFlipTick(tickLower, pool.tickSpacing)\n\t\t}\n\n\t\tif flippedUpper {\n\t\t\tpool.tickBitmapFlipTick(tickUpper, pool.tickSpacing)\n\t\t}\n\t}\n\n\tfeeGrowthInside0X128, feeGrowthInside1X128 := pool.tickGetFeeGrowthInside(\n\t\ttickLower,\n\t\ttickUpper,\n\t\ttick,\n\t\t_feeGrowthGlobal0X128,\n\t\t_feeGrowthGlobal1X128,\n\t)\n\n\tpositionKey := positionGetKey(owner, tickLower, tickUpper)\n\n\tposition := pool.positionUpdateWithKey(\n\t\tpositionKey,\n\t\tliquidityDelta,\n\t\tu256.MustFromDecimal(feeGrowthInside0X128.ToString()),\n\t\tu256.MustFromDecimal(feeGrowthInside1X128.ToString()),\n\t)\n\n\tif liquidityDelta.IsNeg() {\n\t\tif flippedLower {\n\t\t\tdelete(pool.ticks, tickLower)\n\t\t}\n\n\t\tif flippedUpper {\n\t\t\tdelete(pool.ticks, tickUpper)\n\t\t}\n\t}\n\n\treturn position\n}\n"},{"name":"protocol_fee_pool_creation.gno","body":"package pool\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// poolCreationFee is the fee that is charged when a user creates a pool.\n//\n// The fee is denominated in GNS tokens.\nvar (\n\tpoolCreationFee = uint64(100_000_000) // 100_GNS\n)\n\n// GetPoolCreationFee returns the poolCreationFee\nfunc GetPoolCreationFee() uint64 {\n\treturn poolCreationFee\n}\n\n// SetPoolCreationFee sets the poolCreationFee\n//\n// This function can only be called by the admin or governance.\n//\n// Panics:\n//   - If the caller is not the admin or governance\nfunc SetPoolCreationFee(fee uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[POOL] protocol_fee_pool_creation.gno__SetPoolCreationFee() || only admin(%s) or governance(%s) can set pool creation fee, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\tpoolCreationFee = fee\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_fee\", uint64ToStr(fee),\n\t)\n}\n"},{"name":"protocol_fee_withdrawal.gno","body":"package pool\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// withdrawalFee is the fee that is charged when a user withdraws their collected fees\nvar (\n\twithdrawalFee = uint64(100) // 1%\n)\n\n// HandleWithdrawalFee withdraws the fee from the user and returns the amount after the fee\n//\n// Panics:\n// - caller is not the position contract\n// - caller does not have enough balance to give the fee\nfunc HandleWithdrawalFee(\n\ttokenId uint64,\n\ttoken0Path string,\n\t_amount0 string, // uint256\n\ttoken1Path string,\n\t_amount1 string, // uint256\n\tpoolPath string,\n) (string, string) { // uint256 x2\n\t// only position contract can call this function\n\tif std.PrevRealm().PkgPath() != consts.POSITION_PATH {\n\t\tpanic(ufmt.Sprintf(\"[POOL] withdrawal_fee.gno__HandleWithdrawalFee() || expected std.PrevRealm().PkgPath()(%s), got %s\", consts.POSITION_PATH, std.PrevRealm().PkgPath()))\n\t}\n\n\tamount0 := u256.MustFromDecimal(_amount0)\n\tamount1 := u256.MustFromDecimal(_amount1)\n\n\tif withdrawalFee == 0 {\n\t\treturn _amount0, _amount1\n\t}\n\n\tfeeAmount0 := new(u256.Uint).Mul(amount0, u256.NewUint(withdrawalFee))\n\tfeeAmount0 = new(u256.Uint).Div(feeAmount0, u256.NewUint(10000))\n\n\tfeeAmount1 := new(u256.Uint).Mul(amount1, u256.NewUint(withdrawalFee))\n\tfeeAmount1 = new(u256.Uint).Div(feeAmount1, u256.NewUint(10000))\n\n\tok := transferFromByRegisterCall(token0Path, std.GetOrigCaller(), consts.PROTOCOL_FEE_ADDR, feeAmount0.Uint64())\n\tif !ok {\n\t\tpanic(ufmt.Sprintf(\"[POOL] withdrawal_fee.gno__HandleWithdrawalFee() || expected transferFromByRegisterCall(%s, %s, %s, %s) == true\", token0Path, std.GetOrigCaller(), consts.PROTOCOL_FEE_ADDR, feeAmount0))\n\t}\n\tstd.Emit(\n\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"lpTokenId\", strconv.FormatUint(tokenId, 10),\n\t\t\"poolPath\", poolPath,\n\t\t\"reason\", \"withdrawal\",\n\t\t\"token\", token0Path,\n\t\t\"amount\", feeAmount0.ToString(),\n\t)\n\n\tok = transferFromByRegisterCall(token1Path, std.GetOrigCaller(), consts.PROTOCOL_FEE_ADDR, feeAmount1.Uint64())\n\tif !ok {\n\t\tpanic(ufmt.Sprintf(\"[POOL] withdrawal_fee.gno__HandleWithdrawalFee() || expected transferFromByRegisterCall(%s, %s, %s, %s) == true\", token1Path, std.GetOrigCaller(), consts.PROTOCOL_FEE_ADDR, feeAmount1))\n\t}\n\tstd.Emit(\n\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"lpTokenId\", strconv.FormatUint(tokenId, 10),\n\t\t\"poolPath\", poolPath,\n\t\t\"reason\", \"withdrawal\",\n\t\t\"token\", token1Path,\n\t\t\"amount\", feeAmount1.ToString(),\n\t)\n\n\tafterAmount0 := new(u256.Uint).Sub(amount0, feeAmount0)\n\tafterAmount1 := new(u256.Uint).Sub(amount1, feeAmount1)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\"p_token0Path\", token0Path,\n\t\t\"p_token1Path\", token1Path,\n\t\t\"fee0Amount\", feeAmount0.ToString(),\n\t\t\"fee1Amount\", feeAmount1.ToString(),\n\t)\n\n\treturn afterAmount0.ToString(), afterAmount1.ToString()\n}\n\n// GetWithdrawalFee returns the withdrawal fee\nfunc GetWithdrawalFee() uint64 {\n\treturn withdrawalFee\n}\n\n// SetWithdrawalFee sets the withdrawal fee\n//\n// Panics:\n// - caller is not the admin\nfunc SetWithdrawalFee(fee uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[POOL] protocol_fee_withdrawal.gno__SetWithdrawalFee() || only admin(%s) or governance(%s) can set withdrawal fee, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\t// 10000 (bps) = 100%\n\tif fee \u003e 10000 {\n\t\tpanic(ufmt.Sprintf(\"[POOL] withdrawal_fee.gno__SetWithdrawalFee() || fee(%d) must be in range 0 ~ 10000\", fee))\n\t}\n\n\twithdrawalFee = fee\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_fee\", uint64ToStr(fee),\n\t)\n}\n"},{"name":"tick.gno","body":"package pool\n\nimport (\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// tickTickSpacingToMaxLiquidityPerTick calculates the maximum liquidity\n// per tick for a given tick spacing.\nfunc tickTickSpacingToMaxLiquidityPerTick(tickSpacing int32) *u256.Uint {\n\tminTick := (consts.MIN_TICK / tickSpacing) * tickSpacing\n\tmaxTick := (consts.MAX_TICK / tickSpacing) * tickSpacing\n\tnumTicks := uint64((maxTick-minTick)/tickSpacing) + 1\n\n\t_maxUint128 := u256.MustFromDecimal(consts.MAX_UINT128)\n\treturn new(u256.Uint).Div(_maxUint128, u256.NewUint(numTicks))\n}\n\n// tickGetFeeGrowthInside calculates the fee growth inside a tick range.\nfunc (pool *Pool) tickGetFeeGrowthInside(\n\ttickLower int32,\n\ttickUpper int32,\n\ttickCurrent int32,\n\tfeeGrowthGlobal0X128 *u256.Uint, // uint256\n\tfeeGrowthGlobal1X128 *u256.Uint, // uint256\n) (*u256.Uint, *u256.Uint) { // uint256\n\tlower := pool.ticks[tickLower]\n\tlower.init()\n\n\tupper := pool.ticks[tickUpper]\n\tupper.init()\n\n\tvar feeGrowthBelow0X128, feeGrowthBelow1X128 *u256.Uint\n\tif tickCurrent \u003e= tickLower {\n\t\tfeeGrowthBelow0X128 = lower.feeGrowthOutside0X128\n\t\tfeeGrowthBelow1X128 = lower.feeGrowthOutside1X128\n\t} else {\n\t\tfeeGrowthBelow0X128 = new(u256.Uint).Sub(feeGrowthGlobal0X128, lower.feeGrowthOutside0X128)\n\t\tfeeGrowthBelow1X128 = new(u256.Uint).Sub(feeGrowthGlobal1X128, lower.feeGrowthOutside1X128)\n\t}\n\n\tvar feeGrowthAbove0X128, feeGrowthAbove1X128 *u256.Uint\n\tif tickCurrent \u003c tickUpper {\n\t\tfeeGrowthAbove0X128 = upper.feeGrowthOutside0X128\n\t\tfeeGrowthAbove1X128 = upper.feeGrowthOutside1X128\n\t} else {\n\t\tfeeGrowthAbove0X128 = new(u256.Uint).Sub(feeGrowthGlobal0X128, upper.feeGrowthOutside0X128)\n\t\tfeeGrowthAbove1X128 = new(u256.Uint).Sub(feeGrowthGlobal1X128, upper.feeGrowthOutside1X128)\n\t}\n\n\tfeeGrowthInside0X128 := new(u256.Uint).Sub(new(u256.Uint).Sub(feeGrowthGlobal0X128, feeGrowthBelow0X128), feeGrowthAbove0X128)\n\tfeeGrowthInside1X128 := new(u256.Uint).Sub(new(u256.Uint).Sub(feeGrowthGlobal1X128, feeGrowthBelow1X128), feeGrowthAbove1X128)\n\n\treturn feeGrowthInside0X128, feeGrowthInside1X128\n}\n\n// tickUpdate updates a tick's state and returns whether the tick was flipped.\n//\n// Panics:\n//   - If the resulting liquidity gross exceeds the maximum allowed liquidity.\nfunc (pool *Pool) tickUpdate(\n\ttick int32,\n\ttickCurrent int32,\n\tliquidityDelta *i256.Int, // int128\n\tfeeGrowthGlobal0X128 *u256.Uint, // uint256\n\tfeeGrowthGlobal1X128 *u256.Uint, // uint256\n\tupper bool,\n\tmaxLiquidity *u256.Uint, // uint256\n) (flipped bool) {\n\t// PARAM INIT\n\tliquidityDelta = liquidityDelta.NilToZero()\n\tfeeGrowthGlobal0X128 = feeGrowthGlobal0X128.NilToZero()\n\tfeeGrowthGlobal1X128 = feeGrowthGlobal1X128.NilToZero()\n\n\tinfo := pool.ticks[tick]\n\tinfo.init()\n\n\tliquidityGrossBefore := info.liquidityGross\n\tliquidityGrossAfter := liquidityMathAddDelta(liquidityGrossBefore, liquidityDelta)\n\n\tif !(liquidityGrossAfter.Lte(maxLiquidity)) {\n\t\tpanic(\"tick panic #1\")\n\t}\n\n\tflipped = (liquidityGrossAfter.IsZero()) != (liquidityGrossBefore.IsZero())\n\n\tif liquidityGrossBefore.IsZero() {\n\t\tif tick \u003c= tickCurrent {\n\t\t\tinfo.feeGrowthOutside0X128 = feeGrowthGlobal0X128\n\t\t\tinfo.feeGrowthOutside1X128 = feeGrowthGlobal1X128\n\t\t}\n\n\t\tinfo.initialized = true\n\t}\n\n\tinfo.liquidityGross = liquidityGrossAfter\n\n\tif upper {\n\t\tinfo.liquidityNet = i256.Zero().Sub(info.liquidityNet, liquidityDelta)\n\t} else {\n\t\tinfo.liquidityNet = i256.Zero().Add(info.liquidityNet, liquidityDelta)\n\t}\n\n\tpool.ticks[tick] = info\n\n\treturn flipped\n}\n\n// tickCross updates a tick's state when it is crossed and returns the liquidity net.\nfunc (pool *Pool) tickCross(\n\ttick int32,\n\tfeeGrowthGlobal0X128 *u256.Uint, // uint256\n\tfeeGrowthGlobal1X128 *u256.Uint, // uint256\n) *i256.Int {\n\tinfo := pool.ticks[tick]\n\tinfo.init()\n\n\tinfo.feeGrowthOutside0X128 = new(u256.Uint).Sub(feeGrowthGlobal0X128, info.feeGrowthOutside0X128)\n\tinfo.feeGrowthOutside1X128 = new(u256.Uint).Sub(feeGrowthGlobal1X128, info.feeGrowthOutside1X128)\n\n\tpool.ticks[tick] = info\n\n\tliquidityNet := info.liquidityNet\n\treturn liquidityNet\n}\n"},{"name":"tick_bitmap.gno","body":"package pool\n\nimport (\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\tplp \"gno.land/p/gnoswap/pool\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// tickBitmapPosition calculates the word and bit position for a given tick\nfunc tickBitmapPosition(tick int32) (int16, uint8) {\n\twordPos := int16(tick \u003e\u003e 8) // tick / 256\n\tbitPos := uint8(tick % 256)\n\n\treturn wordPos, bitPos\n}\n\n// tickBitmapFlipTick flips tthe bit corresponding to the given tick\n// in the pool's tick bitmap.\n//\n// Panics:\n//   - If tick % tickSpacing != 0\nfunc (pool *Pool) tickBitmapFlipTick(\n\ttick int32,\n\ttickSpacing int32,\n) {\n\tif tick%tickSpacing != 0 {\n\t\tpanic(ufmt.Sprintf(\"[POOL] tick_bitmap.gno__tickBitmapFlipTick() || tick(%d) MOD tickSpacing(%d) != 0(%d)\", tick, tickSpacing, tick%tickSpacing))\n\t}\n\n\twordPos, bitPos := tickBitmapPosition(tick / tickSpacing)\n\n\t// 1 \u003c\u003c bitPos\n\tmask := new(u256.Uint).Lsh(u256.NewUint(1), uint(bitPos))\n\n\tpool.tickBitmaps[wordPos] = pool.tickBitmaps[wordPos].NilToZero()\n\tpool.tickBitmaps[wordPos] = new(u256.Uint).Xor(pool.tickBitmaps[wordPos], mask)\n}\n\n// tickBitmapNextInitializedTickWithInOneWord finds the next initialized tick within\n// one word of the bitmap.\nfunc (pool *Pool) tickBitmapNextInitializedTickWithInOneWord(\n\ttick int32,\n\ttickSpacing int32,\n\tlte bool,\n) (int32, bool) {\n\tcompress := tick / tickSpacing\n\tif tick \u003c 0 \u0026\u0026 tick%tickSpacing != 0 {\n\t\tcompress--\n\t}\n\n\tif lte {\n\t\twordPos, bitPos := tickBitmapPosition(compress)\n\n\t\t// mask := (1 \u003c\u003c bitPos) - 1 + (1 \u003c\u003c bitPos)\n\t\tshift1LeftByBitPos := new(u256.Uint).Lsh(u256.NewUint(1), uint(bitPos))\n\n\t\tmask := shift1LeftByBitPos.Clone()\n\t\tmask = new(u256.Uint).Sub(mask, u256.NewUint(1))\n\t\tmask = new(u256.Uint).Add(mask, shift1LeftByBitPos.Clone())\n\n\t\tpool.tickBitmaps[wordPos] = pool.tickBitmaps[wordPos].NilToZero()\n\t\tmasked := new(u256.Uint).And(pool.tickBitmaps[wordPos], mask)\n\n\t\tinitialized := !(masked.IsZero())\n\n\t\tif initialized {\n\t\t\tnext := (compress - int32(bitPos-plp.BitMathMostSignificantBit(masked))) * tickSpacing\n\t\t\treturn next, initialized\n\t\t}\n\n\t\tnext := (compress - int32(bitPos)) * tickSpacing\n\t\treturn next, initialized\n\t}\n\n\twordPos, bitPos := tickBitmapPosition(compress + 1)\n\n\tshift1LeftByBitPos := new(u256.Uint).Lsh(u256.NewUint(1), uint(bitPos))\n\t_mask := shift1LeftByBitPos.Clone()\n\t_mask = new(u256.Uint).Sub(_mask, u256.NewUint(1))\n\tmask := bitwiseNotForUint256BitmapIndexing(_mask)\n\n\tpool.tickBitmaps[wordPos] = pool.tickBitmaps[wordPos].NilToZero()\n\tmasked := new(u256.Uint).And(pool.tickBitmaps[wordPos], mask)\n\n\tinitialized := !(masked.IsZero())\n\tif initialized {\n\t\tnext := (compress + 1 + int32(plp.BitMathLeastSignificantBit(masked)-bitPos)) * tickSpacing\n\t\treturn next, initialized\n\t} else {\n\t\tnext := (compress + 1 + int32(255-bitPos)) * tickSpacing\n\n\t\treturn next, initialized\n\t}\n}\n\n// bitwiseNotForUint256BitmapIndexing performs a bitwise NOT operation on the uint256 value.\n// This function is designed for use in bitmap indexing\nfunc bitwiseNotForUint256BitmapIndexing(x *u256.Uint) *u256.Uint {\n\t// REF: https://stackoverflow.com/a/77071037\n\n\t// Create a mask with all bits set to 1\n\tmask := u256.MustFromDecimal(consts.MAX_UINT256)\n\tmask = new(u256.Uint).Sub(mask, u256.NewUint(1))\n\n\t// XOR with mask to perform bitwise NOT\n\t// result := x ^ mask\n\n\tresult := new(u256.Uint).Xor(x, mask)\n\treturn result\n}\n"},{"name":"token_register.gno","body":"package pool\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\n// GRC20Interface is the interface for GRC20 tokens\n// It is used to interact with the GRC20 tokens without importing but by registering each tokens function\ntype GRC20Interface interface {\n\tTransfer() func(to pusers.AddressOrName, amount uint64)\n\tTransferFrom() func(from, to pusers.AddressOrName, amount uint64)\n\tBalanceOf() func(owner pusers.AddressOrName) uint64\n\tApprove() func(spender pusers.AddressOrName, amount uint64)\n}\n\nvar (\n\tregistered = make(map[string]GRC20Interface)\n\tlocked     = false // mutex\n)\n\n// GetRegisteredTokens returns a list of all registered tokens\nfunc GetRegisteredTokens() []string {\n\ttokens := make([]string, 0, len(registered))\n\tfor k := range registered {\n\t\ttokens = append(tokens, k)\n\t}\n\treturn tokens\n}\n\n// RegisterGRC20Interface registers a GRC20 token interface\n//\n// Panics:\n//   - caller is not the admin\n//   - token already registered\nfunc RegisterGRC20Interface(pkgPath string, igrc20 GRC20Interface) {\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[POOL] token_register.gno__RegisterGRC20Interface() || unauthorized address(%s) to register\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tpanic(ufmt.Sprintf(\"[POOL] token_register.gno__RegisterGRC20Interface() || pkgPath(%s) already registered\", pkgPath))\n\t}\n\n\tregistered[pkgPath] = igrc20\n}\n\n// UnregisterGRC20Interface unregisters a GRC20 token interface\n//\n// Panics:\n//   - caller is not the admin\nfunc UnregisterGRC20Interface(pkgPath string) {\n\t// only admin can unregister\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[POOL] token_register.gno__UnregisterGRC20Interface() || unauthorized address(%s) to unregister\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tdelete(registered, pkgPath)\n\t}\n}\n\nfunc transferByRegisterCall(pkgPath string, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[POOL] token_register.gno__transferByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].Transfer()(pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[POOl] token_register.gno__transferByRegisterCall() || expected locked to be false\")\n\t}\n\n\treturn true\n}\n\nfunc transferFromByRegisterCall(pkgPath string, from, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[POOL] token_register.gno__transferFromByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].TransferFrom()(pusers.AddressOrName(from), pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[POOl] token_register.gno__transferFromByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc balanceOfByRegisterCall(pkgPath string, owner std.Address) uint64 {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[POOL] token_register.gno__balanceOfByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tbalance := registered[pkgPath].BalanceOf()(pusers.AddressOrName(owner))\n\treturn balance\n}\n\nfunc approveByRegisterCall(pkgPath string, spender std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[POOL] token_register.gno__approveByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tregistered[pkgPath].Approve()(pusers.AddressOrName(spender), amount)\n\n\treturn true\n}\n\nfunc handleNative(pkgPath string) string {\n\tif pkgPath == consts.GNOT {\n\t\treturn consts.WRAPPED_WUGNOT\n\t}\n\n\treturn pkgPath\n}\n"},{"name":"type.gno","body":"package pool\n\nimport (\n\t\"std\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\ntype Slot0 struct {\n\tsqrtPriceX96 *u256.Uint // current price of the pool as a sqrt(token1/token0) Q96 value\n\ttick         int32      // current tick of the pool, i.e according to the last tick transition that was run\n\tfeeProtocol  uint8      // protocol fee for both tokens of the pool\n\tunlocked     bool       // whether the pool is currently locked to reentrancy\n}\n\ntype Balances struct {\n\t// current balance of the pool in token0/token1\n\ttoken0 *u256.Uint\n\ttoken1 *u256.Uint\n}\n\ntype ProtocolFees struct {\n\t// current protocol fees of the pool in token0/token1\n\ttoken0 *u256.Uint\n\ttoken1 *u256.Uint\n}\n\ntype ModifyPositionParams struct {\n\towner std.Address // address that owns the position\n\n\t// the tick range of the position, bounds are included\n\ttickLower int32\n\ttickUpper int32\n\n\tliquidityDelta *i256.Int // any change in liquidity\n}\n\ntype SwapCache struct {\n\tfeeProtocol    uint8      // protocol fee for the input token\n\tliquidityStart *u256.Uint // liquidity at the beginning of the swap\n}\n\nfunc newSwapCache(\n\tfeeProtocol uint8,\n\tliquidityStart *u256.Uint,\n) SwapCache {\n\treturn SwapCache{\n\t\tfeeProtocol:    feeProtocol,\n\t\tliquidityStart: liquidityStart,\n\t}\n}\n\ntype SwapState struct {\n\tamountSpecifiedRemaining *i256.Int  // amount remaining to be swapped in/out of the input/output token\n\tamountCalculated         *i256.Int  // amount already swapped out/in of the output/input token\n\tsqrtPriceX96             *u256.Uint // current sqrt(price)\n\ttick                     int32      // tick associated with the current sqrt(price)\n\tfeeGrowthGlobalX128      *u256.Uint // global fee growth of the input token\n\tprotocolFee              *u256.Uint // amount of input token paid as protocol fee\n\tliquidity                *u256.Uint // current liquidity in range\n}\n\nfunc (pool *Pool) newSwapState(\n\tamountSpecifiedRemaining *i256.Int,\n\tfeeGrowthGlobalX128 *u256.Uint,\n\tliquidity *u256.Uint,\n) SwapState {\n\tslot0 := pool.slot0\n\n\treturn SwapState{\n\t\tamountSpecifiedRemaining: amountSpecifiedRemaining,\n\t\tamountCalculated:         i256.Zero(),\n\t\tsqrtPriceX96:             slot0.sqrtPriceX96,\n\t\ttick:                     slot0.tick,\n\t\tfeeGrowthGlobalX128:      feeGrowthGlobalX128,\n\t\tprotocolFee:              u256.Zero(),\n\t\tliquidity:                liquidity,\n\t}\n}\n\ntype StepComputations struct {\n\tsqrtPriceStartX96 *u256.Uint // price at the beginning of the step\n\ttickNext          int32      // next tick to swap to from the current tick in the swap direction\n\tinitialized       bool       // whether tickNext is initialized\n\tsqrtPriceNextX96  *u256.Uint // sqrt(price) for the next tick (token1/token0) Q96\n\tamountIn          *u256.Uint // how much being swapped in this step\n\tamountOut         *u256.Uint // how much is being swapped out in this step\n\tfeeAmount         *u256.Uint // how much fee is being paid in this step\n}\n\ntype PositionInfo struct {\n\tliquidity *u256.Uint // amount of liquidity owned by this position\n\n\t// fee growth per unit of liquidity as of the last update to liquidity or fees owed\n\tfeeGrowthInside0LastX128 *u256.Uint\n\tfeeGrowthInside1LastX128 *u256.Uint\n\n\t// fees owed to the position owner in token0/token1\n\ttokensOwed0 *u256.Uint\n\ttokensOwed1 *u256.Uint\n}\n\nfunc (p *PositionInfo) init() {\n\tp.liquidity = p.liquidity.NilToZero()\n\tp.feeGrowthInside0LastX128 = p.feeGrowthInside0LastX128.NilToZero()\n\tp.feeGrowthInside1LastX128 = p.feeGrowthInside1LastX128.NilToZero()\n\tp.tokensOwed0 = p.tokensOwed0.NilToZero()\n\tp.tokensOwed1 = p.tokensOwed1.NilToZero()\n}\n\ntype TickInfo struct {\n\tliquidityGross *u256.Uint // total position liquidity that references this tick\n\tliquidityNet   *i256.Int  // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)\n\n\t// fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n\t// only has relative meaning, not absolute — the value depends on when the tick is initialized\n\tfeeGrowthOutside0X128 *u256.Uint\n\tfeeGrowthOutside1X128 *u256.Uint\n\n\ttickCumulativeOutside int64 // cumulative tick value on the other side of the tick\n\n\t// the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n\t// only has relative meaning, not absolute — the value depends on when the tick is initialized\n\tsecondsPerLiquidityOutsideX128 *u256.Uint\n\n\t// the seconds spent on the other side of the tick (relative to the current tick)\n\t// only has relative meaning, not absolute — the value depends on when the tick is initialized\n\tsecondsOutside uint32\n\n\tinitialized bool // whether the tick is initialized\n}\n\nfunc (t *TickInfo) init() {\n\tt.liquidityGross = t.liquidityGross.NilToZero()\n\tt.liquidityNet = t.liquidityNet.NilToZero()\n\tt.feeGrowthOutside0X128 = t.feeGrowthOutside0X128.NilToZero()\n\tt.feeGrowthOutside1X128 = t.feeGrowthOutside1X128.NilToZero()\n\tt.secondsPerLiquidityOutsideX128 = t.secondsPerLiquidityOutsideX128.NilToZero()\n}\n\ntype Ticks map[int32]TickInfo          // tick =\u003e TickInfo\ntype TickBitmaps map[int16]*u256.Uint  // tick(wordPos) =\u003e bitmap(tickWord ^ mask)\ntype Positions map[string]PositionInfo // positionKey =\u003e PositionInfo\n\n// type Pool describes a single Pool's state\n// A pool is identificed with a unique key (token0, token1, fee), where token0 \u003c token1\ntype Pool struct {\n\t// token0/token1 path of the pool\n\ttoken0Path string\n\ttoken1Path string\n\n\tbalances Balances // balances of the pool\n\n\tfee uint32 // fee tier of the pool\n\n\ttickSpacing int32 // spacing between ticks\n\n\tmaxLiquidityPerTick *u256.Uint // the maximum amount of liquidity that can be added per tick\n\n\tslot0 Slot0\n\n\tfeeGrowthGlobal0X128 *u256.Uint // uint256\n\tfeeGrowthGlobal1X128 *u256.Uint // uint256\n\n\tprotocolFees ProtocolFees\n\n\tliquidity *u256.Uint // total amount of liquidity in the pool\n\n\tticks Ticks // maps tick index to tick\n\n\ttickBitmaps TickBitmaps // maps tick index to tick bitmap\n\n\tpositions Positions // maps the key (caller, lower tick, upper tick) to a unique position\n}\n"},{"name":"utils.gno","body":"package pool\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nfunc a2u(addr std.Address) pusers.AddressOrName {\n\treturn pusers.AddressOrName(addr)\n}\n\nfunc u256Min(num1, num2 *u256.Uint) *u256.Uint {\n\tif num1.Lt(num2) {\n\t\treturn num1\n\t}\n\n\treturn num2\n}\n\nfunc uint8ToStr(i uint8) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc int32ToStr(i int32) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc uint64ToStr(i uint64) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc boolToStr(b bool) string {\n\tif b {\n\t\treturn \"true\"\n\t}\n\n\treturn \"false\"\n}\n\nfunc origCaller() string {\n\treturn std.GetOrigCaller().String()\n}\n\nfunc prevRealm() string {\n\treturn std.PrevRealm().PkgPath()\n}\n\nfunc callType() string {\n\tif prevRealm() == \"\" {\n\t\treturn \"DIRECT\"\n\t}\n\n\treturn \"INDIRECT\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"iYIrijl3ElxPCVL8H6GcCio14FkLrqZi+6whlWnHNzxe9KsAKkZywrJJj/4eIQMBud76XY6vzsy1EXFExqZ8YA=="}],"memo":""},"blockNum":"716183"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"position","path":"gno.land/r/gnoswap/v2/position","files":[{"name":"_GET_no_receiver.gno.gno","body":"package position\n\nimport (\n\t\"std\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n)\n\n// type Position\nfunc PositionGetPosition(tokenId uint64) Position {\n\treturn positions[tokenId]\n}\n\nfunc PositionGetPositionNonce(tokenId uint64) *u256.Uint {\n\treturn positions[tokenId].nonce\n}\n\nfunc PositionGetPositionOperator(tokenId uint64) std.Address {\n\treturn positions[tokenId].operator\n}\n\nfunc PositionGetPositionPoolKey(tokenId uint64) string {\n\treturn positions[tokenId].poolKey\n}\n\nfunc PositionGetPositionTickLower(tokenId uint64) int32 {\n\treturn positions[tokenId].tickLower\n}\n\nfunc PositionGetPositionTickUpper(tokenId uint64) int32 {\n\treturn positions[tokenId].tickUpper\n}\n\nfunc PositionGetPositionLiquidity(tokenId uint64) *u256.Uint {\n\treturn positions[tokenId].liquidity\n}\n\nfunc PositionGetPositionFeeGrowthInside0LastX128(tokenId uint64) *u256.Uint {\n\treturn positions[tokenId].feeGrowthInside0LastX128\n}\n\nfunc PositionGetPositionFeeGrowthInside1LastX128(tokenId uint64) *u256.Uint {\n\treturn positions[tokenId].feeGrowthInside1LastX128\n}\n\nfunc PositionGetPositionTokensOwed0(tokenId uint64) *u256.Uint {\n\treturn positions[tokenId].tokensOwed0\n}\n\nfunc PositionGetPositionTokensOwed1(tokenId uint64) *u256.Uint {\n\treturn positions[tokenId].tokensOwed1\n}\n\nfunc PositionIsInRange(tokenId uint64) bool {\n\tposition := positions[tokenId]\n\tpoolPath := position.poolKey\n\tpoolCurrentTick := pl.PoolGetSlot0Tick(poolPath)\n\n\tif position.tickLower \u003c= poolCurrentTick \u0026\u0026 poolCurrentTick \u003c= position.tickUpper {\n\t\treturn true\n\t}\n\n\treturn false\n}\n"},{"name":"_GET_no_receiver_string.gno","body":"package position\n\n// type Position\nfunc PositionGetPositionNonceStr(tokenId uint64) string {\n\treturn positions[tokenId].nonce.ToString()\n}\n\nfunc PositionGetPositionLiquidityStr(tokenId uint64) string {\n\treturn positions[tokenId].liquidity.ToString()\n}\n\nfunc PositionGetPositionFeeGrowthInside0LastX128Str(tokenId uint64) string {\n\treturn positions[tokenId].feeGrowthInside0LastX128.ToString()\n}\n\nfunc PositionGetPositionFeeGrowthInside1LastX128Str(tokenId uint64) string {\n\treturn positions[tokenId].feeGrowthInside1LastX128.ToString()\n}\n\nfunc PositionGetPositionTokensOwed0Str(tokenId uint64) string {\n\treturn positions[tokenId].tokensOwed0.ToString()\n}\n\nfunc PositionGetPositionTokensOwed1Str(tokenId uint64) string {\n\treturn positions[tokenId].tokensOwed1.ToString()\n}\n"},{"name":"_RPC_api.gno","body":"package position\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/r/gnoswap/v2/common\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n)\n\ntype RpcPosition struct {\n\tLpTokenId                uint64 `json:\"lpTokenId\"`\n\tBurned                   bool   `json:\"burned\"`\n\tOperator                 string `json:\"operator\"`\n\tPoolKey                  string `json:\"poolKey\"`\n\tTickLower                int32  `json:\"tickLower\"`\n\tTickUpper                int32  `json:\"tickUpper\"`\n\tLiquidity                string `json:\"liquidity\"`\n\tFeeGrowthInside0LastX128 string `json:\"feeGrowthInside0LastX128\"`\n\tFeeGrowthInside1LastX128 string `json:\"feeGrowthInside1LastX128\"`\n\tTokensOwed0              string `json:\"token0Owed\"`\n\tTokensOwed1              string `json:\"token1Owed\"`\n\n\tToken0Balance string `json:\"token0Balance\"`\n\tToken1Balance string `json:\"token1Balance\"`\n\tFeeUnclaimed0 string `json:\"fee0Unclaimed\"`\n\tFeeUnclaimed1 string `json:\"fee1Unclaimed\"`\n}\n\ntype RpcUnclaimedFee struct {\n\tLpTokenId uint64 `json:\"lpTokenId\"`\n\tFee0      string `json:\"fee0\"`\n\tFee1      string `json:\"fee1\"`\n}\n\ntype ResponseQueryBase struct {\n\tHeight    int64 `json:\"height\"`\n\tTimestamp int64 `json:\"timestamp\"`\n}\n\ntype ResponseApiGetPositions struct {\n\tStat     ResponseQueryBase `json:\"stat\"`\n\tResponse []RpcPosition     `json:\"response\"`\n}\n\nfunc ApiGetPositions() string {\n\trpcPositions := []RpcPosition{}\n\tfor lpTokenId, _ := range positions {\n\t\trpcPosition := rpcMakePosition(lpTokenId)\n\t\trpcPositions = append(rpcPositions, rpcPosition)\n\t}\n\n\tr := ResponseApiGetPositions{\n\t\tStat: ResponseQueryBase{\n\t\t\tHeight:    std.GetHeight(),\n\t\t\tTimestamp: time.Now().Unix(),\n\t\t},\n\t\tResponse: rpcPositions,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, position := range r.Response {\n\t\t_positionNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\":                json.NumberNode(\"lpTokenId\", float64(position.LpTokenId)),\n\t\t\t\"burned\":                   json.BoolNode(\"burned\", position.Burned),\n\t\t\t\"operator\":                 json.StringNode(\"operator\", position.Operator),\n\t\t\t\"poolKey\":                  json.StringNode(\"poolKey\", position.PoolKey),\n\t\t\t\"tickLower\":                json.NumberNode(\"tickLower\", float64(position.TickLower)),\n\t\t\t\"tickUpper\":                json.NumberNode(\"tickUpper\", float64(position.TickUpper)),\n\t\t\t\"liquidity\":                json.StringNode(\"liquidity\", position.Liquidity),\n\t\t\t\"feeGrowthInside0LastX128\": json.StringNode(\"feeGrowthInside0LastX128\", position.FeeGrowthInside0LastX128),\n\t\t\t\"feeGrowthInside1LastX128\": json.StringNode(\"feeGrowthInside1LastX128\", position.FeeGrowthInside1LastX128),\n\t\t\t\"token0Owed\":               json.StringNode(\"token0Owed\", position.TokensOwed0),\n\t\t\t\"token1Owed\":               json.StringNode(\"token1Owed\", position.TokensOwed1),\n\t\t\t\"token0Balance\":            json.StringNode(\"token0Balance\", position.Token0Balance),\n\t\t\t\"token1Balance\":            json.StringNode(\"token1Balance\", position.Token1Balance),\n\t\t\t\"fee0Unclaimed\":            json.StringNode(\"fee0Unclaimed\", position.FeeUnclaimed0),\n\t\t\t\"fee1Unclaimed\":            json.StringNode(\"fee1Unclaimed\", position.FeeUnclaimed1),\n\t\t})\n\t\tresponses.AppendArray(_positionNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] _RPC_api.gno__ApiGetPositions() || error marshalling json: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetPosition(lpTokenId uint64) string {\n\trpcPositions := []RpcPosition{}\n\n\t_, ok := positions[lpTokenId]\n\tif ok {\n\t\trpcPosition := rpcMakePosition(lpTokenId)\n\t\trpcPositions = append(rpcPositions, rpcPosition)\n\t}\n\n\tr := ResponseApiGetPositions{\n\t\tStat: ResponseQueryBase{\n\t\t\tHeight:    std.GetHeight(),\n\t\t\tTimestamp: time.Now().Unix(),\n\t\t},\n\t\tResponse: rpcPositions,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, position := range r.Response {\n\t\t_positionNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\":                json.NumberNode(\"lpTokenId\", float64(position.LpTokenId)),\n\t\t\t\"burned\":                   json.BoolNode(\"burned\", position.Burned),\n\t\t\t\"operator\":                 json.StringNode(\"operator\", position.Operator),\n\t\t\t\"poolKey\":                  json.StringNode(\"poolKey\", position.PoolKey),\n\t\t\t\"tickLower\":                json.NumberNode(\"tickLower\", float64(position.TickLower)),\n\t\t\t\"tickUpper\":                json.NumberNode(\"tickUpper\", float64(position.TickUpper)),\n\t\t\t\"liquidity\":                json.StringNode(\"liquidity\", position.Liquidity),\n\t\t\t\"feeGrowthInside0LastX128\": json.StringNode(\"feeGrowthInside0LastX128\", position.FeeGrowthInside0LastX128),\n\t\t\t\"feeGrowthInside1LastX128\": json.StringNode(\"feeGrowthInside1LastX128\", position.FeeGrowthInside1LastX128),\n\t\t\t\"token0Owed\":               json.StringNode(\"token0Owed\", position.TokensOwed0),\n\t\t\t\"token1Owed\":               json.StringNode(\"token1Owed\", position.TokensOwed1),\n\t\t\t\"token0Balance\":            json.StringNode(\"token0Balance\", position.Token0Balance),\n\t\t\t\"token1Balance\":            json.StringNode(\"token1Balance\", position.Token1Balance),\n\t\t\t\"fee0Unclaimed\":            json.StringNode(\"fee0Unclaimed\", position.FeeUnclaimed0),\n\t\t\t\"fee1Unclaimed\":            json.StringNode(\"fee1Unclaimed\", position.FeeUnclaimed1),\n\t\t})\n\t\tresponses.AppendArray(_positionNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] _RPC_api.gno__ApiGetPositions() || error marshalling json: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetPositionsByPoolPath(poolPath string) string {\n\trpcPositions := []RpcPosition{}\n\tfor lpTokenId, position := range positions {\n\n\t\tif position.poolKey != poolPath {\n\t\t\tcontinue\n\t\t}\n\n\t\trpcPosition := rpcMakePosition(lpTokenId)\n\t\trpcPositions = append(rpcPositions, rpcPosition)\n\t}\n\n\tr := ResponseApiGetPositions{\n\t\tStat: ResponseQueryBase{\n\t\t\tHeight:    std.GetHeight(),\n\t\t\tTimestamp: time.Now().Unix(),\n\t\t},\n\t\tResponse: rpcPositions,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, position := range r.Response {\n\t\t_positionNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\":                json.NumberNode(\"lpTokenId\", float64(position.LpTokenId)),\n\t\t\t\"burned\":                   json.BoolNode(\"burned\", position.Burned),\n\t\t\t\"operator\":                 json.StringNode(\"operator\", position.Operator),\n\t\t\t\"poolKey\":                  json.StringNode(\"poolKey\", position.PoolKey),\n\t\t\t\"tickLower\":                json.NumberNode(\"tickLower\", float64(position.TickLower)),\n\t\t\t\"tickUpper\":                json.NumberNode(\"tickUpper\", float64(position.TickUpper)),\n\t\t\t\"liquidity\":                json.StringNode(\"liquidity\", position.Liquidity),\n\t\t\t\"feeGrowthInside0LastX128\": json.StringNode(\"feeGrowthInside0LastX128\", position.FeeGrowthInside0LastX128),\n\t\t\t\"feeGrowthInside1LastX128\": json.StringNode(\"feeGrowthInside1LastX128\", position.FeeGrowthInside1LastX128),\n\t\t\t\"token0Owed\":               json.StringNode(\"token0Owed\", position.TokensOwed0),\n\t\t\t\"token1Owed\":               json.StringNode(\"token1Owed\", position.TokensOwed1),\n\t\t\t\"token0Balance\":            json.StringNode(\"token0Balance\", position.Token0Balance),\n\t\t\t\"token1Balance\":            json.StringNode(\"token1Balance\", position.Token1Balance),\n\t\t\t\"fee0Unclaimed\":            json.StringNode(\"fee0Unclaimed\", position.FeeUnclaimed0),\n\t\t\t\"fee1Unclaimed\":            json.StringNode(\"fee1Unclaimed\", position.FeeUnclaimed1),\n\t\t})\n\t\tresponses.AppendArray(_positionNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] _RPC_api.gno__ApiGetPositions() || error marshalling json: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetPositionsByAddress(address string) string {\n\trpcPositions := []RpcPosition{}\n\tfor lpTokenId, position := range positions {\n\n\t\tif position.operator.String() != address {\n\t\t\tcontinue\n\t\t}\n\n\t\trpcPosition := rpcMakePosition(lpTokenId)\n\t\trpcPositions = append(rpcPositions, rpcPosition)\n\t}\n\n\tr := ResponseApiGetPositions{\n\t\tStat: ResponseQueryBase{\n\t\t\tHeight:    std.GetHeight(),\n\t\t\tTimestamp: time.Now().Unix(),\n\t\t},\n\t\tResponse: rpcPositions,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, position := range r.Response {\n\t\t_positionNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\":                json.NumberNode(\"lpTokenId\", float64(position.LpTokenId)),\n\t\t\t\"burned\":                   json.BoolNode(\"burned\", position.Burned),\n\t\t\t\"operator\":                 json.StringNode(\"operator\", position.Operator),\n\t\t\t\"poolKey\":                  json.StringNode(\"poolKey\", position.PoolKey),\n\t\t\t\"tickLower\":                json.NumberNode(\"tickLower\", float64(position.TickLower)),\n\t\t\t\"tickUpper\":                json.NumberNode(\"tickUpper\", float64(position.TickUpper)),\n\t\t\t\"liquidity\":                json.StringNode(\"liquidity\", position.Liquidity),\n\t\t\t\"feeGrowthInside0LastX128\": json.StringNode(\"feeGrowthInside0LastX128\", position.FeeGrowthInside0LastX128),\n\t\t\t\"feeGrowthInside1LastX128\": json.StringNode(\"feeGrowthInside1LastX128\", position.FeeGrowthInside1LastX128),\n\t\t\t\"token0Owed\":               json.StringNode(\"token0Owed\", position.TokensOwed0),\n\t\t\t\"token1Owed\":               json.StringNode(\"token1Owed\", position.TokensOwed1),\n\t\t\t\"token0Balance\":            json.StringNode(\"token0Balance\", position.Token0Balance),\n\t\t\t\"token1Balance\":            json.StringNode(\"token1Balance\", position.Token1Balance),\n\t\t\t\"fee0Unclaimed\":            json.StringNode(\"fee0Unclaimed\", position.FeeUnclaimed0),\n\t\t\t\"fee1Unclaimed\":            json.StringNode(\"fee1Unclaimed\", position.FeeUnclaimed1),\n\t\t})\n\t\tresponses.AppendArray(_positionNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] _RPC_api.gno__ApiGetPositions() || error marshalling json: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetPositionsUnclaimedFee() string {\n\trpcUnclaimedFee := []RpcUnclaimedFee{}\n\tfor lpTokenId, _ := range positions {\n\t\tunclaimedFee0, unclaimedFee1 := unclaimedFee(lpTokenId)\n\t\trpcUnclaimedFee = append(rpcUnclaimedFee, RpcUnclaimedFee{\n\t\t\tLpTokenId: lpTokenId,\n\t\t\tFee0:      unclaimedFee0.ToString(),\n\t\t\tFee1:      unclaimedFee1.ToString(),\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, unclaimedFee := range rpcUnclaimedFee {\n\t\t_unclaimedFeeNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\": json.NumberNode(\"lpTokenId\", float64(unclaimedFee.LpTokenId)),\n\t\t\t\"fee0\":      json.StringNode(\"fee0\", unclaimedFee.Fee0),\n\t\t\t\"fee1\":      json.StringNode(\"fee1\", unclaimedFee.Fee1),\n\t\t})\n\t\tresponses.AppendArray(_unclaimedFeeNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] _RPC_api.gno__ApiGetPositionsUnClaimedFee() || error marshalling json: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetPositionUnclaimedFeeByLpTokenId(lpTokenId uint64) string {\n\trpcUnclaimedFee := []RpcUnclaimedFee{}\n\n\tunclaimedFee0, unclaimedFee1 := unclaimedFee(lpTokenId)\n\trpcUnclaimedFee = append(rpcUnclaimedFee, RpcUnclaimedFee{\n\t\tLpTokenId: lpTokenId,\n\t\tFee0:      unclaimedFee0.ToString(),\n\t\tFee1:      unclaimedFee1.ToString(),\n\t})\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, unclaimedFee := range rpcUnclaimedFee {\n\t\t_unclaimedFeeNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\": json.NumberNode(\"lpTokenId\", float64(unclaimedFee.LpTokenId)),\n\t\t\t\"fee0\":      json.StringNode(\"fee0\", unclaimedFee.Fee0),\n\t\t\t\"fee1\":      json.StringNode(\"fee1\", unclaimedFee.Fee1),\n\t\t})\n\t\tresponses.AppendArray(_unclaimedFeeNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] _RPC_api.gno__ApiGetPositionUnclaimedFeeByLpTokenId() || error marshalling json: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc rpcMakePosition(lpTokenId uint64) RpcPosition {\n\tposition, exist := positions[lpTokenId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] getter_api.gno__rpcMakePosition() || position not found for lpTokenId(%d)\", lpTokenId))\n\t}\n\n\tburned := isBurned(lpTokenId)\n\n\tpool := pl.GetPoolFromPoolPath(position.poolKey)\n\tcurrentX96 := pool.PoolGetSlot0SqrtPriceX96()\n\tlowerX96 := common.TickMathGetSqrtRatioAtTick(position.tickLower)\n\tupperX96 := common.TickMathGetSqrtRatioAtTick(position.tickUpper)\n\n\ttoken0Balance, token1Balance := common.GetAmountsForLiquidity(\n\t\tcurrentX96,\n\t\tlowerX96,\n\t\tupperX96,\n\t\ti256.FromUint256(position.liquidity),\n\t)\n\n\tunclaimedFee0 := i256.Zero()\n\tunclaimedFee1 := i256.Zero()\n\tif !burned {\n\t\tunclaimedFee0, unclaimedFee1 = unclaimedFee(lpTokenId)\n\t}\n\n\treturn RpcPosition{\n\t\tLpTokenId:                lpTokenId,\n\t\tBurned:                   burned,\n\t\tOperator:                 position.operator.String(),\n\t\tPoolKey:                  position.poolKey,\n\t\tTickLower:                position.tickLower,\n\t\tTickUpper:                position.tickUpper,\n\t\tLiquidity:                position.liquidity.ToString(),\n\t\tFeeGrowthInside0LastX128: position.feeGrowthInside0LastX128.ToString(),\n\t\tFeeGrowthInside1LastX128: position.feeGrowthInside1LastX128.ToString(),\n\t\tTokensOwed0:              position.tokensOwed0.ToString(),\n\t\tTokensOwed1:              position.tokensOwed1.ToString(),\n\t\tToken0Balance:            token0Balance,\n\t\tToken1Balance:            token1Balance,\n\t\tFeeUnclaimed0:            unclaimedFee0.ToString(),\n\t\tFeeUnclaimed1:            unclaimedFee1.ToString(),\n\t}\n}\n\nfunc unclaimedFee(tokenId uint64) (*i256.Int, *i256.Int) {\n\t// ref: https://blog.uniswap.org/uniswap-v3-math-primer-2#calculating-uncollected-fees\n\n\t_liquidity := positions[tokenId].liquidity // u256\n\tliquidity := i256.FromUint256(_liquidity)  // i256\n\n\ttickLower := positions[tokenId].tickLower\n\ttickUpper := positions[tokenId].tickUpper\n\n\tpoolKey := positions[tokenId].poolKey\n\tpool := pl.GetPoolFromPoolPath(poolKey)\n\n\tcurrentTick := pool.PoolGetSlot0Tick()\n\n\t_feeGrowthGlobal0X128 := pool.PoolGetFeeGrowthGlobal0X128()     // u256\n\tfeeGrowthGlobal0X128 := i256.FromUint256(_feeGrowthGlobal0X128) // i256\n\n\t_feeGrowthGlobal1X128 := pool.PoolGetFeeGrowthGlobal1X128()     // u256\n\tfeeGrowthGlobal1X128 := i256.FromUint256(_feeGrowthGlobal1X128) // i256\n\n\t_tickUpperFeeGrowthOutside0X128 := pool.PoolGetTickFeeGrowthOutside0X128(tickUpper) // u256\n\ttickUpperFeeGrowthOutside0X128 := i256.FromUint256(_tickUpperFeeGrowthOutside0X128) // i256\n\n\t_tickUpperFeeGrowthOutside1X128 := pool.PoolGetTickFeeGrowthOutside1X128(tickUpper) // u256\n\ttickUpperFeeGrowthOutside1X128 := i256.FromUint256(_tickUpperFeeGrowthOutside1X128) // i256\n\n\t_tickLowerFeeGrowthOutside0X128 := pool.PoolGetTickFeeGrowthOutside0X128(tickLower) // u256\n\ttickLowerFeeGrowthOutside0X128 := i256.FromUint256(_tickLowerFeeGrowthOutside0X128) // i256\n\n\t_tickLowerFeeGrowthOutside1X128 := pool.PoolGetTickFeeGrowthOutside1X128(tickLower) // u256\n\ttickLowerFeeGrowthOutside1X128 := i256.FromUint256(_tickLowerFeeGrowthOutside1X128) // i256\n\n\t_feeGrowthInside0LastX128 := positions[tokenId].feeGrowthInside0LastX128 // u256\n\tfeeGrowthInside0LastX128 := i256.FromUint256(_feeGrowthInside0LastX128)  // i256\n\n\t_feeGrowthInside1LastX128 := positions[tokenId].feeGrowthInside1LastX128 // u256\n\tfeeGrowthInside1LastX128 := i256.FromUint256(_feeGrowthInside1LastX128)  // i256\n\n\tvar tickLowerFeeGrowthBelow0, tickLowerFeeGrowthBelow1, tickUpperFeeGrowthAbove0, tickUpperFeeGrowthAbove1 *i256.Int\n\n\tif currentTick \u003e= tickUpper {\n\t\ttickUpperFeeGrowthAbove0 = subIn256(feeGrowthGlobal0X128, tickUpperFeeGrowthOutside0X128)\n\t\ttickUpperFeeGrowthAbove1 = subIn256(feeGrowthGlobal1X128, tickUpperFeeGrowthOutside1X128)\n\t} else {\n\t\ttickUpperFeeGrowthAbove0 = tickUpperFeeGrowthOutside0X128\n\t\ttickUpperFeeGrowthAbove1 = tickUpperFeeGrowthOutside1X128\n\t}\n\n\tif currentTick \u003e= tickLower {\n\t\ttickLowerFeeGrowthBelow0 = tickLowerFeeGrowthOutside0X128\n\t\ttickLowerFeeGrowthBelow1 = tickLowerFeeGrowthOutside1X128\n\t} else {\n\t\ttickLowerFeeGrowthBelow0 = subIn256(feeGrowthGlobal0X128, tickLowerFeeGrowthOutside0X128)\n\t\ttickLowerFeeGrowthBelow1 = subIn256(feeGrowthGlobal1X128, tickLowerFeeGrowthOutside1X128)\n\t}\n\n\tfeeGrowthInside0X128 := subIn256(feeGrowthGlobal0X128, tickLowerFeeGrowthBelow0)\n\tfeeGrowthInside0X128 = subIn256(feeGrowthInside0X128, tickUpperFeeGrowthAbove0)\n\n\tfeeGrowthInside1X128 := subIn256(feeGrowthGlobal1X128, tickLowerFeeGrowthBelow1)\n\tfeeGrowthInside1X128 = subIn256(feeGrowthInside1X128, tickUpperFeeGrowthAbove1)\n\n\tvalue01 := subIn256(feeGrowthInside0X128, feeGrowthInside0LastX128)\n\tvalue02 := i256.Zero().Mul(liquidity, value01)\n\tunclaimedFee0 := i256.Zero().Div(value02, i256.MustFromDecimal(consts.Q128))\n\n\tvalue11 := subIn256(feeGrowthInside1X128, feeGrowthInside1LastX128)\n\tvalue12 := i256.Zero().Mul(liquidity, value11)\n\tunclaimedFee1 := i256.Zero().Div(value12, i256.MustFromDecimal(consts.Q128))\n\n\treturn unclaimedFee0, unclaimedFee1\n}\n\nfunc subIn256(x, y *i256.Int) *i256.Int {\n\tvalue := i256.Zero()\n\tdiff := value.Sub(x, y)\n\n\tif diff.IsNeg() {\n\t\tq256 := i256.MustFromDecimal(consts.MAX_UINT256)\n\t\treturn diff.Add(diff, q256)\n\t}\n\n\treturn diff\n}\n\nfunc isBurned(tokenId uint64) bool {\n\treturn positions[tokenId].burned\n}\n"},{"name":"_RPC_dry.gno","body":"package position\n\nimport (\n\t\"gno.land/r/gnoswap/v2/common\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// DryMint simulates a mint and returns the amount0, amount1 that would be minted.\n//\n// It calculates the square root ratios at these ticks\n// and determines the liquidity for the given amounts. Based on the current tick,\n// it calculates and returns the amounts of the two assets that would be minted.\n//\n// Returns:\n//\n//\tTwo strings representing the amounts of the first and second assets\n//\tthat would be minted.\nfunc DryMint(\n\ttickCurrent int32,\n\ttickLower int32,\n\ttickUpper int32,\n\t_amount0Desired string,\n\t_amount1Desired string,\n) (string, string) {\n\t// FROM: position__liquidity_management.gno\n\tsqrtRatioX96 := common.TickMathGetSqrtRatioAtTick(tickCurrent)\n\tsqrtLowerX96 := common.TickMathGetSqrtRatioAtTick(tickLower)\n\tsqrtUpperX96 := common.TickMathGetSqrtRatioAtTick(tickUpper)\n\n\tamount0Desired := u256.MustFromDecimal(_amount0Desired)\n\tamount1Desired := u256.MustFromDecimal(_amount1Desired)\n\n\tliquidity := common.GetLiquidityForAmounts(\n\t\tsqrtRatioX96,\n\t\tsqrtLowerX96,\n\t\tsqrtUpperX96,\n\t\tamount0Desired,\n\t\tamount1Desired,\n\t)\n\ti256Liquidity := i256.FromUint256(liquidity)\n\n\t// Calculate amounts based on the tick range and liquidity\n\tamount0, amount1 := calculateAmounts(tickCurrent, tickLower, tickUpper, sqrtRatioX96, sqrtLowerX96, sqrtUpperX96, i256Liquidity)\n\n\treturn amount0.ToString(), amount1.ToString()\n}\n\nfunc calculateAmounts(\n\ttickCurrent, tickLower, tickUpper int32,\n\tsqrtRatioX96, sqrtLowerX96, sqrtUpperX96 *u256.Uint,\n\ti256Liquidity *i256.Int,\n) (*i256.Int, *i256.Int) {\n\tvar amount0, amount1 *i256.Int\n\tif !i256Liquidity.IsZero() {\n\t\tswitch {\n\t\tcase tickCurrent \u003c tickLower:\n\t\t\tamount0 = getAmount0(sqrtLowerX96, sqrtUpperX96, i256Liquidity)\n\t\tcase tickCurrent \u003c tickUpper:\n\t\t\tamount0 = getAmount0(sqrtRatioX96, sqrtUpperX96, i256Liquidity)\n\t\t\tamount1 = getAmount1(sqrtLowerX96, sqrtRatioX96, i256Liquidity)\n\t\tdefault:\n\t\t\tamount1 = getAmount1(sqrtLowerX96, sqrtUpperX96, i256Liquidity)\n\t\t}\n\t}\n\treturn amount0.NilToZero(), amount1.NilToZero()\n}\n\nfunc getAmount0(sqrtRatioStartX96, sqrtRatioEndX96 *u256.Uint, i256Liquidity *i256.Int) *i256.Int {\n\tamount0Str := common.SqrtPriceMathGetAmount0DeltaStr(sqrtRatioStartX96, sqrtRatioEndX96, i256Liquidity)\n\treturn i256.MustFromDecimal(amount0Str)\n}\n\nfunc getAmount1(sqrtRatioStartX96, sqrtRatioEndX96 *u256.Uint, i256Liquidity *i256.Int) *i256.Int {\n\tamount1Str := common.SqrtPriceMathGetAmount1DeltaStr(sqrtRatioStartX96, sqrtRatioEndX96, i256Liquidity)\n\treturn i256.MustFromDecimal(amount1Str)\n}\n"},{"name":"gno_helper.gno","body":"package position\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nfunc GetOrigPkgAddr() std.Address {\n\treturn consts.POSITION_ADDR\n}\n"},{"name":"helper.gno","body":"package position\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\nfunc getNextId() uint64 {\n\treturn nextId\n}\n\nfunc tid(tokenId interface{}) grc721.TokenID {\n\tif tokenId == nil {\n\t\tpanic(\"[POSITION] test_helper.gno__tid() || tokenId is nil\")\n\t}\n\n\tswitch tokenId.(type) {\n\tcase string:\n\t\treturn grc721.TokenID(tokenId.(string))\n\tcase int:\n\t\treturn grc721.TokenID(strconv.Itoa(tokenId.(int)))\n\tcase uint64:\n\t\treturn grc721.TokenID(strconv.Itoa(int(tokenId.(uint64))))\n\tcase grc721.TokenID:\n\t\treturn tokenId.(grc721.TokenID)\n\tdefault:\n\t\tpanic(\"[POSITION] utils.gno__tid() || unsupported tokenId type\")\n\t}\n}\n"},{"name":"liquidity_management.gno","body":"package position\n\nimport (\n\t\"gno.land/r/gnoswap/v2/common\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nfunc addLiquidity(params AddLiquidityParams) (*u256.Uint, *u256.Uint, *u256.Uint) { // uint128, uint256, uint256\n\tpool := pl.GetPoolFromPoolPath(params.poolKey)\n\n\tsqrtPriceX96 := pool.PoolGetSlot0SqrtPriceX96()\n\tsqrtRatioAX96 := common.TickMathGetSqrtRatioAtTick(params.tickLower)\n\tsqrtRatioBX96 := common.TickMathGetSqrtRatioAtTick(params.tickUpper)\n\n\tliquidity := common.GetLiquidityForAmounts(\n\t\tsqrtPriceX96,\n\t\tsqrtRatioAX96,\n\t\tsqrtRatioBX96,\n\t\tparams.amount0Desired,\n\t\tparams.amount1Desired,\n\t)\n\n\tpToken0, pToken1, pFee := poolKeyDivide(params.poolKey)\n\tamount0, amount1 := pl.Mint( // string(uint256), string(uint256)\n\t\tpToken0,                       // token0Path string\n\t\tpToken1,                       // token1Path string\n\t\tpFee,                          // fee uint16\n\t\tconsts.POSITION_ADDR.String(), // recipient std.Address\n\t\tparams.tickLower,              // tickLower int32\n\t\tparams.tickUpper,              // tickUpper int32\n\t\tliquidity.ToString(),          // _liquidityAmount string(uint128)\n\t)\n\n\tamount0Uint := u256.MustFromDecimal(amount0)\n\tamount1Uint := u256.MustFromDecimal(amount1)\n\n\tamount0Cond := amount0Uint.Gte(params.amount0Min)\n\tamount1Cond := amount1Uint.Gte(params.amount1Min)\n\n\tif !(amount0Cond \u0026\u0026 amount1Cond) {\n\t\tpanic(\"[POSITION] liquidity_management.gno__addLiquidity() || LM_Price Slippage Check\")\n\t}\n\n\treturn liquidity, amount0Uint, amount1Uint\n}\n"},{"name":"nft_helper.gno","body":"package position\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/r/gnoswap/v2/gnft\"\n)\n\nfunc exists(tokenId uint64) bool {\n\t// non exist tokenId will panic\n\t// use defer to catch the panic\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tpanic(ufmt.Sprintf(\"[POSITION] nft_helper.gno__exists() || tokenId(%s) doesn't exist\", tokenId))\n\t\t}\n\t}()\n\n\t// exists method in grc721 is private\n\t// we don't have much choice but to use ownerOf\n\towner := gnft.OwnerOf(tid(tokenId))\n\tif owner == consts.ZERO_ADDRESS {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] nft_helper.gno__exists() || tokenId(%s) doesn't exist__ZeroAddressOwner\", tokenId))\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Error handling isn't necessary here\nfunc isApprovedOrOwner(addr std.Address, tokenId uint64) bool {\n\ttid := tid(tokenId)\n\n\t// check whether token exists\n\tif !exists(tokenId) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] nft_helper.gno__isApprovedOrOwner() || tokenId(%s) doesn't exist\", tokenId))\n\t}\n\n\t// check owner first\n\towner := gnft.OwnerOf(tid)\n\tif addr == owner {\n\t\treturn true\n\t}\n\n\t// if not owner, check whether approved in position contract\n\tposition, exist := positions[tokenId]\n\tif exist {\n\t\tif addr == position.operator {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// if not owner, check whether approved in actual grc721 contract\n\toperator, ok := gnft.GetApproved(tid)\n\tif ok \u0026\u0026 addr == operator {\n\t\treturn true\n\t}\n\n\treturn false\n}\n"},{"name":"position.gno","body":"package position\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/wugnot\"\n\t\"gno.land/r/gnoswap/v2/gnft\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\n\t\"gno.land/r/gnoswap/v2/common\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ten \"gno.land/r/gnoswap/v2/emission\"\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n)\n\nvar (\n\tpositions map[uint64]Position = make(map[uint64]Position) // tokenId -\u003e Position\n\tnextId    uint64              = 1                         // lp token id\n)\n\n// Mint creates a new liquidity position and mints liquidity tokens.\n//\n// This function allows users to provide liquidity to a pool by specifying the token pair,\n// fee tier, price range (via ticks), and desired token amounts. It handles both GRC20 tokens\n// and native GNOT (which is wrapped to WUGNOT internally).\n//\n// Panics:\n//   - If the caller is not authorized (when caller limitation is enabled).\n//   - If there's a mismatch between sent and received WUGNOT amounts.\n//   - If the minting operation fails or returns unexpected results.\n//\n// Note: This function automatically sorts the token pair if they are provided in the wrong order.\n// It also handles the conversion between GNOT and WUGNOT transparently for the user.\nfunc Mint(\n\ttoken0 string,\n\ttoken1 string,\n\tfee uint32,\n\ttickLower int32,\n\ttickUpper int32,\n\t_amount0Desired string, // *u256.Uint\n\t_amount1Desired string, // *u256.Uint\n\t_amount0Min string, // *u256.Uint\n\t_amount1Min string, // *u256.Uint\n\tdeadline int64,\n\tmintTo string,\n) (uint64, string, string, string) { // tokenId, liquidity, amount0, amount1 ( *u256.Uint x3 )\n\ten.MintAndDistributeGns()\n\n\tif common.GetLimitCaller() {\n\t\t// only user or staker can call\n\t\tisUserCalled := std.IsOriginCall()\n\t\tisStakerCalled := std.PrevRealm().Addr() == consts.STAKER_ADDR\n\t\tif !(isUserCalled || isStakerCalled) {\n\t\t\tpanic(\"POSITION] position.gno__Mint() || only user or staker can call\")\n\t\t}\n\t}\n\n\ttoken0, token1, token0IsNative, token1IsNative := processTokens(token0, token1)\n\tuserWugnotBalance := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\n\tif token1 \u003c token0 {\n\t\ttoken0, token1 = token1, token0\n\t\t_amount0Desired, _amount1Desired = _amount1Desired, _amount0Desired\n\t\t_amount0Min, _amount1Min = _amount1Min, _amount0Min\n\t\ttickLower, tickUpper = -tickUpper, -tickLower\n\t\ttoken0IsNative, token1IsNative = token1IsNative, token0IsNative\n\t}\n\n\tamount0Desired := u256.MustFromDecimal(_amount0Desired)\n\tamount1Desired := u256.MustFromDecimal(_amount1Desired)\n\tamount0Min := u256.MustFromDecimal(_amount0Min)\n\tamount1Min := u256.MustFromDecimal(_amount1Min)\n\n\t// one of token amount can be 0 if position is out of range\n\t// check this condition by using DryMint()\n\tpoolPath := ufmt.Sprintf(\"%s:%s:%d\", token0, token1, fee)\n\n\thandleNativeToken(token0IsNative, token1IsNative)\n\n\tmintParams := MintParams{\n\t\ttoken0:         token0,\n\t\ttoken1:         token1,\n\t\tfee:            fee,\n\t\ttickLower:      tickLower,\n\t\ttickUpper:      tickUpper,\n\t\tamount0Desired: amount0Desired,\n\t\tamount1Desired: amount1Desired,\n\t\tamount0Min:     amount0Min,\n\t\tamount1Min:     amount1Min,\n\t\tdeadline:       deadline,\n\t\tmintTo:         std.Address(mintTo),\n\t}\n\n\ttokenId, liquidity, amount0, amount1 := mint(mintParams)\n\n\thandleLeftoverNativeToken(token0IsNative, token1IsNative, userWugnotBalance)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tickLower\", int32ToStr(tickLower),\n\t\t\"p_tickUpper\", int32ToStr(tickUpper),\n\t\t\"poolPath\", poolPath,\n\t\t\"tokenId\", uint64ToStr(tokenId),\n\t\t\"liquidity\", liquidity.ToString(),\n\t\t\"amount0\", amount0.ToString(),\n\t\t\"amount1\", amount1.ToString(),\n\t)\n\n\treturn tokenId, liquidity.ToString(), amount0.ToString(), amount1.ToString()\n}\n\nfunc processTokens(token0, token1 string) (string, string, bool, bool) {\n\ttoken0IsNative := false\n\ttoken1IsNative := false\n\tif token0 == consts.GNOT {\n\t\ttoken0 = consts.WRAPPED_WUGNOT\n\t\ttoken0IsNative = true\n\t} else if token1 == consts.GNOT {\n\t\ttoken1 = consts.WRAPPED_WUGNOT\n\t\ttoken1IsNative = true\n\t}\n\treturn token0, token1, token0IsNative, token1IsNative\n}\n\nfunc handleNativeToken(token0IsNative, token1IsNative bool) {\n\tif token0IsNative || token1IsNative {\n\t\toldUserWugnotBalance := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\t\tsent := std.GetOrigSend()\n\t\tugnotSent := uint64(sent.AmountOf(\"ugnot\"))\n\t\tif ugnotSent \u003e 0 {\n\t\t\twrap(ugnotSent)\n\t\t\tnewUserWugnotBalance := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\t\t\tif (newUserWugnotBalance - oldUserWugnotBalance) != ugnotSent {\n\t\t\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__Mint() || wugnot sent(%d) != wugnot received(%d)\", ugnotSent, newUserWugnotBalance-oldUserWugnotBalance))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc handleLeftoverNativeToken(token0IsNative, token1IsNative bool, userWugnotBalance uint64) {\n\tif token0IsNative || token1IsNative {\n\t\tuserWugnotAfterMint := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\t\tleftOver := userWugnotAfterMint - userWugnotBalance\n\t\tif leftOver \u003e 0 {\n\t\t\tunwrap(leftOver)\n\t\t}\n\t}\n}\n\nfunc mint(params MintParams) (uint64, *u256.Uint, *u256.Uint, *u256.Uint) {\n\tcheckDeadline(params.deadline)\n\n\tpool := pl.GetPool(params.token0, params.token1, params.fee)\n\tliquidity, amount0, amount1 := addLiquidity(\n\t\tAddLiquidityParams{\n\t\t\tpoolKey:        pl.GetPoolPath(params.token0, params.token1, params.fee),\n\t\t\ttickLower:      params.tickLower,\n\t\t\ttickUpper:      params.tickUpper,\n\t\t\tamount0Desired: params.amount0Desired,\n\t\t\tamount1Desired: params.amount1Desired,\n\t\t\tamount0Min:     params.amount0Min,\n\t\t\tamount1Min:     params.amount1Min,\n\t\t},\n\t)\n\n\ttokenId := nextId\n\tgnft.Mint(a2u(params.mintTo), tid(tokenId)) // owner, tokenId\n\tnextId++\n\n\tpositionKey := positionKeyCompute(GetOrigPkgAddr(), params.tickLower, params.tickUpper)\n\t_feeGrowthInside0LastX128, _feeGrowthInside1LastX128 := pool.PoolGetPositionFeeGrowthInside0LastX128(positionKey), pool.PoolGetPositionFeeGrowthInside1LastX128(positionKey)\n\tfeeGrowthInside0LastX128 := u256.MustFromDecimal(_feeGrowthInside0LastX128.ToString())\n\tfeeGrowthInside1LastX128 := u256.MustFromDecimal(_feeGrowthInside1LastX128.ToString())\n\n\tposition := Position{\n\t\tnonce:                    u256.Zero(),\n\t\toperator:                 std.GetOrigCaller(),\n\t\tpoolKey:                  pl.GetPoolPath(params.token0, params.token1, params.fee),\n\t\ttickLower:                params.tickLower,\n\t\ttickUpper:                params.tickUpper,\n\t\tliquidity:                liquidity,\n\t\tfeeGrowthInside0LastX128: feeGrowthInside0LastX128,\n\t\tfeeGrowthInside1LastX128: feeGrowthInside1LastX128,\n\t\ttokensOwed0:              u256.Zero(),\n\t\ttokensOwed1:              u256.Zero(),\n\t\tburned:                   false,\n\t}\n\tpositions[tokenId] = position\n\n\treturn tokenId, liquidity, amount0, amount1\n}\n\n// IncreaseLiquidity increases liquidity of the existing position\n//\n// Panics if any of the following conditions are met:\n// - position doesn't exist\n// - caller is not owner of the position\n// - deadline is passed\nfunc IncreaseLiquidity(\n\ttokenId uint64,\n\t_amount0Desired string, // uint256\n\t_amount1Desired string, // uint256\n\t_amount0Min string, // uint256\n\t_amount1Min string, // uint256\n\tdeadline int64,\n) (uint64, string, string, string, string) { // tokenId, liquidity, amount0, amount1, poolPath\n\ten.MintAndDistributeGns()\n\n\tamount0Desired := u256.MustFromDecimal(_amount0Desired)\n\tamount1Desired := u256.MustFromDecimal(_amount1Desired)\n\tamount0Min := u256.MustFromDecimal(_amount0Min)\n\tamount1Min := u256.MustFromDecimal(_amount1Min)\n\tincreaseLiquidityParams := IncreaseLiquidityParams{\n\t\ttokenId:        tokenId,\n\t\tamount0Desired: amount0Desired,\n\t\tamount1Desired: amount1Desired,\n\t\tamount0Min:     amount0Min,\n\t\tamount1Min:     amount1Min,\n\t\tdeadline:       deadline,\n\t}\n\n\t// wrap if target pool has wugnot\n\tposition := positions[tokenId]\n\tpToken0, pToken1, _ := poolKeyDivide(position.poolKey)\n\n\tisToken0Wugnot := pToken0 == consts.WRAPPED_WUGNOT\n\tisToken1Wugnot := pToken1 == consts.WRAPPED_WUGNOT\n\n\tuserOldWugnotBalance := wugnot.BalanceOf(a2u(std.GetOrigCaller())) // before wrap, user's origin wugnot balance\n\tif isToken0Wugnot || isToken1Wugnot {\n\t\tsent := std.GetOrigSend()\n\t\tugnotSent := uint64(sent.AmountOf(\"ugnot\"))\n\t\twrap(ugnotSent)\n\t}\n\n\t// INCREASE\n\t_, liquidity, amount0, amount1, poolPath := increaseLiquidity(increaseLiquidityParams)\n\n\t// unwrap left\n\tif isToken0Wugnot || isToken1Wugnot {\n\t\tuserNewWugnotBalance := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\n\t\tleftOver := userNewWugnotBalance - userOldWugnotBalance\n\t\tunwrap(leftOver)\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\"poolPath\", poolPath,\n\t\t\"liquidity\", liquidity.ToString(),\n\t\t\"amount0\", amount0.ToString(),\n\t\t\"amount1\", amount1.ToString(),\n\t)\n\n\treturn tokenId, liquidity.ToString(), amount0.ToString(), amount1.ToString(), poolPath\n}\n\nfunc increaseLiquidity(params IncreaseLiquidityParams) (uint64, *u256.Uint, *u256.Uint, *u256.Uint, string) {\n\t// verify tokenId exists\n\tif !exists(params.tokenId) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__increaseLiquidity() || tokenId(%d) doesn't exist\", params.tokenId))\n\t}\n\n\t// MUST BE OWNER TO INCREASE LIQUIDITY\n\t// can not be approved address \u003e staked position can't be modified\n\towner := gnft.OwnerOf(tid(params.tokenId))\n\tif owner != std.GetOrigCaller() {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__increaseLiquidity() || only owner can increase liquidity__owner(%s) == std.GetOrigCaller(%s)\", owner, std.GetOrigCaller()))\n\t}\n\n\tcheckDeadline(params.deadline)\n\n\tposition := positions[params.tokenId]\n\tliquidity, amount0, amount1 := addLiquidity(\n\t\tAddLiquidityParams{\n\t\t\tpoolKey:        position.poolKey,\n\t\t\ttickLower:      position.tickLower,\n\t\t\ttickUpper:      position.tickUpper,\n\t\t\tamount0Desired: params.amount0Desired,\n\t\t\tamount1Desired: params.amount1Desired,\n\t\t\tamount0Min:     params.amount0Min,\n\t\t\tamount1Min:     params.amount1Min,\n\t\t},\n\t)\n\n\tpool := pl.GetPoolFromPoolPath(position.poolKey)\n\tpositionKey := positionKeyCompute(GetOrigPkgAddr(), position.tickLower, position.tickUpper)\n\t_feeGrowthInside0LastX128, _feeGrowthInside1LastX128 := pool.PoolGetPositionFeeGrowthInside0LastX128(positionKey), pool.PoolGetPositionFeeGrowthInside1LastX128(positionKey)\n\tfeeGrowthInside0LastX128 := u256.MustFromDecimal(_feeGrowthInside0LastX128.ToString())\n\tfeeGrowthInside1LastX128 := u256.MustFromDecimal(_feeGrowthInside1LastX128.ToString())\n\n\t{\n\t\tdiff := new(u256.Uint).Sub(feeGrowthInside0LastX128, position.feeGrowthInside0LastX128)\n\t\tmulDiv := u256.MulDiv(diff, position.liquidity, u256.MustFromDecimal(consts.Q128))\n\n\t\tposition.tokensOwed0 = new(u256.Uint).Add(position.tokensOwed0, mulDiv)\n\t}\n\n\t{\n\t\tdiff := new(u256.Uint).Sub(feeGrowthInside1LastX128, position.feeGrowthInside1LastX128)\n\t\tmulDiv := u256.MulDiv(diff, position.liquidity, u256.MustFromDecimal(consts.Q128))\n\n\t\tposition.tokensOwed1 = new(u256.Uint).Add(position.tokensOwed1, mulDiv)\n\t}\n\n\tposition.feeGrowthInside0LastX128 = feeGrowthInside0LastX128\n\tposition.feeGrowthInside1LastX128 = feeGrowthInside1LastX128\n\tposition.liquidity = new(u256.Uint).Add(position.liquidity, liquidity)\n\tposition.burned = false\n\n\tpositions[params.tokenId] = position\n\n\treturn params.tokenId, liquidity, amount0, amount1, position.poolKey\n}\n\n// DecreaseLiquidity decreases liquidity of the existing position\n//\n// Panics if any of the following conditions are met:\n// - position doesn't exist\n// - position has 0 liquidity\n// - caller is not owner of the position\n// - liquidityRatio is not in range 1 ~ 100\n// - deadline is passed\nfunc DecreaseLiquidity(\n\ttokenId uint64,\n\tliquidityRatio uint64,\n\t_amount0Min string, // uint256\n\t_amount1Min string, // uint256\n\tdeadline int64,\n\tunwrapResult bool,\n) (uint64, string, string, string, string, string, string) { // tokenId, liquidity, fee0, fee1, amount0, amount1, poolPath\n\ten.MintAndDistributeGns()\n\n\tisNormalRange := liquidityRatio \u003e= 1 \u0026\u0026 liquidityRatio \u003c= 100\n\tif !isNormalRange {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__decreaseLiquidity() || liquidityRatio(%d) should be in range 1 ~ 100\", liquidityRatio))\n\t}\n\n\tamount0Min := u256.MustFromDecimal(_amount0Min)\n\tamount1Min := u256.MustFromDecimal(_amount1Min)\n\tdecreaseLiquidityParams := DecreaseLiquidityParams{\n\t\ttokenId:        tokenId,\n\t\tliquidityRatio: liquidityRatio,\n\t\tamount0Min:     amount0Min,\n\t\tamount1Min:     amount1Min,\n\t\tdeadline:       deadline,\n\t\tunwrapResult:   unwrapResult,\n\t}\n\n\ttokenId, liquidity, fee0, fee1, amount0, amount1, poolPath := decreaseLiquidity(decreaseLiquidityParams)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\"p_liquidityRatio\", uint64ToStr(liquidityRatio),\n\t\t\"poolPath\", poolPath,\n\t\t\"liquidity\", liquidity.ToString(),\n\t\t\"fee0\", fee0.ToString(),\n\t\t\"fee1\", fee1.ToString(),\n\t\t\"amount0\", amount0.ToString(),\n\t\t\"amount1\", amount1.ToString(),\n\t)\n\n\treturn tokenId, liquidity.ToString(), fee0.ToString(), fee1.ToString(), amount0.ToString(), amount1.ToString(), poolPath\n}\n\n// decreaseLiquidity reduces the liquidity of a given position and collects the corresponding tokens.\n//\n// Panics:\n//   - If the token ID doesn't exist.\n//   - If the position has already been burned.\n//   - If the caller is not the owner of the position.\n//   - If the deadline has passed.\n//   - If the received amounts are less than the specified minimums.\n//\n// Note: This function handles both GRC20 tokens and native GNOT (wrapped as WUGNOT).\n// If unwrapResult is true and the position involves WUGNOT, any leftover WUGNOT will be\n// unwrapped to GNOT at the end of the operation.\nfunc decreaseLiquidity(params DecreaseLiquidityParams) (uint64, *u256.Uint, *u256.Uint, *u256.Uint, *u256.Uint, *u256.Uint, string) {\n\tuserOldWugnotBalance := wugnot.BalanceOf(a2u(std.GetOrigCaller())) // before unwrap\n\n\tverifyTokenIdAndOwnership(params.tokenId)\n\tcheckDeadline(params.deadline)\n\n\t// BEFORE DECREASE LIQUIDITY, COLLECT FEE FIRST\n\t_, fee0Str, fee1Str, _ := CollectFee(params.tokenId)\n\tfee0 := u256.MustFromDecimal(fee0Str)\n\tfee1 := u256.MustFromDecimal(fee1Str)\n\n\tposition := positions[params.tokenId]\n\tpositionLiquidity := position.liquidity\n\n\tif positionLiquidity.IsZero() {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__decreaseLiquidity() || position(tokenId:%d) has 0 liquidity\", params.tokenId))\n\t}\n\n\tliquidityToRemove := calculateLiquidityToRemove(positionLiquidity, params.liquidityRatio)\n\n\tpToken0, pToken1, pFee := poolKeyDivide(position.poolKey)\n\tpool := pl.GetPoolFromPoolPath(position.poolKey)\n\n\t// BURN HERE\n\t_burnedAmount0, _burnedAmount1 := pl.Burn(pToken0, pToken1, pFee, position.tickLower, position.tickUpper, liquidityToRemove.ToString())\n\n\tburnedAmount0 := u256.MustFromDecimal(_burnedAmount0)\n\tburnedAmount1 := u256.MustFromDecimal(_burnedAmount1)\n\n\tverifyBurnedAmounts(burnedAmount0, burnedAmount1, params.amount0Min, params.amount1Min)\n\n\tpositionKey := positionKeyCompute(GetOrigPkgAddr(), position.tickLower, position.tickUpper)\n\t_feeGrowthInside0LastX128, _feeGrowthInside1LastX128 := pool.PoolGetPositionFeeGrowthInside0LastX128(positionKey), pool.PoolGetPositionFeeGrowthInside1LastX128(positionKey)\n\tfeeGrowthInside0LastX128 := u256.MustFromDecimal(_feeGrowthInside0LastX128.ToString())\n\tfeeGrowthInside1LastX128 := u256.MustFromDecimal(_feeGrowthInside1LastX128.ToString())\n\n\tposition.tokensOwed0 = updateTokensOwed(\n\t\tfeeGrowthInside0LastX128,\n\t\tposition.feeGrowthInside0LastX128,\n\t\tposition.liquidity,\n\t\tburnedAmount0,\n\t\tposition.tokensOwed0,\n\t)\n\n\tposition.tokensOwed1 = updateTokensOwed(\n\t\tfeeGrowthInside1LastX128,\n\t\tposition.feeGrowthInside1LastX128,\n\t\tposition.liquidity,\n\t\tburnedAmount1,\n\t\tposition.tokensOwed1,\n\t)\n\n\tposition.feeGrowthInside0LastX128 = feeGrowthInside0LastX128\n\tposition.feeGrowthInside1LastX128 = feeGrowthInside1LastX128\n\tposition.liquidity = new(u256.Uint).Sub(positionLiquidity, liquidityToRemove)\n\tpositions[params.tokenId] = position\n\n\t// GIVE BACK TO USER\n\t_amount0, _amount1 := pl.Collect(\n\t\tpToken0,\n\t\tpToken1,\n\t\tpFee,\n\t\tstd.GetOrigCaller().String(),\n\t\tposition.tickLower,\n\t\tposition.tickUpper,\n\t\t_burnedAmount0,\n\t\t_burnedAmount1,\n\t)\n\n\tamount0 := u256.MustFromDecimal(_amount0)\n\tamount1 := u256.MustFromDecimal(_amount1)\n\n\tposition.tokensOwed0 = new(u256.Uint).Sub(position.tokensOwed0, amount0)\n\tposition.tokensOwed1 = new(u256.Uint).Sub(position.tokensOwed1, amount1)\n\tpositions[params.tokenId] = position\n\n\tif position.isClear() {\n\t\t// burnNFT(params.tokenId) // actual burn\n\t\tburnPosition(params.tokenId) // just update flag\n\t}\n\n\t// NO UNWRAP\n\tif !params.unwrapResult {\n\t\treturn params.tokenId, liquidityToRemove, fee0, fee1, amount0, amount1, position.poolKey\n\t}\n\n\thandleUnwrap(pToken0, pToken1, params.unwrapResult, userOldWugnotBalance)\n\n\treturn params.tokenId, liquidityToRemove, fee0, fee1, amount0, amount1, position.poolKey\n}\n\nfunc verifyTokenIdAndOwnership(tokenId uint64) {\n\tif !exists(tokenId) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__decreaseLiquidity() || tokenId(%d) doesn't exist\", tokenId))\n\t}\n\towner := gnft.OwnerOf(tid(tokenId))\n\tif owner != std.GetOrigCaller() {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__decreaseLiquidity() || only owner can decrease liquidity__owner(%s) == std.GetOrigCaller(%s)\", owner, std.GetOrigCaller()))\n\t}\n}\n\nfunc calculateLiquidityToRemove(positionLiquidity *u256.Uint, liquidityRatio uint64) *u256.Uint {\n\tliquidityToRemove := new(u256.Uint).Mul(positionLiquidity, u256.NewUint(liquidityRatio))\n\tliquidityToRemove = new(u256.Uint).Div(liquidityToRemove, u256.NewUint(100))\n\tif positionLiquidity.Lt(liquidityToRemove) || liquidityRatio == 100 {\n\t\treturn positionLiquidity\n\t}\n\treturn liquidityToRemove\n}\n\nfunc verifyBurnedAmounts(burnedAmount0, burnedAmount1, amount0Min, amount1Min *u256.Uint) {\n\tif !(burnedAmount0.Gte(amount0Min) \u0026\u0026 burnedAmount1.Gte(amount1Min)) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__decreaseLiquidity() || burnedAmount0(%s) \u003e= amount0Min(%s) \u0026\u0026 burnedAmount1(%s) \u003e= amount1Min(%s)\", burnedAmount0.ToString(), amount0Min.ToString(), burnedAmount1.ToString(), amount1Min.ToString()))\n\t}\n}\n\nfunc handleUnwrap(pToken0, pToken1 string, unwrapResult bool, userOldWugnotBalance uint64) {\n\tif (pToken0 == consts.WRAPPED_WUGNOT || pToken1 == consts.WRAPPED_WUGNOT) \u0026\u0026 unwrapResult {\n\t\tuserNewWugnotBalance := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\t\tleftOver := userNewWugnotBalance - userOldWugnotBalance\n\t\tunwrap(leftOver)\n\t}\n}\n\n// Repositiomn adjusts the position of an existing liquidity token\n// by changing its price range and liquidity amount.\nfunc Reposition(\n\ttokenId uint64,\n\ttickLower int32,\n\ttickUpper int32,\n\t_amount0Desired string, // uint256\n\t_amount1Desired string, // uint256\n\t_amount0Min string, // *u256.Uint\n\t_amount1Min string, // *u256.Uint\n) (uint64, string, int32, int32, string, string) { // tokenId, liquidity, tickLower, tickUpper, amount0, amount1\n\ten.MintAndDistributeGns()\n\n\t// verify tokenId exists\n\tif !exists(tokenId) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__Reposition() || tokenId(%d) doesn't exist\", tokenId))\n\t}\n\n\t// MUST BE OWNER TO REPOSITION\n\t// can not be approved address \u003e staked position can't be modified\n\towner := gnft.OwnerOf(tid(tokenId))\n\tif owner != std.GetOrigCaller() {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__Reposition() || only owner can reposition__owner(%s) == std.GetOrigCaller(%s)\", owner, std.GetOrigCaller()))\n\t}\n\n\t// position should be burned to reposition\n\tposition := positions[tokenId]\n\toldTickLower := position.tickLower\n\toldTickUpper := position.tickUpper\n\n\tif !(position.isClear()) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__Reposition() || position(tokenId:%d) isn't clear(liquidity:%d, tokensOwed0:%d, tokensOwed1:%d)\", tokenId, position.liquidity, position.tokensOwed0, position.tokensOwed1))\n\t}\n\n\ttoken0, token1, _ := poolKeyDivide(position.poolKey)\n\t// check if gnot pool\n\ttoken0IsNative := false\n\ttoken1IsNative := false\n\tif token0 == consts.WRAPPED_WUGNOT {\n\t\ttoken0IsNative = true\n\t} else if token1 == consts.WRAPPED_WUGNOT {\n\t\ttoken1IsNative = true\n\t}\n\n\tugnotSent := uint64(0)\n\tif token0IsNative || token1IsNative {\n\t\t// WRAP IT\n\t\tsent := std.GetOrigSend()\n\t\tugnotSent = uint64(sent.AmountOf(\"ugnot\"))\n\n\t\twrap(ugnotSent)\n\t}\n\n\tliquidity, amount0, amount1 := addLiquidity(\n\t\tAddLiquidityParams{\n\t\t\tpoolKey:        position.poolKey,\n\t\t\ttickLower:      tickLower,\n\t\t\ttickUpper:      tickUpper,\n\t\t\tamount0Desired: u256.MustFromDecimal(_amount0Desired),\n\t\t\tamount1Desired: u256.MustFromDecimal(_amount1Desired),\n\t\t\tamount0Min:     u256.MustFromDecimal(_amount0Min),\n\t\t\tamount1Min:     u256.MustFromDecimal(_amount1Min),\n\t\t},\n\t)\n\n\tpool := pl.GetPoolFromPoolPath(position.poolKey)\n\tpositionKey := positionKeyCompute(GetOrigPkgAddr(), tickLower, tickUpper)\n\t_feeGrowthInside0LastX128, _feeGrowthInside1LastX128 := pool.PoolGetPositionFeeGrowthInside0LastX128(positionKey), pool.PoolGetPositionFeeGrowthInside1LastX128(positionKey)\n\tfeeGrowthInside0LastX128 := u256.MustFromDecimal(_feeGrowthInside0LastX128.ToString())\n\tfeeGrowthInside1LastX128 := u256.MustFromDecimal(_feeGrowthInside1LastX128.ToString())\n\n\tposition.tickLower = tickLower\n\tposition.tickUpper = tickUpper\n\tposition.liquidity = liquidity\n\tposition.feeGrowthInside0LastX128 = feeGrowthInside0LastX128\n\tposition.feeGrowthInside1LastX128 = feeGrowthInside1LastX128\n\tposition.tokensOwed0 = u256.Zero()\n\tposition.tokensOwed1 = u256.Zero()\n\tposition.burned = false\n\n\tpositions[tokenId] = position\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\"p_tickLower\", int32ToStr(tickLower),\n\t\t\"p_tickUpper\", int32ToStr(tickUpper),\n\t\t\"liquidity\", liquidity.ToString(),\n\t\t\"amount0\", amount0.ToString(),\n\t\t\"amount1\", amount1.ToString(),\n\t\t\"old_tickLower\", int32ToStr(oldTickLower),\n\t\t\"old_tickUpper\", int32ToStr(oldTickUpper),\n\t\t\"poolPath\", position.poolKey,\n\t)\n\n\treturn tokenId, liquidity.ToString(), tickLower, tickUpper, amount0.ToString(), amount1.ToString()\n}\n\n// CollectFee collects swap fee from the position\n//\n// Panics:\n//   - position doesn't exist\n//   - caller is not owner or approved\nfunc CollectFee(tokenId uint64) (uint64, string, string, string) { // tokenId, tokensOwed0, tokensOwed1, poolPath\n\ten.MintAndDistributeGns()\n\n\t// verify tokenId\n\tif !exists(tokenId) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__CollectFee() || tokenId(%d) doesn't exist\", tokenId))\n\t}\n\n\t// verify owner or approved\n\tisAuthorizedForToken(tokenId)\n\n\t// verify position\n\tposition, exist := positions[tokenId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__CollectFee() || position(tokenId:%d) doesn't exist\", tokenId))\n\t}\n\n\ttoken0, token1, fee := poolKeyDivide(position.poolKey)\n\n\tpl.Burn(\n\t\ttoken0,\n\t\ttoken1,\n\t\tfee,\n\t\tposition.tickLower,\n\t\tposition.tickUpper,\n\t\t\"0\", // burn '0' liquidity to collect fee\n\t)\n\n\tpositionKey := positionKeyCompute(GetOrigPkgAddr(), position.tickLower, position.tickUpper)\n\tpool := pl.GetPoolFromPoolPath(position.poolKey)\n\t_feeGrowthInside0LastX128, _feeGrowthInside1LastX128 := pool.PoolGetPositionFeeGrowthInside0LastX128(positionKey), pool.PoolGetPositionFeeGrowthInside1LastX128(positionKey)\n\tfeeGrowthInside0LastX128 := u256.MustFromDecimal(_feeGrowthInside0LastX128.ToString())\n\tfeeGrowthInside1LastX128 := u256.MustFromDecimal(_feeGrowthInside1LastX128.ToString())\n\n\tposition.feeGrowthInside0LastX128 = feeGrowthInside0LastX128\n\tposition.feeGrowthInside1LastX128 = feeGrowthInside1LastX128\n\n\t// check user wugnot amount\n\t// need this value to unwrap fee\n\tuserWugnot := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\n\tamount0, amount1 := pl.Collect(\n\t\ttoken0,\n\t\ttoken1,\n\t\tfee,\n\t\tstd.GetOrigCaller().String(),\n\t\tposition.tickLower,\n\t\tposition.tickUpper,\n\t\tconsts.MAX_UINT64,\n\t\tconsts.MAX_UINT64,\n\t)\n\n\tpositions[tokenId] = position\n\n\t// handle withdrawal fee\n\twithoutFee0, withoutFee1 := pl.HandleWithdrawalFee(tokenId, token0, amount0, token1, amount1, position.poolKey)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\"fee0\", withoutFee0,\n\t\t\"fee1\", withoutFee1,\n\t\t\"poolPath\", position.poolKey,\n\t)\n\n\t// UNWRAP\n\tpToken0, pToken1, _ := poolKeyDivide(position.poolKey)\n\tif pToken0 == consts.WUGNOT_PATH || pToken1 == consts.WUGNOT_PATH {\n\t\tuserNewWugnot := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\t\tunwrapAmount := userNewWugnot - userWugnot\n\n\t\tif unwrapAmount \u003e 0 {\n\t\t\tunwrap(unwrapAmount)\n\t\t}\n\t}\n\n\treturn tokenId, withoutFee0, withoutFee1, position.poolKey\n}\n\nfunc calculateTokensOwed(\n\tfeeGrowthInsideLastX128 *u256.Uint,\n\tpositionFeeGrowthInsideLastX128 *u256.Uint,\n\tpositionLiquidity *u256.Uint,\n) *u256.Uint {\n\tdiff := new(u256.Uint).Sub(feeGrowthInsideLastX128, positionFeeGrowthInsideLastX128)\n\treturn u256.MulDiv(diff, positionLiquidity, u256.MustFromDecimal(consts.Q128))\n}\n\nfunc updateTokensOwed(\n\tfeeGrowthInsideLastX128 *u256.Uint,\n\tpositionFeeGrowthInsideLastX128 *u256.Uint,\n\tpositionLiquidity *u256.Uint,\n\tburnedAmount *u256.Uint,\n\ttokensOwed *u256.Uint,\n) *u256.Uint {\n\tadditionalTokensOwed := calculateTokensOwed(feeGrowthInsideLastX128, positionFeeGrowthInsideLastX128, positionLiquidity)\n\tadd := new(u256.Uint).Add(burnedAmount, additionalTokensOwed)\n\treturn new(u256.Uint).Add(tokensOwed, add)\n}\n\nfunc burnNFT(tokenId uint64) {\n\tisAuthorizedForToken(tokenId)\n\n\tposition := positions[tokenId]\n\n\tif !(position.isClear()) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__burnNFT() || position(tokenId:%d) isn't clear(liquidity:%d, tokensOwed0:%d, tokensOwed1:%d)\", tokenId, position.liquidity, position.tokensOwed0, position.tokensOwed1))\n\t}\n\tdelete(positions, tokenId)\n\tgnft.Burn(tid(tokenId))\n}\n\nfunc burnPosition(tokenId uint64) {\n\tposition := positions[tokenId]\n\tif !(position.isClear()) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__burnPosition() || position(tokenId:%d) isn't clear(liquidity:%d, tokensOwed0:%d, tokensOwed1:%d)\", tokenId, position.liquidity, position.tokensOwed0, position.tokensOwed1))\n\t}\n\n\tposition.burned = true\n\tpositions[tokenId] = position\n}\n\nfunc isAuthorizedForToken(tokenId uint64) {\n\tif !(isApprovedOrOwner(std.PrevRealm().Addr(), tokenId)) {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] position.gno__isAuthorizedForToken() || caller(%s) is not approved or owner of tokenId(%d)\", std.PrevRealm().Addr(), tokenId))\n\t}\n}\n"},{"name":"position_key.gno","body":"package position\n\nimport (\n\t\"encoding/base64\"\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc positionKeyCompute(\n\towner std.Address,\n\ttickLower int32,\n\ttickUpper int32,\n) string {\n\tkey := ufmt.Sprintf(\"%s__%d__%d\", owner.String(), tickLower, tickUpper)\n\n\tencoded := base64.StdEncoding.EncodeToString([]byte(key))\n\treturn encoded\n}\n"},{"name":"type.gno","body":"package position\n\nimport (\n\t\"std\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\ntype Position struct {\n\tnonce *u256.Uint // nonce for permits\n\n\toperator std.Address // address that is approved for spending this token\n\n\tpoolKey string // poolPath of the pool which this has lp token\n\n\t// the tick range of the position, bounds are included\n\ttickLower int32\n\ttickUpper int32\n\n\tliquidity *u256.Uint // liquidity of the position\n\n\t// fee growth of the aggregate position as of the last action on the individual position\n\tfeeGrowthInside0LastX128 *u256.Uint\n\tfeeGrowthInside1LastX128 *u256.Uint\n\n\t// how many uncollected tokens are owed to the position, as of the last computation\n\ttokensOwed0 *u256.Uint\n\ttokensOwed1 *u256.Uint\n\n\tburned bool // whether the position has been burned(≈ actuall we don't burn lp token even its empty, just update flag)\n}\n\n// isClear reports whether the position is empty\nfunc (p Position) isClear() bool {\n\treturn p.liquidity.IsZero() \u0026\u0026 p.tokensOwed0.IsZero() \u0026\u0026 p.tokensOwed1.IsZero()\n}\n\ntype MintParams struct {\n\ttoken0         string      // token0 path for a specific pool\n\ttoken1         string      // token1 path for a specific pool\n\tfee            uint32      // fee for a specific pool\n\ttickLower      int32       // lower end of the tick range for the position\n\ttickUpper      int32       // upper end of the tick range for the position\n\tamount0Desired *u256.Uint  // desired amount of token0 to be minted\n\tamount1Desired *u256.Uint  // desired amount of token1 to be minted\n\tamount0Min     *u256.Uint  // minimum amount of token0 to be minted\n\tamount1Min     *u256.Uint  // minimum amount of token1 to be minted\n\tdeadline       int64       // time by which the transaction must be included to effect the change\n\tmintTo         std.Address // address to mint lpToken\n}\n\ntype AddLiquidityParams struct {\n\tpoolKey        string     // poolPath of the pool which has the position\n\ttickLower      int32      // lower end of the tick range for the position\n\ttickUpper      int32      // upper end of the tick range for the position\n\tamount0Desired *u256.Uint // desired amount of token0 to be minted\n\tamount1Desired *u256.Uint // desired amount of token1 to be minted\n\tamount0Min     *u256.Uint // minimum amount of token0 to be minted\n\tamount1Min     *u256.Uint // minimum amount of token1 to be minted\n}\n\ntype IncreaseLiquidityParams struct {\n\ttokenId        uint64     // tokenId of the position to increase liquidity\n\tamount0Desired *u256.Uint // desired amount of token0 to be minted\n\tamount1Desired *u256.Uint // desired amount of token1 to be minted\n\tamount0Min     *u256.Uint // minimum amount of token0 to be minted\n\tamount1Min     *u256.Uint // minimum amount of token1 to be minted\n\tdeadline       int64      // time by which the transaction must be included to effect the change\n}\n\ntype DecreaseLiquidityParams struct {\n\ttokenId        uint64     // tokenId of the position to decrease liquidity\n\tliquidityRatio uint64     // percent of liquidity to decrease, i.e '25' ≈ remove 25% of liquidity\n\tamount0Min     *u256.Uint // minimum amount of token0 to be minted\n\tamount1Min     *u256.Uint // minimum amount of token1 to be minted\n\tdeadline       int64      // time by which the transaction must be included to effect the change\n\tunwrapResult   bool       // whether to unwrap the token if it's wrapped native token\n}\n"},{"name":"utils.gno","body":"package position\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nfunc checkDeadline(deadline int64) {\n\tif time.Now().Unix() \u003e deadline {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] utils.gno__checkDeadline() || transaction too old__time.Now().Unix()(%d) \u003c= deadline(%d)\", time.Now().Unix(), deadline))\n\t}\n}\n\nfunc a2u(addr std.Address) pusers.AddressOrName {\n\treturn pusers.AddressOrName(addr)\n}\n\nfunc poolKeyDivide(poolKey string) (string, string, uint32) {\n\tres := strings.Split(poolKey, \":\")\n\tif len(res) != 3 {\n\t\tpanic(ufmt.Sprintf(\"[POSITION] utils.gno__poolKeyDivide() || invalid poolKey(%s)\", poolKey))\n\t}\n\n\tpToken0, pToken1, pFeeStr := res[0], res[1], res[2]\n\n\tpFee, _ := strconv.Atoi(pFeeStr)\n\treturn pToken0, pToken1, uint32(pFee)\n}\n\nfunc int32ToStr(i int32) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc uint64ToStr(i uint64) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc origCaller() string {\n\treturn std.GetOrigCaller().String()\n}\n\nfunc prevRealm() string {\n\treturn std.PrevRealm().PkgPath()\n}\n\nfunc callType() string {\n\tif prevRealm() == \"\" {\n\t\treturn \"DIRECT\"\n\t}\n\n\treturn \"INDIRECT\"\n}\n"},{"name":"wrap_unwrap.gno","body":"package position\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/wugnot\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nfunc wrap(ugnotAmount uint64) {\n\tif ugnotAmount == 0 {\n\t\treturn\n\t}\n\n\tif ugnotAmount \u003c consts.UGNOT_MIN_DEPOSIT_TO_WRAP {\n\t\tpanic(ufmt.Sprintf(\"Deposit below minimum: %d/%d ugnot.\", ugnotAmount, consts.UGNOT_MIN_DEPOSIT_TO_WRAP))\n\t}\n\n\t// WRAP IT\n\twugnotAddr := std.DerivePkgAddr(consts.WRAPPED_WUGNOT)\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\n\tbanker.SendCoins(consts.POSITION_ADDR, wugnotAddr, std.Coins{{\"ugnot\", int64(ugnotAmount)}})\n\twugnot.Deposit() // POSITION HAS WUGNOT\n\n\t// SEND WUGNOT: POSITION -\u003e USER\n\twugnot.Transfer(a2u(std.GetOrigCaller()), ugnotAmount)\n}\n\nfunc unwrap(wugnotAmount uint64) {\n\tif wugnotAmount == 0 {\n\t\treturn\n\t}\n\n\t// SEND WUGNOT: USER -\u003e POSITION\n\twugnot.TransferFrom(a2u(std.GetOrigCaller()), a2u(consts.POSITION_ADDR), wugnotAmount)\n\n\t// UNWRAP IT\n\twugnot.Withdraw(wugnotAmount)\n\n\t// SEND GNOT: POSITION -\u003e USER\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\tbanker.SendCoins(consts.POSITION_ADDR, std.GetOrigCaller(), std.Coins{{\"ugnot\", int64(wugnotAmount)}})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"aeIGEC5Ymvb6AcxdwWRLk4ElFMmzq2ftcZ2cu7kcg98tE/QgmwpI8RHYnjm7wB6SWQH0Z/hWO2WG5Q9mldjFBg=="}],"memo":""},"blockNum":"716185"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"router","path":"gno.land/r/gnoswap/v2/router","files":[{"name":"comptue_routes.gno","body":"package router\n\nimport (\n\t\"sort\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// PoolWithMeta is a struct that contains poolPath, token0Path, token1Path, fee, tokenPair, and liquidity\n// It's used to store the pool information and sort the pools by liquidity\ntype PoolWithMeta struct {\n\tpoolPath   string\n\ttoken0Path string\n\ttoken1Path string\n\tfee        int\n\ttokenPair  string\n\tliquidity  *u256.Uint\n}\ntype ByLiquidity []PoolWithMeta\n\nfunc (p ByLiquidity) Len() int           { return len(p) }\nfunc (p ByLiquidity) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\nfunc (p ByLiquidity) Less(i, j int) bool { return p[i].liquidity.Gt(p[j].liquidity) }\n\n// BuildRoute is a struct that contains route, tokenIn, and tokenOut\n// It's used to store the route information\ntype BuildRoute struct {\n\troute    []PoolWithMeta\n\ttokenIn  string\n\ttokenOut string\n}\n\nfunc computeAllRoutes(\n\tinputTokenPath string,\n\toutputTokenPath string,\n\tmaxHops int,\n\tpools []PoolWithMeta,\n) []BuildRoute {\n\n\troutes := _computeAllRoutes(\n\t\tinputTokenPath,\n\t\toutputTokenPath,\n\t\t[]BuildRoute{},\n\t\tpools,\n\t\tmaxHops,\n\t)\n\n\treturn routes\n}\n\nfunc _computeAllRoutes(\n\tinputTokenPath string,\n\toutputTokenPath string,\n\tbuildRoute []BuildRoute, // BuildRoute\n\tpools []PoolWithMeta,\n\tmaxHops int,\n) []BuildRoute {\n\tpoolUsed := make([]bool, len(pools))\n\n\troutes := []BuildRoute{}\n\n\ttokenVisited := make(map[string]bool, 0)\n\ttokenVisited[inputTokenPath] = true\n\n\tcomputeRoutes(\n\t\tinputTokenPath,\n\t\toutputTokenPath,\n\t\t[]PoolWithMeta{}, // currentRoute\n\t\tpoolUsed,\n\t\ttokenVisited, // tokenVisited\n\t\t\"\",           // _previousTokenOut\n\t\t//\n\t\tmaxHops,\n\t\tpools,\n\t\t//\n\t\t\u0026routes,\n\t)\n\n\treturn routes\n}\n\nfunc computeRoutes(\n\tinputTokenPath string,\n\toutputTokenPath string,\n\tcurrentRoute []PoolWithMeta,\n\tpoolsUsed []bool,\n\ttokenVisited map[string]bool,\n\t_previousTokenOut string,\n\tmaxHops int,\n\tpools []PoolWithMeta,\n\troutes *[]BuildRoute,\n) *[]BuildRoute {\n\n\trouteLen := len(currentRoute)\n\n\tif routeLen \u003e maxHops {\n\t\treturn routes\n\t}\n\n\tif (routeLen \u003e 0) \u0026\u0026 (currentRoute[routeLen-1].hasToken(outputTokenPath)) {\n\t\tbuildRoute := BuildRoute{}\n\t\tbuildRoute.route = append([]PoolWithMeta{}, currentRoute...)\n\t\tbuildRoute.tokenIn = inputTokenPath\n\t\tbuildRoute.tokenOut = outputTokenPath\n\t\t*routes = append(*routes, buildRoute)\n\t\treturn routes\n\t}\n\n\tfor i, pool := range pools {\n\t\tif poolsUsed[i] {\n\t\t\tcontinue\n\t\t}\n\n\t\tcurPool := pool\n\n\t\tvar previousTokenOut string\n\t\tif _previousTokenOut == \"\" { // first iteration\n\t\t\tpreviousTokenOut = inputTokenPath\n\t\t} else {\n\t\t\tpreviousTokenOut = _previousTokenOut\n\t\t}\n\n\t\tif !curPool.hasToken(previousTokenOut) {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar currentTokenOut string\n\t\tif curPool.token0Path == previousTokenOut {\n\t\t\tcurrentTokenOut = curPool.token1Path\n\t\t} else {\n\t\t\tcurrentTokenOut = curPool.token0Path\n\t\t}\n\n\t\tif tokenVisited[currentTokenOut] {\n\t\t\tcontinue\n\t\t}\n\n\t\ttokenVisited[currentTokenOut] = true\n\t\tcurrentRoute = append(currentRoute, curPool)\n\t\tpoolsUsed[i] = true\n\n\t\tcomputeRoutes(\n\t\t\tinputTokenPath,\n\t\t\toutputTokenPath,\n\t\t\tcurrentRoute,\n\t\t\tpoolsUsed,\n\t\t\ttokenVisited,\n\t\t\tcurrentTokenOut,\n\t\t\t//\n\t\t\tmaxHops,\n\t\t\tpools,\n\t\t\t//\n\t\t\troutes,\n\t\t)\n\n\t\tpoolsUsed[i] = false\n\t\tcurrentRoute = currentRoute[:len(currentRoute)-1]\n\n\t\tdelete(tokenVisited, currentTokenOut)\n\t}\n\n\treturn routes\n}\n\nfunc (pool PoolWithMeta) hasToken(token string) bool {\n\treturn pool.token0Path == token || pool.token1Path == token\n}\n\nfunc findCandidatePools() []PoolWithMeta {\n\tpoolList := pl.PoolGetPoolList()\n\n\tpoolWithMetas := []PoolWithMeta{}\n\tfor _, poolPath := range poolList {\n\t\ttoken0Path, token1Path, pFee := poolPathWithFeeDivide(poolPath)\n\n\t\tpool := pl.GetPoolFromPoolPath(poolPath)\n\t\tliquidity := pool.PoolGetLiquidity()\n\t\tpoolWithMetas = append(poolWithMetas, PoolWithMeta{\n\t\t\tpoolPath,\n\t\t\ttoken0Path,\n\t\t\ttoken1Path,\n\t\t\tpFee,\n\t\t\ttoken0Path + \":\" + token1Path,\n\t\t\tliquidity,\n\t\t})\n\t}\n\n\tgroupedPools := groupPoolsByTokenPair(poolWithMetas)\n\ttop2ByGroup := selectTop2ByGroup(groupedPools)\n\n\tcandidatePools := []PoolWithMeta{}\n\tfor _, pools := range top2ByGroup {\n\t\tcandidatePools = append(candidatePools, pools...)\n\t}\n\n\treturn candidatePools\n}\n\n// group pools by tokenPair\nfunc groupPoolsByTokenPair(pools []PoolWithMeta) map[string][]PoolWithMeta {\n\tgroupedPools := make(map[string][]PoolWithMeta)\n\n\tfor _, pool := range pools {\n\t\tgroupedPools[pool.tokenPair] = append(groupedPools[pool.tokenPair], pool)\n\t}\n\n\treturn groupedPools\n}\n\n// select the top 2 liquidity values per each group\nfunc selectTop2ByGroup(groupedPools map[string][]PoolWithMeta) map[string][]PoolWithMeta {\n\ttop2ByGroup := make(map[string][]PoolWithMeta)\n\n\tfor tokenPair, pools := range groupedPools {\n\t\t// Use sort.Sort with ByLiquidity interface\n\t\tsort.Sort(ByLiquidity(pools))\n\n\t\t// Select the top 2 liquidity values\n\t\ttop2 := pools[:min(2, len(pools))]\n\t\ttop2ByGroup[tokenPair] = top2\n\t}\n\n\treturn top2ByGroup\n}\n"},{"name":"gno_helper.gno","body":"package router\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nfunc GetOrigPkgAddr() std.Address {\n\treturn consts.ROUTER_ADDR\n}\n"},{"name":"protocol_fee_swap.gno","body":"package router\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\n\t\"gno.land/r/demo/wugnot\"\n)\n\nvar (\n\tswapFee = uint64(15) // 0.15%\n)\n\nfunc handleSwapFee(\n\toutputToken string,\n\tamount *u256.Uint,\n\tisDry bool,\n) *u256.Uint {\n\tif swapFee \u003c= 0 {\n\t\treturn amount\n\t}\n\n\tfeeAmount := new(u256.Uint).Mul(amount, u256.NewUint(swapFee))\n\tfeeAmount.Div(feeAmount, u256.NewUint(10000))\n\tfeeAmountUint64 := feeAmount.Uint64()\n\n\tif !isDry {\n\t\tif outputToken == consts.GNOT { // unwrap if coin\n\t\t\t// wugnot: buyer \u003e router\n\t\t\ttransferFromByRegisterCall(outputToken, std.GetOrigCaller(), consts.ROUTER_ADDR, feeAmountUint64)\n\n\t\t\t// ugnot: wugnot \u003e router\n\t\t\twugnot.Withdraw(feeAmountUint64)\n\n\t\t\t// ugnot: router \u003e feeCollector\n\t\t\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\t\t\tbanker.SendCoins(consts.ROUTER_ADDR, consts.PROTOCOL_FEE_ADDR, std.Coins{{\"ugnot\", int64(feeAmountUint64)}})\n\t\t\tstd.Emit(\n\t\t\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\t\t\"m_callType\", callType(),\n\t\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\t\"reason\", \"router_fee\",\n\t\t\t\t\"token\", \"ugnot\",\n\t\t\t\t\"amount\", strconv.FormatUint(feeAmountUint64, 10),\n\t\t\t)\n\t\t} else { // just transfer if grc20\n\t\t\tok := transferFromByRegisterCall(outputToken, std.GetOrigCaller(), consts.PROTOCOL_FEE_ADDR, feeAmountUint64)\n\t\t\tif !ok {\n\t\t\t\tpanic(ufmt.Sprintf(\"[ROUTER] protocol_fee_swap.gno__handleSwapFee() || expected transferFromByRegisterCall(%s, %s, %s, %d) == true\", outputToken, std.GetOrigCaller(), consts.PROTOCOL_FEE_ADDR, feeAmountUint64))\n\t\t\t}\n\t\t\tstd.Emit(\n\t\t\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\t\t\"m_callType\", callType(),\n\t\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\t\"reason\", \"router_fee\",\n\t\t\t\t\"token\", outputToken,\n\t\t\t\t\"amount\", strconv.FormatUint(feeAmountUint64, 10),\n\t\t\t)\n\t\t}\n\t}\n\n\ttoUserAfterProtocol := new(u256.Uint).Sub(amount, feeAmount)\n\treturn toUserAfterProtocol\n}\n\nfunc GetSwapFee() uint64 {\n\treturn swapFee\n}\n\nfunc SetSwapFee(fee uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[ROUTER] protocol_fee_swap.gno__SetSwapFee() || only admin(%s) or governance(%s) can set swap fee, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\t// 10000 (bps) = 100%\n\tif fee \u003e 10000 {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] protocol_fee_swap.gno__SetSwapFee() || fee(%d) must be in range 0 ~ 10000\", fee))\n\t}\n\n\tswapFee = fee\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_fee\", uint64ToStr(fee),\n\t)\n}\n"},{"name":"router.gno","body":"package router\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/r/gnoswap/v2/common\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\n\t\"gno.land/r/demo/wugnot\"\n\n\ten \"gno.land/r/gnoswap/v2/emission\"\n)\n\n// SwapRoute swaps the input token to the output token and returns the result amount\n// If swapType is EXACT_IN, it returns the amount of output token ≈ amount of user to receive\n// If swapType is EXACT_OUT, it returns the amount of input token ≈ amount of user to pay\n//\n// Panics:\n// - amountSpecified is zero or is not numeric\n// - swapType is not EXACT_IN or EXACT_OUT\n// - length of route and quotes are not the same\n// - length of routes is not 1 ~ 7\n// - sum of quotes is not 100\n// - number of hops is not 1 ~ 3\n// - too many token spend or too few token received\nfunc SwapRoute(\n\tinputToken string,\n\toutputToken string,\n\t_amountSpecified string, // int256\n\tswapType string,\n\tstrRouteArr string, // []string\n\tquoteArr string, // []int\n\t_tokenAmountLimit string, // uint256\n) (string, string) { // tokneIn, tokenOut\n\tif swapType != \"EXACT_IN\" \u0026\u0026 swapType != \"EXACT_OUT\" {\n\t\tpanic(\"[ROUTER] Unknown swapType\")\n\t}\n\n\tif common.GetLimitCaller() \u0026\u0026 std.PrevRealm().PkgPath() != \"\" {\n\t\tpanic(\"[ROUTER] router.gno__SwapRoute() || only user can call this function\")\n\t}\n\n\ten.MintAndDistributeGns()\n\n\tamountSpecified := i256.MustFromDecimal(_amountSpecified)\n\ttokenAmountLimit := u256.MustFromDecimal(_tokenAmountLimit)\n\n\troutes := strings.Split(strRouteArr, \",\")\n\tquotes := strings.Split(quoteArr, \",\")\n\n\tvalidateInput(amountSpecified, swapType, routes, quotes)\n\n\tif swapType == \"EXACT_OUT\" {\n\t\tamountSpecified = i256.Zero().Neg(amountSpecified)\n\t}\n\n\tuserOldWugnotBalance, _ := handleGNOT(inputToken, outputToken)\n\n\tresultAmountIn, resultAmountOut := processRoutes(routes, quotes, amountSpecified, swapType)\n\n\tamountIn, amountOut := finalizeSwap(inputToken, outputToken, resultAmountIn, resultAmountOut, swapType, tokenAmountLimit, userOldWugnotBalance)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_input\", inputToken,\n\t\t\"p_output\", outputToken,\n\t\t\"p_swapType\", swapType,\n\t\t\"p_amountSpecified\", _amountSpecified,\n\t\t\"p_route\", strRouteArr,\n\t\t\"p_quote\", quoteArr,\n\t\t\"amountIn\", amountIn,\n\t\t\"amountOut\", amountOut,\n\t\t\"amountOutWithoutFee\", resultAmountOut.ToString(),\n\t)\n\n\treturn amountIn, amountOut\n}\n\nfunc validateInput(amountSpecified *i256.Int, swapType string, routes, quotes []string) {\n\tif amountSpecified.IsZero() || amountSpecified.IsNeg() {\n\t\tpanic(\"[ROUTER] Invalid amountSpecified\")\n\t}\n\n\tif len(routes) \u003c 1 || len(routes) \u003e 7 {\n\t\tpanic(\"[ROUTER] Invalid route length\")\n\t}\n\n\tif len(routes) != len(quotes) {\n\t\tpanic(\"[ROUTER] Mismatch between routes and quotes length\")\n\t}\n\n\tvar quotesSum int64\n\tfor _, quote := range quotes {\n\t\tintQuote, _ := strconv.Atoi(quote)\n\t\tquotesSum += int64(intQuote)\n\t}\n\n\tif quotesSum != 100 {\n\t\tpanic(\"[ROUTER] Quote sum is not 100\")\n\t}\n}\n\nfunc handleGNOT(inputToken, outputToken string) (uint64, uint64) {\n\tuserOldWugnotBalance := uint64(0)\n\tif inputToken == consts.GNOT {\n\t\tsent := std.GetOrigSend()\n\t\tugnotSentByUser := uint64(sent.AmountOf(\"ugnot\"))\n\t\twrap(ugnotSentByUser)\n\t\tuserOldWugnotBalance = wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\t} else if outputToken == consts.GNOT {\n\t\tuserOldWugnotBalance = wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\t}\n\treturn userOldWugnotBalance, 0\n}\n\nfunc processRoutes(routes, quotes []string, amountSpecified *i256.Int, swapType string) (*u256.Uint, *u256.Uint) {\n\tresultAmountIn := u256.Zero()\n\tresultAmountOut := u256.Zero()\n\n\tfor i, route := range routes {\n\t\tnumHops := strings.Count(route, \"*POOL*\") + 1\n\t\tquote, _ := strconv.Atoi(quotes[i])\n\n\t\tif numHops \u003c 1 || numHops \u003e 3 {\n\t\t\tpanic(ufmt.Sprintf(\"[ROUTER] Invalid number of hops: %d\", numHops))\n\t\t}\n\n\t\ttoSwap := i256.Zero().Mul(amountSpecified, i256.NewInt(int64(quote)))\n\t\ttoSwap = toSwap.Div(toSwap, i256.NewInt(100))\n\n\t\tvar amountIn, amountOut *u256.Uint\n\t\tif numHops == 1 {\n\t\t\tamountIn, amountOut = handleSingleSwap(route, toSwap, false)\n\t\t} else {\n\t\t\tamountIn, amountOut = handleMultiSwap(swapType, route, numHops, toSwap, false)\n\t\t}\n\n\t\tresultAmountIn = new(u256.Uint).Add(resultAmountIn, amountIn)\n\t\tresultAmountOut = new(u256.Uint).Add(resultAmountOut, amountOut)\n\t}\n\n\treturn resultAmountIn, resultAmountOut\n}\n\nfunc handleSingleSwap(route string, amountSpecified *i256.Int, isDry bool) (*u256.Uint, *u256.Uint) {\n\tinput, output, fee := getDataForSinglePath(route)\n\tsingleParams := SingleSwapParams{\n\t\ttokenIn:         input,\n\t\ttokenOut:        output,\n\t\tfee:             fee,\n\t\tamountSpecified: amountSpecified,\n\t}\n\n\tif isDry {\n\t\treturn singleSwapDry(singleParams)\n\t}\n\treturn singleSwap(singleParams)\n}\n\nfunc finalizeSwap(inputToken, outputToken string, resultAmountIn, resultAmountOut *u256.Uint, swapType string, tokenAmountLimit *u256.Uint, userOldWugnotBalance uint64) (string, string) {\n\tafterFee := handleSwapFee(outputToken, resultAmountOut, false)\n\n\tuserNewWugnotBalance := wugnot.BalanceOf(a2u(std.GetOrigCaller()))\n\tif inputToken == consts.GNOT {\n\t\tunwrap(userNewWugnotBalance)\n\t} else if outputToken == consts.GNOT {\n\t\tuserRecvWugnot := uint64(userNewWugnotBalance - userOldWugnotBalance)\n\t\tunwrap(userRecvWugnot)\n\t}\n\n\tif swapType == \"EXACT_IN\" {\n\t\tif !tokenAmountLimit.Lte(afterFee) {\n\t\t\tpanic(ufmt.Sprintf(\"[ROUTER] Too few received for user (expected minimum: %s, actual: %s)\", tokenAmountLimit.ToString(), afterFee.ToString()))\n\t\t}\n\t} else {\n\t\tif !resultAmountIn.Lte(tokenAmountLimit) {\n\t\t\tpanic(ufmt.Sprintf(\"[ROUTER] Too much spent for user (expected maximum: %s, actual: %s)\", tokenAmountLimit.ToString(), resultAmountIn.ToString()))\n\t\t}\n\t}\n\n\tintAmountOut := i256.FromUint256(afterFee)\n\treturn resultAmountIn.ToString(), i256.Zero().Neg(intAmountOut).ToString()\n}\n\nfunc handleMultiSwap(swapType string, route string, numHops int, amountSpecified *i256.Int, isDry bool) (*u256.Uint, *u256.Uint) {\n\tswitch swapType {\n\tcase \"EXACT_IN\":\n\t\tinput, output, fee := getDataForMultiPath(route, 0) // first data\n\t\tswapParams := SwapParams{\n\t\t\ttokenIn:         input,\n\t\t\ttokenOut:        output,\n\t\t\tfee:             fee,\n\t\t\trecipient:       std.GetOrigCaller(),\n\t\t\tamountSpecified: amountSpecified,\n\t\t}\n\n\t\tif isDry {\n\t\t\treturn multiSwapDry(swapParams, 0, numHops, route) // iterate here\n\t\t}\n\t\treturn multiSwap(swapParams, 0, numHops, route) // iterate here\n\n\tcase \"EXACT_OUT\":\n\t\tinput, output, fee := getDataForMultiPath(route, numHops-1) // last data\n\t\tswapParams := SwapParams{\n\t\t\ttokenIn:         input,\n\t\t\ttokenOut:        output,\n\t\t\tfee:             fee,\n\t\t\trecipient:       std.GetOrigCaller(),\n\t\t\tamountSpecified: amountSpecified,\n\t\t}\n\n\t\tif isDry {\n\t\t\treturn multiSwapNegativeDry(swapParams, numHops-1, route) // iterate here\n\t\t}\n\t\treturn multiSwapNegative(swapParams, numHops-1, route) // iterate here\n\n\tdefault:\n\t\tpanic(\"[ROUTER] router.gno__handleMultiSwap() || unknown swapType\")\n\t}\n}\n"},{"name":"router_dry.gno","body":"package router\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// DrySwapRoute simulates a token swap route without actually executing the swap.\n// It calculates the expected outcome based on the current state of liquidity pools.\n//\n// The function supports multi-hop and split routes, with up to 7 routes and 3 hops per route.\n// Panics:\n//   - If _amountSpecified is zero, negative, or not a valid number\n//   - If swapType is neither \"EXACT_IN\" nor \"EXACT_OUT\"\n//   - If the number of routes doesn't match the number of quotes\n//   - If there are less than 1 or more than 7 routes\n//   - If the sum of quote percentages is not exactly 100\n//   - If any route has less than 1 or more than 3 hops\n//   - If any other validation or processing error occurs during the simulation\n//\n// Note: This function only simulates the swap and does not modify any state or execute any transactions.\nfunc DrySwapRoute(\n\tinputToken string,\n\toutputToken string,\n\t_amountSpecified string, // int256\n\tswapType string,\n\tstrRouteArr string, // []string\n\tquoteArr string, // []int\n) string { // uint256\n\tif swapType != \"EXACT_IN\" \u0026\u0026 swapType != \"EXACT_OUT\" {\n        panic(\"[ROUTER] Unknown swapType\")\n    }\n\n\tamountSpecified, err := i256.FromDecimal(_amountSpecified)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router_dry.gno__SwapRoute() || i256.FromDecimal(_amountSpecified(%s) failed\", _amountSpecified))\n\t}\n\n\troutes := strings.Split(strRouteArr, \",\")\n\tquotes := strings.Split(quoteArr, \",\")\n\n\tvalidateInput(amountSpecified, swapType, routes, quotes)\n\n\tif swapType == \"EXACT_OUT\" {\n\t\tamountSpecified = i256.Zero().Neg(amountSpecified)\n\t}\n\n\tresultAmountIn := u256.Zero()\n\tresultAmountOut := u256.Zero()\n\n\tfor i, route := range routes {\n\t\tnumHops := strings.Count(route, \"*POOL*\") + 1\n\t\tquote, _ := strconv.Atoi(quotes[i])\n\n\t\tif numHops \u003c 1 || numHops \u003e 3 {\n\t\t\tpanic(ufmt.Sprintf(\"[ROUTER] router_dry.gno__DrySwapRoute() || numHops should be 1 ~ 3 (numHops)[%d]\", numHops))\n\t\t}\n\n\t\ttoSwap := i256.Zero().Mul(amountSpecified, i256.NewInt(int64(quote)))\n\t\ttoSwap = toSwap.Div(toSwap, i256.NewInt(100))\n\n\t\tif numHops == 1 { // SINGLE\n\t\t\tamountIn, amountOut := handleSingleSwap(route, toSwap, true)\n\t\t\tresultAmountIn = new(u256.Uint).Add(resultAmountIn, amountIn)\n\t\t\tresultAmountOut = new(u256.Uint).Add(resultAmountOut, amountOut)\n\t\t} else {\n\t\t\tamountIn, amountOut := handleMultiSwap(swapType, route, numHops, toSwap, true)\n\t\t\tresultAmountIn = new(u256.Uint).Add(resultAmountIn, amountIn)\n\t\t\tresultAmountOut = new(u256.Uint).Add(resultAmountOut, amountOut)\n\t\t}\n\t}\n\n\treturn processResult(swapType, resultAmountIn, resultAmountOut, amountSpecified)\n}\n\nfunc processResult(swapType string, resultAmountIn, resultAmountOut *u256.Uint, amountSpecified *i256.Int) string {\n    switch swapType {\n    case \"EXACT_IN\":\n        if !i256.FromUint256(resultAmountIn).Eq(amountSpecified) {\n            return \"-1\"\n        }\n        return resultAmountOut.ToString()\n    case \"EXACT_OUT\":\n        if i256.FromUint256(resultAmountOut).Lt(amountSpecified) {\n            return \"-1\"\n        }\n        return resultAmountIn.ToString()\n    default:\n        panic(\"[ROUTER] Unknown swapType\")\n    }\n}\n"},{"name":"swap_inner.gno","body":"package router\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\n\t\"gno.land/r/gnoswap/v2/common\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nfunc _swap(\n\tamountSpecified *i256.Int,\n\trecipient std.Address,\n\tsqrtPriceLimitX96 *u256.Uint,\n\tdata SwapCallbackData,\n) (*u256.Uint, *u256.Uint) { // poolRecv, poolOut\n\t// prepare\n\tzeroForOne := data.tokenIn \u003c data.tokenOut\n\n\tif sqrtPriceLimitX96.IsZero() {\n\t\tif zeroForOne {\n\t\t\tsqrtPriceLimitX96 = common.TickMathGetSqrtRatioAtTick(getMinTick(data.fee))\n\t\t\tsqrtPriceLimitX96 = new(u256.Uint).Add(sqrtPriceLimitX96, u256.One())\n\t\t} else {\n\t\t\tsqrtPriceLimitX96 = common.TickMathGetSqrtRatioAtTick(getMaxTick(data.fee))\n\t\t\tsqrtPriceLimitX96 = new(u256.Uint).Sub(sqrtPriceLimitX96, u256.One())\n\t\t}\n\t}\n\n\t// ROUTER approves POOL as spender\n\tapproveByRegisterCall(data.tokenIn, consts.POOL_ADDR, consts.UINT64_MAX)\n\tapproveByRegisterCall(data.tokenOut, consts.POOL_ADDR, consts.UINT64_MAX)\n\n\tamount0Str, amount1Str := pl.Swap( // int256, int256\n\t\tdata.tokenIn,\n\t\tdata.tokenOut,\n\t\tdata.fee,\n\n\t\trecipient.String(),\n\t\tzeroForOne,\n\t\tamountSpecified.ToString(),\n\t\tsqrtPriceLimitX96.ToString(),\n\n\t\tdata.payer.String(),\n\t)\n\tamount0, err := i256.FromDecimal(amount0Str)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router.gno__Swap() || i256.FromDecimal(amount0Str(%s) failed\", amount0Str))\n\t}\n\tamount1, err := i256.FromDecimal(amount1Str)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router.gno__Swap() || i256.FromDecimal(amount1Str(%s) failed\", amount1Str))\n\t}\n\n\tpoolRecv := i256Max(amount0, amount1)\n\tpoolOut := i256Min(amount0, amount1)\n\n\treturn poolRecv.Abs(), poolOut.Abs()\n}\n\nfunc _swapDry(\n\tamountSpecified *i256.Int,\n\tsqrtPriceLimitX96 *u256.Uint,\n\tdata SwapCallbackData,\n) (*u256.Uint, *u256.Uint) { // poolRecv, poolOut\n\tzeroForOne := data.tokenIn \u003c data.tokenOut\n\n\tif sqrtPriceLimitX96.IsZero() {\n\t\tif zeroForOne {\n\t\t\tsqrtPriceLimitX96 = u256.MustFromDecimal(consts.MIN_PRICE)\n\t\t} else {\n\t\t\tsqrtPriceLimitX96 = u256.MustFromDecimal(consts.MAX_PRICE)\n\t\t}\n\t}\n\n\t// check possible\n\tamount0Str, amount1Str, ok := pl.DrySwap(\n\t\tdata.tokenIn,\n\t\tdata.tokenOut,\n\t\tdata.fee,\n\n\t\tzeroForOne,\n\t\tamountSpecified.ToString(),\n\t\tsqrtPriceLimitX96.ToString(),\n\t)\n\tif !ok {\n\t\treturn u256.Zero(), u256.Zero()\n\t}\n\n\tamount0, err := i256.FromDecimal(amount0Str)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router.gno__Swap() || i256.FromDecimal(amount0Str(%s) failed\", amount0Str))\n\t}\n\tamount1, err := i256.FromDecimal(amount1Str)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router.gno__Swap() || i256.FromDecimal(amount1Str(%s) failed\", amount1Str))\n\t}\n\n\tpoolRecv := i256Max(amount0, amount1)\n\tpoolOut := i256Min(amount0, amount1)\n\n\treturn poolRecv.Abs(), poolOut.Abs()\n}\n\nfunc i256Min(x, y *i256.Int) *i256.Int {\n\tif x.Lt(y) {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc i256Max(x, y *i256.Int) *i256.Int {\n\tif x.Gt(y) {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc getMinTick(fee uint32) int32 {\n\tswitch fee {\n\tcase 100:\n\t\treturn -887272\n\tcase 500:\n\t\treturn -887270\n\tcase 3000:\n\t\treturn -887220\n\tcase 10000:\n\t\treturn -887200\n\tdefault:\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router.gno__getMinTick() || unknown fee(%d)\", fee))\n\t}\n}\n\nfunc getMaxTick(fee uint32) int32 {\n\tswitch fee {\n\tcase 100:\n\t\treturn 887272\n\tcase 500:\n\t\treturn 887270\n\tcase 3000:\n\t\treturn 887220\n\tcase 10000:\n\t\treturn 887200\n\tdefault:\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router.gno__getMaxTick() || unknown fee(%d)\", fee))\n\t}\n}\n"},{"name":"swap_multi.gno","body":"package router\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nfunc multiSwap(params SwapParams, currentPoolIndex, numPools int, swapPath string) (*u256.Uint, *u256.Uint) { // firstAmountIn, lastAmountOut\n\tfirstAmountIn := u256.Zero()\n\n\tpayer := std.GetOrigCaller() // user\n\n\tfor {\n\t\tvar recipient std.Address\n\t\tcurrentPoolIndex++\n\n\t\tif currentPoolIndex \u003c numPools {\n\t\t\trecipient = consts.ROUTER_ADDR\n\t\t} else {\n\t\t\trecipient = params.recipient // user ~= std.GetOrigCaller()\n\t\t}\n\n\t\tamountIn, amountOut := _swap(\n\t\t\tparams.amountSpecified,\n\t\t\trecipient,\n\t\t\tu256.Zero(),\n\t\t\tSwapCallbackData{\n\t\t\t\tparams.tokenIn,\n\t\t\t\tparams.tokenOut,\n\t\t\t\tparams.fee,\n\t\t\t\tpayer,\n\t\t\t},\n\t\t)\n\n\t\tif currentPoolIndex == 1 {\n\t\t\tfirstAmountIn = amountIn\n\t\t}\n\n\t\tif currentPoolIndex \u003e= numPools {\n\t\t\treturn firstAmountIn, amountOut\n\t\t}\n\n\t\tpayer = consts.ROUTER_ADDR\n\n\t\tnextInput, nextOutput, nextFee := getDataForMultiPath(swapPath, currentPoolIndex)\n\t\tparams.tokenIn = nextInput\n\t\tparams.tokenOut = nextOutput\n\t\tparams.fee = nextFee\n\n\t\tparams.amountSpecified = i256.FromUint256(amountOut)\n\t}\n}\n\nfunc multiSwapNegative(params SwapParams, numPools int, swapPath string) (*u256.Uint, *u256.Uint) { // firstAmountIn, lastAmountOut\n\tfirstAmountIn := u256.Zero()\n\n\tswapInfo := []SingleSwapParams{}\n\tcurrentPoolIndex := numPools\n\n\t// CALCULATE BACKWARD INFO\n\tfor {\n\t\tamountIn, _ := singleSwapDry(\n\t\t\tSingleSwapParams{\n\t\t\t\ttokenIn:         params.tokenIn,\n\t\t\t\ttokenOut:        params.tokenOut,\n\t\t\t\tfee:             params.fee,\n\t\t\t\tamountSpecified: params.amountSpecified,\n\t\t\t},\n\t\t)\n\n\t\tthisSwap := SingleSwapParams{\n\t\t\ttokenIn:         params.tokenIn,\n\t\t\ttokenOut:        params.tokenOut,\n\t\t\tfee:             params.fee,\n\t\t\tamountSpecified: params.amountSpecified,\n\t\t}\n\n\t\tswapInfo = append(swapInfo, thisSwap)\n\n\t\tif currentPoolIndex == 0 {\n\t\t\tbreak\n\t\t} else {\n\t\t\tcurrentPoolIndex--\n\n\t\t\tnextInput, nextOutput, nextFee := getDataForMultiPath(swapPath, currentPoolIndex)\n\t\t\t_intAmountIn := i256.FromUint256(amountIn)\n\n\t\t\tparams.tokenIn = nextInput\n\t\t\tparams.tokenOut = nextOutput\n\t\t\tparams.fee = nextFee\n\t\t\tparams.amountSpecified = i256.Zero().Neg(_intAmountIn)\n\t\t}\n\t}\n\n\t// PROCESS FORWARD INFO\n\tcurrentPoolIndex = len(swapInfo)\n\tpayer := std.GetOrigCaller() // first payer ~= user\n\tfor {\n\t\tvar recipient std.Address\n\t\tcurrentPoolIndex--\n\t\tif currentPoolIndex == 0 {\n\t\t\trecipient = std.GetOrigCaller() // params.recipient // user ~= std.GetOrigCaller()\n\t\t} else {\n\t\t\trecipient = consts.ROUTER_ADDR\n\t\t}\n\n\t\tamountIn, amountOut := _swap(\n\t\t\tswapInfo[currentPoolIndex].amountSpecified,\n\t\t\trecipient,\n\t\t\tu256.Zero(),\n\t\t\tSwapCallbackData{\n\t\t\t\tswapInfo[currentPoolIndex].tokenIn,\n\t\t\t\tswapInfo[currentPoolIndex].tokenOut,\n\t\t\t\tswapInfo[currentPoolIndex].fee,\n\t\t\t\tpayer,\n\t\t\t},\n\t\t)\n\n\t\t// save route's first hop's amountIn to check whether crossed limit or not\n\t\tif currentPoolIndex == len(swapInfo)-1 {\n\t\t\tfirstAmountIn = amountIn\n\t\t}\n\n\t\tif currentPoolIndex == 0 {\n\t\t\treturn firstAmountIn, amountOut\n\t\t}\n\n\t\tpayer = consts.ROUTER_ADDR\n\t\tswapInfo[currentPoolIndex-1].amountSpecified = i256.FromUint256(amountOut)\n\t}\n}\n\nfunc multiSwapDry(params SwapParams, currentPoolIndex, numPool int, swapPath string) (*u256.Uint, *u256.Uint) { // firstAmountIn, lastAmountOut\n\tfirstAmountIn := u256.Zero()\n\n\tpayer := std.GetOrigCaller() // user\n\n\tfor {\n\t\tcurrentPoolIndex++\n\n\t\tamountIn, amountOut := _swapDry(\n\t\t\tparams.amountSpecified,\n\t\t\tu256.Zero(),\n\t\t\tSwapCallbackData{\n\t\t\t\tparams.tokenIn,\n\t\t\t\tparams.tokenOut,\n\t\t\t\tparams.fee,\n\t\t\t\tpayer,\n\t\t\t},\n\t\t)\n\n\t\tif currentPoolIndex == 1 {\n\t\t\tfirstAmountIn = amountIn\n\t\t}\n\n\t\tif currentPoolIndex \u003e= numPool {\n\t\t\treturn firstAmountIn, amountOut\n\t\t}\n\n\t\tpayer = consts.ROUTER_ADDR\n\t\tnextInput, nextOutput, nextFee := getDataForMultiPath(swapPath, currentPoolIndex)\n\n\t\tparams.tokenIn = nextInput\n\t\tparams.tokenOut = nextOutput\n\t\tparams.fee = nextFee\n\t\tparams.amountSpecified = i256.FromUint256(amountOut)\n\t}\n\n}\n\nfunc multiSwapNegativeDry(params SwapParams, currentPoolIndex int, swapPath string) (*u256.Uint, *u256.Uint) { // firstAmountIn, lastAmountOut\n\tfirstAmountIn := u256.Zero()\n\tpayer := consts.ROUTER_ADDR\n\n\tfor {\n\t\tamountIn, amountOut := _swapDry(\n\t\t\tparams.amountSpecified,\n\t\t\tu256.Zero(),\n\t\t\tSwapCallbackData{\n\t\t\t\tparams.tokenIn,\n\t\t\t\tparams.tokenOut,\n\t\t\t\tparams.fee,\n\t\t\t\tpayer,\n\t\t\t},\n\t\t)\n\n\t\tif currentPoolIndex == 0 {\n\t\t\t// save for return\n\t\t\tfirstAmountIn = amountIn\n\t\t}\n\n\t\tcurrentPoolIndex--\n\n\t\tif currentPoolIndex == -1 {\n\t\t\treturn firstAmountIn, amountOut\n\t\t}\n\n\t\tnextInput, nextOutput, nextFee := getDataForMultiPath(swapPath, currentPoolIndex)\n\t\t_intAmountIn := i256.FromUint256(amountIn)\n\n\t\tparams.amountSpecified = i256.Zero().Neg(_intAmountIn)\n\t\tparams.tokenIn = nextInput\n\t\tparams.tokenOut = nextOutput\n\t\tparams.fee = nextFee\n\t}\n}\n"},{"name":"swap_single.gno","body":"package router\n\nimport (\n\t\"std\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nfunc singleSwap(params SingleSwapParams) (*u256.Uint, *u256.Uint) { // amountIn, amountOut\n\tamountIn, amountOut := _swap(\n\t\tparams.amountSpecified,\n\t\tstd.GetOrigCaller(), // if single swap =\u003e user will recieve\n\t\tu256.Zero(),         // sqrtPriceLimitX96\n\t\tSwapCallbackData{\n\t\t\tparams.tokenIn,\n\t\t\tparams.tokenOut,\n\t\t\tparams.fee,\n\t\t\tstd.PrevRealm().Addr(), // payer ==\u003e msg.sender,\n\t\t},\n\t)\n\n\treturn amountIn, amountOut\n}\n\nfunc singleSwapDry(params SingleSwapParams) (*u256.Uint, *u256.Uint) { // amountIn, amountOut\n\tamountIn, amountOut := _swapDry(\n\t\tparams.amountSpecified,\n\t\tu256.Zero(), // sqrtPriceLimitX96\n\t\tSwapCallbackData{\n\t\t\tparams.tokenIn,\n\t\t\tparams.tokenOut,\n\t\t\tparams.fee,\n\t\t\tstd.PrevRealm().Addr(), // payer ==\u003e msg.sender,\n\t\t},\n\t)\n\n\treturn amountIn, amountOut\n}\n"},{"name":"token_register.gno","body":"package router\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\ntype GRC20Interface interface {\n\tTransfer() func(to pusers.AddressOrName, amount uint64)\n\tTransferFrom() func(from, to pusers.AddressOrName, amount uint64)\n\tBalanceOf() func(owner pusers.AddressOrName) uint64\n\tApprove() func(spender pusers.AddressOrName, amount uint64)\n}\n\nvar (\n\tregistered = make(map[string]GRC20Interface)\n\tlocked     = false // mutex\n)\n\nfunc GetRegisteredTokens() []string {\n\ttokens := make([]string, 0, len(registered))\n\tfor k := range registered {\n\t\ttokens = append(tokens, k)\n\t}\n\treturn tokens\n}\n\nfunc RegisterGRC20Interface(pkgPath string, igrc20 GRC20Interface) {\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] token_register.gno__RegisterGRC20Interface() || unauthorized address(%s) to register\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router_register.gno__RegisterGRC20Interface() || pkgPath(%s) already registered\", pkgPath))\n\t}\n\n\tregistered[pkgPath] = igrc20\n}\n\nfunc UnregisterGRC20Interface(pkgPath string) {\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] token_register.gno__UnregisterGRC20Interface() || unauthorized address(%s) to unregister\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tdelete(registered, pkgPath)\n\t}\n}\n\nfunc transferByRegisterCall(pkgPath string, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router_register.gno__transferByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].Transfer()(pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[POOl] router_register.gno__transferByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc transferFromByRegisterCall(pkgPath string, from, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router_register.gno__transferFromByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].TransferFrom()(pusers.AddressOrName(from), pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[POOl] router_register.gno__transferFromByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc balanceOfByRegisterCall(pkgPath string, owner std.Address) uint64 {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router_register.gno__balanceOfByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tbalance := registered[pkgPath].BalanceOf()(pusers.AddressOrName(owner))\n\treturn balance\n}\n\nfunc approveByRegisterCall(pkgPath string, spender std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] router_register.gno__approveByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tregistered[pkgPath].Approve()(pusers.AddressOrName(spender), amount)\n\n\treturn true\n}\n\nfunc handleNative(pkgPath string) string {\n\tif pkgPath == consts.GNOT {\n\t\treturn consts.WRAPPED_WUGNOT\n\t}\n\n\treturn pkgPath\n}\n"},{"name":"type.gno","body":"package router\n\nimport (\n\t\"std\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n)\n\n// SWAP TYPE\ntype SwapType string\n\nconst (\n\tExactIn  SwapType = \"EXACT_IN\"\n\tExactOut SwapType = \"EXACT_OUT\"\n)\n\n// SINGLE SWAP\ntype SingleSwapParams struct {\n\ttokenIn  string // token to spend\n\ttokenOut string // token to receive\n\tfee      uint32 // fee of the pool used to swap\n\n\t// if positive, it's the amount of tokenIn to spend\n\t// if negative, it's the wanted amount of tokenOut to receive\n\tamountSpecified *i256.Int\n}\n\n// MUTLI SWAP\ntype SwapParams struct {\n\ttokenIn   string      // token to spend\n\ttokenOut  string      // token to receive\n\tfee       uint32      // fee of the pool used to swap\n\trecipient std.Address // address to receive the token\n\n\t// if positive, it's the amount of tokenIn to spend\n\t// if negative, it's the wanted amount of tokenOut to receive\n\tamountSpecified *i256.Int\n}\n\nfunc newSwapParams(tokenIn, tokenOut string, fee uint32, recipient std.Address, amountSpecified *i256.Int) *SwapParams {\n\treturn \u0026SwapParams{\n\t\ttokenIn:        tokenIn,\n\t\ttokenOut:       tokenOut,\n\t\tfee:            fee,\n\t\trecipient:      recipient,\n\t\tamountSpecified: amountSpecified,\n\t}\n}\n\n// SWAP DATA\ntype SwapCallbackData struct {\n\ttokenIn  string // token to spend\n\ttokenOut string // token to receive\n\tfee      uint32 // fee of the pool used to swap\n\n\tpayer std.Address // address to spend the token\n}\n"},{"name":"utils.gno","body":"package router\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc poolPathWithFeeDivide(poolPath string) (string, string, int) {\n\tpoolPathSplit := strings.Split(poolPath, \":\")\n\tif len(poolPathSplit) != 3 {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] _RPC_api.gno__poolPathWithFeeDivide() || len(poolPathSplit) != 3, poolPath: %s\", poolPath))\n\t}\n\n\tfeeInt, err := strconv.Atoi(poolPathSplit[2])\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] _RPC_api.gno__poolPathWithFeeDivide() || cannot convert fee(%s) to int\", poolPathSplit[2]))\n\t}\n\n\treturn poolPathSplit[0], poolPathSplit[1], feeInt\n}\n\nfunc getDataForSinglePath(poolPath string) (string, string, uint32) {\n\tdatas := strings.Split(poolPath, \":\")\n\tif len(datas) != 3 {\n\t\tpanic(ufmt.Sprintf(\"[ROUTER] _util.gno__getDataForSinglePath() || len(datas) != 3 (poolPath:%s)\", poolPath))\n\t}\n\n\ttoken0 := datas[0]\n\ttoken1 := datas[1]\n\tfee, _ := strconv.Atoi(datas[2])\n\n\treturn token0, token1, uint32(fee)\n}\n\nfunc getDataForMultiPath(possiblePath string, poolIdx int) (string, string, uint32) {\n\tpools := strings.Split(possiblePath, \"*POOL*\")\n\n\tvar token0, token1 string\n\tvar fee uint32\n\n\tswitch poolIdx {\n\tcase 0:\n\t\ttoken0, token1, fee = getDataForSinglePath(pools[0])\n\tcase 1:\n\t\ttoken0, token1, fee = getDataForSinglePath(pools[1])\n\tcase 2:\n\t\ttoken0, token1, fee = getDataForSinglePath(pools[2])\n\tdefault:\n\t\treturn \"\", \"\", uint32(0)\n\t}\n\n\treturn token0, token1, fee\n}\n\nfunc isStringInStringArr(arr []string, str string) bool {\n\tfor _, a := range arr {\n\t\tif a == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc removeStringFromStringArr(arr []string, str string) []string {\n\tfor i, a := range arr {\n\t\tif a == str {\n\t\t\treturn append(arr[:i], arr[i+1:]...)\n\t\t}\n\t}\n\treturn arr\n}\n\nfunc a2u(addr std.Address) pusers.AddressOrName {\n\treturn pusers.AddressOrName(addr)\n}\n\nfunc min(a, b int) int {\n\tif a \u003c b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc origCaller() string {\n\treturn std.GetOrigCaller().String()\n}\n\nfunc prevRealm() string {\n\treturn std.PrevRealm().PkgPath()\n}\n\nfunc callType() string {\n\tif prevRealm() == \"\" {\n\t\treturn \"DIRECT\"\n\t}\n\n\treturn \"INDIRECT\"\n}\n\nfunc uint64ToStr(i uint64) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n"},{"name":"wrap_unwrap.gno","body":"package router\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/wugnot\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nfunc wrap(ugnotAmount uint64) {\n\tif ugnotAmount \u003c= 0 {\n\t\tpanic(ufmt.Sprintf(\"cannot wrap 0 ugnot\"))\n\t}\n\n\tif ugnotAmount \u003c consts.UGNOT_MIN_DEPOSIT_TO_WRAP {\n\t\tpanic(ufmt.Sprintf(\"Deposit below minimum: %d/%d ugnot.\", ugnotAmount, consts.UGNOT_MIN_DEPOSIT_TO_WRAP))\n\t}\n\n\t// WRAP IT\n\twugnotAddr := std.DerivePkgAddr(consts.WRAPPED_WUGNOT)\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\tbanker.SendCoins(consts.ROUTER_ADDR, wugnotAddr, std.Coins{{\"ugnot\", int64(ugnotAmount)}})\n\twugnot.Deposit() // ROUTER HAS WUGNOT\n\n\t// SEND WUGNOT: ROUTER -\u003e USER\n\twugnot.Transfer(a2u(std.GetOrigCaller()), ugnotAmount)\n}\n\nfunc unwrap(wugnotAmount uint64) {\n\tif wugnotAmount == 0 {\n\t\treturn\n\t}\n\n\t// SEND WUGNOT: USER -\u003e ROUTER\n\twugnot.TransferFrom(a2u(std.GetOrigCaller()), a2u(consts.ROUTER_ADDR), wugnotAmount)\n\n\t// UNWRAP IT\n\twugnot.Withdraw(wugnotAmount)\n\n\t// SEND GNOT: ROUTER -\u003e USER\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\tbanker.SendCoins(consts.ROUTER_ADDR, std.GetOrigCaller(), std.Coins{{\"ugnot\", int64(wugnotAmount)}})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"Px7sBYDhfcbG3YUTx4zzhvBV6trDDy5ka/od0WnhMExBKkTuQq8GgXctuebV/zKwNHzqyvBfGU1PMOuKcHbMvg=="}],"memo":""},"blockNum":"716186"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"staker","path":"gno.land/r/gnoswap/v2/staker","files":[{"name":"_GET_no_receiver.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\t\"gno.land/r/gnoswap/v2/gns\"\n\n\ten \"gno.land/r/gnoswap/v2/emission\"\n)\n\n// StakerPoolIncentives returns the list of incentive IDs for a given pool\n//\n// Parameters:\n//   - poolPath (string): The path of the pool to get incentives for\n//\n// Returns:\n//   - A slice og incentive IDs associated with the pool\n//\n// Panics:\n//   - If the pool incentives do not exist for the given pool path\nfunc StakerPoolIncentives(poolPath string) []string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tincentives, exist := poolIncentives[poolPath]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerPoolIncentives() || poolPath(%s) incentives does not exist\", poolPath))\n\t}\n\n\treturn incentives\n}\n\n// StakerIncentiveTargetPoolPath returns the target pool path for a given incentive\n//\n// Parameters:\n//   - incentiveId (string): The ID of the incentive\n//\n// Returns:\n//   - The target pool path (string) associated with the incentive\n//\n// Panics:\n//   - If the incentive does nor exist for the given incentive ID\nfunc StakerIncentiveTargetPoolPath(incentiveId string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tincentive, exist := incentives[incentiveId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerIncentiveTargetPoolPath() || incentiveId(%s) incentive does not exist\", incentiveId))\n\t}\n\n\treturn incentive.targetPoolPath\n}\n\n// StakerIncentiveRewardToken returns the reward token for a given incentive\n//\n// Parameters:\n//   - incentiveId (string): The ID of the incentive\n//\n// Returns:\n//   - The reward token (string) associated with the incentive\n//\n// Panics:\n//   - If the incentive does not exist for the given incentiveId\nfunc StakerIncentiveRewardToken(incentiveId string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tincentive, exist := incentives[incentiveId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerIncentiveRewardToken() || incentiveId(%s) incentive does not exist\", incentiveId))\n\t}\n\n\treturn incentive.rewardToken\n}\n\n// StakerIncentiveRewardAmount returns the reward amount for a given incentive as a Uint256\n//\n// Parameters:\n//   - incentiveId (string): The ID of the incentive\n//\n// Returns:\n//   - *u256.Uint: The reward amount associated with the incentive\n//\n// Panics:\n//   - If the incentive does not exist for the given incentiveId\nfunc StakerIncentiveRewardAmount(incentiveId string) *u256.Uint {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tincentive, exist := incentives[incentiveId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerIncentiveRewardAmount() || incentiveId(%s) incentive does not exist\", incentiveId))\n\t}\n\n\treturn incentive.rewardAmount\n}\n\n// StakerIncentiveRewardAmountStr returns the reward amount for a given incentive as a string\n//\n// Parameters:\n//   - incentiveId (string): The ID of the incentive\n//\n// Returns:\n//   - string: The reward amount associated with the incentive as a string\n//\n// Panics:\n//   - If the incentive does not exist for the given incentiveId\nfunc StakerIncentiveRewardAmountStr(incentiveId string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tincentive, exist := incentives[incentiveId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerIncentiveRewardAmount() || incentiveId(%s) incentive does not exist\", incentiveId))\n\t}\n\n\treturn incentive.rewardAmount.ToString()\n}\n\n// StakerIncentiveStartTimestamp returns the start timestamp for a given incentive\n//\n// Parameters:\n//   - incentiveId (string): The ID of the incentive\n//\n// Returns:\n//   - int64: The start timestamp of the incentive\n//\n// Panics:\n//   - If the incentive does not exist for the given incentiveId\nfunc StakerIncentiveStartTimestamp(incentiveId string) int64 {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tincentive, exist := incentives[incentiveId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerIncentiveStartTimestamp() || incentiveId(%s) incentive does not exist\", incentiveId))\n\t}\n\n\treturn incentive.startTimestamp\n}\n\n// StakerIncentiveEndTimestamp returns the end timestamp for a given incentive\n//\n// Parameters:\n//   - incentiveId (string): The ID of the incentive\n//\n// Returns:\n//   - int64: The end timestamp of the incentive\n//\n// Panics:\n//   - If the incentive does not exist for the given incentiveId\nfunc StakerIncentiveEndTimestamp(incentiveId string) int64 {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tincentive, exist := incentives[incentiveId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerIncentiveEndTimestamp() || incentiveId(%s) incentive does not exist\", incentiveId))\n\t}\n\n\treturn incentive.endTimestamp\n}\n\n// StakerIncentiveRefundee returns the refundee address for a given incentive\n//\n// Parameters:\n//   - incentiveId (string): The ID of the incentive\n//\n// Returns:\n//   - std.Address: The refundee address of the incentive\n//\n// Panics:\n//   - If the incentive does not exist for the given incentiveId\nfunc StakerIncentiveRefundee(incentiveId string) std.Address {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tincentive, exist := incentives[incentiveId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerIncentiveRefundee() || incentiveId(%s) incentive does not exist\", incentiveId))\n\t}\n\n\treturn incentive.refundee\n}\n\n// StakerDepositOwner returns the owner address of a deposit for a given LP token ID\n//\n// Parameters:\n//   - lpTokenId (uint64): The ID of the LP token\n//\n// Returns:\n//   - std.Address: The owner address of the deposit\n//\n// Panics:\n//   - If the deposit does not exist for the given lpTokenId\nfunc StakerDepositOwner(lpTokenId uint64) std.Address {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tdeposit, exist := deposits[lpTokenId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerDepositOwner() || tokenId(%d) deposit does not exist\", lpTokenId))\n\t}\n\n\treturn deposit.owner\n}\n\n// StakerDepositNumberOfStakes returns the number of stakes for a given LP token ID\n//\n// Parameters:\n//   - lpTokenId (uint64): The ID of the LP token\n//\n// Returns:\n//   - uint64: The number of stakes for the deposit\n//\n// Panics:\n//   - If the deposit does not exist for the given lpTokenId\nfunc StakerDepositNumberOfStakes(lpTokenId uint64) uint64 {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tdeposit, exist := deposits[lpTokenId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerDepositNumberOfStakes() || tokenId(%d) deposit does not exist\", lpTokenId))\n\t}\n\n\treturn deposit.numberOfStakes\n}\n\n// StakerDepositStakeTimestamp returns the stake timestamp for a given LP token ID\n//\n// Parameters:\n//   - lpTokenId (uint64): The ID of the LP token\n//\n// Returns:\n//   - int64: The stake timestamp of the deposit\n//\n// Panics:\n//   - If the deposit does not exist for the given lpTokenId\nfunc StakerDepositStakeTimestamp(lpTokenId uint64) int64 {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tdeposit, exist := deposits[lpTokenId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerDepositStakeTimestamp() || tokenId(%d) deposit does not exist\", lpTokenId))\n\t}\n\n\treturn deposit.stakeTimestamp\n}\n\n// StakerDepositTargetPoolPath returns the target pool path for a given LP token ID\n//\n// Parameters:\n//   - lpTokenId (uint64): The ID of the LP token\n//\n// Returns:\n//   - string: The target pool path of the deposit\n//\n// Panics:\n//   - If the deposit does not exist for the given lpTokenId\nfunc StakerDepositTargetPoolPath(lpTokenId uint64) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tdeposit, exist := deposits[lpTokenId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerDepositTargetPoolPath() || tokenId(%d) deposit does not exist\", lpTokenId))\n\t}\n\n\treturn deposit.targetPoolPath\n}\n\n// StakerPoolTier returns the tier of a given pool\n//\n// Parameters:\n//   - poolPath (string): The path of the pool\n//\n// Returns:\n//   - uint64: The tier of the pool\n//\n// Panics:\n//   - If the pool tier does not exist for the given poolPath\nfunc StakerPoolTier(poolPath string) uint64 {\n\tinternal, exist := poolTiers[poolPath]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _GET_no_receiver__StakerPoolTier() || poolPath(%s) poolTier does not exist\", poolPath))\n\t}\n\n\treturn internal.tier\n}\n\n// DEBUG INTERNAL (GNS EMISSION)\ntype currentInfo struct {\n\theight           int64\n\ttime             int64\n\tgnsStaker        uint64\n\tgnsDevOps        uint64\n\tgnsCommunityPool uint64\n\tgnsXGNS          uint64\n\tgnsProtocolFee   uint64\n\tgnsGSA           uint64\n}\n\nfunc getCurrentInfo() currentInfo {\n\treturn currentInfo{\n\t\theight:           std.GetHeight(),\n\t\ttime:             time.Now().Unix(),\n\t\tgnsStaker:        gns.BalanceOf(a2u(consts.STAKER_ADDR)),\n\t\tgnsDevOps:        gns.BalanceOf(a2u(consts.DEV_OPS)),\n\t\tgnsCommunityPool: gns.BalanceOf(a2u(consts.COMMUNITY_POOL_ADDR)),\n\t\tgnsXGNS:          gns.BalanceOf(a2u(consts.X_GNS_ADDR)),\n\t\tgnsProtocolFee:   gns.BalanceOf(a2u(consts.PROTOCOL_FEE_ADDR)),\n\t\tgnsGSA:           gns.BalanceOf(a2u(consts.GNOSWAP_ADMIN)),\n\t}\n}\n\nfunc printInfo(prev currentInfo) currentInfo {\n\tcurr := getCurrentInfo()\n\n\tprintln(\"***********************\")\n\tprintln(\"\u003e height:\", curr.height)\n\tprintln(\"\u003e height inc by:\", curr.height-prev.height)\n\tprintln()\n\tprintln(\"\u003e time:\", curr.time)\n\tprintln(\"\u003e time inc by:\", curr.time-prev.time)\n\tprintln()\n\tprintln(\"GNS BALANCE CHANGE\")\n\tprintln(\"\u003e staker_bal\\t\\t\", curr.gnsStaker)\n\tprintln(\"\u003e staker_chg\\t\\t\", int64(curr.gnsStaker-prev.gnsStaker))\n\tprintln()\n\tprintln(\"\u003e dev ops\\t\\t\", curr.gnsDevOps)\n\tprintln(\"\u003e dev ops_chg\\t\\t\", int(curr.gnsDevOps-prev.gnsDevOps))\n\tprintln()\n\tprintln(\"\u003e community pool_bal\\t\", curr.gnsCommunityPool)\n\tprintln(\"\u003e community pool_chg\\t\", int(curr.gnsCommunityPool-prev.gnsCommunityPool))\n\tprintln()\n\tprintln(\"\u003e x_gns_bal\\t\\t\", curr.gnsXGNS)\n\tprintln(\"\u003e x_gns_chg\\t\\t\", int(curr.gnsXGNS-prev.gnsXGNS))\n\tprintln()\n\tprintln(\"\u003e protocol fee_bal\\t\", curr.gnsProtocolFee)\n\tprintln(\"\u003e protocol fee_chg\\t\", int(curr.gnsProtocolFee-prev.gnsProtocolFee))\n\tprintln()\n\tprintln(\"\u003e GSA_bal\\t\\t\", curr.gnsGSA)\n\tprintln(\"\u003e GSA_chg\\t\\t\", int(curr.gnsGSA-prev.gnsGSA))\n\tprintln()\n\tprintln(\"GNS POOL\")\n\tfor k, v := range poolGns {\n\t\tprintln(\"\u003e poolPath:\", k, \"amount:\", v)\n\t}\n\tprintln()\n\n\tprintln(\"GNS POSITION\")\n\tfor k, v := range positionGns {\n\t\tposWarmCalc := positionsInternalWarmUpAmount[k]\n\t\tprintln(\"\u003e tokenId:\", k, \"amount:\", v, \"warmUp:\", getRewardRatio(curr.height-deposits[k].stakeHeight))\n\t\tprintln(\"\u003e 100%\", \"full\", posWarmCalc.full100, \"give\", posWarmCalc.give100)\n\t\tprintln(\"\u003e 70%\", \"full\", posWarmCalc.full70, \"give\", posWarmCalc.give70)\n\t\tprintln(\"\u003e 50%\", \"full\", posWarmCalc.full50, \"give\", posWarmCalc.give50)\n\t\tprintln(\"\u003e 30%\", \"full\", posWarmCalc.full30, \"give\", posWarmCalc.give30)\n\t\tprintln()\n\t}\n\n\tprintln()\n\n\treturn curr\n}\n\ntype ApiEmissionDebugInfo struct {\n\tHeight           int64                  `json:\"height\"`\n\tTime             int64                  `json:\"time\"`\n\tGnsStaker        uint64                 `json:\"gnsStaker\"`\n\tGnsDevOps        uint64                 `json:\"gnsDevOps\"`\n\tGnsCommunityPool uint64                 `json:\"gnsCommunityPool\"`\n\tGnsXGNS          uint64                 `json:\"gnsXGNS\"`\n\tGnsProtocolFee   uint64                 `json:\"gnsProtocolFee\"`\n\tGnsGSA           uint64                 `json:\"gnsGSA\"`\n\tPool             []ApiEmissionDebugPool `json:\"pool\"`\n}\n\ntype ApiEmissionDebugPool struct {\n\tPoolPath          string                     `json:\"poolPath\"`\n\tTier              uint64                     `json:\"tier\"`\n\tNumPoolInSameTier uint64                     `json:\"numPoolInSameTier\"`\n\tPoolReward        uint64                     `json:\"poolReward\"`\n\tPosition          []ApiEmissionDebugPosition `json:\"position\"`\n}\n\ntype ApiEmissionDebugPosition struct {\n\tLpTokenId       uint64 `json:\"lpTokenId\"`\n\tStakedHeight    int64  `json:\"stakedHeight\"`\n\tStakedTimestamp int64  `json:\"stakedTimestamp\"`\n\tStakedDuration  int64  `json:\"stakedDuration\"`\n\tFullAmount      uint64 `json:\"fullAmount\"`\n\tRatio           uint64 `json:\"ratio\"`\n\tRatioAmount     uint64 `json:\"ratioAmount\"`\n}\n\nfunc GetPrintInfo() string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\temissionDebug := ApiEmissionDebugInfo{}\n\temissionDebug.Height = std.GetHeight()\n\temissionDebug.Time = time.Now().Unix()\n\temissionDebug.GnsStaker = gns.BalanceOf(a2u(consts.STAKER_ADDR))\n\temissionDebug.GnsDevOps = gns.BalanceOf(a2u(consts.DEV_OPS))\n\temissionDebug.GnsCommunityPool = gns.BalanceOf(a2u(consts.COMMUNITY_POOL_ADDR))\n\temissionDebug.GnsXGNS = gns.BalanceOf(a2u(consts.X_GNS_ADDR))\n\temissionDebug.GnsProtocolFee = gns.BalanceOf(a2u(consts.PROTOCOL_FEE_ADDR))\n\temissionDebug.GnsGSA = gns.BalanceOf(a2u(consts.GNOSWAP_ADMIN))\n\n\tfor poolPath, internal := range poolTiers {\n\t\ttier := internal.tier\n\t\tpool := ApiEmissionDebugPool{}\n\t\tpool.PoolPath = poolPath\n\t\tpool.Tier = tier\n\n\t\tnumTier1, numTier2, numTier3 := getNumPoolTiers()\n\t\tif tier == 1 {\n\t\t\tpool.NumPoolInSameTier = numTier1\n\t\t} else if tier == 2 {\n\t\t\tpool.NumPoolInSameTier = numTier2\n\t\t} else if tier == 3 {\n\t\t\tpool.NumPoolInSameTier = numTier3\n\t\t}\n\n\t\tpool.PoolReward = poolGns[poolPath]\n\n\t\tfor lpTokenId, deposit := range deposits {\n\t\t\tif deposit.targetPoolPath == poolPath {\n\t\t\t\tposition := ApiEmissionDebugPosition{}\n\t\t\t\tposition.LpTokenId = lpTokenId\n\t\t\t\tposition.StakedHeight = deposit.stakeHeight\n\t\t\t\tposition.StakedTimestamp = deposit.stakeTimestamp\n\t\t\t\tposition.StakedDuration = emissionDebug.Height - deposit.stakeHeight\n\n\t\t\t\tposition.FullAmount = positionGns[lpTokenId]\n\t\t\t\tposition.Ratio = getRewardRatio(position.StakedDuration)\n\t\t\t\tposition.RatioAmount = (position.FullAmount * position.Ratio) / 100\n\n\t\t\t\tpool.Position = append(pool.Position, position)\n\t\t\t}\n\t\t}\n\n\t\temissionDebug.Pool = append(emissionDebug.Pool, pool)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\": json.NumberNode(\"\", float64(emissionDebug.Height)),\n\t\t\"time\":   json.NumberNode(\"\", float64(emissionDebug.Time)),\n\t\t\"gns\": json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"staker\":        json.NumberNode(\"\", float64(emissionDebug.GnsStaker)),\n\t\t\t\"devOps\":        json.NumberNode(\"\", float64(emissionDebug.GnsDevOps)),\n\t\t\t\"communityPool\": json.NumberNode(\"\", float64(emissionDebug.GnsCommunityPool)),\n\t\t\t\"xGNS\":          json.NumberNode(\"\", float64(emissionDebug.GnsXGNS)),\n\t\t\t\"protocolFee\":   json.NumberNode(\"\", float64(emissionDebug.GnsProtocolFee)),\n\t\t\t\"GnoswapAdmin\":  json.NumberNode(\"\", float64(emissionDebug.GnsGSA)),\n\t\t}),\n\t\t\"pool\": json.ArrayNode(\"\", makePoolsNode(emissionDebug.Pool)),\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\treturn \"JSON MARSHAL ERROR\"\n\t}\n\n\treturn string(b)\n}\n\nfunc makePoolsNode(emissionPool []ApiEmissionDebugPool) []*json.Node {\n\tpools := make([]*json.Node, 0)\n\n\tfor poolPath, internal := range poolTiers {\n\t\tnumTier1, numTier2, numTier3 := getNumPoolTiers()\n\t\tnumPoolSameTier := uint64(0)\n\t\ttier := internal.tier\n\t\tif tier == 1 {\n\t\t\tnumPoolSameTier = numTier1\n\t\t} else if tier == 2 {\n\t\t\tnumPoolSameTier = numTier2\n\t\t} else if tier == 3 {\n\t\t\tnumPoolSameTier = numTier3\n\t\t}\n\n\t\tpools = append(pools, json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"poolPath\":        json.StringNode(\"poolPath\", poolPath),\n\t\t\t\"startTimestamp\":  json.NumberNode(\"startTimestamp\", float64(internal.startTimestamp)),\n\t\t\t\"tier\":            json.NumberNode(\"tier\", float64(tier)),\n\t\t\t\"numPoolSameTier\": json.NumberNode(\"numPoolSameTier\", float64(numPoolSameTier)),\n\t\t\t\"poolReward\":      json.NumberNode(\"poolReward\", float64(poolGns[poolPath])),\n\t\t\t\"position\":        json.ArrayNode(\"\", makePositionsNode(poolPath)),\n\t\t}))\n\t}\n\n\treturn pools\n}\n\nfunc makePositionsNode(poolPath string) []*json.Node {\n\tpositions := make([]*json.Node, 0)\n\n\tfor lpTokenId, deposit := range deposits {\n\t\tif deposit.targetPoolPath == poolPath {\n\t\t\tstakedDuration := std.GetHeight() - deposit.stakeHeight\n\t\t\tratio := getRewardRatio(stakedDuration)\n\t\t\tfullAmount, warmUpAmount := rewardMathComputeInternalRewardAmount(lpTokenId)\n\n\t\t\tposCalcWarm := positionsInternalWarmUpAmount[lpTokenId]\n\n\t\t\tpositions = append(positions, json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\t\"lpTokenId\":       json.NumberNode(\"lpTokenId\", float64(lpTokenId)),\n\t\t\t\t\"stakedHeight\":    json.NumberNode(\"stakedHeight\", float64(deposit.stakeHeight)),\n\t\t\t\t\"stakedTimestamp\": json.NumberNode(\"stakedTimestamp\", float64(deposit.stakeTimestamp)),\n\t\t\t\t\"stakedDuration\":  json.NumberNode(\"stakedDuration\", float64(stakedDuration)),\n\t\t\t\t\"fullAmount\":      json.NumberNode(\"fullAmount\", float64(fullAmount)),\n\t\t\t\t\"ratio\":           json.NumberNode(\"ratio\", float64(ratio)),\n\t\t\t\t\"warmUpAmount\":    json.NumberNode(\"warmUpAmount\", float64(warmUpAmount)),\n\t\t\t\t\"full30\":          json.NumberNode(\"full30\", float64(posCalcWarm.full30)),\n\t\t\t\t\"give30\":          json.NumberNode(\"give30\", float64(posCalcWarm.give30)),\n\t\t\t\t\"full50\":          json.NumberNode(\"full50\", float64(posCalcWarm.full50)),\n\t\t\t\t\"give50\":          json.NumberNode(\"give50\", float64(posCalcWarm.give50)),\n\t\t\t\t\"full70\":          json.NumberNode(\"full70\", float64(posCalcWarm.full70)),\n\t\t\t\t\"give70\":          json.NumberNode(\"give70\", float64(posCalcWarm.give70)),\n\t\t\t\t\"full100\":         json.NumberNode(\"full100\", float64(posCalcWarm.full100)),\n\t\t\t\t\"give100\":         json.NumberNode(\"give100\", float64(posCalcWarm.give100)),\n\t\t\t}))\n\t\t}\n\t}\n\n\treturn positions\n}\n\ntype currentExternalInfo struct {\n\theight             int64\n\ttime               int64\n\texternalIncentives []ExternalIncentive\n}\n\nfunc printExternalInfo() {\n\tprintln(\"***********************\")\n\tprintln(\"\u003e height:\", std.GetHeight())\n\tprintln(\"\u003e time:\", time.Now().Unix())\n\tprintln()\n\tprintln(\"[ START ] GET_EXTERNAL INCENTIVE\")\n\tfor poolPath, externalIds := range poolIncentives {\n\t\tprintln(\" \u003e poolPath:\", poolPath)\n\n\t\tfor _, externalId := range externalIds {\n\t\t\tincentive := incentives[externalId]\n\t\t\t// println(\"  \u003e incentiveId:\", externalId)\n\t\t\t// println(\"  \u003e targetPoolPath:\", incentive.targetPoolPath)\n\t\t\tprintln(\"  \u003e rewardToken:\", incentive.rewardToken)\n\t\t\tprintln(\"  \u003e rewardAmount:\", incentive.rewardAmount.ToString())\n\t\t\tprintln(\"  \u003e rewardLeft:\", incentive.rewardLeft.ToString())\n\t\t\tprintln(\"  \u003e startTimestamp:\", incentive.startTimestamp)\n\t\t\tprintln(\"  \u003e endTimestamp:\", incentive.endTimestamp)\n\t\t\tprintln(\"  \u003e rewardPerBlockX96:\", incentive.rewardPerBlockX96.ToString())\n\t\t\tprintln(\"  \u003e refundee:\", incentive.refundee)\n\t\t\tprintln()\n\t\t}\n\t\tprintln()\n\t}\n\n\tprintln(\"[ END ] GET_EXTERNAL INCENTIVE\")\n}\n\nfunc GetPrintExternalInfo() string {\n\t// TODO: LIMIT ONLY ABCI_QUERY CAN CALL THIS\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tupdateExternalIncentiveLeftAmount()\n\n\texternalDebug := ApiExternalDebugInfo{}\n\texternalDebug.Height = std.GetHeight()\n\texternalDebug.Time = time.Now().Unix()\n\n\texternalPositions := []ApiExternalDebugPosition{}\n\tfor lpTokenId, externals := range positionExternal {\n\t\texternalPosition := ApiExternalDebugPosition{}\n\t\texternalPosition.LpTokenId = lpTokenId\n\t\texternalPosition.StakedHeight = deposits[lpTokenId].stakeHeight\n\t\texternalPosition.StakedTimestamp = deposits[lpTokenId].stakeTimestamp\n\n\t\texternalIncentives := []ApiExternalDebugIncentive{}\n\t\tfor incentiveId, external := range externals {\n\t\t\texternalIncentive := ApiExternalDebugIncentive{}\n\n\t\t\texternalIncentive.PoolPath = external.poolPath\n\t\t\texternalIncentive.RewardToken = external.tokenPath\n\n\t\t\tincentive := incentives[incentiveId]\n\t\t\texternalIncentive.RewardAmount = incentive.rewardAmount.ToString()\n\t\t\texternalIncentive.RewardLeft = incentive.rewardLeft.ToString()\n\t\t\texternalIncentive.StartTimestamp = incentive.startTimestamp\n\t\t\texternalIncentive.EndTimestamp = incentive.endTimestamp\n\t\t\texternalIncentive.RewardPerBlockX96 = incentive.rewardPerBlockX96.ToString()\n\t\t\texternalIncentive.RewardPerBlock = new(u256.Uint).Div(incentive.rewardPerBlockX96, u256.MustFromDecimal(consts.Q96)).ToString()\n\t\t\texternalIncentive.Refundee = incentive.refundee\n\n\t\t\texternalIncentive.tokenAmountX96 = external.tokenAmountX96\n\n\t\t\tfullAmount, toGive := rewardMathComputeExternalRewardAmount(lpTokenId, incentiveId)\n\t\t\texternalIncentive.tokenAmountFull += fullAmount\n\t\t\texternalIncentive.tokenAmountActualFull += toGive\n\n\t\t\texternalIncentives = append(externalIncentives, externalIncentive)\n\t\t}\n\t\texternalPosition.Incentive = externalIncentives\n\n\t\texternalPositions = append(externalPositions, externalPosition)\n\t}\n\n\texternalDebug.Position = externalPositions\n\n\t// MARSHAL\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":   json.NumberNode(\"\", float64(externalDebug.Height)),\n\t\t\"time\":     json.NumberNode(\"\", float64(externalDebug.Time)),\n\t\t\"position\": json.ArrayNode(\"\", makeExternalPositionsNode(externalDebug.Position)),\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\treturn \"JSON MARSHAL ERROR\"\n\t}\n\n\treturn string(b)\n}\n\nfunc makeExternalPositionsNode(positions []ApiExternalDebugPosition) []*json.Node {\n\t_q96 := u256.MustFromDecimal(consts.Q96)\n\n\texternalPositions := make([]*json.Node, 0)\n\n\tfor _, externalPosition := range positions {\n\t\tincentives := make([]*json.Node, 0)\n\t\tfor _, incentive := range externalPosition.Incentive {\n\t\t\tincentives = append(incentives, json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\t\"poolPath\":              json.StringNode(\"poolPath\", incentive.PoolPath),\n\t\t\t\t\"rewardToken\":           json.StringNode(\"rewardToken\", incentive.RewardToken),\n\t\t\t\t\"rewardAmount\":          json.StringNode(\"rewardAmount\", incentive.RewardAmount),\n\t\t\t\t\"rewardLeft\":            json.StringNode(\"rewardLeft\", incentive.RewardLeft),\n\t\t\t\t\"startTimestamp\":        json.NumberNode(\"startTimestamp\", float64(incentive.StartTimestamp)),\n\t\t\t\t\"endTimestamp\":          json.NumberNode(\"endTimestamp\", float64(incentive.EndTimestamp)),\n\t\t\t\t\"rewardPerBlockX96\":     json.StringNode(\"rewardPerBlockX96\", incentive.RewardPerBlockX96),\n\t\t\t\t\"rewardPerBlock\":        json.StringNode(\"rewardPerBlock\", incentive.RewardPerBlock),\n\t\t\t\t\"refundee\":              json.StringNode(\"refundee\", incentive.Refundee.String()),\n\t\t\t\t\"tokenAmountX96\":        json.StringNode(\"tokenAmountX96\", incentive.tokenAmountX96.ToString()),\n\t\t\t\t\"tokenAmount\":           json.NumberNode(\"tokenAmount\", float64(new(u256.Uint).Div(incentive.tokenAmountX96, _q96).Uint64())),\n\t\t\t\t\"tokenAmountFull\":       json.NumberNode(\"tokenAmountFull\", float64(incentive.tokenAmountFull)),\n\t\t\t\t\"tokenAmountActualFull\": json.NumberNode(\"tokenAmountActualFull\", float64(incentive.tokenAmountActualFull)),\n\t\t\t}))\n\t\t}\n\n\t\texternalPositions = append(externalPositions, json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\":       json.NumberNode(\"lpTokenId\", float64(externalPosition.LpTokenId)),\n\t\t\t\"stakedHeight\":    json.NumberNode(\"stakedHeight\", float64(externalPosition.StakedHeight)),\n\t\t\t\"stakedTimestamp\": json.NumberNode(\"stakedTimestamp\", float64(externalPosition.StakedTimestamp)),\n\t\t\t\"incentive\":       json.ArrayNode(\"\", incentives),\n\t\t}))\n\t}\n\n\treturn externalPositions\n}\n\ntype ApiExternalDebugInfo struct {\n\tHeight   int64                      `json:\"height\"`\n\tTime     int64                      `json:\"time\"`\n\tPosition []ApiExternalDebugPosition `json:\"pool\"`\n}\n\ntype ApiExternalDebugPosition struct {\n\tLpTokenId       uint64                      `json:\"lpTokenId\"`\n\tStakedHeight    int64                       `json:\"stakedHeight\"`\n\tStakedTimestamp int64                       `json:\"stakedTimestamp\"`\n\tIncentive       []ApiExternalDebugIncentive `json:\"incentive\"`\n}\n\ntype ApiExternalDebugIncentive struct {\n\tPoolPath          string      `json:\"poolPath\"`\n\tRewardToken       string      `json:\"rewardToken\"`\n\tRewardAmount      string      `json:\"rewardAmount\"`\n\tRewardLeft        string      `json:\"rewardLeft\"`\n\tStartTimestamp    int64       `json:\"startTimestamp\"`\n\tEndTimestamp      int64       `json:\"endTimestamp\"`\n\tRewardPerBlockX96 string      `json:\"rewardPerBlockX96\"`\n\tRewardPerBlock    string      `json:\"rewardPerBlock\"`\n\tRefundee          std.Address `json:\"refundee\"`\n\t// FROM externalRewards\n\ttokenAmountX96        *u256.Uint `json:\"tokenAmountX96\"`\n\ttokenAmount           uint64     `json:\"tokenAmount\"`\n\ttokenAmountFull       uint64     `json:\"tokenAmountFull\"`\n\ttokenAmountActualFull uint64     `json:\"tokenAmountActualFull\"`\n}\n"},{"name":"_RPC_api_incentive.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\n\ten \"gno.land/r/gnoswap/v2/emission\"\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/r/gnoswap/v2/gns\"\n)\n\ntype RewardToken struct {\n\tPoolPath         string   `json:\"poolPath\"`\n\tRewardsTokenList []string `json:\"rewardsTokenList\"`\n}\n\ntype ApiExternalIncentive struct {\n\tIncentiveId    string `json:\"incentiveId\"`\n\tPoolPath       string `json:\"poolPath\"`\n\tRewardToken    string `json:\"rewardToken\"`\n\tRewardAmount   string `json:\"rewardAmount\"`\n\tRewardLeft     string `json:\"rewardLeft\"`\n\tStartTimestamp int64  `json:\"startTimestamp\"`\n\tEndTimestamp   int64  `json:\"endTimestamp\"`\n\tActive         bool   `json:\"active\"`\n\tRefundee       string `json:\"refundee\"`\n\tCreatedHeight  int64  `json:\"createdHeight\"`\n}\n\ntype ApiInternalIncentive struct {\n\tPoolPath       string `json:\"poolPath\"`\n\tTier           uint64 `json:\"tier\"`\n\tStartTimestamp int64  `json:\"startTimestamp\"`\n\tRewardPerBlock string `json:\"rewardPerBlock\"`\n}\n\nfunc ApiGetRewardTokens() string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\trewardTokens := []RewardToken{}\n\n\tpoolList := pl.PoolGetPoolList()\n\tfor _, poolPath := range poolList {\n\t\tthisPoolRewardTokens := []string{}\n\n\t\t// HANDLE INTERNAL\n\t\t_, ok := poolTiers[poolPath]\n\t\tif ok {\n\t\t\tthisPoolRewardTokens = append(thisPoolRewardTokens, consts.GNS_PATH)\n\t\t}\n\n\t\t// HANDLE EXTERNAL\n\t\tfor _, incentiveId := range poolIncentives[poolPath] {\n\t\t\tif incentives[incentiveId].rewardToken == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthisPoolRewardTokens = append(thisPoolRewardTokens, incentives[incentiveId].rewardToken)\n\t\t}\n\n\t\tif len(thisPoolRewardTokens) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\trewardTokens = append(rewardTokens, RewardToken{\n\t\t\tPoolPath:         poolPath,\n\t\t\tRewardsTokenList: thisPoolRewardTokens,\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, rewardToken := range rewardTokens {\n\t\t_rewardTokenNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"poolPath\": json.StringNode(\"poolPath\", rewardToken.PoolPath),\n\t\t\t\"tokens\":   json.ArrayNode(\"tokens\", makeRewardTokensArray(rewardToken.RewardsTokenList)),\n\t\t})\n\t\tresponses.AppendArray(_rewardTokenNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetRewardTokens() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetRewardTokensByPoolPath(targetPoolPath string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\trewardTokens := []RewardToken{}\n\n\tpoolList := pl.PoolGetPoolList()\n\tfor _, poolPath := range poolList {\n\t\tif poolPath != targetPoolPath {\n\t\t\tcontinue\n\t\t}\n\n\t\tthisPoolRewardTokens := []string{}\n\n\t\t// HANDLE INTERNAL\n\t\t_, ok := poolTiers[poolPath]\n\t\tif ok {\n\t\t\tthisPoolRewardTokens = append(thisPoolRewardTokens, consts.GNS_PATH)\n\t\t}\n\n\t\t// HANDLE EXTERNAL\n\t\tfor _, incentiveId := range poolIncentives[poolPath] {\n\t\t\tthisPoolRewardTokens = append(thisPoolRewardTokens, incentives[incentiveId].rewardToken)\n\t\t}\n\n\t\trewardTokens = append(rewardTokens, RewardToken{\n\t\t\tPoolPath:         poolPath,\n\t\t\tRewardsTokenList: thisPoolRewardTokens,\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, rewardToken := range rewardTokens {\n\t\t_rewardTokenNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"poolPath\": json.StringNode(\"poolPath\", rewardToken.PoolPath),\n\t\t\t\"tokens\":   json.ArrayNode(\"tokens\", makeRewardTokensArray(rewardToken.RewardsTokenList)),\n\t\t})\n\t\tresponses.AppendArray(_rewardTokenNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetRewardTokensByPoolPath() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetExternalIncentives() string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tupdateExternalIncentiveLeftAmount()\n\n\tapiExternalIncentives := []ApiExternalIncentive{}\n\n\tfor incentiveId, incentive := range incentives {\n\t\tapiExternalIncentives = append(apiExternalIncentives, ApiExternalIncentive{\n\t\t\tIncentiveId:    incentiveId,\n\t\t\tPoolPath:       incentive.targetPoolPath,\n\t\t\tRewardToken:    incentive.rewardToken,\n\t\t\tRewardAmount:   incentive.rewardAmount.ToString(),\n\t\t\tRewardLeft:     incentive.rewardLeft.ToString(),\n\t\t\tStartTimestamp: incentive.startTimestamp,\n\t\t\tEndTimestamp:   incentive.endTimestamp,\n\t\t\tRefundee:       incentive.refundee.String(),\n\t\t\tCreatedHeight:  incentive.createdHeight,\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, incentive := range apiExternalIncentives {\n\t\tactive := false\n\t\tif time.Now().Unix() \u003e= incentive.StartTimestamp \u0026\u0026 time.Now().Unix() \u003c= incentive.EndTimestamp {\n\t\t\tactive = true\n\t\t}\n\n\t\t_incentiveNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"incentiveId\":    json.StringNode(\"incentiveId\", incentive.IncentiveId),\n\t\t\t\"poolPath\":       json.StringNode(\"poolPath\", incentive.PoolPath),\n\t\t\t\"rewardToken\":    json.StringNode(\"rewardToken\", incentive.RewardToken),\n\t\t\t\"rewardAmount\":   json.StringNode(\"rewardAmount\", incentive.RewardAmount),\n\t\t\t\"rewardLeft\":     json.StringNode(\"rewardLeft\", incentive.RewardLeft),\n\t\t\t\"startTimestamp\": json.NumberNode(\"startTimestamp\", float64(incentive.StartTimestamp)),\n\t\t\t\"endTimestamp\":   json.NumberNode(\"endTimestamp\", float64(incentive.EndTimestamp)),\n\t\t\t\"active\":         json.BoolNode(\"active\", active),\n\t\t\t\"refundee\":       json.StringNode(\"refundee\", incentive.Refundee),\n\t\t\t\"createdHeight\":  json.NumberNode(\"createdHeight\", float64(incentive.CreatedHeight)),\n\t\t})\n\t\tresponses.AppendArray(_incentiveNode)\n\t}\n\n\t// RETURN\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetExternalIncentives() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetExternalIncentivesByPoolPath(targetPoolPath string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tupdateExternalIncentiveLeftAmount()\n\n\tapiExternalIncentives := []ApiExternalIncentive{}\n\n\tfor incentiveId, incentive := range incentives {\n\t\tif incentive.targetPoolPath != targetPoolPath {\n\t\t\tcontinue\n\t\t}\n\n\t\tapiExternalIncentives = append(apiExternalIncentives, ApiExternalIncentive{\n\t\t\tIncentiveId:    incentiveId,\n\t\t\tPoolPath:       incentive.targetPoolPath,\n\t\t\tRewardToken:    incentive.rewardToken,\n\t\t\tRewardAmount:   incentive.rewardAmount.ToString(),\n\t\t\tRewardLeft:     incentive.rewardLeft.ToString(),\n\t\t\tStartTimestamp: incentive.startTimestamp,\n\t\t\tEndTimestamp:   incentive.endTimestamp,\n\t\t\tRefundee:       incentive.refundee.String(),\n\t\t\tCreatedHeight:  incentive.createdHeight,\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, incentive := range apiExternalIncentives {\n\t\tactive := false\n\t\tif time.Now().Unix() \u003e= incentive.StartTimestamp \u0026\u0026 time.Now().Unix() \u003c= incentive.EndTimestamp {\n\t\t\tactive = true\n\t\t}\n\n\t\t_incentiveNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"incentiveId\":    json.StringNode(\"incentiveId\", incentive.IncentiveId),\n\t\t\t\"poolPath\":       json.StringNode(\"poolPath\", incentive.PoolPath),\n\t\t\t\"rewardToken\":    json.StringNode(\"rewardToken\", incentive.RewardToken),\n\t\t\t\"rewardAmount\":   json.StringNode(\"rewardAmount\", incentive.RewardAmount),\n\t\t\t\"rewardLeft\":     json.StringNode(\"rewardLeft\", incentive.RewardLeft),\n\t\t\t\"startTimestamp\": json.NumberNode(\"startTimestamp\", float64(incentive.StartTimestamp)),\n\t\t\t\"endTimestamp\":   json.NumberNode(\"endTimestamp\", float64(incentive.EndTimestamp)),\n\t\t\t\"active\":         json.BoolNode(\"active\", active),\n\t\t\t\"refundee\":       json.StringNode(\"refundee\", incentive.Refundee),\n\t\t\t\"createdHeight\":  json.NumberNode(\"createdHeight\", float64(incentive.CreatedHeight)),\n\t\t})\n\t\tresponses.AppendArray(_incentiveNode)\n\t}\n\n\t// RETURN\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetExternalIncentivesByPoolPath() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetExternalIncentivesByRewardTokenPath(rewardTokenPath string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tupdateExternalIncentiveLeftAmount()\n\n\tapiExternalIncentives := []ApiExternalIncentive{}\n\n\tfor incentiveId, incentive := range incentives {\n\t\tif incentive.rewardToken != rewardTokenPath {\n\t\t\tcontinue\n\t\t}\n\n\t\tapiExternalIncentives = append(apiExternalIncentives, ApiExternalIncentive{\n\t\t\tIncentiveId:    incentiveId,\n\t\t\tPoolPath:       incentive.targetPoolPath,\n\t\t\tRewardToken:    incentive.rewardToken,\n\t\t\tRewardAmount:   incentive.rewardAmount.ToString(),\n\t\t\tRewardLeft:     incentive.rewardLeft.ToString(),\n\t\t\tStartTimestamp: incentive.startTimestamp,\n\t\t\tEndTimestamp:   incentive.endTimestamp,\n\t\t\tRefundee:       incentive.refundee.String(),\n\t\t\tCreatedHeight:  incentive.createdHeight,\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, incentive := range apiExternalIncentives {\n\t\tactive := false\n\t\tif time.Now().Unix() \u003e= incentive.StartTimestamp \u0026\u0026 time.Now().Unix() \u003c= incentive.EndTimestamp {\n\t\t\tactive = true\n\t\t}\n\n\t\t_incentiveNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"incentiveId\":    json.StringNode(\"incentiveId\", incentive.IncentiveId),\n\t\t\t\"poolPath\":       json.StringNode(\"poolPath\", incentive.PoolPath),\n\t\t\t\"rewardToken\":    json.StringNode(\"rewardToken\", incentive.RewardToken),\n\t\t\t\"rewardAmount\":   json.StringNode(\"rewardAmount\", incentive.RewardAmount),\n\t\t\t\"rewardLeft\":     json.StringNode(\"rewardLeft\", incentive.RewardLeft),\n\t\t\t\"startTimestamp\": json.NumberNode(\"startTimestamp\", float64(incentive.StartTimestamp)),\n\t\t\t\"endTimestamp\":   json.NumberNode(\"endTimestamp\", float64(incentive.EndTimestamp)),\n\t\t\t\"active\":         json.BoolNode(\"active\", active),\n\t\t\t\"refundee\":       json.StringNode(\"refundee\", incentive.Refundee),\n\t\t\t\"createdHeight\":  json.NumberNode(\"createdHeight\", float64(incentive.CreatedHeight)),\n\t\t})\n\t\tresponses.AppendArray(_incentiveNode)\n\t}\n\n\t// RETURN\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetExternalIncentivesByRewardTokenPath() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetInternalIncentives() string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tapiInternalIncentives := []ApiInternalIncentive{}\n\n\tfor poolPath, internal := range poolTiers {\n\t\tapiInternalIncentives = append(apiInternalIncentives, ApiInternalIncentive{\n\t\t\tPoolPath:       poolPath,\n\t\t\tTier:           internal.tier,\n\t\t\tStartTimestamp: internal.startTimestamp,\n\t\t\tRewardPerBlock: calculateInternalRewardPerBlockByPoolPath(poolPath),\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, incentive := range apiInternalIncentives {\n\t\t_incentiveNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"poolPath\":       json.StringNode(\"poolPath\", incentive.PoolPath),\n\t\t\t\"rewardToken\":    json.StringNode(\"rewardToken\", consts.GNS_PATH),\n\t\t\t\"tier\":           json.NumberNode(\"tier\", float64(incentive.Tier)),\n\t\t\t\"startTimestamp\": json.NumberNode(\"startTimestamp\", float64(incentive.StartTimestamp)),\n\t\t\t\"rewardPerBlock\": json.StringNode(\"rewardPerBlock\", incentive.RewardPerBlock),\n\t\t\t\"accuGns\":        json.NumberNode(\"accuGns\", float64(poolAccuGns[incentive.PoolPath])),\n\t\t})\n\t\tresponses.AppendArray(_incentiveNode)\n\t}\n\n\t// RETURN\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetInternalIncentives() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetInternalIncentivesByPoolPath(targetPoolPath string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tapiInternalIncentives := []ApiInternalIncentive{}\n\n\tfor poolPath, internal := range poolTiers {\n\t\tif poolPath != targetPoolPath {\n\t\t\tcontinue\n\t\t}\n\n\t\tapiInternalIncentives = append(apiInternalIncentives, ApiInternalIncentive{\n\t\t\tPoolPath:       poolPath,\n\t\t\tTier:           internal.tier,\n\t\t\tStartTimestamp: internal.startTimestamp,\n\t\t\tRewardPerBlock: calculateInternalRewardPerBlockByPoolPath(poolPath),\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, incentive := range apiInternalIncentives {\n\t\t_incentiveNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"poolPath\":       json.StringNode(\"poolPath\", incentive.PoolPath),\n\t\t\t\"rewardToken\":    json.StringNode(\"rewardToken\", consts.GNS_PATH),\n\t\t\t\"tier\":           json.NumberNode(\"tier\", float64(incentive.Tier)),\n\t\t\t\"startTimestamp\": json.NumberNode(\"startTimestamp\", float64(incentive.StartTimestamp)),\n\t\t\t\"rewardPerBlock\": json.StringNode(\"rewardPerBlock\", incentive.RewardPerBlock),\n\t\t\t\"accuGns\":        json.NumberNode(\"accuGns\", float64(poolAccuGns[targetPoolPath])),\n\t\t})\n\t\tresponses.AppendArray(_incentiveNode)\n\t}\n\n\t// RETURN\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetInternalIncentivesByPoolPath() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetInternalIncentivesByTiers(targetTier uint64) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tapiInternalIncentives := []ApiInternalIncentive{}\n\n\tfor poolPath, internal := range poolTiers {\n\t\tif internal.tier != targetTier {\n\t\t\tcontinue\n\t\t}\n\n\t\tapiInternalIncentives = append(apiInternalIncentives, ApiInternalIncentive{\n\t\t\tPoolPath:       poolPath,\n\t\t\tTier:           internal.tier,\n\t\t\tStartTimestamp: internal.startTimestamp,\n\t\t\tRewardPerBlock: calculateInternalRewardPerBlockByPoolPath(poolPath),\n\t\t})\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, incentive := range apiInternalIncentives {\n\t\t_incentiveNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"poolPath\":       json.StringNode(\"poolPath\", incentive.PoolPath),\n\t\t\t\"rewardToken\":    json.StringNode(\"rewardToken\", consts.GNS_PATH),\n\t\t\t\"tier\":           json.NumberNode(\"tier\", float64(incentive.Tier)),\n\t\t\t\"startTimestamp\": json.NumberNode(\"startTimestamp\", float64(incentive.StartTimestamp)),\n\t\t\t\"rewardPerBlock\": json.StringNode(\"rewardPerBlock\", incentive.RewardPerBlock),\n\t\t\t\"accuGns\":        json.NumberNode(\"accuGns\", float64(poolAccuGns[incentive.PoolPath])),\n\t\t})\n\t\tresponses.AppendArray(_incentiveNode)\n\t}\n\n\t// RETURN\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetInternalIncentivesByTiers() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc makeRewardTokensArray(rewardsTokenList []string) []*json.Node {\n\trewardsTokenArray := make([]*json.Node, len(rewardsTokenList))\n\tfor i, rewardToken := range rewardsTokenList {\n\t\trewardsTokenArray[i] = json.StringNode(\"\", rewardToken)\n\t}\n\treturn rewardsTokenArray\n}\n\nfunc calculateInternalRewardPerBlockByPoolPath(poolPath string) string {\n\tnowHeight := std.GetHeight()\n\tfullGnsForThisHeight := gns.GetAmountByHeight(nowHeight)\n\n\t// staker distribution pct\n\tbpsPct := en.GetDistributionPct(1)\n\n\t// calculate reward per block\n\tstakerGns := fullGnsForThisHeight * bpsPct / 10000\n\n\ttier1Amount, tier2Amount, tier3Amount := getTiersAmount(stakerGns)\n\ttier1Num, tier2Num, tier3Num := getNumPoolTiers()\n\n\ttier := poolTiers[poolPath].tier\n\n\tif tier == 1 {\n\t\treturn ufmt.Sprintf(\"%d\", tier1Amount/tier1Num)\n\t} else if tier == 2 {\n\t\treturn ufmt.Sprintf(\"%d\", tier2Amount/tier2Num)\n\t} else if tier == 3 {\n\t\treturn ufmt.Sprintf(\"%d\", tier3Amount/tier3Num)\n\t}\n\n\treturn \"0\"\n}\n\nfunc updateExternalIncentiveLeftAmount() {\n\t// external incentive reward left update\n\tfor _, positionWarmUpAmount := range positionsExternalWarmUpAmount {\n\t\tfor incentiveId, warmUpAmount := range positionWarmUpAmount {\n\n\t\t\tfull := warmUpAmount.full100 + warmUpAmount.full70 + warmUpAmount.full50 + warmUpAmount.full30\n\n\t\t\tincentive := incentives[incentiveId]\n\t\t\tincentive.rewardLeft = new(u256.Uint).Sub(incentive.rewardLeft, u256.NewUint(full))\n\t\t\tincentives[incentiveId] = incentive\n\t\t}\n\t}\n}\n"},{"name":"_RPC_api_stake.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ten \"gno.land/r/gnoswap/v2/emission\"\n)\n\n// LpTokenReward represents the rewards associated with a specific LP token\ntype LpTokenReward struct {\n\tLpTokenId uint64   `json:\"lpTokenId\"` // The ID of the LP token\n\tAddress   string   `json:\"address\"`   // The address associated with the LP token\n\tRewards   []Reward `json:\"rewards\"`\n}\n\n// Reward represents a single reward for a staked LP token\ntype Reward struct {\n\tIncentiveType     string `json:\"incentiveType\"`     // The type of incentive (INTERNAL or EXTERNAL)\n\tIncentiveId       string `json:\"incentiveId\"`       // The unique identifier of the incentive\n\tTargetPoolPath    string `json:\"targetPoolPath\"`    // The path of the target pool for the reward\n\tRewardTokenPath   string `json:\"rewardTokenPath\"`   // The pathe of the reward token\n\tRewardTokenAmount uint64 `json:\"rewardTokenAmount\"` // The amount of the reward token\n\tStakeTimestamp    int64  `json:\"stakeTimestamp\"`    // The timestamp when the LP token was staked\n\tStakeHeight       int64  `json:\"stakeHeight\"`       // The block height when the LP token was staked\n\tIncentiveStart    int64  `json:\"incentiveStart\"`    // The timestamp when the incentive started\n}\n\n// Stake represents a single stake\ntype Stake struct {\n\tTokenId        uint64      `json:\"tokenId\"`        // The ID of the staked LP token\n\tOwner          std.Address `json:\"owner\"`          // The address of the owner of the staked LP token\n\tNumberOfStakes uint64      `json:\"numberOfStakes\"` // The number of times this LP token has been staked\n\tStakeTimestamp int64       `json:\"stakeTimestamp\"` // The timestamp when the LP token was staked\n\tStakeHeight    int64       `json:\"stakeHeight\"`    // The block height when the LP token was staked\n\tTargetPoolPath string      `json:\"targetPoolPath\"` // The path of the target pool for the stake\n}\n\n// ResponseQueryBase contains basic information about a query response.\ntype ResponseQueryBase struct {\n\tHeight    int64 `json:\"height\"`    // The block height at the time of the query\n\tTimestamp int64 `json:\"timestamp\"` // The timestamp at the time of the query\n}\n\n// ResponseApiGetRewards represents the API response for getting rewards.\ntype ResponseApiGetRewards struct {\n\tStat     ResponseQueryBase `json:\"stat\"`     // Basic query information\n\tResponse []LpTokenReward   `json:\"response\"` // A slice of LpTokenReward structs\n}\n\n// ResponseApiGetRewardByLpTokenId represents the API response for getting rewards for a specific LP token.\ntype ResponseApiGetRewardByLpTokenId struct {\n\tStat     ResponseQueryBase `json:\"stat\"`     // Basic query information\n\tResponse LpTokenReward     `json:\"response\"` // The LpTokenReward for the specified LP token\n}\n\n// ResponseApiGetStakes represents the API response for getting stakes.\ntype ResponseApiGetStakes struct {\n\tStat     ResponseQueryBase `json:\"stat\"`     // Basic query information\n\tResponse []Stake           `json:\"response\"` // A slice of Stake structs\n}\n\nfunc ApiGetRewards() string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tlpTokenRewards := []LpTokenReward{}\n\n\tfor tokenId, deposit := range deposits {\n\t\trewards := []Reward{}\n\n\t\t// get internal gns reward\n\t\t_, internalGNS := rewardMathComputeInternalRewardAmount(tokenId)\n\t\tif internalGNS \u003e 0 {\n\t\t\trewards = append(rewards, Reward{\n\t\t\t\tIncentiveType:     \"INTERNAL\",\n\t\t\t\tIncentiveId:       \"\",\n\t\t\t\tTargetPoolPath:    deposit.targetPoolPath,\n\t\t\t\tRewardTokenPath:   consts.GNS_PATH,\n\t\t\t\tRewardTokenAmount: internalGNS,\n\t\t\t\tStakeTimestamp:    deposit.stakeTimestamp,\n\t\t\t\tStakeHeight:       deposit.stakeHeight,\n\t\t\t\tIncentiveStart:    deposit.stakeTimestamp,\n\t\t\t})\n\t\t}\n\n\t\t// find all external reward list for poolPath which lpTokenId is staked\n\t\tfor _, incentiveId := range poolIncentives[deposit.targetPoolPath] {\n\t\t\tincentive := incentives[incentiveId]\n\n\t\t\tstakedOrCreatedAt := max(deposit.stakeTimestamp, incentive.startTimestamp)\n\t\t\tnow := time.Now().Unix()\n\t\t\tif now \u003c stakedOrCreatedAt {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t_, externalReward := rewardMathComputeExternalRewardAmount(tokenId, incentiveId)\n\t\t\tif externalReward \u003e= 0 {\n\t\t\t\trewards = append(rewards, Reward{\n\t\t\t\t\tIncentiveType:     \"EXTERNAL\",\n\t\t\t\t\tIncentiveId:       incentiveId,\n\t\t\t\t\tTargetPoolPath:    deposit.targetPoolPath,\n\t\t\t\t\tRewardTokenPath:   incentives[incentiveId].rewardToken,\n\t\t\t\t\tRewardTokenAmount: externalReward,\n\t\t\t\t\tStakeTimestamp:    deposit.stakeTimestamp,\n\t\t\t\t\tStakeHeight:       deposit.stakeHeight,\n\t\t\t\t\tIncentiveStart:    incentive.startTimestamp,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tif len(rewards) \u003e 0 {\n\t\t\tlpTokenReward := LpTokenReward{\n\t\t\t\tLpTokenId: tokenId,\n\t\t\t\tAddress:   deposit.owner.String(),\n\t\t\t\tRewards:   rewards,\n\t\t\t}\n\t\t\tlpTokenRewards = append(lpTokenRewards, lpTokenReward)\n\t\t}\n\t}\n\n\tqb := ResponseQueryBase{\n\t\tHeight:    std.GetHeight(),\n\t\tTimestamp: time.Now().Unix(),\n\t}\n\n\tr := ResponseApiGetRewards{\n\t\tStat:     qb,\n\t\tResponse: lpTokenRewards,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, reward := range r.Response {\n\t\t_rewardNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\": json.NumberNode(\"lpTokenId\", float64(reward.LpTokenId)),\n\t\t\t\"address\":   json.StringNode(\"address\", reward.Address),\n\t\t\t\"rewards\":   json.ArrayNode(\"rewards\", makeRewardsArray(reward.Rewards)),\n\t\t})\n\t\tresponses.AppendArray(_rewardNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetRewards() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetRewardsByLpTokenId(targetLpTokenId uint64) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tlpTokenRewards := []LpTokenReward{}\n\n\tfor tokenId, deposit := range deposits {\n\t\tif tokenId != targetLpTokenId {\n\t\t\tcontinue\n\t\t}\n\n\t\trewards := []Reward{}\n\n\t\t// get internal gns reward\n\t\t_, internalGNS := rewardMathComputeInternalRewardAmount(tokenId)\n\t\tif internalGNS \u003e 0 {\n\t\t\trewards = append(rewards, Reward{\n\t\t\t\tIncentiveType:     \"INTERNAL\",\n\t\t\t\tIncentiveId:       \"\",\n\t\t\t\tTargetPoolPath:    deposit.targetPoolPath,\n\t\t\t\tRewardTokenPath:   consts.GNS_PATH,\n\t\t\t\tRewardTokenAmount: internalGNS,\n\t\t\t\tStakeTimestamp:    deposit.stakeTimestamp,\n\t\t\t\tStakeHeight:       deposit.stakeHeight,\n\t\t\t\tIncentiveStart:    deposit.stakeTimestamp,\n\t\t\t})\n\t\t}\n\n\t\t// find all external reward list for poolPath which lpTokenId is staked\n\t\tfor _, incentiveId := range poolIncentives[deposit.targetPoolPath] {\n\t\t\tincentive := incentives[incentiveId]\n\n\t\t\tstakedOrCreatedAt := max(deposit.stakeTimestamp, incentive.startTimestamp)\n\t\t\tnow := time.Now().Unix()\n\t\t\tif now \u003c stakedOrCreatedAt {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t_, externalReward := rewardMathComputeExternalRewardAmount(tokenId, incentiveId)\n\t\t\tif externalReward \u003e 0 {\n\t\t\t\trewards = append(rewards, Reward{\n\t\t\t\t\tIncentiveType:     \"EXTERNAL\",\n\t\t\t\t\tIncentiveId:       incentiveId,\n\t\t\t\t\tTargetPoolPath:    deposit.targetPoolPath,\n\t\t\t\t\tRewardTokenPath:   incentives[incentiveId].rewardToken,\n\t\t\t\t\tRewardTokenAmount: externalReward,\n\t\t\t\t\tStakeTimestamp:    deposit.stakeTimestamp,\n\t\t\t\t\tStakeHeight:       deposit.stakeHeight,\n\t\t\t\t\tIncentiveStart:    incentive.startTimestamp,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tlpTokenReward := LpTokenReward{\n\t\t\tLpTokenId: tokenId,\n\t\t\tAddress:   deposit.owner.String(),\n\t\t\tRewards:   rewards,\n\t\t}\n\t\tlpTokenRewards = append(lpTokenRewards, lpTokenReward)\n\t}\n\n\tqb := ResponseQueryBase{\n\t\tHeight:    std.GetHeight(),\n\t\tTimestamp: time.Now().Unix(),\n\t}\n\n\tr := ResponseApiGetRewards{\n\t\tStat:     qb,\n\t\tResponse: lpTokenRewards,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, reward := range r.Response {\n\t\t_rewardNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\": json.NumberNode(\"lpTokenId\", float64(reward.LpTokenId)),\n\t\t\t\"address\":   json.StringNode(\"address\", reward.Address),\n\t\t\t\"rewards\":   json.ArrayNode(\"rewards\", makeRewardsArray(reward.Rewards)),\n\t\t})\n\t\tresponses.AppendArray(_rewardNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetRewardsByLpTokenId() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetRewardsByAddress(targetAddress string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tlpTokenRewards := []LpTokenReward{}\n\n\tfor tokenId, deposit := range deposits {\n\t\tif deposit.owner.String() != targetAddress {\n\t\t\tcontinue\n\t\t}\n\n\t\trewards := []Reward{}\n\n\t\t// get internal gns reward\n\t\t_, internalGNS := rewardMathComputeInternalRewardAmount(tokenId)\n\t\tif internalGNS \u003e 0 {\n\t\t\trewards = append(rewards, Reward{\n\t\t\t\tIncentiveType:     \"INTERNAL\",\n\t\t\t\tIncentiveId:       \"\",\n\t\t\t\tTargetPoolPath:    deposit.targetPoolPath,\n\t\t\t\tRewardTokenPath:   consts.GNS_PATH,\n\t\t\t\tRewardTokenAmount: internalGNS,\n\t\t\t\tStakeTimestamp:    deposit.stakeTimestamp,\n\t\t\t\tStakeHeight:       deposit.stakeHeight,\n\t\t\t\tIncentiveStart:    deposit.stakeTimestamp,\n\t\t\t})\n\t\t}\n\n\t\t// find all external reward list for poolPath which lpTokenId is staked\n\t\tfor _, incentiveId := range poolIncentives[deposit.targetPoolPath] {\n\t\t\tincentive := incentives[incentiveId]\n\n\t\t\tstakedOrCreatedAt := max(deposit.stakeTimestamp, incentive.startTimestamp)\n\t\t\tnow := time.Now().Unix()\n\t\t\tif now \u003c stakedOrCreatedAt {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t_, externalReward := rewardMathComputeExternalRewardAmount(tokenId, incentiveId)\n\t\t\trewards = append(rewards, Reward{\n\t\t\t\tIncentiveType:     \"EXTERNAL\",\n\t\t\t\tIncentiveId:       incentiveId,\n\t\t\t\tTargetPoolPath:    deposit.targetPoolPath,\n\t\t\t\tRewardTokenPath:   incentives[incentiveId].rewardToken,\n\t\t\t\tRewardTokenAmount: externalReward,\n\t\t\t\tStakeTimestamp:    deposit.stakeTimestamp,\n\t\t\t\tStakeHeight:       deposit.stakeHeight,\n\t\t\t\tIncentiveStart:    incentive.startTimestamp,\n\t\t\t})\n\t\t}\n\t\tlpTokenReward := LpTokenReward{\n\t\t\tLpTokenId: tokenId,\n\t\t\tAddress:   deposit.owner.String(),\n\t\t\tRewards:   rewards,\n\t\t}\n\t\tlpTokenRewards = append(lpTokenRewards, lpTokenReward)\n\t}\n\n\tqb := ResponseQueryBase{\n\t\tHeight:    std.GetHeight(),\n\t\tTimestamp: time.Now().Unix(),\n\t}\n\n\tr := ResponseApiGetRewards{\n\t\tStat:     qb,\n\t\tResponse: lpTokenRewards,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, reward := range r.Response {\n\t\t_rewardNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"lpTokenId\": json.NumberNode(\"lpTokenId\", float64(reward.LpTokenId)),\n\t\t\t\"address\":   json.StringNode(\"address\", reward.Address),\n\t\t\t\"rewards\":   json.ArrayNode(\"rewards\", makeRewardsArray(reward.Rewards)),\n\t\t})\n\t\tresponses.AppendArray(_rewardNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetRewardsByAddress() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetStakes() string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tstakes := []Stake{}\n\tfor tokenId, deposit := range deposits {\n\t\tstakes = append(stakes, Stake{\n\t\t\tTokenId:        tokenId,\n\t\t\tOwner:          deposit.owner,\n\t\t\tNumberOfStakes: deposit.numberOfStakes,\n\t\t\tStakeTimestamp: deposit.stakeTimestamp,\n\t\t\tTargetPoolPath: deposit.targetPoolPath,\n\t\t})\n\t}\n\n\tqb := ResponseQueryBase{\n\t\tHeight:    std.GetHeight(),\n\t\tTimestamp: time.Now().Unix(),\n\t}\n\n\tr := ResponseApiGetStakes{\n\t\tStat:     qb,\n\t\tResponse: stakes,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, stake := range r.Response {\n\t\t_stakeNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"tokenId\":        json.NumberNode(\"tokenId\", float64(stake.TokenId)),\n\t\t\t\"owner\":          json.StringNode(\"owner\", stake.Owner.String()),\n\t\t\t\"numberOfStakes\": json.NumberNode(\"numberOfStakes\", float64(stake.NumberOfStakes)),\n\t\t\t\"stakeTimestamp\": json.NumberNode(\"stakeTimestamp\", float64(stake.StakeTimestamp)),\n\t\t\t\"targetPoolPath\": json.StringNode(\"targetPoolPath\", stake.TargetPoolPath),\n\t\t})\n\t\tresponses.AppendArray(_stakeNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetStakes() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetStakesByLpTokenId(targetLpTokenId uint64) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tstakes := []Stake{}\n\n\tfor tokenId, deposit := range deposits {\n\t\tif tokenId != targetLpTokenId {\n\t\t\tcontinue\n\t\t}\n\n\t\tstakes = append(stakes, Stake{\n\t\t\tTokenId:        tokenId,\n\t\t\tOwner:          deposit.owner,\n\t\t\tNumberOfStakes: deposit.numberOfStakes,\n\t\t\tStakeTimestamp: deposit.stakeTimestamp,\n\t\t\tTargetPoolPath: deposit.targetPoolPath,\n\t\t})\n\t}\n\n\tqb := ResponseQueryBase{\n\t\tHeight:    std.GetHeight(),\n\t\tTimestamp: time.Now().Unix(),\n\t}\n\n\tr := ResponseApiGetStakes{\n\t\tStat:     qb,\n\t\tResponse: stakes,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, stake := range r.Response {\n\t\t_stakeNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"tokenId\":        json.NumberNode(\"tokenId\", float64(stake.TokenId)),\n\t\t\t\"owner\":          json.StringNode(\"owner\", stake.Owner.String()),\n\t\t\t\"numberOfStakes\": json.NumberNode(\"numberOfStakes\", float64(stake.NumberOfStakes)),\n\t\t\t\"stakeTimestamp\": json.NumberNode(\"stakeTimestamp\", float64(stake.StakeTimestamp)),\n\t\t\t\"targetPoolPath\": json.StringNode(\"targetPoolPath\", stake.TargetPoolPath),\n\t\t})\n\t\tresponses.AppendArray(_stakeNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetStakes() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\nfunc ApiGetStakesByAddress(targetAddress string) string {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tstakes := []Stake{}\n\n\tfor tokenId, deposit := range deposits {\n\t\tif deposit.owner.String() != targetAddress {\n\t\t\tcontinue\n\t\t}\n\n\t\tstakes = append(stakes, Stake{\n\t\t\tTokenId:        tokenId,\n\t\t\tOwner:          deposit.owner,\n\t\t\tNumberOfStakes: deposit.numberOfStakes,\n\t\t\tStakeTimestamp: deposit.stakeTimestamp,\n\t\t\tTargetPoolPath: deposit.targetPoolPath,\n\t\t})\n\t}\n\n\tqb := ResponseQueryBase{\n\t\tHeight:    std.GetHeight(),\n\t\tTimestamp: time.Now().Unix(),\n\t}\n\n\tr := ResponseApiGetStakes{\n\t\tStat:     qb,\n\t\tResponse: stakes,\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, stake := range r.Response {\n\t\t_stakeNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"tokenId\":        json.NumberNode(\"tokenId\", float64(stake.TokenId)),\n\t\t\t\"owner\":          json.StringNode(\"owner\", stake.Owner.String()),\n\t\t\t\"numberOfStakes\": json.NumberNode(\"numberOfStakes\", float64(stake.NumberOfStakes)),\n\t\t\t\"stakeTimestamp\": json.NumberNode(\"stakeTimestamp\", float64(stake.StakeTimestamp)),\n\t\t\t\"targetPoolPath\": json.StringNode(\"targetPoolPath\", stake.TargetPoolPath),\n\t\t})\n\t\tresponses.AppendArray(_stakeNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] _RPC_api_stake.gno__ApiGetStakes() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\n// for off chain to check if lpTokenId is staked via RPC\nfunc IsStaked(tokenId uint64) bool {\n\t_, exist := deposits[tokenId]\n\treturn exist\n}\n\nfunc makeRewardsArray(rewards []Reward) []*json.Node {\n\trewardsArray := make([]*json.Node, len(rewards))\n\n\tfor i, reward := range rewards {\n\t\trewardsArray[i] = json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"incentiveType\":     json.StringNode(\"incentiveType\", reward.IncentiveType),\n\t\t\t\"incentiveId\":       json.StringNode(\"incentiveId\", reward.IncentiveId),\n\t\t\t\"targetPoolPath\":    json.StringNode(\"targetPoolPath\", reward.TargetPoolPath),\n\t\t\t\"rewardTokenPath\":   json.StringNode(\"rewardTokenPath\", reward.RewardTokenPath),\n\t\t\t\"rewardTokenAmount\": json.NumberNode(\"rewardTokenAmount\", float64(reward.RewardTokenAmount)),\n\t\t\t\"stakeTimestamp\":    json.NumberNode(\"stakeTimestamp\", float64(reward.StakeTimestamp)),\n\t\t\t\"stakeHeight\":       json.NumberNode(\"stakeHeight\", float64(reward.StakeHeight)),\n\t\t\t\"incentiveStart\":    json.NumberNode(\"incentiveStart\", float64(reward.IncentiveStart)),\n\t\t})\n\t}\n\treturn rewardsArray\n}\n"},{"name":"calculate_pool_position_reward.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/r/gnoswap/v2/gns\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\n// poolPath -\u003e gnsAmount [accu]\nvar poolGns map[string]uint64 = make(map[string]uint64)\n\n// poolPath -\u003e gnsAmount [current block]\nvar poolCurrentBlockGns map[string]uint64 = make(map[string]uint64)\n\n// poolPath -\u003e gnsAmount [how much left from last block]\nvar poolLastTmpGns map[string]uint64 = make(map[string]uint64)\n\n// poolPath -\u003e accumulatedGns\nvar poolAccuGns map[string]uint64 = make(map[string]uint64)\n\n// tokenId -\u003e gnsAmount\nvar positionGns map[uint64]uint64 = make(map[uint64]uint64)\n\n// tokenId -\u003e lastGnsAmount\nvar positionLastGns map[uint64]uint64 = make(map[uint64]uint64)\n\n// tokenId -\u003e incentiveId -\u003e lastRewardAmount\nvar positionLastExternal map[uint64]map[string]*u256.Uint = make(map[uint64]map[string]*u256.Uint)\n\n// incentiveId -\u003e lastCalculatedTimestamp\nvar externalLastCalculatedTimestamp map[string]int64 = make(map[string]int64)\n\n// incentiveId -\u003e gnsAmount\nvar externalGns map[string]uint64 = make(map[string]uint64)\n\ntype externalRewards struct {\n\tincentiveId    string\n\tpoolPath       string\n\ttokenPath      string\n\ttokenAmountX96 *u256.Uint\n\t//\n\ttokenAmountFull       uint64\n\ttokenAmountActualFull uint64\n}\n\n// tokenId -\u003e incentiveId -\u003e externalRewards\nvar positionExternal map[uint64]map[string]externalRewards = make(map[uint64]map[string]externalRewards)\n\nvar (\n\tlastCalculatedHeight  int64\n\tlastCalculatedBalance uint64\n)\n\n// XXX: need to improve nested iteration\n// CalcPoolPosition calculates and updates the position of pools and rewards for stakers.\n//\n// It performs the following operations:\n//\n//  1. Calculates newly minted GNS tokens and distributes them among pool tiers.\n//  2. Updates pool GNS balances and accumulated GNS for each pool.\n//  3. Calculates and updates internal rewards for each staker's position.\n//  4. Calculates and updates external rewards from incentives for each staker's postion.\n//\n// This function is meant to be called periodically to keep the pool postions\n// and reward calculations up-to-date.\n//\n// It uses the current block height and its timestamp to determine the calculation period.\nfunc CalcPoolPosition() {\n\tprintln()\n\tprintln(\"=== [ START START START ] CALC__CalcPoolPosition\")\n\t_q96 := u256.MustFromDecimal(consts.Q96)\n\n\theight := std.GetHeight()\n\tnow := time.Now().Unix()\n\n\tprintln(\"CALC__CalcPoolPosition__height\", height)\n\tprintln(\"CALC__CalcPoolPosition__lastCalculatedHeight\", lastCalculatedHeight)\n\tif height \u003c= lastCalculatedHeight {\n\t\tprintln(\" \u003e [XXX] CALC__CalcPoolPosition__SKIP\", height, lastCalculatedHeight)\n\t\tprintln()\n\t\treturn\n\t}\n\n\t// calculate pool\n\tstakerGnsBalance := gnsBalance(consts.STAKER_ADDR)\n\tprintln(\" \u003e CALC__stakerGnsBalance:\", stakerGnsBalance)\n\tprintln(\" \u003e CALC__externalGnsAmount:\", externalGnsAmount())\n\n\tstakerGnsBalance -= externalGnsAmount()\n\tprintln(\"CALC__stakerGnsBalance - externalGnsAmount\", stakerGnsBalance)\n\tprintln(\"CALC__lastCalculatedBalance:\", lastCalculatedBalance)\n\n\tmintedGnsAmount := stakerGnsBalance - lastCalculatedBalance\n\tprintln(\"CALC__mintedGnsAmount:\", mintedGnsAmount)\n\n\tlastCalculatedBalance = stakerGnsBalance\n\n\tprintln(\"CALC__height:\", height)\n\tprintln(\"CALC__lastCalculatedHeight:\", lastCalculatedHeight)\n\n\tduration := height - lastCalculatedHeight\n\tprintln(\"CALC__duration:\", duration)\n\n\tprintln(\"CALC__getTiersAmount_mintedGnsAmount:\", mintedGnsAmount)\n\ttier1Amount, tier2Amount, tier3Amount := getTiersAmount(mintedGnsAmount)\n\n\ttier1Num, tier2Num, tier3Num := getNumPoolTiers()\n\tprintln(\"CALC__tier1Num:\", tier1Num)\n\tprintln(\"CALC__tier1Amount:\", tier1Amount)\n\n\tprintln(\"CALC__tier2Num:\", tier2Num)\n\tprintln(\"CALC__tier2Amount:\", tier2Amount)\n\n\tprintln(\"CALC__tier3Num:\", tier3Num)\n\tprintln(\"CALC__tier3Amount:\", tier3Amount)\n\n\tprintln(\"CALC__duration:\", duration)\n\tprintln(\"CALC__height:\", height)\n\tprintln()\n\n\tprintln(\"[ START ] CALC__poolTiers DISTRIBUTE\")\n\tfor poolPath, internal := range poolTiers {\n\t\tprintln(\" \u003e CALC__poolPath:\", poolPath)\n\t\ttier := internal.tier\n\t\tstartHeight := internal.startHeight\n\t\ttierAmount := uint64(0)\n\t\tprintln(\" \u003e CALC__tier:\", tier)\n\t\tprintln(\" \u003e CALC__startHeight:\", startHeight)\n\n\t\tif tier == 1 {\n\t\t\ttierAmount = tier1Amount / tier1Num\n\t\t} else if tier == 2 {\n\t\t\ttierAmount = tier2Amount / tier2Num\n\t\t} else if tier == 3 {\n\t\t\ttierAmount = tier3Amount / tier3Num\n\t\t}\n\t\tprintln(\" \u003e CALC__tierAmount:\", tierAmount)\n\n\t\tprintln(\" \u003e CALC__BEFORE_poolGns[poolPath]:\", poolGns[poolPath])\n\t\tprintln(\" \u003e CALC__BEFORE_poolAccuGns[poolPath]:\", poolAccuGns[poolPath])\n\t\tpoolGns[poolPath] += tierAmount\n\t\tpoolAccuGns[poolPath] += tierAmount\n\t\tprintln(\" \u003e CALC__AFTER_poolGns[poolPath]:\", poolGns[poolPath])\n\t\tprintln(\" \u003e CALC__AFTER_poolAccuGns[poolPath]:\", poolAccuGns[poolPath])\n\n\t\t// current block minted gns + left from last block distributed gns\n\t\tpoolCurrentBlockGns[poolPath] = tierAmount\n\t\tprintln(\" \u003e CALC__poolCurrentBlockGns[poolPath]:\", poolCurrentBlockGns[poolPath])\n\n\t\tprintln(\" \u003e CALC__ADD_poolLastTmpGns[poolPath]:\", poolLastTmpGns[poolPath])\n\n\t\tpoolCurrentBlockGns[poolPath] += poolLastTmpGns[poolPath]\n\t\tprintln(\" \u003e CALC__AFTER_ADD\", poolCurrentBlockGns[poolPath])\n\n\t\tpoolLastTmpGns[poolPath] = 0\n\t\tprintln(\" \u003e CALC__INIT_TO_ZERO_poolLastTmpGns[poolPath]:\", poolLastTmpGns[poolPath])\n\n\t\ttotalStakedLiquidity := getPoolTotalStakedLiquidity(poolPath)\n\t\tprintln(\" \u003e CALC__poolPath:\", poolPath, \"totalStakedLiquidity:\", totalStakedLiquidity.ToString())\n\n\t\tif totalStakedLiquidity.ToString() == \"0\" {\n\t\t\tprintln(\"  \u003e CALC__ZERO_POOL\", poolPath, \"HAS TIER OF\", internal.tier, \"BUT NONE STAKED, SEND AMOUNT TO PROTOCOL FEE\")\n\t\t\tprintln(\"  \u003e CALC__ZERO_poolGns[poolPath]:\", poolGns[poolPath])\n\n\t\t\tsend := min(poolGns[poolPath], gnsBalance(consts.STAKER_ADDR)-externalGnsAmount())\n\t\t\tprintln(\"  \u003e CALC__ZERO_SEND_min(poolGns[poolPath], gnsBalance(consts.STAKER_ADDR)-externalGnsAmount()\", send)\n\t\t\tprintln(\"  \u003e CALC__BEFORE_STAKER_GNS:\", gnsBalance(consts.STAKER_ADDR)-externalGnsAmount())\n\t\t\tprintln(\"  \u003e CALC__BEFORE_FEE_GNS:\", gnsBalance(consts.PROTOCOL_FEE_ADDR))\n\t\t\tprintln(\"  \u003e CALC__BEFORE_lastCalculatedBalance:\", lastCalculatedBalance)\n\n\t\t\tgns.Transfer(a2u(consts.PROTOCOL_FEE_ADDR), send)\n\t\t\tstd.Emit(\n\t\t\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\t\t\"m_callType\", callType(),\n\t\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\t\"poolPath\", poolPath,\n\t\t\t\t\"reason\", \"emission_target_pool_no_staked\",\n\t\t\t\t\"token\", consts.GNS_PATH,\n\t\t\t\t\"amount\", strconv.FormatUint(send, 10),\n\t\t\t)\n\n\t\t\tpoolGns[poolPath] = 0\n\t\t\tpoolCurrentBlockGns[poolPath] = 0\n\t\t\tlastCalculatedBalance = gnsBalance(consts.STAKER_ADDR) - externalGnsAmount()\n\n\t\t\tprintln(\"  \u003e CALC__AFTER_STAKER_GNS:\", gnsBalance(consts.STAKER_ADDR)-externalGnsAmount())\n\t\t\tprintln(\"  \u003e CALC__AFTER_FEE_GNS:\", gnsBalance(consts.PROTOCOL_FEE_ADDR))\n\t\t\tprintln(\"  \u003e CALC__AFTER_poolGns[poolPath] = 0\")\n\t\t\tprintln(\"  \u003e CALC__AFTER_poolCurrentBlockGns[poolPath] = 0\")\n\t\t\tprintln(\"  \u003e CALC__AFTER_lastCalculatedBalance:\", lastCalculatedBalance)\n\t\t\tprintln(\"  \u003e ----------------------- WAS EMPTY POOL\")\n\t\t}\n\t}\n\tprintln(\"[ END ] CALC__poolTiers DISTRIBUTE END\")\n\n\tprintln()\n\n\tprintln(\"[ START ] CALC__deposits ITERATION\")\n\n\texternalToUpdate := []string{}\n\tfor tokenId, deposit := range deposits {\n\t\tpoolPath := deposit.targetPoolPath\n\t\tpoolCurrentBlockAmount := poolCurrentBlockGns[poolPath]\n\t\tprintln(\" \u003e CALC__tokenId:\", tokenId)\n\t\tprintln(\" \u003e CALC__poolCurrentBlockAmount:\", poolCurrentBlockAmount)\n\n\t\t// ------------------------------------ INTERNAL\n\t\tif poolCurrentBlockAmount \u003e 0 {\n\t\t\t// calculate position gns rewards\n\t\t\tliqRatioX96 := getMyLiquidityRatio(poolPath, tokenId)\n\n\t\t\tpositionAmountX96 := u256.Zero().Mul(u256.NewUint(poolCurrentBlockAmount), liqRatioX96)\n\t\t\tpositionAmountX := u256.Zero().Div(positionAmountX96, _q96)\n\t\t\tpositionAmount := positionAmountX.Uint64()\n\n\t\t\t// XXX: REMOVE AFTER QA\n\t\t\tprintln(\" \u003e CALC__liqRatioX96:\", liqRatioX96.ToString())\n\t\t\tprintln(\" \u003e CALC__positionAmountX:\", positionAmountX.ToString())\n\n\t\t\tprintln(\" \u003e CALC__BEFORE\")\n\t\t\tprintln(\" \u003e CALC__positionGns[tokenId]:\", positionGns[tokenId])\n\t\t\tprintln(\" \u003e CALC__poolLastTmpGns[poolPath]:\", poolLastTmpGns[poolPath])\n\t\t\tpositionLastGns[tokenId] = positionGns[tokenId]\n\t\t\tpositionGns[tokenId] += positionAmount\n\t\t\tpoolLastTmpGns[poolPath] += positionAmount\n\t\t\tprintln(\" \u003e CALC__AFTER\")\n\t\t\tprintln(\" \u003e CALC__positionAmount:\", positionAmount)\n\t\t\tprintln(\" \u003e CALC__positionGns[tokenId]:\", positionGns[tokenId])\n\t\t\tprintln(\" \u003e CALC__poolLastTmpGns[poolPath]:\", poolLastTmpGns[poolPath])\n\t\t\tprintln()\n\n\t\t\t// calculate internal amount from previous to now\n\t\t\trewardMathComputeInternalRewardAmount(tokenId)\n\t\t}\n\n\t\tprintln()\n\t\tprintln()\n\t\tprintln()\n\n\t\t// ------------------------------------ EXTERNAL\n\t\t// calculate position external rewards\n\t\tincentiveIds := poolIncentives[poolPath]\n\t\tprintln(\"[ START ] CALC__EXTERNAL, TOKEN_ID\", tokenId)\n\t\tfor _, incentiveId := range incentiveIds {\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_incentiveId:\", incentiveId)\n\t\t\tincentive := incentives[incentiveId]\n\n\t\t\tstartTimestamp := incentive.startTimestamp\n\t\t\tendTimestamp := incentive.endTimestamp\n\t\t\tnow := time.Now().Unix()\n\t\t\t// if inactive incentive, do not calculate\n\t\t\tif !(startTimestamp \u003c= now \u0026\u0026 now \u003c= endTimestamp) {\n\t\t\t\tprintln(\"  \u003e CALC__EXTERNAL_INACTIVE\")\n\t\t\t\tprintln(\"  \u003e start:\\t\", startTimestamp)\n\t\t\t\tprintln(\"  \u003e now:\\t\", now)\n\t\t\t\tprintln(\"  \u003e end:\\t\", endTimestamp)\n\t\t\t\tprintln(\"  \u003e s-n::\\t\", startTimestamp-now)\n\t\t\t\tprintln(\"  \u003e s-n/b:\\t\", (startTimestamp-now)/2)\n\t\t\t\tprintln()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\trewardToken := incentive.rewardToken\n\t\t\trewardAmount := incentive.rewardAmount\n\t\t\trewardLeft := incentive.rewardLeft\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_rewardToken:\\t\\t\", rewardToken)\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_rewardAmount:\\t\", rewardAmount.ToString())\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_rewardLeft:\\t\\t\", rewardLeft.ToString())\n\n\t\t\t// how many blocks passed since\n\t\t\t// max time between (start of the incentive) and (staked at) and (last calculated)\n\t\t\t_max := max(startTimestamp, deposit.stakeTimestamp)\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_max:\\t\\t\\t\", _max)\n\t\t\tprintln(\"    \u003e startTimestamp:\\t\\t\\t\", startTimestamp)\n\t\t\tprintln(\"    \u003e deposit.stakeTimestamp:\\t\\t\", deposit.stakeTimestamp)\n\n\t\t\t_max = max(_max, externalLastCalculatedTimestamp[incentiveId])\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_max:\\t\\t\\t\", _max)\n\t\t\tprintln(\"    \u003e externalLastCalculatedTimestamp[incentiveId]:\", externalLastCalculatedTimestamp[incentiveId])\n\n\t\t\tblocksPassed := (now - _max) / consts.BLOCK_GENERATION_INTERVAL\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_blocksPassed:\\t\", blocksPassed)\n\t\t\tprintln(\"   \u003e incentive_start:\\t\\t\\t\", startTimestamp)\n\t\t\tprintln(\"   \u003e stake_timestamp:\\t\\t\\t\", deposit.stakeTimestamp)\n\t\t\tprintln(\"   \u003e last_calculated:\\t\\t\\t\", externalLastCalculatedTimestamp[incentiveId])\n\t\t\tprintln(\"   \u003e now:\\t\\t\\t\\t\", now)\n\t\t\tif blocksPassed == 0 {\n\t\t\t\tprintln(\"  \u003e CALC__EXTERNAL_BLOCKS_PASSED_ZERO\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tliqRatioX96 := getMyLiquidityRatio(poolPath, tokenId)\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_liqRatioX96:\\t\\t\", liqRatioX96.ToString())\n\n\t\t\tcurrentPoolRewardX96 := u256.Zero().Mul(incentive.rewardPerBlockX96, u256.NewUint(uint64(blocksPassed)))\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_currentPoolReward:\\t\", currentPoolRewardX96.ToString())\n\t\t\tprintln(\"    \u003e block_passed:\\t\\t\\t\", blocksPassed)\n\t\t\tprintln(\"    \u003e rewardPerBlockX96:\\t\\t\", incentive.rewardPerBlockX96.ToString())\n\n\t\t\tpositionAmountX96_x2 := u256.Zero().Mul(currentPoolRewardX96, liqRatioX96)\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_positionAmountX96_x2:\", positionAmountX96_x2.ToString())\n\n\t\t\tpositionAmountX96 := u256.Zero().Div(positionAmountX96_x2, _q96)\n\t\t\tprintln(\"  \u003e CALC__EXTERNAL_positionAmountX96:\\t\", positionAmountX96.ToString())\n\n\t\t\trewardLeftX96 := new(u256.Uint).Mul(rewardLeft, _q96)\n\t\t\tif positionAmountX96.Gt(rewardLeftX96) {\n\t\t\t\tpositionAmountX96 = rewardLeftX96\n\t\t\t}\n\n\t\t\t_, exist := positionLastExternal[tokenId]\n\t\t\tif !exist {\n\t\t\t\tpositionLastExternal[tokenId] = make(map[string]*u256.Uint)\n\t\t\t}\n\n\t\t\t_, exist = positionsExternalLastCalculatedHeight[tokenId]\n\t\t\tif !exist {\n\t\t\t\tpositionsExternalLastCalculatedHeight[tokenId] = make(map[string]int64)\n\t\t\t\tpositionsExternalLastCalculatedHeight[tokenId][incentiveId] = height - int64(blocksPassed)\n\t\t\t}\n\n\t\t\t_, exist = positionsExternalWarmUpAmount[tokenId]\n\t\t\tif !exist {\n\t\t\t\tpositionsExternalWarmUpAmount[tokenId] = make(map[string]warmUpAmount)\n\t\t\t}\n\n\t\t\t_, exist = positionsExternalWarmUpAmount[tokenId][incentiveId]\n\t\t\tif !exist {\n\t\t\t\tpositionsExternalWarmUpAmount[tokenId][incentiveId] = warmUpAmount{}\n\t\t\t}\n\n\t\t\t_, exist = positionExternal[tokenId]\n\t\t\tif !exist {\n\t\t\t\tpositionExternal[tokenId] = make(map[string]externalRewards)\n\t\t\t}\n\n\t\t\t_, exist = positionExternal[tokenId][incentiveId]\n\t\t\tif !exist {\n\t\t\t\tpositionExternal[tokenId][incentiveId] = externalRewards{\n\t\t\t\t\tincentiveId:    incentiveId,\n\t\t\t\t\tpoolPath:       poolPath,\n\t\t\t\t\ttokenPath:      rewardToken,\n\t\t\t\t\ttokenAmountX96: positionAmountX96,\n\t\t\t\t}\n\t\t\t\tpositionLastExternal[tokenId][incentiveId] = u256.Zero()\n\t\t\t} else {\n\t\t\t\ttempLastExternalAmount := positionExternal[tokenId][incentiveId].tokenAmountX96\n\t\t\t\tpositionLastExternal[tokenId][incentiveId] = tempLastExternalAmount\n\t\t\t\tpositionExternal[tokenId][incentiveId] = externalRewards{\n\t\t\t\t\tincentiveId:    incentiveId,\n\t\t\t\t\tpoolPath:       poolPath,\n\t\t\t\t\ttokenPath:      rewardToken,\n\t\t\t\t\ttokenAmountX96: new(u256.Uint).Add(tempLastExternalAmount, positionAmountX96),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trewardMathComputeExternalRewardAmount(tokenId, incentiveId)\n\t\t\tpositionsExternalLastCalculatedHeight[tokenId][incentiveId] = height\n\t\t\texternalToUpdate = append(externalToUpdate, incentiveId)\n\t\t}\n\t\tprintln(\"[ END ] CALC__EXTERNAL, TOKEN_ID\", tokenId)\n\t}\n\t// update all external incentives time\n\tuniquExternals := removeDupeStr(externalToUpdate)\n\tfor _, incentiveId := range uniquExternals {\n\t\texternalLastCalculatedTimestamp[incentiveId] = now\n\t}\n\n\t// update flag\n\tprintln(\"UPDATE FLAG\")\n\tlastCalculatedHeight = height\n\tprintln(\" \u003e lastCalculatedHeight:\", lastCalculatedHeight)\n\tlastCalculatedBalance = gnsBalance(consts.STAKER_ADDR) - externalGnsAmount()\n\tprintln(\" \u003e lastCalculatedBalance:\", lastCalculatedBalance)\n\tprintln()\n\n\tprintln(\"[ START ] CALC__FINAL\")\n\tfor poolPath, _ := range poolTiers {\n\t\tamount := poolLastTmpGns[poolPath]\n\t\tprintln(\" \u003e CALC__FINAL_POOL\", poolPath)\n\t\tprintln(\" \u003e CALC__FINAL_amount\", amount)\n\t\tprintln(\" \u003e CALC__FINAL_poolCurrentBlockGns[poolPath]\", poolCurrentBlockGns[poolPath])\n\t\tprintln(\" \u003e CALC__FINAL_poolLastTmpGns[poolPath]\", poolLastTmpGns[poolPath])\n\t\tif amount \u003e 0 {\n\t\t\tif poolCurrentBlockGns[poolPath] \u003e= amount {\n\t\t\t\tprintln(\" \u003e CALC__SAME_OR_LEFT\")\n\t\t\t\tpoolLastTmpGns[poolPath] = poolCurrentBlockGns[poolPath] - amount\n\t\t\t\tprintln(\" \u003e poolLastTmpGns[poolPath]\", poolLastTmpGns[poolPath])\n\t\t\t} else {\n\t\t\t\tprintln(\" \u003e CALC__FINAL_WRONG\")\n\t\t\t\tpoolCurrentBlockGns[poolPath] = 0\n\t\t\t}\n\t\t} else {\n\t\t\tprintln(\" \u003e CALC__FINAL__amount = 0\")\n\t\t}\n\t}\n\tprintln(\"[ END ] CALC__FINAL\")\n\tprintln()\n\n\t// clear(poolCurrentBlockGns) // gno doesn't support `clear` keyword yet\n\tpoolCurrentBlockGns = make(map[string]uint64)\n\tprintln(\"=== [ END END END ] CALC__CalcPoolPosition\")\n\tprintln()\n}\n\nfunc removeDupeStr(strSlice []string) []string {\n\tseen := make(map[string]struct{}, len(strSlice))\n\tresult := make([]string, 0, len(strSlice))\n\n\tfor _, str := range strSlice {\n\t\tif _, ok := seen[str]; !ok {\n\t\t\tseen[str] = struct{}{}\n\t\t\tresult = append(result, str)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc externalGnsAmount() uint64 {\n\tamount := uint64(0)\n\tfor _, v := range externalGns {\n\t\tamount += v\n\t}\n\treturn amount\n}\n"},{"name":"external_token_list.gno","body":"package staker\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\n// defaultAllowed is the list of default allowed tokens to create external incentive\nvar defaultAllowed = []string{consts.GNS_PATH, consts.WUGNOT_PATH, consts.GNOT}\n\n// allowedTokens is a slice of all allowed token paths, including the default and added tokens.\nvar allowedTokens = []string{}\n\nfunc init() {\n\tallowedTokens = defaultAllowed\n}\n\n// AddToken adds a new token path to the list of allowed tokens\n// Only the admin (GNOSWAP_ADMIN) can add a new token.\n//\n// Parameters:\n//   - tokenPath (string): The path of the token to add\n//\n// Panics:\n//   - If the caller is not the GNOSWAP_ADMIN\nfunc AddToken(tokenPath string) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN {\n\t\tpanic(\"only admin can add token\")\n\t}\n\n\t// if exist just return\n\tfor _, t := range allowedTokens {\n\t\tif t == tokenPath {\n\t\t\treturn\n\t\t}\n\t}\n\n\tallowedTokens = append(allowedTokens, tokenPath)\n}\n\n// RemoveToken removes a token path from the list of allowed tokens.\n// Only the admin (GNOSWAP_ADMIN) can remove a token.\n//\n// Default tokens can not be removed.\n//\n// Parameters:\n//   - tokenPath (string): The path of the token to remove\n//\n// Panics:\n//   - If the caller is not the GNOSWAP_ADMIN\nfunc RemoveToken(tokenPath string) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN {\n\t\tpanic(\"only admin can remove token\")\n\t}\n\n\t// if default token, can not remove\n\tisDefault := contains(defaultAllowed, tokenPath)\n\tif isDefault {\n\t\tpanic(\"can not remove default token\")\n\t}\n\n\tfor i, t := range allowedTokens {\n\t\tif t == tokenPath {\n\t\t\tallowedTokens = append(allowedTokens[:i], allowedTokens[i+1:]...)\n\t\t\treturn\n\t\t}\n\t}\n}\n"},{"name":"gno_helper.gno","body":"package staker\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nfunc GetOrigPkgAddr() std.Address {\n\treturn consts.STAKER_ADDR\n}\n"},{"name":"incentive_id.gno","body":"package staker\n\nimport (\n\t\"encoding/base64\"\n\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc incentiveIdCompute(caller std.Address, targetPoolPath, rewardToken string, startTimestamp, endTimestamp, height int64) string {\n\tkey := ufmt.Sprintf(\"%s:%s:%s:%d:%d:%d\", caller.String(), targetPoolPath, rewardToken, startTimestamp, endTimestamp, height)\n\n\tencoded := base64.StdEncoding.EncodeToString([]byte(key))\n\treturn encoded\n}\n"},{"name":"manage_pool_tiers.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\ten \"gno.land/r/gnoswap/v2/emission\"\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\n\t\"gno.land/p/demo/json\"\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\ntype ApiPoolWithEmissionGnsAmount struct {\n\tPoolPath       string `json:\"poolPath\"`\n\tTier           uint64 `json:\"tier\"`\n\tAmount         uint64 `json:\"amount\"`\n\tStartTimestamp int64  `json:\"startTimestamp\"`\n}\n\n// GetPoolsWithTier returns a list of string that consists of pool path and tier\nfunc GetPoolsWithTier() []string {\n\tvar pools []string\n\tfor pool, tier := range poolTiers {\n\t\tpools = append(pools, ufmt.Sprintf(\"%s_%d\", pool, tier.tier))\n\t}\n\treturn pools\n}\n\n// GetPoolsWithTierStruct returns a map of pools and their associated tier information\nfunc GetPoolsWithTierStruct() map[string]InternalTier {\n\treturn poolTiers\n}\n\n// GetPoolsWithEmissionGnsAmount returns a json formatted list of string that consists of pool path, tier, and the amount of GNS to be distributed as gns emission\nfunc GetPoolsWithEmissionGnsAmount() string {\n\tvar internals []ApiPoolWithEmissionGnsAmount\n\n\tconst MAX_EMISSION_SUPPLY = 675_000_000_000_000 // uGNS\n\n\ttier1Amount, tier2Amount, tier3Amount := getTiersAmount(MAX_EMISSION_SUPPLY)\n\n\ttier1Num, tier2Num, tier3Num := getNumPoolTiers()\n\n\tfor poolPath, internal := range poolTiers {\n\t\ttier := internal.tier\n\t\ttierAmount := uint64(0)\n\n\t\tif tier == 1 {\n\t\t\ttierAmount = tier1Amount / tier1Num\n\t\t} else if tier == 2 {\n\t\t\ttierAmount = tier2Amount / tier2Num\n\t\t} else if tier == 3 {\n\t\t\ttierAmount = tier3Amount / tier3Num\n\t\t}\n\n\t\tinternalIncentive := ApiPoolWithEmissionGnsAmount{}\n\t\tinternalIncentive.PoolPath = poolPath\n\t\tinternalIncentive.Tier = tier\n\t\tinternalIncentive.Amount = tierAmount\n\t\tinternalIncentive.StartTimestamp = internal.startTimestamp\n\n\t\tinternals = append(internals, internalIncentive)\n\t}\n\n\t// STAT NODE\n\t_stat := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"height\":    json.NumberNode(\"height\", float64(std.GetHeight())),\n\t\t\"timestamp\": json.NumberNode(\"timestamp\", float64(time.Now().Unix())),\n\t})\n\n\t// RESPONSE (ARRAY) NODE\n\tresponses := json.ArrayNode(\"\", []*json.Node{})\n\tfor _, internal := range internals {\n\t\t_incentiveNode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\t\"poolPath\":       json.StringNode(\"poolPath\", internal.PoolPath),\n\t\t\t\"rewardToken\":    json.StringNode(\"rewardToken\", consts.GNS_PATH),\n\t\t\t\"startTimestamp\": json.NumberNode(\"startTimestamp\", float64(internal.StartTimestamp)),\n\t\t\t\"tier\":           json.NumberNode(\"tier\", float64(internal.Tier)),\n\t\t\t\"amount\":         json.NumberNode(\"amount\", float64(internal.Amount)),\n\t\t})\n\t\tresponses.AppendArray(_incentiveNode)\n\t}\n\n\tnode := json.ObjectNode(\"\", map[string]*json.Node{\n\t\t\"stat\":     _stat,\n\t\t\"response\": responses,\n\t})\n\n\tb, err := json.Marshal(node)\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] manage_pool_tiers.gno__GetPoolsWithEmissionGnsAmount() || json marshal error: %s\", err.Error()))\n\t}\n\n\treturn string(b)\n}\n\n// GetEachTierPoolNum returns a list of string that consists of each tier and the number of pools in that tier\nfunc GetEachTierPoolNum() []string {\n\tnumTier1, numTier2, numTier3 := getNumPoolTiers()\n\n\ttier1 := ufmt.Sprintf(\"%d_%d\", 1, numTier1)\n\ttier2 := ufmt.Sprintf(\"%d_%d\", 2, numTier2)\n\ttier3 := ufmt.Sprintf(\"%d_%d\", 3, numTier3)\n\n\treturn []string{tier1, tier2, tier3}\n}\n\n// SetPoolTier sets the tier of a specified pool\n//\n// Parameters:\n//   - pool (string): The path of the pool to set the tier for\n//   - tier (uint64): The tier level to set (must be between 1 and 3)\n//\n// Panics:\n//   - Caller is not admin or governance address\n//   - Pool does not exist\n//   - Pool already exists in poolTiers\n//   - Tier is not valid (not between 1 and 3)\nfunc SetPoolTier(pool string, tier uint64) {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\t// panic if pool does not exist\n\tif !(pl.DoesPoolPathExist(pool)) {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] manage_pool_tiers.gno__SetPoolTier() || pool(%s) does not exist\", pool))\n\t}\n\n\t// panic if pool exists in poolTiers\n\t_, exist := poolTiers[pool]\n\tif exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] manage_pool_tiers.gno__SetPoolTier() || pool(%s) already exists in poolTiers\", pool))\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[STAKER] manage_pool_tiers.gno__SetPoolTier() || only admin(%s) or governance(%s) can set additional pool with tier, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\t// check if tier is valid\n\tmustValidTier(tier)\n\n\tpoolTiers[pool] = InternalTier{\n\t\ttier:           tier,\n\t\tstartTimestamp: time.Now().Unix(),\n\t\tstartHeight:    std.GetHeight(),\n\t\tupdateHeight:   std.GetHeight(),\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_poolPath\", pool,\n\t\t\"p_tier\", uint64ToStr(tier),\n\t)\n}\n\n// ChangePoolTier changes the tier of an existing pool in poolTiers\n//\n// Parameters:\n//   - pool (string): The path of the pool to change the tier for\n//   - tier (uint64): The new tier level to set (must be between 1 and 3)\n//\n// Panics:\n//   - Caller is not admin or governance address\n//   - Pool does not exist in poolTiers\n//   - Tier is not valid (not between 1 and 3)\n//   - Pool is default pool (MUST_EXISTS_IN_TIER_1)\nfunc ChangePoolTier(pool string, tier uint64) {\n\t// because we changed poolTiers, previous calculation should be based on last tier\n\t// from next calculation, it will be based on new tier\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\t// panic if pool does not exist in poolTiers\n\tinternal, exist := poolTiers[pool]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] manage_pool_tiers.gno__ChangePoolTier() || pool(%s) does not exist in poolTiers\", pool))\n\t}\n\n\t// check if tier is valid\n\tmustValidTier(tier)\n\n\t// CAN'T CHANGE TIER OF THIS GNS:GNOT 0.3%\n\tif pool == MUST_EXISTS_IN_TIER_1 {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] manage_pool_tiers.gno__ChangePoolTier() || Cannot change tier of this pool(%s)\", pool))\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[STAKER] manage_pool_tiers.gno__ChangePoolTier() || only admin(%s) or governance(%s) can change existing pool tier, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_poolPath\", pool,\n\t\t\"p_tier\", uint64ToStr(tier),\n\t)\n\n\tinternal.tier = tier\n\tinternal.updateHeight = std.GetHeight()\n\tpoolTiers[pool] = internal\n}\n\n// RemovePoolTier removes the pool from poolTiers\n//\n// Parameters:\n//   - pool (string): The path of the pool to remove from poolTiers\n//\n// Panics:\n//   - Caller is not admin or governance address\n//   - Pool is default pool (MUST_EXISTS_IN_TIER_1)\nfunc RemovePoolTier(pool string) {\n\t// because we remove pool from poolTiers, this should be final calculation\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tif pool == MUST_EXISTS_IN_TIER_1 {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] manage_pool_tiers.gno__RemovePoolTier() || Cannot change tier of this pool(%s)\", pool))\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[STAKER] manage_pool_tiers.gno__RemovePoolTier() || only admin(%s) or governance(%s) can remove existing pool with tier, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\tdelete(poolTiers, pool)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_poolPath\", pool,\n\t)\n}\n\n// mustValidTier checks if the provided tier is valid (between 1 and 3)\nfunc mustValidTier(tier uint64) {\n\tif tier \u003c 1 || tier \u003e 3 {\n\t\tpanic(ufmt.Sprintf(\"tier(%d) is not valid\", tier))\n\t}\n}\n"},{"name":"mint_stake.gno","body":"package staker\n\nimport (\n\t\"std\"\n\n\tpn \"gno.land/r/gnoswap/v2/position\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/r/gnoswap/v2/gnft\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\n// MintAndStake mints LP tokens and stakes them in a single transaction.\n//\n// Parameters:\n//   - token0, token1 (string): Addresses of the two tokens in the liquidity pool.\n//   - fee (string): The fee tier of the pool.\n//   - tickLower, tickUpper (string): The lower and upper tick boundaries for the position.\n//   - amount0Desired, amount1Desired (string): Desired amounts of token0 and token1 to add as liquidity.\n//   - amount0Min, amount1Min (string): Minimum amounts of token0 and token1 to add as liquidity.\n//   - deadline (int64): The timestamp by which the transaction must be executed.\n//\n// Returns:\n//   - tokenId          (uint64): The ID of the minted NFT representing the liquidity position.\n//   - liquidity        (string): The amount of liquidity added to the pool.\n//   - amount0, amount1 (string): The actual amounts of token0 and token1 used to provide liquidity.\n//   - poolPath         (string): The path identifier for the liquidity pool.\n//\n// Note: All amount parameters are strings representing *u256.Uint values.\nfunc MintAndStake(\n\ttoken0 string,\n\ttoken1 string,\n\tfee uint32,\n\ttickLower int32,\n\ttickUpper int32,\n\tamount0Desired string, // *u256.Uint\n\tamount1Desired string, // *u256.Uint\n\tamount0Min string, // *u256.Uint\n\tamount1Min string, // *u256.Uint\n\tdeadline int64,\n) (uint64, string, string, string, string) { // tokenId, liquidity, amount0, amount1, poolPath ( *u256.Uint x3)\n\n\t// if one click native\n\tif token0 == consts.GNOT || token1 == consts.GNOT {\n\t\t// check sent ugnot\n\t\tsent := std.GetOrigSend()\n\t\tugnotSent := uint64(sent.AmountOf(\"ugnot\"))\n\n\t\t// not enough ugnot sent\n\t\tif ugnotSent \u003c consts.UGNOT_MIN_DEPOSIT_TO_WRAP {\n\t\t\tpanic(ufmt.Sprintf(\"[STAKER] mint_stake.gno__MintAndStake() || too less(%d) ugnot sent (minimum:%d)\", ugnotSent, consts.UGNOT_MIN_DEPOSIT_TO_WRAP))\n\t\t}\n\n\t\t// send it over to position to wrap\n\t\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\t\tbanker.SendCoins(consts.STAKER_ADDR, consts.POSITION_ADDR, std.Coins{{Denom: \"ugnot\", Amount: int64(ugnotSent)}})\n\t}\n\n\ttokenId, liquidity, amount0, amount1 := pn.Mint(\n\t\ttoken0,\n\t\ttoken1,\n\t\tfee,\n\t\ttickLower,\n\t\ttickUpper,\n\t\tamount0Desired,\n\t\tamount1Desired,\n\t\tamount0Min,\n\t\tamount1Min,\n\t\tdeadline,\n\t\tconsts.STAKER_ADDR.String(),\n\t)\n\n\t// at this point staker has minted token\n\ttoTid := grc721.TokenID(ufmt.Sprintf(\"%d\", tokenId))\n\tgnft.SetTokenURI(toTid)\n\n\tpoolPath, _, _ := StakeToken(tokenId) // poolPath, stakedAmount0, stakedAmount1\n\n\t/*\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP\",\n\t\t\t\"m_callType\", callType(),\n\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\"p_tickLower\", int32ToStr(tickLower),\n\t\t\t\"p_tickUpper\", int32ToStr(tickUpper),\n\t\t\t\"poolPath\", poolPath,\n\t\t\t\"tokenId\", uint64ToStr(tokenId),\n\t\t\t\"liquidity\", liquidity,\n\t\t\t\"amount0\", amount0,\n\t\t\t\"amount1\", amount1,\n\t\t)\n\t*/\n\n\treturn tokenId, liquidity, amount0, amount1, poolPath\n}\n"},{"name":"protocol_fee_unstaking.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\n\t\"gno.land/r/gnoswap/v2/gns\"\n)\n\nvar (\n\tunstakingFee = uint64(100) // 1%\n)\n\nfunc handleUnstakingFee(\n\ttokenPath string,\n\tamount uint64,\n\tinternal bool,\n\ttokenId uint64,\n\tpoolPath string,\n) uint64 {\n\tif unstakingFee == 0 {\n\t\treturn amount\n\t}\n\n\tfeeAmount := amount * unstakingFee / 10000\n\tif feeAmount == 0 {\n\t\treturn amount\n\t}\n\n\tif internal {\n\t\t// staker contract has fee\n\t\tgns.Transfer(a2u(consts.PROTOCOL_FEE_ADDR), feeAmount)\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\t\"m_callType\", callType(),\n\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\"lpTokenId\", strconv.FormatUint(tokenId, 10),\n\t\t\t\"poolPath\", poolPath,\n\t\t\t\"reason\", \"unstaking_fee\",\n\t\t\t\"token\", consts.GNS_PATH,\n\t\t\t\"amount\", strconv.FormatUint(feeAmount, 10),\n\t\t)\n\n\t} else {\n\t\t// external contract has fee\n\t\tok := transferByRegisterCall(tokenPath, consts.PROTOCOL_FEE_ADDR, feeAmount)\n\t\tif !ok {\n\t\t\tpanic(ufmt.Sprintf(\"[STAKER] reward_fee.gno__handleUnstakingFee() || expected transferByRegisterCall(%s, %s, %s) == true\", tokenPath, consts.PROTOCOL_FEE_ADDR, u256.NewUint(feeAmount).ToString()))\n\t\t}\n\t\tstd.Emit(\n\t\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\t\"m_callType\", callType(),\n\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\"lpTokenId\", strconv.FormatUint(tokenId, 10),\n\t\t\t\"poolPath\", poolPath,\n\t\t\t\"reason\", \"unstaking_fee\",\n\t\t\t\"token\", tokenPath,\n\t\t\t\"amount\", strconv.FormatUint(feeAmount, 10),\n\t\t)\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", \"INDIRECT\",\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenPath\", tokenPath,\n\t\t\"p_internal\", boolToStr(internal),\n\t\t\"feeAmount\", uint64ToStr(feeAmount),\n\t)\n\n\treturn amount - feeAmount\n}\n\nfunc GetUnstakingFee() uint64 {\n\treturn unstakingFee\n}\n\nfunc SetUnstakingFee(fee uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[STAKER] protocol_fee_unstaking.gno__SetUnstakingFee() || only admin(%s) or governance(%s) can set unstaking fee, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\t// 10000 (bps) = 100%\n\tif fee \u003e 10000 {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] reward_fee.gno__SetUnstakingFee() || fee(%d) must be in range 0 ~ 10000\", fee))\n\t}\n\n\tunstakingFee = fee\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_fee\", uint64ToStr(fee),\n\t)\n}\n"},{"name":"reward_math.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\tpos \"gno.land/r/gnoswap/v2/position\"\n)\n\ntype warmUpAmount struct {\n\tfull30 uint64\n\tgive30 uint64\n\tleft30 uint64\n\n\tfull50 uint64\n\tgive50 uint64\n\tleft50 uint64\n\n\tfull70 uint64\n\tgive70 uint64\n\tleft70 uint64\n\n\tfull100 uint64\n\tgive100 uint64 // doesn't need this I think\n\tleft100 uint64 // doesn't need this I think\n}\n\nvar positionsInternalWarmUpAmount = make(map[uint64]warmUpAmount) // positionId =\u003e warmUpAmount\n\nvar positionsExternalWarmUpAmount = make(map[uint64]map[string]warmUpAmount)  // positionId =\u003e incentiveId =\u003e warmUpAmount\nvar positionsExternalLastCalculatedHeight = make(map[uint64]map[string]int64) // positionId =\u003e incentiveId =\u003e lastCalculatedHeight\n\nfunc rewardMathComputeInternalRewardAmount(tokenId uint64) (uint64, uint64) {\n\tprintln(\"[ START ] REWARD__INTERNAL_rewardMathComputeInternalRewardAmount_TOKEN_ID:\", tokenId)\n\tdeposit := deposits[tokenId]\n\n\t// using block\n\tstakeHeight := deposit.stakeHeight\n\tcurrentHeight := std.GetHeight()\n\tstakedDuration := currentHeight - stakeHeight\n\tdurationRatio := getRewardRatio(stakedDuration)\n\n\tprintln(\" \u003e REWARD__INTERNAL_rewardMathComputeInternalRewardAmount_HEIGHT:\", currentHeight)\n\n\t// 과거 계산 시점부터 현재 블록까지 쌓인 리워드에 대해 각 가중치별로 분배\n\ttoDistribute := positionGns[tokenId] - positionLastGns[tokenId]\n\tprintln(\" \u003e REWARD__INTERNAL_positionGns[tokenId]\", positionGns[tokenId])\n\tprintln(\" \u003e REWARD__INTERNAL_positionLastGns[tokenId]\", positionLastGns[tokenId])\n\n\tuntil30 := uint64(stakeHeight + warmUp[50] - 1)  // 150\n\tuntil50 := uint64(stakeHeight + warmUp[70] - 1)  // 300\n\tuntil70 := uint64(stakeHeight + warmUp[100] - 1) // 900\n\tbegin100 := uint64(stakeHeight + warmUp[100])    // 901~\n\n\tlastCalculatedHeightU64 := uint64(lastCalculatedHeight)\n\n\tq96 := u256.MustFromDecimal(consts.Q96)\n\ttoDistributeX96 := new(u256.Uint).Mul(u256.NewUint(toDistribute), q96)\n\tavgGnsBlockAmountX96 := new(u256.Uint).Div(toDistributeX96, u256.NewUint(uint64(currentHeight)-lastCalculatedHeightU64))\n\tprintln(\" \u003e REWARD__INTERNAL_toDistribute:\", toDistribute)\n\tprintln(\" \u003e REWARD__INTERNAL_uint64(currentHeight)-lastCalculatedHeightU64):\", uint64(currentHeight)-lastCalculatedHeightU64)\n\tprintln(\" \u003e REWARD__INTERNAL_avgGnsBlockAmountX96:\", avgGnsBlockAmountX96.ToString())\n\n\tpositionWarmUpAmount, exist := positionsInternalWarmUpAmount[tokenId]\n\tif !exist {\n\t\tpanic(\"THIS SHOULD NOT HAPPEN\")\n\t}\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.full100\", positionWarmUpAmount.full100)\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.give100\", positionWarmUpAmount.give100)\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.left100\", positionWarmUpAmount.left100)\n\tprintln()\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.full70\", positionWarmUpAmount.full70)\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.give70\", positionWarmUpAmount.give70)\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.left70\", positionWarmUpAmount.left70)\n\tprintln()\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.full50\", positionWarmUpAmount.full50)\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.give50\", positionWarmUpAmount.give50)\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.left50\", positionWarmUpAmount.left50)\n\tprintln()\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.full30\", positionWarmUpAmount.full30)\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.give30\", positionWarmUpAmount.give30)\n\tprintln(\" \u003e REWARD__INTERNAL_BEFORE_positionWarmUpAmount.left30\", positionWarmUpAmount.left30)\n\tprintln()\n\n\tswitch durationRatio {\n\tcase 100:\n\t\tif lastCalculatedHeightU64 \u003e begin100 {\n\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWARD ONLY 100%\")\n\t\t\t// 100%\n\t\t\tdur100 := uint64(currentHeight) - lastCalculatedHeightU64\n\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR100\", dur100)\n\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur100, 100)\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT100\", amount)\n\t\t\tpositionWarmUpAmount.full100 += full\n\t\t\tpositionWarmUpAmount.give100 += toGive\n\t\t\tpositionWarmUpAmount.left100 += full - toGive\n\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_100%\", gnsAmountToGive)\n\t\t} else {\n\t\t\tif lastCalculatedHeightU64 \u003e until50 {\n\t\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWARD 100% AND 70%\")\n\t\t\t\t// 100%\n\t\t\t\tdur100 := uint64(currentHeight) - until70\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR100\", dur100)\n\t\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur100, 100)\n\t\t\t\tpositionWarmUpAmount.full100 += full\n\t\t\t\tpositionWarmUpAmount.give100 += toGive\n\t\t\t\tpositionWarmUpAmount.left100 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT100\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_100%\", gnsAmountToGive)\n\n\t\t\t\t// 70%\n\t\t\t\tdur70 := until70 - lastCalculatedHeightU64\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR70\", dur70)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur70, 70)\n\t\t\t\tpositionWarmUpAmount.full70 += full\n\t\t\t\tpositionWarmUpAmount.give70 += toGive\n\t\t\t\tpositionWarmUpAmount.left70 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT70\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_70%\", gnsAmountToGive)\n\t\t\t} else if lastCalculatedHeightU64 \u003e until30 {\n\t\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWARD 100% AND 70% AND 50%\")\n\t\t\t\t// 100%\n\t\t\t\tdur100 := uint64(currentHeight) - until70\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR100\", dur100)\n\t\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur100, 100)\n\t\t\t\tpositionWarmUpAmount.full100 += full\n\t\t\t\tpositionWarmUpAmount.give100 += toGive\n\t\t\t\tpositionWarmUpAmount.left100 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT100\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_100%\", gnsAmountToGive)\n\n\t\t\t\t// 70%\n\t\t\t\tdur70 := until70 - until50\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR70\", dur70)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur70, 70)\n\t\t\t\tpositionWarmUpAmount.full70 += full\n\t\t\t\tpositionWarmUpAmount.give70 += toGive\n\t\t\t\tpositionWarmUpAmount.left70 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT70\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_70%\", gnsAmountToGive)\n\n\t\t\t\t// 50%\n\t\t\t\tdur50 := until50 - lastCalculatedHeightU64\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR50\", dur50)\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_50%\", gnsAmountToGive)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur50, 50)\n\t\t\t\tpositionWarmUpAmount.full50 += full\n\t\t\t\tpositionWarmUpAmount.give50 += toGive\n\t\t\t\tpositionWarmUpAmount.left50 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT50\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t} else {\n\t\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWARD 100% AND 70% AND 50% AND 30%\")\n\t\t\t\t// 100%\n\t\t\t\tdur100 := uint64(currentHeight) - until70\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR100\", dur100)\n\t\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur100, 100)\n\t\t\t\tpositionWarmUpAmount.full100 += full\n\t\t\t\tpositionWarmUpAmount.give100 += toGive\n\t\t\t\tpositionWarmUpAmount.left100 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT100\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_100%\", gnsAmountToGive)\n\n\t\t\t\t// 70%\n\t\t\t\tdur70 := until70 - until50\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR70\", dur70)\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_70%\", gnsAmountToGive)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur70, 70)\n\t\t\t\tpositionWarmUpAmount.full70 += full\n\t\t\t\tpositionWarmUpAmount.give70 += toGive\n\t\t\t\tpositionWarmUpAmount.left70 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT70\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t// 50%\n\t\t\t\tdur50 := until50 - until30\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR50\", dur50)\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_50%\", gnsAmountToGive)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur50, 50)\n\t\t\t\tpositionWarmUpAmount.full50 += full\n\t\t\t\tpositionWarmUpAmount.give50 += toGive\n\t\t\t\tpositionWarmUpAmount.left50 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT50\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t// 30%\n\t\t\t\tdur30 := until30 - lastCalculatedHeightU64\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR30\", dur30)\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_30%\", gnsAmountToGive)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur30, 30)\n\t\t\t\tpositionWarmUpAmount.full30 += full\n\t\t\t\tpositionWarmUpAmount.give30 += toGive\n\t\t\t\tpositionWarmUpAmount.left30 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT30\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t}\n\t\t}\n\n\tcase 70:\n\t\tif lastCalculatedHeightU64 \u003e until50 {\n\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWARD ONLY 70%\")\n\t\t\t// 70%\n\t\t\tdur70 := uint64(currentHeight) - lastCalculatedHeightU64\n\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR70\", dur70)\n\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur70, 70)\n\t\t\tpositionWarmUpAmount.full70 += full\n\t\t\tpositionWarmUpAmount.give70 += toGive\n\t\t\tpositionWarmUpAmount.left70 += full - toGive\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT70\", amount)\n\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_70%\", gnsAmountToGive)\n\t\t} else {\n\t\t\tif lastCalculatedHeightU64 \u003e until30 {\n\t\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWAWRD 70% AND 50%\")\n\t\t\t\t// 70%\n\t\t\t\tdur70 := uint64(currentHeight) - until50\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR70\", dur70)\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_70%\", gnsAmountToGive)\n\t\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur70, 70)\n\t\t\t\tpositionWarmUpAmount.full70 += full\n\t\t\t\tpositionWarmUpAmount.give70 += toGive\n\t\t\t\tpositionWarmUpAmount.left70 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT70\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t// 50%\n\t\t\t\tdur50 := until50 - lastCalculatedHeightU64\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR50\", dur50)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur50, 50)\n\t\t\t\tpositionWarmUpAmount.full50 += full\n\t\t\t\tpositionWarmUpAmount.give50 += toGive\n\t\t\t\tpositionWarmUpAmount.left50 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT50\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_50%\", gnsAmountToGive)\n\t\t\t} else {\n\t\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWARD 70% AND 50% AND 30%\")\n\t\t\t\t// 70%\n\t\t\t\tdur70 := uint64(currentHeight) - until50\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR70\", dur70)\n\t\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur70, 70)\n\t\t\t\tpositionWarmUpAmount.full70 += full\n\t\t\t\tpositionWarmUpAmount.give70 += toGive\n\t\t\t\tpositionWarmUpAmount.left70 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT70\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_70%\", gnsAmountToGive)\n\n\t\t\t\t// 50%\n\t\t\t\tdur50 := until50 - until30\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR50\", dur50)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur50, 50)\n\t\t\t\tpositionWarmUpAmount.full50 += full\n\t\t\t\tpositionWarmUpAmount.give50 += toGive\n\t\t\t\tpositionWarmUpAmount.left50 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT50\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_50%\", gnsAmountToGive)\n\n\t\t\t\t// 30%\n\t\t\t\tdur30 := until30 - lastCalculatedHeightU64\n\t\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR30\", dur30)\n\t\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur30, 30)\n\t\t\t\tpositionWarmUpAmount.full30 += full\n\t\t\t\tpositionWarmUpAmount.give30 += toGive\n\t\t\t\tpositionWarmUpAmount.left30 += full - toGive\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT30\", amount)\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t// println(\"  \u003e REWARD__INTERNAL_30%\", gnsAmountToGive)\n\t\t\t}\n\t\t}\n\n\tcase 50:\n\t\tif lastCalculatedHeightU64 \u003e until30 {\n\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWARD ONLY 50%\")\n\t\t\t// 50%\n\t\t\tdur50 := uint64(currentHeight) - lastCalculatedHeightU64\n\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR50\", dur50)\n\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur50, 50)\n\t\t\tpositionWarmUpAmount.full50 += full\n\t\t\tpositionWarmUpAmount.give50 += toGive\n\t\t\tpositionWarmUpAmount.left50 += full - toGive\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT50\", amount)\n\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_50%\", gnsAmountToGive)\n\t\t} else {\n\t\t\tprintln(\" \u003e REWARD__INTERNAL_REWAD 50% AND 30%\")\n\t\t\tdur50 := uint64(currentHeight) - until30\n\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR50\", dur50)\n\t\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur50, 50)\n\t\t\tpositionWarmUpAmount.full50 += full\n\t\t\tpositionWarmUpAmount.give50 += toGive\n\t\t\tpositionWarmUpAmount.left50 += full - toGive\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT50\", amount)\n\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_50%\", gnsAmountToGive)\n\n\t\t\t// 30%\n\t\t\tdur30 := until30 - lastCalculatedHeightU64\n\t\t\tfull, toGive = calcAmount(avgGnsBlockAmountX96, dur30, 30)\n\t\t\tpositionWarmUpAmount.full30 += full\n\t\t\tpositionWarmUpAmount.give30 += toGive\n\t\t\tpositionWarmUpAmount.left30 += full - toGive\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT30\", amount)\n\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR30\", dur30)\n\t\t\t// println(\"  \u003e REWARD__INTERNAL_30%\", gnsAmountToGive)\n\t\t}\n\n\tcase 30:\n\t\tprintln(\" \u003e REWARD__INTERNAL_REWARD 30%\")\n\t\tdur30 := uint64(currentHeight) - lastCalculatedHeightU64\n\t\tfull, toGive := calcAmount(avgGnsBlockAmountX96, dur30, 30)\n\t\tpositionWarmUpAmount.full30 += full\n\t\tpositionWarmUpAmount.give30 += toGive\n\t\tpositionWarmUpAmount.left30 += full - toGive\n\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t// println(\"  \u003e REWARD__INTERNAL_AMOUNT30\", amount)\n\t\tprintln(\"  \u003e REWARD__INTERNAL_DUR30\", dur30)\n\t\t// println(\"  \u003e REWARD__INTERNAL_30%\", amount)\n\n\tdefault:\n\t\tprintln(\" \u003e REWARD__INTERNAL_0 REWARD RATIO\")\n\t}\n\n\tprintln(\" \u003e REWARD__INTERNAL_STAKER\", gnsBalance(consts.STAKER_ADDR))\n\tprintln(\" \u003e REWARD__INTERNAL_tokenId:\", tokenId)\n\tprintln(\" \u003e REWARD__INTERNAL_toDistribute:\", toDistribute)\n\t// println(\" \u003e REWARD__INTERNAL_gnsAmountToGive\", gnsAmountToGive)\n\n\tprintln(\" \u003e REWARD__INTERNAL_stakeHeight:\", stakeHeight)\n\tprintln(\" \u003e REWARD__INTERNAL_durationRatio:\", durationRatio)\n\tprintln(\" \u003e REWARD__INTERNAL_currentHeight:\", currentHeight)\n\tprintln(\" \u003e REWARD__INTERNAL_[?] lastCalculatedHeight:\", lastCalculatedHeight)\n\tprintln(\" \u003e REWARD__INTERNAL_until30:\", until30)\n\tprintln(\" \u003e REWARD__INTERNAL_until50:\", until50)\n\tprintln(\" \u003e REWARD__INTERNAL_until70:\", until70)\n\tprintln(\" \u003e REWARD__INTERNAL_begin100:\", begin100)\n\n\tprintln(\" \u003e REWARD__INTERNAL_full30:\", positionWarmUpAmount.full30)\n\tprintln(\" \u003e REWARD__INTERNAL_give30:\", positionWarmUpAmount.give30)\n\n\tprintln(\" \u003e REWARD__INTERNAL_full50:\", positionWarmUpAmount.full50)\n\tprintln(\" \u003e REWARD__INTERNAL_give50:\", positionWarmUpAmount.give50)\n\n\tprintln(\" \u003e REWARD__INTERNAL_full70:\", positionWarmUpAmount.full70)\n\tprintln(\" \u003e REWARD__INTERNAL_give70:\", positionWarmUpAmount.give70)\n\n\tprintln(\" \u003e REWARD__INTERNAL_full100:\", positionWarmUpAmount.full100)\n\tprintln(\" \u003e REWARD__INTERNAL_give100:\", positionWarmUpAmount.give100)\n\n\taccuFull := uint64(0)\n\taccuGive := uint64(0)\n\n\taccuFull += positionWarmUpAmount.full30 + positionWarmUpAmount.full50 + positionWarmUpAmount.full70 + positionWarmUpAmount.full100\n\taccuGive += positionWarmUpAmount.give30 + positionWarmUpAmount.give50 + positionWarmUpAmount.give70 + positionWarmUpAmount.give100\n\n\tprintln(\" \u003e REWARD__INTERNAL_accuFull:\", accuFull)\n\tprintln(\" \u003e REWARD__INTERNAL_accuGive:\", accuGive)\n\n\tpositionsInternalWarmUpAmount[tokenId] = positionWarmUpAmount\n\tprintln(\" \u003e REWARD__INTERNAL_positionsInternalWarmUpAmount[tokenId]:\", positionsInternalWarmUpAmount[tokenId])\n\n\tprintln(\"[ END ] REWARD__INTERNAL_rewardMathComputeInternalRewardAmount_TOKEN_ID:\", tokenId)\n\tprintln()\n\n\treturn accuFull, accuGive\n}\n\nfunc rewardMathComputeExternalRewardAmount(tokenId uint64, incentiveId string) (uint64, uint64) {\n\tprintln(\"[ START ] REWARD__EXTERNAL_rewardMathComputeInternalRewardAmount_TOKEN_ID:\", tokenId)\n\tprintln(\"  \u003e REWARD__EXTERNAL_incentiveId:\", incentiveId)\n\n\tcurrentHeight := std.GetHeight()\n\n\texternals := positionExternal[tokenId]\n\n\t_max := max(incentives[incentiveId].startTimestamp, deposits[tokenId].stakeTimestamp)\n\tprintln(\"  \u003e REWARD__EXTERNAL_incentives[incentiveId].startTimestamp:\", incentives[incentiveId].startTimestamp)\n\tprintln(\"  \u003e REWARD__EXTERNAL_deposits[tokenId].stakeTimestamp:\", deposits[tokenId].stakeTimestamp)\n\tprintln(\"  \u003e REWARD__EXTERNAL_max:\", _max)\n\n\tstakedOrExternalDuration := (time.Now().Unix() - _max) / consts.BLOCK_GENERATION_INTERVAL\n\tprintln(\"  \u003e REWARD__EXTERNAL_time.Now().Unix():\", time.Now().Unix())\n\tprintln(\"  \u003e REWARD__EXTERNAL_consts.BLOCK_GENERATION_INTERVAL:\", consts.BLOCK_GENERATION_INTERVAL)\n\tprintln(\"  \u003e REWARD__EXTERNAL_stakedOrExternalDuration:\", stakedOrExternalDuration)\n\n\tstakedOrExternalStartedHeight := std.GetHeight() - stakedOrExternalDuration\n\tprintln(\"  \u003e REWARD__EXTERNAL_height:\", std.GetHeight())\n\tprintln(\"  \u003e REWARD__EXTERNAL_stakedOrExternalStartedHeight:\", stakedOrExternalStartedHeight)\n\n\tuntil30 := uint64(stakedOrExternalStartedHeight + warmUp[50] - 1)  // 150\n\tuntil50 := uint64(stakedOrExternalStartedHeight + warmUp[70] - 1)  // 300\n\tuntil70 := uint64(stakedOrExternalStartedHeight + warmUp[100] - 1) // 900\n\tbegin100 := uint64(stakedOrExternalStartedHeight + warmUp[100])    // 901~\n\n\tfor _, external := range externals {\n\t\tif external.incentiveId == incentiveId {\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_incentiveId:\", incentiveId)\n\n\t\t\ttokenAmountX96 := external.tokenAmountX96\n\t\t\ttoDistributeX96 := new(u256.Uint).Sub(tokenAmountX96, positionLastExternal[tokenId][incentiveId])\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_tokenAmountX96:\", tokenAmountX96.ToString())\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_positionLastExternal[tokenId][incentiveId]:\", positionLastExternal[tokenId][incentiveId].ToString())\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_toDistributeX96:\", toDistributeX96.ToString())\n\t\t\tif tokenAmountX96.Lt(positionLastExternal[tokenId][incentiveId]) {\n\t\t\t\tpanic(\"THIS SHOULD NOT HAPPEN_EXTERNAL #1\")\n\t\t\t}\n\n\t\t\tlastCalculatedHeightU64 := uint64(positionsExternalLastCalculatedHeight[tokenId][incentiveId])\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_lastCalculatedHeightU64:\", lastCalculatedHeightU64)\n\n\t\t\tavgExternalBlockAmountX96 := new(u256.Uint).Div(toDistributeX96, u256.NewUint(uint64(std.GetHeight())-lastCalculatedHeightU64))\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_toDistirbuteX96:\", toDistributeX96.ToString())\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_uint64(std.GetHeight())-lastCalculatedHeightU64):\", uint64(std.GetHeight())-lastCalculatedHeightU64)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_avgExternalBlockAmountX96:\", avgExternalBlockAmountX96.ToString())\n\n\t\t\tpositionExternalWarmUpAmount, exist := positionsExternalWarmUpAmount[tokenId][incentiveId]\n\t\t\tif !exist {\n\t\t\t\tprintln(\"tokenId:\", tokenId)\n\t\t\t\tprintln(\"incentiveId:\", incentiveId)\n\t\t\t\tpanic(\"THIS SHOULD NOT HAPPEN_EXTERNAL #2\")\n\t\t\t}\n\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.full100\", positionExternalWarmUpAmount.full100)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.give100\", positionExternalWarmUpAmount.give100)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.left100\", positionExternalWarmUpAmount.left100)\n\t\t\tprintln()\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.full70\", positionExternalWarmUpAmount.full70)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.give70\", positionExternalWarmUpAmount.give70)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.left70\", positionExternalWarmUpAmount.left70)\n\t\t\tprintln()\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.full50\", positionExternalWarmUpAmount.full50)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.give50\", positionExternalWarmUpAmount.give50)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.left50\", positionExternalWarmUpAmount.left50)\n\t\t\tprintln()\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.full30\", positionExternalWarmUpAmount.full30)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.give30\", positionExternalWarmUpAmount.give30)\n\t\t\tprintln(\"   \u003e REWARD__EXTERNAL_BEFORE_positionExternalWarmUpAmount.left30\", positionExternalWarmUpAmount.left30)\n\t\t\tprintln()\n\n\t\t\tdurationRatio := getRewardRatio(stakedOrExternalDuration)\n\n\t\t\tswitch durationRatio {\n\t\t\tcase 100:\n\t\t\t\tif lastCalculatedHeightU64 \u003e begin100 {\n\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWARD ONLY 100%\")\n\t\t\t\t\t// 100%\n\t\t\t\t\tdur100 := uint64(currentHeight) - lastCalculatedHeightU64\n\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR100\", dur100)\n\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur100, 100)\n\t\t\t\t\tpositionExternalWarmUpAmount.full100 += full\n\t\t\t\t\tpositionExternalWarmUpAmount.give100 += toGive\n\t\t\t\t\tpositionExternalWarmUpAmount.left100 += full - toGive\n\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t} else {\n\t\t\t\t\tif lastCalculatedHeightU64 \u003e until50 {\n\t\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWARD 100% AND 70%\")\n\t\t\t\t\t\t// 100%\n\t\t\t\t\t\tdur100 := uint64(currentHeight) - until70\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR100\", dur100)\n\t\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur100, 100)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full100 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give100 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left100 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 70%\n\t\t\t\t\t\tdur70 := until70 - lastCalculatedHeightU64\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR70\", dur70)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur70, 70)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full70 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give70 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left70 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t\t} else if lastCalculatedHeightU64 \u003e until30 {\n\t\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWARD 100% AND 70% AND 50%\")\n\t\t\t\t\t\t// 100%\n\t\t\t\t\t\tdur100 := uint64(currentHeight) - until70\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR100\", dur100)\n\t\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur100, 100)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full100 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give100 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left100 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 70%\n\t\t\t\t\t\tdur70 := until70 - until50\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR70\", dur70)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur70, 70)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full70 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give70 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left70 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 50%\n\t\t\t\t\t\tdur50 := until50 - lastCalculatedHeightU64\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR50\", dur50)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur50, 50)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full50 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give50 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left50 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWARD 100% AND 70% AND 50% AND 30%\")\n\t\t\t\t\t\t// 100%\n\t\t\t\t\t\tdur100 := uint64(currentHeight) - until70\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR100\", dur100)\n\t\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur100, 100)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full100 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give100 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left100 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 70%\n\t\t\t\t\t\tdur70 := until70 - until50\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR70\", dur70)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur70, 70)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full70 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give70 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left70 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 50%\n\t\t\t\t\t\tdur50 := until50 - until30\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR50\", dur50)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur50, 50)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full50 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give50 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left50 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 30%\n\t\t\t\t\t\tdur30 := until30 - lastCalculatedHeightU64\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR30\", dur30)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur30, 30)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full30 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give30 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left30 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tcase 70:\n\t\t\t\tif lastCalculatedHeightU64 \u003e until50 {\n\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWARD ONLY 70%\")\n\t\t\t\t\t// 70%\n\t\t\t\t\tdur70 := uint64(currentHeight) - lastCalculatedHeightU64\n\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR70\", dur70)\n\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur70, 70)\n\t\t\t\t\tpositionExternalWarmUpAmount.full70 += full\n\t\t\t\t\tpositionExternalWarmUpAmount.give70 += toGive\n\t\t\t\t\tpositionExternalWarmUpAmount.left70 += full - toGive\n\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t} else {\n\t\t\t\t\tif lastCalculatedHeightU64 \u003e until30 {\n\t\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWAWRD 70% AND 50%\")\n\t\t\t\t\t\t// 70%\n\t\t\t\t\t\tdur70 := uint64(currentHeight) - until50\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR70\", dur70)\n\t\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur70, 70)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full70 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give70 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left70 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 50%\n\t\t\t\t\t\tdur50 := until50 - lastCalculatedHeightU64\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR50\", dur50)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur50, 50)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full50 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give50 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left50 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWARD 70% AND 50% AND 30%\")\n\t\t\t\t\t\t// 70%\n\t\t\t\t\t\tdur70 := uint64(currentHeight) - until50\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR70\", dur70)\n\t\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur70, 70)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full70 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give70 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left70 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 50%\n\t\t\t\t\t\tdur50 := until50 - until30\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR50\", dur50)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur50, 50)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full50 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give50 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left50 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t\t// 30%\n\t\t\t\t\t\tdur30 := until30 - lastCalculatedHeightU64\n\t\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR30\", dur30)\n\t\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur30, 30)\n\t\t\t\t\t\tpositionExternalWarmUpAmount.full30 += full\n\t\t\t\t\t\tpositionExternalWarmUpAmount.give30 += toGive\n\t\t\t\t\t\tpositionExternalWarmUpAmount.left30 += full - toGive\n\t\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tcase 50:\n\t\t\t\tif lastCalculatedHeightU64 \u003e until30 {\n\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWARD ONLY 50%\")\n\t\t\t\t\t// 50%\n\t\t\t\t\tdur50 := uint64(currentHeight) - lastCalculatedHeightU64\n\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR50\", dur50)\n\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur50, 50)\n\t\t\t\t\tpositionExternalWarmUpAmount.full50 += full\n\t\t\t\t\tpositionExternalWarmUpAmount.give50 += toGive\n\t\t\t\t\tpositionExternalWarmUpAmount.left50 += full - toGive\n\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t} else {\n\t\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWAD 50% AND 30%\")\n\t\t\t\t\tdur50 := uint64(currentHeight) - until30\n\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR50\", dur50)\n\t\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur50, 50)\n\t\t\t\t\tpositionExternalWarmUpAmount.full50 += full\n\t\t\t\t\tpositionExternalWarmUpAmount.give50 += toGive\n\t\t\t\t\tpositionExternalWarmUpAmount.left50 += full - toGive\n\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\n\t\t\t\t\t// 30%\n\t\t\t\t\tdur30 := until30 - lastCalculatedHeightU64\n\t\t\t\t\tfull, toGive = calcAmount(avgExternalBlockAmountX96, dur30, 30)\n\t\t\t\t\tpositionExternalWarmUpAmount.full30 += full\n\t\t\t\t\tpositionExternalWarmUpAmount.give30 += toGive\n\t\t\t\t\tpositionExternalWarmUpAmount.left30 += full - toGive\n\t\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR30\", dur30)\n\t\t\t\t}\n\n\t\t\tcase 30:\n\t\t\t\tprintln(\" \u003e REWARD__EXTERNAL_REWARD 30%\")\n\t\t\t\tdur30 := uint64(currentHeight) - lastCalculatedHeightU64\n\t\t\t\tfull, toGive := calcAmount(avgExternalBlockAmountX96, dur30, 30)\n\t\t\t\tpositionExternalWarmUpAmount.full30 += full\n\t\t\t\tpositionExternalWarmUpAmount.give30 += toGive\n\t\t\t\tpositionExternalWarmUpAmount.left30 += full - toGive\n\t\t\t\t// gnsAmountToGive += amount // UPDATE EACH PERIOD\n\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_DUR30\", dur30)\n\n\t\t\tdefault:\n\t\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_0 REWARD RATIO\")\n\t\t\t}\n\n\t\t\tprintln()\n\t\t\tprintln(\"  \u003e REWARD_==================================\")\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_tokenId:\", tokenId)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_toDistirbuteX96:\", toDistributeX96.ToString())\n\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_currentHeight:\", currentHeight)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_stakeHeight:\", deposits[tokenId].stakeHeight)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_stakedOrExternalStartedHeight:\", stakedOrExternalStartedHeight)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_stakedOrExternalDuration:\", stakedOrExternalDuration)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_durationRatio:\", durationRatio)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_lastCalculatedHeightU64:\", lastCalculatedHeightU64)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_until30:\", until30)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_until50:\", until50)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_until70:\", until70)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_begin100:\", begin100)\n\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_full30:\", positionExternalWarmUpAmount.full30)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_give30:\", positionExternalWarmUpAmount.give30)\n\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_full50:\", positionExternalWarmUpAmount.full50)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_give50:\", positionExternalWarmUpAmount.give50)\n\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_full70:\", positionExternalWarmUpAmount.full70)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_give70:\", positionExternalWarmUpAmount.give70)\n\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_full100:\", positionExternalWarmUpAmount.full100)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_give100:\", positionExternalWarmUpAmount.give100)\n\n\t\t\taccuFull := uint64(0)\n\t\t\taccuGive := uint64(0)\n\n\t\t\taccuFull += positionExternalWarmUpAmount.full30 + positionExternalWarmUpAmount.full50 + positionExternalWarmUpAmount.full70 + positionExternalWarmUpAmount.full100\n\t\t\taccuGive += positionExternalWarmUpAmount.give30 + positionExternalWarmUpAmount.give50 + positionExternalWarmUpAmount.give70 + positionExternalWarmUpAmount.give100\n\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_accuFull:\", accuFull)\n\t\t\tprintln(\"  \u003e REWARD__EXTERNAL_accuGive:\", accuGive)\n\n\t\t\tpositionsExternalWarmUpAmount[tokenId][incentiveId] = positionExternalWarmUpAmount\n\t\t\t// println(\"  \u003e REWARD__EXTERNAL_positionsExternalWarmUpAmount[tokenId][incentiveId]:\", positionsExternalWarmUpAmount[tokenId][incentiveId])\n\n\t\t\tprintln(\"[ END ] REWARD__EXTERNAL_rewardMathComputeExternalRewardAmount_TOKEN_ID:\", tokenId, \" INCENTIVE_ID:\", incentiveId)\n\t\t\tprintln()\n\n\t\t\treturn accuFull, accuGive\n\t\t}\n\t}\n\n\tpanic(\"NO INCENTIVE_ID FOUND\")\n}\n\nfunc getPoolTotalStakedLiquidity(poolPath string) *u256.Uint {\n\tpoolStakedLiquidity := u256.Zero()\n\t// get all staked liquidity\n\tfor tokenId, deposit := range deposits { // key is tokenId // used in this range loop only\n\t\tif deposit.targetPoolPath == poolPath {\n\t\t\tisInRange := pos.PositionIsInRange(tokenId)\n\t\t\tif isInRange == false {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpositionLiquidity := pos.PositionGetPositionLiquidity(tokenId)\n\t\t\tpoolStakedLiquidity = new(u256.Uint).Add(poolStakedLiquidity, positionLiquidity)\n\t\t}\n\t}\n\n\treturn poolStakedLiquidity\n}\n\nfunc getMyLiquidityRatio(poolPath string, tokenId uint64) *u256.Uint {\n\t_q96 := u256.MustFromDecimal(consts.Q96)\n\n\tpoolStakedLiquidity := getPoolTotalStakedLiquidity(poolPath)\n\t// XXX REMOVE AFTER QA\n\t// println()\n\t// println(\"tokenId:\", tokenId)\n\t// println(\"POOL_LIQ:\", poolStakedLiquidity.ToString())\n\n\t// my(current tokenId) liquidity\n\tmyLiquidity := pos.PositionGetPositionLiquidity(tokenId)\n\n\t// XXX REMOVE AFTER QA\n\t// println(\"MY_LIQ:\", myLiquidity.ToString())\n\n\tisInRange := pos.PositionIsInRange(tokenId)\n\tif isInRange == false {\n\t\treturn u256.Zero()\n\t}\n\n\tmyLiquidityX96 := new(u256.Uint).Mul(myLiquidity, _q96)\n\tmyLiquidityX96X10000000 := new(u256.Uint).Mul(myLiquidityX96, u256.NewUint(1_000_000_000))\n\n\tpoolStakedLiquidityX96 := new(u256.Uint).Mul(poolStakedLiquidity, _q96)\n\n\tmyLiquidityRatio := new(u256.Uint).Div(myLiquidityX96X10000000, poolStakedLiquidityX96) // this value needs to be divided by 1_000_000_000\n\tmyLiquidityRatio = new(u256.Uint).Mul(myLiquidityRatio, _q96)                           // so first mul consts.Q96\n\tmyLiquidityRatio = new(u256.Uint).Div(myLiquidityRatio, u256.NewUint(1_000_000_000))    // then divided by 1_000_000_000\n\n\t// XXX REMOVE AFTER QA\n\t// println(\"myLiquidityRatio:\", myLiquidityRatio.ToString())\n\treturn myLiquidityRatio\n}\n\n// get current pool tier and reward ratio\nfunc getPoolTierAndRatio(poolPath string) (uint64, *u256.Uint) {\n\t_q96 := u256.MustFromDecimal(consts.Q96)\n\n\t// current pool's tier\n\tinternal, ok := poolTiers[poolPath]\n\tif !ok {\n\t\treturn 0, u256.Zero()\n\t}\n\ttier := internal.tier\n\n\t// that tiers ratio\n\tratio := getTierRatio(tier)\n\tratioX96 := new(u256.Uint).Mul(u256.NewUint(ratio), _q96) // first consts.Q96\n\n\t// finally current pools ratio\n\tnumTier1, numTier2, numTier3 := getNumPoolTiers()\n\n\tvar weight *u256.Uint\n\tswitch tier {\n\tcase 1:\n\t\tweight = new(u256.Uint).Div(ratioX96, u256.NewUint(numTier1))\n\tcase 2:\n\t\tweight = new(u256.Uint).Div(ratioX96, u256.NewUint(numTier2))\n\tcase 3:\n\t\tweight = new(u256.Uint).Div(ratioX96, u256.NewUint(numTier3))\n\tdefault:\n\t\tpanic(ufmt.Sprintf(\"[STAKER] reward_math.gno__getPoolTierAndRatio() || invalid tier(%d)\", tier))\n\t}\n\n\treturn tier, weight\n}\n\n// get number of pools for each tier\nfunc getNumPoolTiers() (uint64, uint64, uint64) {\n\tvar tier1, tier2, tier3 uint64\n\n\tfor _, v := range poolTiers {\n\t\tswitch v.tier {\n\t\tcase 1:\n\t\t\ttier1++\n\t\tcase 2:\n\t\t\ttier2++\n\t\tcase 3:\n\t\t\ttier3++\n\t\tdefault:\n\t\t\tpanic(ufmt.Sprintf(\"[STAKER] reward_math.gno__getNumPoolTiers() || invalid tier(%d)\", v))\n\t\t}\n\t}\n\n\treturn tier1, tier2, tier3\n}\n\n// get reward ratio by staking duration height\nfunc getRewardRatio(height int64) uint64 {\n\tswitch {\n\tcase height \u003e= warmUp[100]:\n\t\treturn 100\n\tcase height \u003e= warmUp[70]:\n\t\treturn 70\n\tcase height \u003e= warmUp[50]:\n\t\treturn 50\n\tcase height \u003e= warmUp[30]:\n\t\treturn 30\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc getTierRatio(tier uint64) uint64 {\n\tif tier \u003c 1 || tier \u003e 3 {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] reward_math.gno__getTierRatio() || tier(%d) must be 1 ~ 3\", tier))\n\t}\n\n\tratio1, ratio2, ratio3 := listTierRatio()\n\tswitch tier {\n\tcase 1:\n\t\treturn ratio1 // default 50\n\tcase 2:\n\t\treturn ratio2 // default 30\n\tcase 3:\n\t\treturn ratio3 // default 20\n\tdefault:\n\t\tpanic(\"[STAKER] reward_math.gno__getTierRatio() || invalid ratio\")\n\t}\n}\n\n// return all ratio for each tier\nfunc listTierRatio() (uint64, uint64, uint64) {\n\t// basic\n\t// tier1 50%\n\t// tier2 30%\n\t// tier3 20%\n\n\t// since `float` type has determinisim issue, we use `int` instead\n\t// so instead of return 50%, we return 50\n\t// we'll divide by 100 later\n\n\tnumTier1, numTier2, numTier3 := getNumPoolTiers()\n\tif numTier1 \u003c= 0 {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] reward_math.gno__listTierRatio() || at least 1 numTier1 need(%d), [numTier2:(%d), numTier3:(%d)]\", numTier1, numTier2, numTier3))\n\t}\n\n\tif numTier2 == 0 \u0026\u0026 numTier3 == 0 { // only tier 1 exists\n\t\treturn 100, 0, 0\n\t} else if numTier2 == 0 \u0026\u0026 numTier3 \u003e= 1 { // tier 1 and 3 exists ( tier2 ratio goes to tier1 )\n\t\treturn 80, 0, 20\n\t} else if numTier2 \u003e= 1 \u0026\u0026 numTier3 == 0 { // tier 1 and 2 exists ( tier3 ratio goes to tier1 )\n\t\treturn 70, 30, 0\n\t} else if numTier2 \u003e= 1 \u0026\u0026 numTier3 \u003e= 1 { // all tiers exists\n\t\treturn 50, 30, 20\n\t}\n\n\tpanic(\"[STAKER] reward_math.gno__listTierRatio() || invalid tier ratio\")\n}\n\nfunc getTiersAmount(amount uint64) (uint64, uint64, uint64) {\n\ttier1Ratio, tier2Ratio, tier3Ratio := listTierRatio()\n\n\ttier1Amount := (amount * tier1Ratio) / 100\n\ttier2Amount := (amount * tier2Ratio) / 100\n\ttier3Amount := (amount * tier3Ratio) / 100\n\n\treturn tier1Amount, tier2Amount, tier3Amount\n}\n\nfunc calcAmount(avgBlockAmountX96 *u256.Uint, dur, pct uint64) (uint64, uint64) {\n\tdurAmountX96 := new(u256.Uint).Mul(avgBlockAmountX96, u256.NewUint(dur))\n\tfullAmount := new(u256.Uint).Div(durAmountX96, u256.MustFromDecimal(consts.Q96)).Uint64()\n\n\tdurAmountX96 = new(u256.Uint).Mul(durAmountX96, u256.NewUint(pct))\n\tdurAmountX96 = new(u256.Uint).Div(durAmountX96, u256.NewUint(100))\n\n\tdurAmount := new(u256.Uint).Div(durAmountX96, u256.MustFromDecimal(consts.Q96)).Uint64()\n\treturn fullAmount, durAmount\n}\n"},{"name":"staker.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/r/gnoswap/v2/common\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/r/gnoswap/v2/gnft\"\n\t\"gno.land/r/gnoswap/v2/gns\"\n\n\ten \"gno.land/r/gnoswap/v2/emission\"\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\tpn \"gno.land/r/gnoswap/v2/position\"\n\n\ti256 \"gno.land/p/gnoswap/int256\"\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\nvar (\n\t/* internal */\n\n\t// poolTiers stores internal tier information for each pool\n\tpoolTiers map[string]InternalTier = make(map[string]InternalTier)\n\n\t/* external */\n\n\t// poolIncentives maps pool paths to their associated incentive IDs\n\tpoolIncentives map[string][]string = make(map[string][]string)\n\n\t// incentives stores external incentive for each incentive ID\n\tincentives map[string]ExternalIncentive = make(map[string]ExternalIncentive)\n\n\t// deposits stores deposit information for each tokenId\n\tdeposits map[uint64]Deposit = make(map[uint64]Deposit)\n)\n\nconst (\n\tTIMESTAMP_90DAYS  = 7776000\n\tTIMESTAMP_180DAYS = 15552000\n\tTIMESTAMP_365DAYS = 31536000\n\n\tMAX_UNIX_EPOCH_TIME = 253402300799 // 9999-12-31 23:59:59\n\n\tMUST_EXISTS_IN_TIER_1 = \"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000\"\n)\n\nfunc init() {\n\t// init pool tiers\n\t// tier 1\n\t// ONLY GNOT:GNS 0.3%\n\tpoolTiers[MUST_EXISTS_IN_TIER_1] = InternalTier{\n\t\ttier:           1,\n\t\tstartTimestamp: time.Now().Unix(),\n\t\tstartHeight:    std.GetHeight(),\n\t\tupdateHeight:   std.GetHeight(),\n\t}\n}\n\n// StakeToken stakes the LP token to the staker contract\n//\n// Parameters:\n//   - tokenID (uint64): The ID of the LP token to stake\n//\n// Returnes:\n//   - poolPath     (string): The path of the pool associated with the staked token\n//   - token0Amount (string): The amount of token0 in the position\n//   - token1Amount (string): The amount of token1 in the position\n//\n// Panics:\n//   - tokenId already staked\n//   - tokenId has no liquidity\n//   - tokenId is not owned by the caller or staker\nfunc StakeToken(tokenId uint64) (string, string, string) { // poolPath, token0Amount, token1Amount\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\t// check whether tokenId already staked or not\n\t_, exist := deposits[tokenId]\n\tif exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__StakeToken() || tokenId(%d) already staked\", tokenId))\n\t}\n\n\t// if caller is owner\n\tcallerIsOwner := gnft.OwnerOf(tid(tokenId)) == std.GetOrigCaller()\n\t// stakerIsOwner\n\tstakerIsOwner := gnft.OwnerOf(tid(tokenId)) == GetOrigPkgAddr()\n\tif !(callerIsOwner || stakerIsOwner) {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__StakeToken() || Neither Caller(%s) or Staker(%s) is not owner of tokenId(%d)\", std.GetOrigCaller(), GetOrigPkgAddr(), tokenId))\n\t}\n\n\t// check pool path from tokenid\n\tpoolPath := pn.PositionGetPositionPoolKey(tokenId)\n\n\t// check if target pool doesn't have internal or external incentive then panic\n\thasInternal := poolHasInternal(poolPath)\n\thasExternal := poolHasExternal(poolPath)\n\tif hasInternal == false \u0026\u0026 hasExternal == false {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__StakeToken() || poolPath(%s) has no internal or external incentive(can not stake)\", poolPath))\n\t}\n\n\t// check tokenId has liquidity or not\n\tliquidity := pn.PositionGetPositionLiquidity(tokenId) // *u256.Uint\n\tif liquidity.Lte(u256.Zero()) {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__StakeToken() || tokenId(%d) has no liquidity\", tokenId))\n\t}\n\n\t// staked status\n\tdeposit := deposits[tokenId]\n\tdeposit.owner = std.GetOrigCaller() // NOT ACTUAL OWNER, MUST BE USER ALWAYS\n\tdeposit.numberOfStakes++\n\tdeposit.stakeTimestamp = time.Now().Unix()\n\tdeposit.stakeHeight = std.GetHeight()\n\tdeposit.targetPoolPath = poolPath\n\tdeposits[tokenId] = deposit\n\n\tif callerIsOwner { // if caller is owner, transfer NFT ownership to staker contract\n\t\ttransferDeposit(tokenId, GetOrigPkgAddr())\n\t} else if stakerIsOwner { // if staker is owner, approve NFT to caller (≈one click staking)\n\t\tgnft.Approve(a2u(std.GetOrigCaller()), tid(tokenId))\n\t}\n\n\ttoken0Amount, token1Amount := getTokenPairBalanceFromPosition(tokenId)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\"poolPath\", poolPath,\n\t\t\"amount0\", token0Amount,\n\t\t\"amount1\", token1Amount,\n\t)\n\n\tpositionsInternalWarmUpAmount[tokenId] = warmUpAmount{}\n\treturn poolPath, token0Amount, token1Amount\n}\n\n// CollectReward collects staked rewards for the given tokenId\n//\n// Parameters:\n//   - tokenId (uint64): The ID of the LP token to collect rewards for\n//\n// Returns:\n//   - poolPath (string): The path of the pool associated with the collected rewards\n//\n// Panics:\n//   - token is not staked\n//   - caller is not owner of lp token\nfunc CollectReward(tokenId uint64) string { // poolPath\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tdeposit, exist := deposits[tokenId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__CollectReward() || tokenId(%d) not staked\", tokenId))\n\t}\n\n\tif std.PrevRealm().Addr() != deposit.owner {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__CollectReward() || only owner(%s) can collect reward from tokenId(%d), std.PrevRealm().Addr()(%s)\", deposit.owner, tokenId, std.PrevRealm().Addr()))\n\t}\n\n\tpoolPath := deposits[tokenId].targetPoolPath\n\n\tprintln(\"[ START ] CollectReward_EXTERNAL\", tokenId)\n\n\t_, exist = positionExternal[tokenId]\n\tif exist {\n\t\tfor _, external := range positionExternal[tokenId] {\n\t\t\tincentive := incentives[external.incentiveId]\n\t\t\tincentiveId := external.incentiveId\n\n\t\t\tprintln(\" \u003e CollectReward_EXTERNAL_START\")\n\t\t\tprintln(\"  \u003e tokenId:\", tokenId)\n\t\t\tprintln(\"  \u003e incentiveId:\", incentiveId)\n\t\t\tprintln(\"  \u003e rewardToken:\", external.tokenPath)\n\n\t\t\tfullAmount, toGive := rewardMathComputeExternalRewardAmount(tokenId, incentiveId)\n\t\t\tprintln(\"  \u003e position fullAmount(rewardMathComputeExternal)\", fullAmount)\n\t\t\tprintln(\"  \u003e position toGive(rewardMathComputeExternal)\", toGive)\n\n\t\t\tif toGive == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t_this := positionExternal[tokenId][incentiveId]\n\t\t\t_this.tokenAmountX96 = u256.Zero()\n\t\t\t_this.tokenAmountFull += fullAmount\n\t\t\t_this.tokenAmountActualFull += toGive\n\t\t\tpositionExternal[tokenId][incentiveId] = _this\n\n\t\t\ttoUser := handleUnstakingFee(external.tokenPath, toGive, false, tokenId, incentive.targetPoolPath)\n\t\t\tprintln(\"  \u003e position toUser(after staking fee)\", toUser)\n\t\t\tprintln(\"  \u003e unstakingFee\", toGive-toUser)\n\t\t\ttransferByRegisterCall(external.tokenPath, deposit.owner, toUser)\n\t\t\tprintln(\"  \u003e toAddr:\", deposit.owner)\n\t\t\tprintln(\"  \u003e toUser:\", toUser)\n\n\t\t\tpositionsExternalWarmUpAmount[tokenId][incentiveId] = warmUpAmount{} // JUST CLEAR\n\t\t\tpositionLastExternal[tokenId][incentiveId] = u256.Zero()             // JUST CLEAR\n\n\t\t\tleft := fullAmount - toGive\n\t\t\tprintln(\"  \u003e warm up left := fullAmount - toGive (to protocol_fee)\", left)\n\t\t\ttransferByRegisterCall(external.tokenPath, consts.PROTOCOL_FEE_ADDR, left)\n\t\t\tstd.Emit(\n\t\t\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\t\t\"m_callType\", callType(),\n\t\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\t\"lpTokenId\", uint64ToStr(tokenId),\n\t\t\t\t\"poolPath\", poolPath,\n\t\t\t\t\"reason\", \"unstaking_fee_penalty\",\n\t\t\t\t\"token\", external.tokenPath,\n\t\t\t\t\"amount\", strconv.FormatUint(left, 10),\n\t\t\t)\n\n\t\t\tincentive.rewardLeft = new(u256.Uint).Sub(incentive.rewardLeft, u256.NewUint(fullAmount))\n\t\t\tincentives[incentiveId] = incentive\n\n\t\t\tif external.tokenPath == consts.GNS_PATH {\n\t\t\t\texternalGns[incentiveId] -= fullAmount\n\t\t\t}\n\n\t\t\tstd.Emit(\n\t\t\t\t\"GNOSWAP\",\n\t\t\t\t\"m_callType\", callType(),\n\t\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\t\t\"poolPath\", poolPath,\n\t\t\t\t\"rewardToken\", external.tokenPath,\n\t\t\t\t\"recipient\", deposit.owner.String(),\n\t\t\t\t\"amount\", uint64ToStr(toUser),\n\t\t\t)\n\t\t}\n\t}\n\tprintln(\"[ END ] CollectReward_EXTERNAL\", tokenId)\n\tprintln()\n\n\t// INTERNAL gns emission\n\tprintln(\"[ START ] CollectReward_INTERNAL\", tokenId)\n\tfullAmount, toGive := rewardMathComputeInternalRewardAmount(tokenId)\n\tprintln(\" \u003e position fullAmount(rewardMathComputeInternal)\", fullAmount)\n\tprintln(\" \u003e position toGive(rewardMathComputeInternal)\", toGive)\n\tif toGive == 0 {\n\t\treturn poolPath\n\t}\n\ttoUser := handleUnstakingFee(consts.GNS_PATH, toGive, true, tokenId, poolPath)\n\tprintln(\" \u003e position toUser(after staking fee)\", toUser)\n\tprintln(\" \u003e unstakingFee\", toGive-toUser)\n\tgns.Transfer(a2u(deposit.owner), toUser)\n\n\tprintln(\" \u003e clear positionGns[tokenId] = 0\")\n\t// positionGns[tokenId] = 0\n\n\t// delete(positionsInternalWarmUpAmount, tokenId) // DO NOT DELETE\n\tpositionsInternalWarmUpAmount[tokenId] = warmUpAmount{} // JUST CLEAR\n\n\tprintln(\" \u003e poolGns[poolPath]\", poolGns[poolPath])\n\tprintln(\" \u003e position fullAmount\", fullAmount)\n\n\tpoolGns[poolPath] -= fullAmount\n\tprintln(\" \u003e poolGns[poolPath] - fullAmount\", poolGns[poolPath])\n\n\tleft := fullAmount - toGive\n\tprintln(\" \u003e warm up left := fullAmount - toGive (to protocol_fee)\", left)\n\tgns.Transfer(a2u(consts.PROTOCOL_FEE_ADDR), left)\n\tstd.Emit(\n\t\t\"GNOSWAP_PROTOCOL_FEE\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"lpTokenId\", uint64ToStr(tokenId),\n\t\t\"poolPath\", poolPath,\n\t\t\"reason\", \"gns_penalty\",\n\t\t\"token\", consts.GNS_PATH,\n\t\t\"amount\", strconv.FormatUint(left, 10),\n\t)\n\n\t// emit internal reward tokens\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\"poolPath\", poolPath,\n\t\t\"rewardToken\", consts.GNS_PATH,\n\t\t\"recipient\", deposit.owner.String(),\n\t\t\"fullAmount\", uint64ToStr(fullAmount),\n\t\t\"toGive\", uint64ToStr(toGive),\n\t\t\"amount\", uint64ToStr(toUser),\n\t\t\"unstakingFee\", uint64ToStr(toGive-toUser),\n\t\t\"left\", uint64ToStr(left),\n\t)\n\n\t// DEBUG\n\tprintln(\" \u003e fullAmount\", fullAmount)\n\tprintln(\" \u003e toGive\", toGive)\n\tprintln(\" \u003e toUser\", toUser)\n\tprintln(\" \u003e unstakingFee\", toGive-toUser)\n\tprintln(\" \u003e left\", left)\n\n\t// UPDATE stakerGns Balance for calculate_pool_position_reward\n\tlastCalculatedBalance = gnsBalance(consts.STAKER_ADDR) - externalGnsAmount()\n\n\tprintln(\"[ END ] CollectReward_INTERNAL\", tokenId)\n\treturn poolPath\n}\n\n// UnstakeToken unstakes the LP token from the staker and collects all reward from tokenId\n//\n// Parameters:\n//   - tokenId (uint64): The ID of the LP token to unstake\n//\n// Returns:\n//   - poolPath     (string): The path of the pool associated with the unstaked token\n//   - token0Amount (string): The amount of token0 in the unstaked position\n//   - token1Amount (string): The amount of token1 in the unstaked position\n//\n// Panics:\n//   - If the token is not staked\nfunc UnstakeToken(tokenId uint64) (string, string, string) { // poolPath, token0Amount, token1Amount\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\t// unstaked status\n\tdeposit, exist := deposits[tokenId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__UnstakeToken() || tokenId(%d) not staked\", tokenId))\n\t}\n\t// Claim All Rewards\n\tCollectReward(tokenId)\n\n\tdelete(positionGns, tokenId)\n\tdelete(deposits, tokenId)\n\tdelete(positionsInternalWarmUpAmount, tokenId)\n\n\t// transfer NFT ownership to origin owner\n\tgnft.TransferFrom(a2u(GetOrigPkgAddr()), a2u(deposit.owner), tid(tokenId))\n\n\tpoolPath := pn.PositionGetPositionPoolKey(tokenId)\n\ttoken0Amount, token1Amount := getTokenPairBalanceFromPosition(tokenId)\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_tokenId\", uint64ToStr(tokenId),\n\t\t\"poolPath\", poolPath,\n\t\t\"from\", GetOrigPkgAddr().String(),\n\t\t\"to\", deposit.owner.String(),\n\t\t\"amount0\", token0Amount,\n\t\t\"amount1\", token1Amount,\n\t)\n\n\treturn poolPath, token0Amount, token1Amount\n}\n\n// CreateExternalIncentive creates an external incentive for the targetPoolPath\n//\n// Parameters:\n//   - targetPoolPath (string): The path of the pool to create the incentive for\n//   - rewardToken    (string): The token path of the reward token (must be registered)\n//   - _rewardAmount  (string): The amount of reward token to provide as incentive\n//   - startTimestamp (int64): The start timestamp of the incentive\n//   - endTimestamp   (int64): The end timestamp of the incentive\n//\n// Panics:\n//   - If startTimestamp is not in the future\n//   - If externalDuration is not 90, 180, or 365 days\n//   - If user doesn't have enough balance to provide as reward\nfunc CreateExternalIncentive(\n\ttargetPoolPath string,\n\trewardToken string, // token path should be registered\n\t_rewardAmount string,\n\tstartTimestamp int64,\n\tendTimestamp int64,\n) {\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tif common.GetLimitCaller() {\n\t\tisUserCalled := std.PrevRealm().PkgPath() == \"\"\n\t\tif !isUserCalled {\n\t\t\tpanic(\"[STAKER] staker.gno__CreateExternalIncentive() || only user can call this function\")\n\t\t}\n\t}\n\n\t// panic if pool does not exist\n\tif !(pl.DoesPoolPathExist(targetPoolPath)) {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__CreateExternalIncentive() || targetPoolPath(%s) does not exist\", targetPoolPath))\n\t}\n\n\t// check token can be used as reward\n\tisAllowedForExternalReward(targetPoolPath, rewardToken)\n\n\trewardAmount := u256.MustFromDecimal(_rewardAmount)\n\n\t// native ugnot check\n\tif rewardToken == consts.GNOT {\n\t\tsent := std.GetOrigSend()\n\t\tugnotSent := uint64(sent.AmountOf(\"ugnot\"))\n\n\t\tif ugnotSent != rewardAmount.Uint64() {\n\t\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__CreateExternalIncentive() || user(%s) sent ugnot(%d) amount not equal to rewardAmount(%d)\", std.GetOrigCaller(), ugnotSent, rewardAmount.Uint64()))\n\t\t}\n\n\t\twrap(ugnotSent)\n\n\t\trewardToken = consts.WUGNOT_PATH\n\t}\n\n\t// must be in seconds format, not milliseconds\n\t// must be at least +1 day midnight\n\t// must be midnight of the day\n\tcheckStartTime(startTimestamp)\n\n\t// endTimestamp cannot be later than 253402300799 (9999-12-31 23:59:59)\n\tif endTimestamp \u003e= MAX_UNIX_EPOCH_TIME {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__CreateExternalIncentive() || endTimestamp(%d) cannot be later than 253402300799 (9999-12-31 23:59:59)\", endTimestamp))\n\t}\n\n\texternalDuration := uint64(endTimestamp - startTimestamp)\n\tif !(externalDuration == TIMESTAMP_90DAYS || externalDuration == TIMESTAMP_180DAYS || externalDuration == TIMESTAMP_365DAYS) {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__CreateExternalIncentive() || externalDuration(%d) must be 90, 180, 365 days)\", externalDuration))\n\t}\n\n\tfromBalanceBefore := balanceOfByRegisterCall(rewardToken, std.GetOrigCaller())\n\n\tif fromBalanceBefore \u003c rewardAmount.Uint64() {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__CreateExternalIncentive() || user(%s) doesn't have enough amount balance(%d) to create incentive(%d)\", std.GetOrigCaller(), fromBalanceBefore, rewardAmount.Uint64()))\n\t}\n\n\tpoolRewardBalanceBefore := balanceOfByRegisterCall(rewardToken, GetOrigPkgAddr())\n\n\tincentiveId := incentiveIdCompute(std.GetOrigCaller(), targetPoolPath, rewardToken, startTimestamp, endTimestamp, std.GetHeight())\n\n\t// if same incentiveId exists =\u003e increase rewardTokenAmount\n\tfor _, v := range poolIncentives[targetPoolPath] {\n\t\tif v == incentiveId {\n\t\t\ttransferFromByRegisterCall(rewardToken, std.GetOrigCaller(), GetOrigPkgAddr(), rewardAmount.Uint64())\n\n\t\t\tincentive, ok := incentives[v]\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tincentiveDuration := endTimestamp - startTimestamp\n\t\t\tincentiveBlock := incentiveDuration / consts.BLOCK_GENERATION_INTERVAL\n\t\t\trewardAmountX96 := new(u256.Uint).Mul(rewardAmount, u256.MustFromDecimal(consts.Q96))\n\t\t\trewardPerBlockX96 := new(u256.Uint).Div(rewardAmountX96, u256.NewUint(uint64(incentiveBlock)))\n\t\t\tincentive.rewardPerBlockX96 = rewardPerBlockX96\n\n\t\t\tincentive.rewardAmount = new(u256.Uint).Add(incentive.rewardAmount, rewardAmount)\n\t\t\tincentive.rewardLeft = new(u256.Uint).Add(incentive.rewardLeft, rewardAmount)\n\t\t\tincentives[v] = incentive\n\n\t\t\tif rewardToken == consts.GNS_PATH {\n\t\t\t\texternalGns[incentiveId] = incentive.rewardAmount.Uint64()\n\t\t\t}\n\n\t\t\tstd.Emit(\n\t\t\t\t\"GNOSWAP\",\n\t\t\t\t\"m_callType\", callType(),\n\t\t\t\t\"m_origCaller\", origCaller(),\n\t\t\t\t\"m_prevRealm\", prevRealm(),\n\t\t\t\t\"p_poolPath\", targetPoolPath,\n\t\t\t\t\"p_rewardToken\", rewardToken,\n\t\t\t\t\"p_rewardAmount\", incentive.rewardAmount.ToString(),\n\t\t\t\t\"p_startTimestamp\", int64ToStr(startTimestamp),\n\t\t\t\t\"p_endTimestamp\", int64ToStr(endTimestamp),\n\t\t\t\t\"incentiveId\", incentiveId,\n\t\t\t\t\"external\", \"updated\",\n\t\t\t)\n\n\t\t\treturn\n\t\t}\n\t}\n\n\ttransferFromByRegisterCall(rewardToken, std.GetOrigCaller(), GetOrigPkgAddr(), rewardAmount.Uint64())\n\n\tpoolRewardBalanceAfter := balanceOfByRegisterCall(rewardToken, GetOrigPkgAddr())\n\tif !(poolRewardBalanceAfter-poolRewardBalanceBefore == rewardAmount.Uint64()) {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__CreateExternalIncentive() || pool reward balance not updated correctly(before:%d, added:%d, final:%d)\", poolRewardBalanceBefore, rewardAmount.Uint64(), poolRewardBalanceAfter))\n\t}\n\n\tincentiveDuration := endTimestamp - startTimestamp\n\tincentiveBlock := incentiveDuration / consts.BLOCK_GENERATION_INTERVAL\n\trewardAmountX96 := new(u256.Uint).Mul(rewardAmount, u256.MustFromDecimal(consts.Q96))\n\trewardPerBlockX96 := new(u256.Uint).Div(rewardAmountX96, u256.NewUint(uint64(incentiveBlock)))\n\n\tincentives[incentiveId] = ExternalIncentive{\n\t\ttargetPoolPath:    targetPoolPath,\n\t\trewardToken:       rewardToken,\n\t\trewardAmount:      rewardAmount,\n\t\trewardLeft:        rewardAmount,\n\t\tstartTimestamp:    startTimestamp,\n\t\tendTimestamp:      endTimestamp,\n\t\trewardPerBlockX96: rewardPerBlockX96,\n\t\trefundee:          std.GetOrigCaller(),\n\t\tcreatedHeight:     std.GetHeight(),\n\t}\n\n\tpoolIncentives[targetPoolPath] = append(poolIncentives[targetPoolPath], incentiveId)\n\n\texternalLastCalculatedTimestamp[incentiveId] = time.Now().Unix()\n\n\tif rewardToken == consts.GNS_PATH {\n\t\texternalGns[incentiveId] = rewardAmount.Uint64()\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_poolPath\", targetPoolPath,\n\t\t\"p_rewardToken\", rewardToken,\n\t\t\"p_rewardAmount\", _rewardAmount,\n\t\t\"p_startTimestamp\", int64ToStr(startTimestamp),\n\t\t\"p_endTimestamp\", int64ToStr(endTimestamp),\n\t\t\"incentiveId\", incentiveId,\n\t\t\"external\", \"created\",\n\t)\n}\n\n// EndExternalIncentive ends the external incentive and refunds the remaining reward\n//\n// Parameters:\n//   - _refundee\t     (string): The address of the refundee\n//   - targetPoolPath (string): The path of the pool associated with the incentive\n//   - rewardToken    (string): The token path of the reward token\n//   - startTimestamp (int64): The start timestamp of the incentive\n//   - endTimestamp   (int64): The end timestamp of the incentive\n//   - height         (int64): The height of the block when the incentive was created\n//\n// Panics:\n//   - If incentive expiration time is not over\n//   - If reward token amount is not enough to refund\n//   - If the caller is neither the refundee nor the admin\nfunc EndExternalIncentive(_refundee, targetPoolPath, rewardToken string, startTimestamp, endTimestamp, height int64) {\n\trefundee := std.Address(_refundee)\n\n\tincentiveId := incentiveIdCompute(refundee, targetPoolPath, rewardToken, startTimestamp, endTimestamp, height)\n\n\tincentive, exist := incentives[incentiveId]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__EndExternalIncentive() || cannot end non existent incentive(%s)\", incentiveId))\n\t}\n\n\tif time.Now().Unix() \u003c incentive.endTimestamp {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__EndExternalIncentive() || cannot end incentive before endTimestamp(%d), current(%d)\", incentive.endTimestamp, time.Now().Unix()))\n\t}\n\n\t// when incentive end time is over\n\t// admin or refundee can end incentive ( left amount will be refunded )\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != refundee {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__EndExternalIncentive() || only refundee(%s) or admin(%s) can end incentive\", refundee, consts.GNOSWAP_ADMIN))\n\t}\n\n\t// refundee can end incentive with refund\n\trefund := incentive.rewardLeft\n\trefundUint64 := refund.Uint64()\n\n\tpoolLeftExternalRewardAmount := balanceOfByRegisterCall(incentive.rewardToken, GetOrigPkgAddr())\n\n\tif poolLeftExternalRewardAmount \u003c refundUint64 {\n\t\trefundUint64 = poolLeftExternalRewardAmount\n\t}\n\n\ttransferByRegisterCall(incentive.rewardToken, incentive.refundee, refundUint64)\n\t// unwrap if wugnot\n\tif incentive.rewardToken == consts.WUGNOT_PATH {\n\t\tunwrap(refundUint64)\n\t}\n\n\tdelete(incentives, incentiveId)\n\tfor i, v := range poolIncentives[targetPoolPath] {\n\t\tif v == incentiveId {\n\t\t\tpoolIncentives[targetPoolPath] = append(poolIncentives[targetPoolPath][:i], poolIncentives[targetPoolPath][i+1:]...)\n\t\t}\n\t}\n\n\tstd.Emit(\n\t\t\"GNOSWAP\",\n\t\t\"m_callType\", callType(),\n\t\t\"m_origCaller\", origCaller(),\n\t\t\"m_prevRealm\", prevRealm(),\n\t\t\"p_poolPath\", targetPoolPath,\n\t\t\"p_rewardToken\", rewardToken,\n\t\t\"p_refundee\", _refundee,\n\t\t\"end_by\", incentive.refundee.String(),\n\t\t\"refund_amount\", refund.ToString(),\n\t)\n}\n\nfunc checkStartTime(startTimestamp int64) {\n\t// must be in seconds format, not milliseconds\n\t// REF: https://stackoverflow.com/a/23982005\n\tnumStr := strconv.Itoa(int(startTimestamp))\n\tif len(numStr) \u003e= 13 {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__checkStartTime() || startTimestamp(%d) must be in seconds format, not milliseconds\", startTimestamp))\n\t}\n\n\t// must be at least +1 day midnight\n\ttomorrowMidnight := time.Now().AddDate(0, 0, 1).Truncate(24 * time.Hour).Unix()\n\tif startTimestamp \u003c tomorrowMidnight {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__checkStartTime() || startTimestamp(%d) must be at least +1 day midnight(%d)\", startTimestamp, tomorrowMidnight))\n\t}\n\n\t// must be midnight of the day\n\tstartTime := time.Unix(startTimestamp, 0)\n\thour, minute, second := startTime.Hour(), startTime.Minute(), startTime.Second()\n\n\tisMidnight := hour == 0 \u0026\u0026 minute == 0 \u0026\u0026 second == 0\n\tif !isMidnight {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__checkStartTime() || startTime(%d = %s) must be midnight of the day\", startTimestamp, startTime.String()))\n\t}\n}\n\nfunc transferDeposit(tokenId uint64, to std.Address) {\n\towner := gnft.OwnerOf(tid(tokenId))\n\tif std.GetOrigCaller() == to {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__transferDeposit() || only owner(%s) can transfer tokenId(%d), std.GetOrigCaller()(%s)\", owner, tokenId, std.GetOrigCaller()))\n\t}\n\n\t// transfer NFT ownership\n\tgnft.TransferFrom(a2u(owner), a2u(to), tid(tokenId))\n}\n\nfunc getTokenPairBalanceFromPosition(tokenId uint64) (string, string) {\n\tpoolKey := pn.PositionGetPositionPoolKey(tokenId)\n\n\tpool := pl.GetPoolFromPoolPath(poolKey)\n\tcurrentX96 := pool.PoolGetSlot0SqrtPriceX96()\n\tlowerX96 := common.TickMathGetSqrtRatioAtTick(pn.PositionGetPositionTickLower(tokenId))\n\tupperX96 := common.TickMathGetSqrtRatioAtTick(pn.PositionGetPositionTickUpper(tokenId))\n\n\ttoken0Balance, token1Balance := common.GetAmountsForLiquidity(\n\t\tcurrentX96,\n\t\tlowerX96,\n\t\tupperX96,\n\t\ti256.FromUint256(pn.PositionGetPositionLiquidity(tokenId)),\n\t)\n\n\tif token0Balance == \"\" {\n\t\ttoken0Balance = \"0\"\n\t}\n\tif token1Balance == \"\" {\n\t\ttoken1Balance = \"0\"\n\t}\n\n\treturn token0Balance, token1Balance\n}\n\nfunc gnsBalance(addr std.Address) uint64 {\n\treturn gns.BalanceOf(a2u(addr))\n}\n\nfunc isAllowedForExternalReward(poolPath, tokenPath string) {\n\ttoken0, token1, _ := poolPathDivide(poolPath)\n\n\tif tokenPath == token0 || tokenPath == token1 {\n\t\treturn\n\t}\n\n\tallowed := contains(allowedTokens, tokenPath)\n\tif allowed {\n\t\treturn\n\t}\n\n\tpanic(ufmt.Sprintf(\"[STAKER] staker.gno__isAllowedForExternalReward() || tokenPath(%s) is not allowed for external reward for poolPath(%s)\", tokenPath, poolPath))\n}\n\nfunc poolHasInternal(poolPath string) bool {\n\t_, exist := poolTiers[poolPath]\n\treturn exist\n}\n\nfunc poolHasExternal(poolPath string) bool {\n\t_, exist := poolIncentives[poolPath]\n\treturn exist\n}\n"},{"name":"token_register.gno","body":"package staker\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\ntype GRC20Interface interface {\n\tTransfer() func(to pusers.AddressOrName, amount uint64)\n\tTransferFrom() func(from, to pusers.AddressOrName, amount uint64)\n\tBalanceOf() func(owner pusers.AddressOrName) uint64\n\tApprove() func(spender pusers.AddressOrName, amount uint64)\n}\n\nvar (\n\t// registered is a map of registered GRC20 interfaces keyed by package path\n\tregistered = make(map[string]GRC20Interface)\n\tlocked     = false // mutex\n)\n\n// GetRegisteredTokens returns a slice of all registered tokjen package paths\nfunc GetRegisteredTokens() []string {\n\ttokens := make([]string, 0, len(registered))\n\tfor k := range registered {\n\t\ttokens = append(tokens, k)\n\t}\n\treturn tokens\n}\n\n// RegisterGRC20Interface registers a GRC20 interface for a given package path.\n//\n// Panics:\n//   - If the caller is not the authorized TOKEN_REGISTER address\n//   - If the package path is already registered\nfunc RegisterGRC20Interface(pkgPath string, igrc20 GRC20Interface) {\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker_register.gno__RegisterGRC20Interface() || unauthorized address(%s) to register\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker_register.gno__RegisterGRC20Interface() || pkgPath(%s) already registered\", pkgPath))\n\t}\n\n\tregistered[pkgPath] = igrc20\n}\n\n// UnregisterGRC20Interface removes a registered GRC20 interface for a given package path.\n//\n// Panics:\n//   - If the caller is not the authorized TOKEN_REGISTER address\nfunc UnregisterGRC20Interface(pkgPath string) {\n\t// only admin can unregister\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker_register.gno__UnregisterGRC20Interface() || unauthorized address(%s) to unregister\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tdelete(registered, pkgPath)\n\t}\n}\n\nfunc transferByRegisterCall(pkgPath string, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker_register.gno__transferByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].Transfer()(pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[POOl] staker_register.gno__transferByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc transferFromByRegisterCall(pkgPath string, from, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker_register.gno__transferFromByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].TransferFrom()(pusers.AddressOrName(from), pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[POOl] staker_register.gno__transferFromByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc balanceOfByRegisterCall(pkgPath string, owner std.Address) uint64 {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker_register.gno__balanceOfByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tbalance := registered[pkgPath].BalanceOf()(pusers.AddressOrName(owner))\n\treturn balance\n}\n\nfunc approveByRegisterCall(pkgPath string, spender std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] staker_register.gno__approveByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tregistered[pkgPath].Approve()(pusers.AddressOrName(spender), amount)\n\n\treturn true\n}\n\nfunc handleNative(pkgPath string) string {\n\tif pkgPath == consts.GNOT {\n\t\treturn consts.WRAPPED_WUGNOT\n\t}\n\n\treturn pkgPath\n}\n"},{"name":"type.gno","body":"package staker\n\nimport (\n\t\"std\"\n\n\tu256 \"gno.land/p/gnoswap/uint256\"\n)\n\ntype InternalTier struct {\n\ttier           uint64\n\tstartTimestamp int64\n\tstartHeight    int64\n\tupdateHeight   int64\n}\n\ntype ExternalIncentive struct {\n\ttargetPoolPath    string\n\trewardToken       string\n\trewardAmount      *u256.Uint\n\trewardLeft        *u256.Uint\n\tstartTimestamp    int64\n\tendTimestamp      int64\n\trewardPerBlockX96 *u256.Uint\n\trefundee          std.Address\n\tcreatedHeight     int64\n}\n\ntype Deposit struct {\n\towner          std.Address\n\tnumberOfStakes uint64\n\tstakeTimestamp int64\n\tstakeHeight    int64\n\ttargetPoolPath string\n}\n"},{"name":"utils.gno","body":"package staker\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/ufmt\"\n\n\tpusers \"gno.land/p/demo/users\"\n)\n\nfunc poolPathAlign(poolPath string) string {\n\tres := strings.Split(poolPath, \":\")\n\tif len(res) != 3 {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] utils.gno__poolPathAlign() || invalid poolPath(%s)\", poolPath))\n\t}\n\n\tpToken0, pToken1, fee := res[0], res[1], res[2]\n\n\tif pToken0 \u003c pToken1 {\n\t\treturn ufmt.Sprintf(\"%s:%s:%s\", pToken0, pToken1, fee)\n\t}\n\n\treturn ufmt.Sprintf(\"%s:%s:%s\", pToken1, pToken0, fee)\n}\n\nfunc poolPathDivide(poolPath string) (string, string, string) {\n\tres := strings.Split(poolPath, \":\")\n\tif len(res) != 3 {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] utils.gno__poolPathDivide() || invalid poolPath(%s)\", poolPath))\n\t}\n\n\tpToken0, pToken1, fee := res[0], res[1], res[2]\n\treturn pToken0, pToken1, fee\n}\n\nfunc a2u(addr std.Address) pusers.AddressOrName {\n\treturn pusers.AddressOrName(addr)\n}\n\nfunc tid(tokenId interface{}) grc721.TokenID {\n\tif tokenId == nil {\n\t\tpanic(\"[STAKER] utils.gno__tid() || tokenId is nil\")\n\t}\n\n\tswitch tokenId.(type) {\n\tcase string:\n\t\treturn grc721.TokenID(tokenId.(string))\n\tcase int:\n\t\treturn grc721.TokenID(strconv.Itoa(tokenId.(int)))\n\tcase uint64:\n\t\treturn grc721.TokenID(strconv.Itoa(int(tokenId.(uint64))))\n\tcase grc721.TokenID:\n\t\treturn tokenId.(grc721.TokenID)\n\tdefault:\n\t\tpanic(\"[STAKER] utils.gno__tid() || unsupported tokenId type\")\n\t}\n}\n\nfunc max(x, y int64) int64 {\n\tif x \u003e y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc min(x, y uint64) uint64 {\n\tif x \u003c y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc uint8ToStr(i uint8) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc int32ToStr(i int32) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc int64ToStr(i int64) string {\n\treturn strconv.FormatInt(i, 10)\n}\n\nfunc uint64ToStr(i uint64) string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc strToUint64(s string) uint64 {\n\ti, err := strconv.Atoi(s)\n\n\tif err != nil {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] utils.gno__strToUint64() || failed to convert string(%s) to uint64\", s))\n\t}\n\n\treturn uint64(i)\n}\n\nfunc boolToStr(b bool) string {\n\tif b {\n\t\treturn \"true\"\n\t}\n\n\treturn \"false\"\n}\n\nfunc origCaller() string {\n\treturn std.GetOrigCaller().String()\n}\n\nfunc prevRealm() string {\n\treturn std.PrevRealm().PkgPath()\n}\n\nfunc callType() string {\n\tif prevRealm() == \"\" {\n\t\treturn \"DIRECT\"\n\t}\n\n\treturn \"INDIRECT\"\n}\n\nfunc contains(slice []string, item string) bool {\n\tfor _, element := range slice {\n\t\tif element == item {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"},{"name":"warm_up.gno","body":"package staker\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar warmUp = make(map[int64]int64) // map[percent]block\n\nfunc init() {\n\twarmUp[100] = 1296001 // 30d ~\n\twarmUp[70] = 432001   // 10d ~ 30d\n\twarmUp[50] = 216001   // 5d ~ 10d\n\twarmUp[30] = 1        // ~ 5d\n}\n\nfunc GetWarmUp(percent int64) int64 {\n\tvalue, exist := warmUp[percent]\n\tif !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] reward_math_warm_up.gno__GetWarmUp() || percent(%d) must be 30, 50, 70, 100\", percent))\n\t}\n\n\treturn value\n}\n\nfunc SetWarmUp(percent int64, block int64) {\n\tif _, exist := warmUp[percent]; !exist {\n\t\tpanic(ufmt.Sprintf(\"[STAKER] reward_math_warm_up.gno__SetWarmUp() || percent(%d) must be 30, 50, 70, 100\", percent))\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[STAKER] reward_math_warm_up.gno__SetWarmUp() || only admin(%s) or governance(%s) can set warm up period, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\twarmUp[percent] = block\n}\n"},{"name":"wrap_gns_block_time_change.gno","body":"package staker\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\ten \"gno.land/r/gnoswap/v2/emission\"\n\n\t\"gno.land/r/gnoswap/v2/gns\"\n)\n\nfunc GnsSetAvgBlockTimeInMs(ms int64) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"[STAKER] wrap_gns_block_time_change.gno__GnsSetAvgBlockTimeInMs() || only admin(%s) or governance(%s) can set avg block time, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\ten.MintAndDistributeGns()\n\tCalcPoolPosition()\n\n\tgns.SetAvgBlockTimeInMs(ms)\n}\n"},{"name":"wrap_unwrap.gno","body":"package staker\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/wugnot\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nfunc wrap(ugnotAmount uint64) {\n\tif ugnotAmount \u003c= 0 {\n\t\tpanic(ufmt.Sprintf(\"cannot wrap 0 ugnot\"))\n\t}\n\n\tif ugnotAmount \u003c consts.UGNOT_MIN_DEPOSIT_TO_WRAP {\n\t\tpanic(ufmt.Sprintf(\"Deposit below minimum: %d/%d ugnot.\", ugnotAmount, consts.UGNOT_MIN_DEPOSIT_TO_WRAP))\n\t}\n\n\t// WRAP IT\n\twugnotAddr := std.DerivePkgAddr(consts.WRAPPED_WUGNOT)\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\tbanker.SendCoins(consts.STAKER_ADDR, wugnotAddr, std.Coins{{Denom: \"ugnot\", Amount: int64(ugnotAmount)}})\n\twugnot.Deposit() // STAKER HAS WUGNOT\n\n\t// SEND WUGNOT: STAKER -\u003e USER\n\twugnot.Transfer(a2u(std.GetOrigCaller()), ugnotAmount)\n}\n\nfunc unwrap(wugnotAmount uint64) {\n\tif wugnotAmount == 0 {\n\t\treturn\n\t}\n\n\t// SEND WUGNOT: USER -\u003e STAKER\n\twugnot.TransferFrom(a2u(std.GetOrigCaller()), a2u(consts.STAKER_ADDR), wugnotAmount)\n\n\t// UNWRAP IT\n\twugnot.Withdraw(wugnotAmount)\n\n\t// SEND GNOT: STAKER -\u003e USER\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\tbanker.SendCoins(consts.STAKER_ADDR, std.GetOrigCaller(), std.Coins{{Denom: \"ugnot\", Amount: int64(wugnotAmount)}})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"40CkhNodCQuQMEWvq2ivxoS5ePQeLIp+2WU0nocY3CFJavSo3a9PzSUxKvry2TIFs9uvjNrZtTrvjZUbjtPgBg=="}],"memo":""},"blockNum":"716188"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"community_pool","path":"gno.land/r/gnoswap/v2/community_pool","files":[{"name":"community_pool.gno","body":"package community_pool\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\nfunc TransferToken(pkgPath string, to std.Address, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"only admin(%s) or governance(%s) can transfer community pool's balance, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[COMMUNITY_POOL] community_pool.gno__TransferToken() || pkgPath(%s) not registered\", pkgPath))\n\t}\n\n\tregistered[pkgPath].Transfer()(a2u(to), amount)\n}\n\nfunc a2u(addr std.Address) pusers.AddressOrName {\n\treturn pusers.AddressOrName(addr)\n}\n"},{"name":"token_register.gno","body":"package community_pool\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\ntype GRC20Interface interface {\n\tTransfer() func(to pusers.AddressOrName, amount uint64)\n\tTransferFrom() func(from, to pusers.AddressOrName, amount uint64)\n\tBalanceOf() func(owner pusers.AddressOrName) uint64\n\tApprove() func(spender pusers.AddressOrName, amount uint64)\n}\n\nvar (\n\tregistered = make(map[string]GRC20Interface)\n\tlocked     = false // mutex\n)\n\nfunc GetRegisteredTokens() []string {\n\ttokens := make([]string, 0, len(registered))\n\tfor k := range registered {\n\t\ttokens = append(tokens, k)\n\t}\n\treturn tokens\n}\n\nfunc RegisterGRC20Interface(pkgPath string, igrc20 GRC20Interface) {\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[COMMUNITY_POOL] token_register.gno__RegisterGRC20Interface() || unauthorized address(%s) to register\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tpanic(ufmt.Sprintf(\"[COMMUNITY_POOL] token_register.gno__RegisterGRC20Interface() || pkgPath(%s) already registered\", pkgPath))\n\t}\n\n\tregistered[pkgPath] = igrc20\n}\n\nfunc UnregisterGRC20Interface(pkgPath string) {\n\t// only admin can unregister\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[COMMUNITY_POOL] token_register.gno__UnregisterGRC20Interface() || unauthorized address(%s) to unregister\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tdelete(registered, pkgPath)\n\t}\n}\n\nfunc transferByRegisterCall(pkgPath string, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[COMMUNITY_POOL] token_register.gno__transferByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].Transfer()(pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[COMMUNITY_POOL] token_register.gno__transferByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc transferFromByRegisterCall(pkgPath string, from, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[COMMUNITY_POOL] token_register.gno__transferFromByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].TransferFrom()(pusers.AddressOrName(from), pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[POOl] token_register.gno__transferFromByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc balanceOfByRegisterCall(pkgPath string, owner std.Address) uint64 {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[COMMUNITY_POOL] token_register.gno__balanceOfByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tbalance := registered[pkgPath].BalanceOf()(pusers.AddressOrName(owner))\n\treturn balance\n}\n\nfunc approveByRegisterCall(pkgPath string, spender std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[COMMUNITY_POOL] token_register.gno__approveByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tregistered[pkgPath].Approve()(pusers.AddressOrName(spender), amount)\n\n\treturn true\n}\n\nfunc handleNative(pkgPath string) string {\n\tif pkgPath == consts.GNOT {\n\t\treturn consts.WRAPPED_WUGNOT\n\t}\n\n\treturn pkgPath\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"DakcxDSF0ROShxGtVUGzXkW4amHhEXGTHX85adQztv0Blkqo5K2q7mtKjaQTo65rvoaPz86c3p8gN83Q8ierqQ=="}],"memo":""},"blockNum":"716190"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","package":{"name":"protocol_fee","path":"gno.land/r/gnoswap/v2/protocol_fee","files":[{"name":"protocol_fee.gno","body":"package protocol_fee\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar xGnsPctBps uint64 = 5000 // 50%\n\nfunc DistributeProtocolFee() {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"only admin(%s) or governance(%s) can distribute protocol fee, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\ttokens := GetRegisteredTokens()\n\tfor _, token := range tokens {\n\t\t// default distribute protocol fee percent\n\t\t// xGNS 50%\n\t\t// devOps 50%\n\t\t// ...\n\n\t\tbalance := balanceOfByRegisterCall(token, consts.PROTOCOL_FEE_ADDR)\n\t\tif balance \u003e 0 {\n\t\t\ttoDevOps := balance * 5000 / 10000\n\t\t\ttoXGns := balance - toDevOps\n\n\t\t\ttransferByRegisterCall(token, consts.DEV_OPS, toDevOps)\n\t\t\ttransferByRegisterCall(token, consts.X_GNS_ADDR, toXGns)\n\t\t}\n\t}\n}\n\nfunc ChagneXGnsDistributePercent(fee uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tif caller != consts.GNOSWAP_ADMIN \u0026\u0026 caller != consts.GOV_ADDR {\n\t\tpanic(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"only admin(%s) or governance(%s) can change protocol fee distribution percent, called from %s\",\n\t\t\t\tconsts.GNOSWAP_ADMIN,\n\t\t\t\tconsts.GOV_ADDR,\n\t\t\t\tcaller,\n\t\t\t),\n\t\t)\n\t}\n\n\tif fee \u003e 10000 {\n\t\tpanic(\"fee should be less than 10000\")\n\t}\n\n\txGnsPctBps = fee\n}\n\nfunc GetXGnsDistributePercent() uint64 {\n\treturn xGnsPctBps\n}\n"},{"name":"token_register.gno","body":"package protocol_fee\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/r/gnoswap/v2/consts\"\n)\n\ntype GRC20Interface interface {\n\tTransfer() func(to pusers.AddressOrName, amount uint64)\n\tTransferFrom() func(from, to pusers.AddressOrName, amount uint64)\n\tBalanceOf() func(owner pusers.AddressOrName) uint64\n\tApprove() func(spender pusers.AddressOrName, amount uint64)\n}\n\nvar (\n\tregistered = make(map[string]GRC20Interface)\n\tlocked     = false // mutex\n)\n\nfunc GetRegisteredTokens() []string {\n\ttokens := make([]string, 0, len(registered))\n\tfor k := range registered {\n\t\ttokens = append(tokens, k)\n\t}\n\treturn tokens\n}\n\nfunc RegisterGRC20Interface(pkgPath string, igrc20 GRC20Interface) {\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[PROTOCOL_FEE] token_register.gno__RegisterGRC20Interface() || unauthorized address(%s) to register\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tpanic(ufmt.Sprintf(\"[PROTOCOL_FEE] token_register.gno__RegisterGRC20Interface() || pkgPath(%s) already registered\", pkgPath))\n\t}\n\n\tregistered[pkgPath] = igrc20\n}\n\nfunc UnregisterGRC20Interface(pkgPath string) {\n\t// only admin can unregister\n\tcaller := std.GetOrigCaller()\n\tif caller != consts.TOKEN_REGISTER {\n\t\tpanic(ufmt.Sprintf(\"[PROTOCOL_FEE] token_register.gno__UnregisterGRC20Interface() || unauthorized address(%s) to unregister\", caller.String()))\n\t}\n\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif found {\n\t\tdelete(registered, pkgPath)\n\t}\n}\n\nfunc transferByRegisterCall(pkgPath string, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[PROTOCOL_FEE] token_register.gno__transferByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].Transfer()(pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[PROTOCOL_FEE] token_register.gno__transferByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc transferFromByRegisterCall(pkgPath string, from, to std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[PROTOCOL_FEE] token_register.gno__transferFromByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tif !locked {\n\t\tlocked = true\n\t\tregistered[pkgPath].TransferFrom()(pusers.AddressOrName(from), pusers.AddressOrName(to), amount)\n\n\t\tdefer func() {\n\t\t\tlocked = false\n\t\t}()\n\t} else {\n\t\tpanic(\"[POOl] token_register.gno__transferFromByRegisterCall() || expected locked to be false\")\n\t}\n\treturn true\n}\n\nfunc balanceOfByRegisterCall(pkgPath string, owner std.Address) uint64 {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[PROTOCOL_FEE] token_register.gno__balanceOfByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tbalance := registered[pkgPath].BalanceOf()(pusers.AddressOrName(owner))\n\treturn balance\n}\n\nfunc approveByRegisterCall(pkgPath string, spender std.Address, amount uint64) bool {\n\tpkgPath = handleNative(pkgPath)\n\n\t_, found := registered[pkgPath]\n\tif !found {\n\t\tpanic(ufmt.Sprintf(\"[PROTOCOL_FEE] token_register.gno__approveByRegisterCall() || pkgPath(%s) not found\", pkgPath))\n\t}\n\n\tregistered[pkgPath].Approve()(pusers.AddressOrName(spender), amount)\n\n\treturn true\n}\n\nfunc handleNative(pkgPath string) string {\n\tif pkgPath == consts.GNOT {\n\t\treturn consts.WRAPPED_WUGNOT\n\t}\n\n\treturn pkgPath\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"bpbYQLY0AwoM7F+HQ3I530R7EYv9VYTIruhRrgUY8EET2dBzB1WxJzeT7dsMqvXAMO4z04r83T1nYwW/tebunQ=="}],"memo":""},"blockNum":"716192"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"register_gnodev","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/v2/register_gnodev","files":[{"name":"register_gnodev.gno","body":"package register_gnodev\n\nimport (\n\tpusers \"gno.land/p/demo/users\"\n\n\t\"gno.land/r/onbloc/bar\"\n\t\"gno.land/r/onbloc/baz\"\n\t\"gno.land/r/onbloc/foo\"\n\n\t\"gno.land/r/onbloc/obl\"\n\t\"gno.land/r/onbloc/qux\"\n\t\"gno.land/r/onbloc/usdc\"\n\n\t\"gno.land/r/demo/foo20\"\n\t\"gno.land/r/demo/wugnot\"\n\n\t\"gno.land/r/gnoswap/v2/gns\"\n\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n)\n\ntype FooToken struct{}\n\nfunc (FooToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn foo.Transfer\n}\nfunc (FooToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn foo.TransferFrom\n}\nfunc (FooToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn foo.BalanceOf\n}\nfunc (FooToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn foo.Approve\n}\n\ntype BarToken struct{}\n\nfunc (BarToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn bar.Transfer\n}\nfunc (BarToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn bar.TransferFrom\n}\nfunc (BarToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn bar.BalanceOf\n}\nfunc (BarToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn bar.Approve\n}\n\ntype BazToken struct{}\n\nfunc (BazToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn baz.Transfer\n}\nfunc (BazToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn baz.TransferFrom\n}\nfunc (BazToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn baz.BalanceOf\n}\nfunc (BazToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn baz.Approve\n}\n\ntype QuxToken struct{}\n\nfunc (QuxToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn qux.Transfer\n}\nfunc (QuxToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn qux.TransferFrom\n}\nfunc (QuxToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn qux.BalanceOf\n}\nfunc (QuxToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn qux.Approve\n}\n\ntype GnsToken struct{}\n\nfunc (GnsToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn gns.Transfer\n}\nfunc (GnsToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn gns.TransferFrom\n}\nfunc (GnsToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn gns.BalanceOf\n}\nfunc (GnsToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn gns.Approve\n}\n\ntype OblToken struct{}\n\nfunc (OblToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn obl.Transfer\n}\nfunc (OblToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn obl.TransferFrom\n}\nfunc (OblToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn obl.BalanceOf\n}\nfunc (OblToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn obl.Approve\n}\n\ntype Foo20Token struct{}\n\nfunc (Foo20Token) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn foo20.Transfer\n}\nfunc (Foo20Token) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn foo20.TransferFrom\n}\nfunc (Foo20Token) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn foo20.BalanceOf\n}\nfunc (Foo20Token) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn foo20.Approve\n}\n\ntype WugnotToken struct{}\n\nfunc (WugnotToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn wugnot.Transfer\n}\nfunc (WugnotToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn wugnot.TransferFrom\n}\nfunc (WugnotToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn wugnot.BalanceOf\n}\nfunc (WugnotToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn wugnot.Approve\n}\n\ntype UsdcToken struct{}\n\nfunc (UsdcToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn usdc.Transfer\n}\nfunc (UsdcToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn usdc.TransferFrom\n}\nfunc (UsdcToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn usdc.BalanceOf\n}\nfunc (UsdcToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn usdc.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/demo/wugnot\", WugnotToken{})\n\tpl.RegisterGRC20Interface(\"gno.land/r/demo/foo20\", Foo20Token{})\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/foo\", FooToken{})\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/bar\", BarToken{})\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/baz\", BazToken{})\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/qux\", QuxToken{})\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/obl\", OblToken{})\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/usdc\", UsdcToken{})\n\tpl.RegisterGRC20Interface(\"gno.land/r/gnoswap/v2/gns\", GnsToken{})\n\n\tsr.RegisterGRC20Interface(\"gno.land/r/demo/wugnot\", WugnotToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/demo/foo20\", Foo20Token{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/foo\", FooToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/bar\", BarToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/baz\", BazToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/qux\", QuxToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/obl\", OblToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/usdc\", UsdcToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/gnoswap/v2/gns\", GnsToken{})\n\n\trr.RegisterGRC20Interface(\"gno.land/r/demo/wugnot\", WugnotToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/demo/foo20\", Foo20Token{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/foo\", FooToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/bar\", BarToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/baz\", BazToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/qux\", QuxToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/obl\", OblToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/usdc\", UsdcToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/gnoswap/v2/gns\", GnsToken{})\n\n\tpf.RegisterGRC20Interface(\"gno.land/r/demo/wugnot\", WugnotToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/demo/foo20\", Foo20Token{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/foo\", FooToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/bar\", BarToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/baz\", BazToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/qux\", QuxToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/obl\", OblToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/usdc\", UsdcToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/gnoswap/v2/gns\", GnsToken{})\n\n\tcp.RegisterGRC20Interface(\"gno.land/r/demo/wugnot\", WugnotToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/demo/foo20\", Foo20Token{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/foo\", FooToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/bar\", BarToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/baz\", BazToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/qux\", QuxToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/obl\", OblToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/usdc\", UsdcToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/gnoswap/v2/gns\", GnsToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"HD9LPhVUNFY25mMjhkUtV9qrTqueC0lGAe8bVfYyXaIiSg+gUd1v1letRTzG/vPLjzdn/ZxD9D/i36dlkw4rtg=="}],"memo":""},"blockNum":"716193"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"SetPoolCreationFee","args":["0"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"4NsEgCdvg70+WUr+GhaHRhdbnOPY5+cfs694X1LnPn47LhiuNsHFVeKojOXJb/Uavhr8wzsLXeBPUwz7uMHecw=="}],"memo":""},"blockNum":"716194"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/demo/wugnot","gno.land/r/gnoswap/v2/gns","3000","79228162514264337593543950337"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"qXblr629J+7phJZC+hPmf5xXAtjFiBc9vfURRJNpiXAr/0qgpIPI5exYGJ/HY0TVoZVjdla2H6Bd7wDeCTqAzw=="}],"memo":""},"blockNum":"716196"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/bar","gno.land/r/onbloc/baz","100","79188560314459151373725315960"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"5v0bJLMExIX/RynS/+gKHsP7C8oba4OJ9WsLIDAefnFUojcy0RWBOrOJ91ort73cEsaoubv8LPTGAALKmXu1lQ=="}],"memo":""},"blockNum":"716198"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/foo","gno.land/r/onbloc/qux","100","79188560314459151373725315960"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"5ezBA4Q4WeoIXh4bhs9vhq2XZcRqWJwsU5WE3FHEtcpbFDfQ95NDbyamPbHJbt++XJHxgWs/y+j+JRwReG/fbQ=="}],"memo":""},"blockNum":"716200"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"FXxBwfOW/BfdrVgZkjwKwQddt2UdNuYGSc263xiuJNJMDsnN8ZmGnFWi0e9MiCRgv7g9glMdF3sU0qsd3aRJkQ=="}],"memo":""},"blockNum":"716202"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"TstCLpiWb4Fp0OtiTBbyGG9sUd3xlNzWP1capBAiEHYIiLNAP95zppc17UyDIQdbZDllaRY/QqNRsjcwbwuczQ=="}],"memo":""},"blockNum":"716204"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","18446744073709551615"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"9HBcj2k9VHvME2BjU5nVpiz/lnvUp5a5Dxj4tiQweUsy1J63lIFdFiSwB0MUJ+AY8lkLt8MRDZmUEZSWiL7Pow=="}],"memo":""},"blockNum":"716206"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"20000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/gnoswap/v2/gns","gnot","3000","-49980","49980","20000000","20000000","1","1","9999999999","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"lT5dWD9J2nzUi0mHbBtuSfgQZH/5/ZAfFzw/DK+wnekH7Qsk3b1eZ28l8uH7pTLfKohbu5OmWt9y+GM85hQ/0g=="}],"memo":""},"blockNum":"716207"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","1"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"AWT0LQjCPsGwFCNRKyDyyc1ng70xrzabqPnpLACRmJklEpmalz40QDu+77ZmCDCXtVV3WKcbJ95g9LRqNqGbfA=="}],"memo":""},"blockNum":"716209"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["1"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"26ODcvSTYJm7u8UslsmI9aL/mowAKjzFzfJxj+z3VSwmj9YhYJq3/fUJ3g2oES1Ck8afjS97fa3ZNi4kwDDz1g=="}],"memo":""},"blockNum":"716211"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"SetPoolCreationFee","args":["100000000"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"RPtHeeQ9AHWTtWeENgJ8l56WFak0UHCkCthFOMWwtcQAlla2AwBbe5cC+LV+sjdfklx1BxiX/UnxSC6fawKI3g=="}],"memo":""},"blockNum":"716214"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/onbloc/pepe","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/onbloc/pepe\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"2tr51nGBHTuqgBdnGCvckVZbl0ZEAYrQzK5masfA82JTwpL6JURWj5Gd4vGvTstn/BYm+e8UgW15ZVLvnvmqRw=="}],"memo":""},"blockNum":"716359"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/onbloc/pepe","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/onbloc/pepe\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/onbloc/pepe\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"7jcHXHkQSHLI5F/ycgrIYjMOQ77EwS064LTI8xmUbVAoHlRd4hkse1e7USX+uNMbdyKv5c3L2euhNF8RlOW9xw=="}],"memo":""},"blockNum":"716361"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/gnoswap/gns","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/gnoswap/gns\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/gnoswap/gns\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/gnoswap/gns\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/gnoswap/gns\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/gnoswap/gns\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/gnoswap/gns\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"4G3bv4PnATF4bLaUSf/FjUmvaDHoqeCncWF0qjN5rNIh9/6NMq7JyeIyFKxRj7h71wfcFrf2opAdzwZBt9+BeA=="}],"memo":""},"blockNum":"716373"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/blake_lee/blake","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/blake_lee/blake\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"rsWHHGuDCClP22Ef9TDBdGGDywXf72V9a4sGwvDvjvlhsaGX37m4U9xdi+32L8NcStLy4ZATUoruxgHidOFL3Q=="}],"memo":""},"blockNum":"716381"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/blake_lee/blake20","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/blake_lee/blake20\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/blake_lee/blake20\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"XplA5Z2GmYKwtBYoMKuvyltYQft1ZLZn/TcYnusJ5KR/wp+zg0VXEoT0vCAmAy88JdvmR/i6iL3L9yJL1NeX7g=="}],"memo":""},"blockNum":"716383"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/jinwoo\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"XfR4awGLb7+Aa8iECCWN7bYLTimluYaCj72aZzN4xqhxUjgBxbDu5F6bvi3ySvD0wiErY649RDmV+ejLYTUu4Q=="}],"memo":""},"blockNum":"716390"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g164p69fcmqpedqh30e9wcrcffzkswy798ca2485/nr\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"Yi2rrAC0vFXFnAMCguagE5ccQrLwbvQSrjGR2gKy4wNGByBr8RuGXf8Mct4qtQIcZ5f8AMlbhnukH7ivd1ttBA=="}],"memo":""},"blockNum":"716393"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g146gxysfx24t3nar4z4yzkca2g8u9vl8xlpmtq0/tuna\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"CobBKbO9wz+dl5HjeMW1rj0gzgi2yLrjVElLLIqrRlRJqhh2LI2qci7YNXNKvhQ0/0vBBiRyPpTNooBtGDuH+g=="}],"memo":""},"blockNum":"716396"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1s3gd740mld8chsjw5g0nmmzfd9g520w9e7m5t6/sandwich\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"eNciacmN31Q7XB4Td69T+FMss93dAHNSDcKvGktjmsUNYSNK/RgyfSBKCjmXWhd9BstDseO0VBaccthfmZnT2Q=="}],"memo":""},"blockNum":"716398"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1w6886hdj2tet0seyw6kn8fl92sx06prgd9w9j8/vmt\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"sfqwQYu9MDHOHm+gH7OQwEddLbnp7fZVRoBj9zyE8s4LjG7Ab1s3osfTW+uhjJH5fcm963pTHtAEs0aC3N9mtw=="}],"memo":""},"blockNum":"716410"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/grc20_launchpad","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/grc20_launchpad\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/grc20_launchpad\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"DOTEsTxUhuNiqKKpPiuapN86a7rb7ki7nvqtLAxEbfQol8s4eMyG1+KUDCW2DvvVckTvDbs6TQhjOpRgxHG8qw=="}],"memo":""},"blockNum":"716414"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/lunc","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/lunc\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/lunc\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"gaBboUTfenCISmWguf40PCxFJATBFMDw/ajkeagPttA1lkK08Z0tck0MADqeHEKCzi125XmgsM+YXObMyjwd/w=="}],"memo":""},"blockNum":"716416"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/wif","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/wif\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/wif\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"RKjNPf1Uohs5yjQe6ZN4o/Jjrg6KdpWPGr27jP1rbT8nvMudV4SUkYNQGNSphubAC6U/e1jxxi7q/NrgdUSgvg=="}],"memo":""},"blockNum":"716423"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/villaquiranm/tofu","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/villaquiranm/tofu\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/villaquiranm/tofu\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"hQBojSQ5/Ns6VazhXEtSrLnSOdwrfHuqcTNyIeRifat9sCKxb+tYA5gkLofGm0BJopD1LmRiCPARsAV6lrHz7g=="}],"memo":""},"blockNum":"716424"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/foom20\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"g4lDS/ryTwPogALCvK9vczA9VaHAVfALFwbfhBs68uUMsXIYQDC/Hon7Pct+i8v6r3eKXL0a2bL08fr/8xth2g=="}],"memo":""},"blockNum":"716459"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/candy20\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"1Fv7bQVrqH00upBRpcLNzTso5vJbn0ubkelceKJcz11/YPjDsyBnYM6NtEm71WJzz334LUVufUyWbSOzKgFHdQ=="}],"memo":""},"blockNum":"716461"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1ngywvql2ql7t8uzl63w60eqcejkwg4rm4lxdw9/minus\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"RCuApitc2M6XoUt9AvZDRUoH+uA447s0ISxvnazTyihMAJ9xkawBXemFVShl5v7xX1rqImo3dqCZABfQn2fVsg=="}],"memo":""},"blockNum":"716463"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g1pgcgqvm5ta3rfw7t67yp9faj94ynmxn5ygx2cd/gnome\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"6BfCMCmBmQapOiF+z4SBsU6S0bhPaZPC2gaXheGOY5wvcttKldR3wN0KRBeku+0NKBooZqCr/GZq/tVSoPSzLA=="}],"memo":""},"blockNum":"716484"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5","package":{"name":"token_register","path":"gno.land/r/g1er355fkjksqpdtwmhf5penwa82p0rhqxkkyhk5/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey","files":[{"name":"register.gno","body":"package token_register\n\nimport (\n\ttoken \"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\"\n\n\tpusers \"gno.land/p/demo/users\"\n\n\tpl \"gno.land/r/gnoswap/v2/pool\"\n\trr \"gno.land/r/gnoswap/v2/router\"\n\tsr \"gno.land/r/gnoswap/v2/staker\"\n\tpf \"gno.land/r/gnoswap/v2/protocol_fee\"\n\tcp \"gno.land/r/gnoswap/v2/community_pool\"\n)\n\ntype NewToken struct{}\n\nfunc (NewToken) Transfer() func(to pusers.AddressOrName, amount uint64) {\n\treturn token.Transfer\n}\n\nfunc (NewToken) TransferFrom() func(from, to pusers.AddressOrName, amount uint64) {\n\treturn token.TransferFrom\n}\n\nfunc (NewToken) BalanceOf() func(owner pusers.AddressOrName) uint64 {\n\treturn token.BalanceOf\n}\n\nfunc (NewToken) Approve() func(spender pusers.AddressOrName, amount uint64) {\n\treturn token.Approve\n}\n\nfunc init() {\n\tpl.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n\trr.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n\tsr.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n\tpf.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n\tcp.RegisterGRC20Interface(\"gno.land/r/g13f63ua8uhmuf9mgc0x8zfz04yrsaqh7j78vcgq/monkey\", NewToken{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqmmYKxiRDVAgo6iCd7tRUreVtTLUm3iIw6iCw+knaqF"},"signature":"0gGyO8lDLm01L2BXiQT/kNfUjd4eEgaRKb3uCUz+yNpbbcepz9Tdr1NYqZG0RaHaaz678WnxA3KmiuCh92358Q=="}],"memo":""},"blockNum":"716487"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1fp54k0r5eaep9gl6qumhmc4c64mln3ueh4xgrt","amount":"5000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"J83FvrIBV8syZ7RTas1WqwUnN6rxcbV0kA+DTGlLFbo1xR5d8NxpLIwyQR8lx4TsAVUE+5GYCcyN8l8SvZt5EQ=="}],"memo":""},"blockNum":"717374"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fp54k0r5eaep9gl6qumhmc4c64mln3ueh4xgrt","package":{"name":"hello","path":"gno.land/r/g1fp54k0r5eaep9gl6qumhmc4c64mln3ueh4xgrt/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnVRfQG9ERkQjOHYZ+3mHlv4I7Def8uIinqn/k4aBNGS"},"signature":"PGOCXev88tGmX+sQjXQJU58bzGkOMc0/TyWb4h//orgnIL4oJV4NOn2M3J68yuzQJkUxHoKm+XAizKDGMpHkqQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"717408"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fp54k0r5eaep9gl6qumhmc4c64mln3ueh4xgrt","package":{"name":"hello","path":"gno.land/r/g1fp54k0r5eaep9gl6qumhmc4c64mln3ueh4xgrt/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnVRfQG9ERkQjOHYZ+3mHlv4I7Def8uIinqn/k4aBNGS"},"signature":"gB6hbFGjJg7Kvn9PQI1YLCiYTj5iWFPcNcU1r8GTHo1C3r0ZVLwDj+hRt9NTuTCQhkswIN0YxpMG1GBqnRB0eQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"717416"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fp54k0r5eaep9gl6qumhmc4c64mln3ueh4xgrt","package":{"name":"hello","path":"gno.land/r/g1fp54k0r5eaep9gl6qumhmc4c64mln3ueh4xgrt/hello","files":[{"name":"package.gno","body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnVRfQG9ERkQjOHYZ+3mHlv4I7Def8uIinqn/k4aBNGS"},"signature":"CYNhfBcijPe0jlqP/TL3jbmeKUieBXpWl5JILZk3rnpmFEBFT9zMkme294gy+Y1CNiP66reeVJlni49hhNQo/w=="}],"memo":"Deployed through play.gno.land"},"blockNum":"717421"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"hhhlldu","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/hhhlldu","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(addressFrom std.Address,amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"FZlYK4Cb2cUhIfexNpG/fUrs7KVXLGtYoIFHC/iclDJ4ImDlkACA/mdAcFpgbBLQqbMEOm65HgIXus/hU1KtPg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"718145"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"9999999999999ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/gnoswap/v2/gns","gnot","3000","-6960","6960","10000000000000","9999999999999","9950000000000","9949999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"ehZMaN55ZSqEBS0pdcG81BZOujKYggUk46+tdB20Swttze+lkV63mfWv+kJOEMtfbPowPAAsNGKSe7Bg+S4Gaw=="}],"memo":""},"blockNum":"718154"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"9999999999999ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/gnoswap/v2/gns","gnot","3000","-6960","6960","10000000000000","9999999999999","9950000000000","9949999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"6ji/iSAK4KBHYr4wf6Y1Aa4XYwJjbbkPgPv89x/oyP1cIND1AlA9hnCZcLLSFUkWs2eT77GwIhuD046jxGPTsQ=="}],"memo":""},"blockNum":"718166"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/demo/wugnot","gno.land/r/onbloc/usdc","3000","79228162514264337593543950336"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","5000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","4999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","5000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"5000000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/onbloc/usdc","3000","-6960","6960","5000000000000","4999999999999","4975000000000","4974999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"lDNU5hRq99OToFqOo21l29t1ny3r9jJGaLsEKJb+IP86kCINn4fcRGlvsjM2aNqL1mG5LL63aqvIEW9nubb8cw=="}],"memo":""},"blockNum":"718199"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"10000000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/v2/gns","3000","-6960","6960","10000000000000","9999999999999","9950000000000","9949999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"lj63pMnb2AT15+cS+i14rNqAt+9WYRHA1EAz8csLUrpDuohPagiDW0eQkkMJqCWxWQC1U3kTAN5UbkJS8GdB8Q=="}],"memo":""},"blockNum":"718217"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/demo/wugnot","gno.land/r/onbloc/usdc","3000","79228162514264337593543950336"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"10000000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/onbloc/usdc","3000","-6960","6960","10000000000000","9999999999999","9950000000000","9949999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"z/h3NpbNw4iThAf789G1mIIXvnLyn5lN9xh3Xtbzu4IF+aT9k4mIx896ckKXS5axEN9X7EmmPX4rBx5r1o8DTA=="}],"memo":""},"blockNum":"718244"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"hhhlldu","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/hhhlldu","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(addressFrom std.Address,amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"ALL6hoY05ncQr8cmKvwO82pBeYunSuSYszmQNyerChR9G8w1WVfIwgDjnmUViFmCBKbjav1w+4s9zAruaC/WvA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"718409"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"neko","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/neko","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(addressFrom std.Address,amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"PA09H4P2G1/5FNXPe8QqIBd7d6Nrl47bsPIESMBQC74lgNRxnMkqSrWWIg7ataRlkCx3RUumXXvhBuA7iiowCQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"718414"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"UnstakeToken","args":["1"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"6NkB0mv2Wj3dZyMZtJHi6UUHlvX+ydRHxP18HVltvPclPYF03dZ2mcvg2jll4QJWPH6bbHBTPhAEjwOyWAMiyA=="}],"memo":""},"blockNum":"718427"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/usdc","gno.land/r/gnoswap/v2/gns","3000","79228162514264337593543950336"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","5000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","4999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/usdc","gno.land/r/gnoswap/v2/gns","3000","-6960","6960","5000000000000","4999999999999","4975000000000","4974999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"LQbvJvHFKHnUshwvjUdOKTU+HOqpvB+h+vAIjDJ92j9dHNuBZID+xARJsBZDRHPgo88PiEcqZb1WN3mByGP+RQ=="}],"memo":""},"blockNum":"718443"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"9999999999999ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/gnoswap/v2/gns","gnot","3000","-6960","6960","10000000000000","9999999999999","9950000000000","9949999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"Z4MUd8xg09adpxWJ9yhUTioBDDbetwDZzJ2k/FfylCZZP2cbgKizEgdAJVD8zTyx0/ol3XYI3x6RqQq8iUuCdg=="}],"memo":""},"blockNum":"718446"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"bridge","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/bridge","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(addressFrom std.Address,amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"94uRca0q6FGDl92kVaxX5PbBrYPae0NheC0Q9qod751ld4CPWpKShpU2dXQcj5/bEdEYdC2+tFpoyYUUDoSJVQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"718454"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/usdc","gno.land/r/demo/wugnot","3000","79228162514264337593543950336"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"9999999999999ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/usdc","gnot","3000","-6960","6960","10000000000000","9999999999999","9950000000000","9949999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"Zv8nCMUzPjpC8RGHHJyj8HWIbXiAMYHQ9ImzR5NbtR9Q1EZtqzdsgiT9eYJYM0Y02OY1iUmpjnTbIoaBnT9o/w=="}],"memo":""},"blockNum":"718462"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","1000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/gnoswap/v2/gns:gno.land/r/onbloc/usdc:3000","gno.land/r/gnoswap/v2/gns","1000000000000","1723075200","1730851200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"xnLkJMh+sJ4wr8kfqKLZxTGQ1TtJkVkGGnGVlgA7c7ob1ZlXdLXkwp8c47UD4txYtXKto2sKIetTiMSccs4W8Q=="}],"memo":""},"blockNum":"718475"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/bar","gno.land/r/gnoswap/v2/gns","3000","55943889866178682795415489053"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","500000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","249874748824"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/bar","gno.land/r/gnoswap/v2/gns","3000","-13860","0","500000000000","249874748824","497500000000","248625375080","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"l9eSLiDKNwsvFKapTEpJe/Bxnoi01CNKYK4VeQJheyhwUl1nwuF4wMMXh1yKoSUer9/qIGfcZP68WplirSzKRg=="}],"memo":""},"blockNum":"718480"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/bar","gno.land/r/gnoswap/v2/gns","3000","55943889866178682795415489053"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","500000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","249874748824"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/bar","gno.land/r/gnoswap/v2/gns","3000","-13860","0","500000000000","249874748824","497500000000","248625375080","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"TvFy1n0V8nwoBI6KWT947BfGw8dg+fIZRcaMoliffF8XvmTfE7PtEbZIaMFGjtbWzPFhi9ofcrwbw+GMW1iCQg=="}],"memo":""},"blockNum":"718489"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"8NSpzpJpmcRlnvZ/oyUtGdM6KRTz2SewA66cJl9NW8B+oMZhcDsDUZeYtMnq19Pp+P4FGNdjREs0bogc2+EQBg=="}],"memo":""},"blockNum":"718496"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/usdc","1000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000","100","990624"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"nYr/+tXBOOz8/D/Uxwk6mY4nW5r/oe3/WQYDWK6+NTsUyh75+i4PGcffiXFHien21NluuneR2YYfXzq43+Ctvw=="}],"memo":""},"blockNum":"718503"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/bar","gno.land/r/gnoswap/v2/gns","3000","55943889866178682795415489053"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","49974949764"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/bar","gno.land/r/gnoswap/v2/gns","3000","-13860","0","100000000000","49974949764","99500000000","49725075015","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"zKnK7Y0MvVac0A62ryvpQn47SjjfJahjpAKSqAsPyDE052dmPebVy/jr0MO4/Hw2+txLqvbrgRpbun24RO6MBQ=="}],"memo":""},"blockNum":"718505"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/gnoswap/v2/gns","gnot","10000000","EXACT_IN","gno.land/r/gnoswap/v2/gns:gno.land/r/demo/wugnot:3000","100","9905266"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"IjDmIDOEeE/lOfD+9t5Gk16baCXs3F1uxB8eFCngU0hOem+JihJ2iP8ANX8WxOAQ67DR/QuTw6PjtBin3lF/9Q=="}],"memo":""},"blockNum":"718513"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","1000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"1000000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000","gnot","1000000000000","1723075200","1730851200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"n3dTZXUwCdYPns7LEYHUcGBhPBeTLU9WNrK9eYKgwJcsV4r6GvAG1iYGkMQixUFvb2ZnAKK9LcsJTi3uPgTn5Q=="}],"memo":""},"blockNum":"718530"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/bar","gno.land/r/gnoswap/v2/gns","3000","55943889866178682795415489053"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","49974949764"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/bar","gno.land/r/gnoswap/v2/gns","3000","-13860","0","100000000000","49974949764","70000000000","34982464835","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"bj6g8PyURF9SziomNW8sdFTD1hckab7vzeJpKXvouWN8ZardGxHOswWs61KuR67ThD4vvhFuJkNivp6RkEtIcw=="}],"memo":""},"blockNum":"718538"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","100000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"100000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","gnot","100000000000","1723075200","1730851200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"fMg9iidcp46u4sOZhsrg3I5omtIFeWiuwLC/5G+phGlk/l88eqf1eAclPBJPHEQZKalQdOHSljCeXwIC24aVjQ=="}],"memo":""},"blockNum":"718550"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/baz","gno.land/r/demo/wugnot","3000","55943889866178682795415489053"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","499749497649"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","499749497649"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"499749497649ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/baz","gnot","3000","-13860","0","1000000000000","499749497649","995000000000","497250750161","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"/IFHdwK4Vx64Nwyb7piGB9+wH8WH69E7/8YhWO+U9pMlHkwUUrho3YVmuBFgHJBa7Ac2Jkz0RMQBjLEb+fU2SQ=="}],"memo":""},"blockNum":"718556"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/baz","gno.land/r/demo/wugnot","3000","55943889866178682795415489053"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","499749497649"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","499749497649"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"499749497649ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/baz","gnot","3000","-13860","0","1000000000000","499749497649","700000000000","349824648354","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"u+oTlpYdKqKNGQANmHAV+P6FzOWPWPlPVNvhdWo0qhJFeufrsDXw/kv+BDJbZJbt14EvKDYEniV3AVCFSvGMHg=="}],"memo":""},"blockNum":"718559"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","1000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"1000000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/v2/gns","3000","-887220","887220","1000000000000","999999999999","995000000000","994999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"W9l93133quKOWcTAeuueRGXi0m1wVTcpN2N6Jkw0mD8lAtsm5zeKWwx7jqLWFKvW7n4rj7hqRfHjVT6Z1Gqe+Q=="}],"memo":""},"blockNum":"718592"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","5000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","5000499999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","5000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"5000000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/onbloc/usdc","3000","-887220","887220","5000000000000","5000499999999","4975000000000","4975497499999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"EugRIs4WVr/m60oixKqie0FzF62iORNh+3dRxw63QQRrLMkksloTomc6joJKsoLqheQ+JREIKphxJoy8VCM65A=="}],"memo":""},"blockNum":"718609"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","5000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","5001701527947"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/gnoswap/v2/gns","gno.land/r/onbloc/usdc","3000","-6960","6960","5000000000000","5001701527947","4975000000000","4976693020307","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"oOvc6hEq1CPkPEWKJuQ3Qb3/0/kZo+E0V/igTpxA1/wM20RRFOXe0ijVMuccIpH6hbRg1mRY7/YAUiOJF9l4bg=="}],"memo":""},"blockNum":"718614"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","5000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","6555864707629"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/gnoswap/v2/gns","gno.land/r/onbloc/usdc","3000","-2880","2160","5000000000000","6555864707629","4975000000000","6523085384091","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"cY8BkH/m+vogQ+/EwQswA1NyXnzH+8Ldf5IYO6NpgMZSrnLk3yiliTkpUjYtgBCS7KAxJLty2vBAfGRl9fGRxw=="}],"memo":""},"blockNum":"718622"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/usdc","gno.land/r/gnoswap/v2/gns","100000000000","EXACT_IN","gno.land/r/onbloc/usdc:gno.land/r/gnoswap/v2/gns:3000","100","98923819610"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"8w1dytF/Lnyscx3R7mYXgtQh0TL/M1IDf6LYMQORN5gXb5kE103fRRYbZyNtGB6wJBiecPuBq5W9dVbNhf/wHA=="}],"memo":""},"blockNum":"718628"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","1"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["1"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","3"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["3"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","7"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["7"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"8Nufjg3yEDZmZBBhhBaHb/aQazbG8HfzHumB0L6blAQgt/mzJzc77UAzvuyg75A4PR8cu6WlZpSbVsauTkSb1A=="}],"memo":""},"blockNum":"718642"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","784567000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","803114770868"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","784567000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"784567000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/onbloc/usdc","3000","-14460","13980","784567000000","803114770868","780644165000","799099197014","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"UST30Gezi1kd21tq4ZAORaYoIfM73x6GuirrE533mQB1yGg80Lu26bYlrmtYdxtvsvo9OeXWc9zbd6xMNAKyrw=="}],"memo":""},"blockNum":"718652"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","4"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["4"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","8"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["8"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","11"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["11"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"2DLZ3LEfBDgEeKapcNaWH1JXyCHlKMWhoXG5RzE5xj8gV2r0Oa3HJo01vGU1tRIQsMmfZVvESwS/HTOBcEDW4Q=="}],"memo":""},"blockNum":"718657"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","4"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["4"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","8"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["8"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","11"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["11"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"/sEeI7J6CEu7g/MMxRlXKNMV1n1lcOYDP0Z3YtvNTIx+xCa9YAvE9d3LVxOWWFuD3f6igp53lsK/RxgNu44dGg=="}],"memo":""},"blockNum":"718664"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","2"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["2"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","9"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["9"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","10"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["10"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"EypHSdZ9jxU0QSToBZ/dWMJaeBXmWrKra73ntxhe1h1ndRDWb8WtqbP0+SnN33HGjyf0mGax5fj8PJ1zyaHFqQ=="}],"memo":""},"blockNum":"718683"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/staker","func":"SetPoolTier","args":["gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000","1"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"mNtH/BMrKHySqtXDjKZ8LiYsT7ZDq+I7mNfBPTywiD13YYsyz6VrHXNYAXu34EgWWyLF2OmyFv281fIPYWtSxQ=="}],"memo":""},"blockNum":"718709"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"SetPoolTier","args":["gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000","1"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"G+++fm8SHsddhJThDf16kl98huQ4OQwY5BJZRE4WU1l3MKGjq+lnxzsrAtHfubp7IGesww0FKG3rPpDAeUU6yw=="}],"memo":""},"blockNum":"718756"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"SetPoolTier","args":["gno.land/r/gnoswap/v2/gns:gno.land/r/onbloc/usdc:3000","1"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"Co5wnmFcxmYA65o+ILT+pISuI3LFvYbzXj1AD3YZ5OgiKZdIjhOk6T46zVpRbbJiLmEbPLBjTIqfg6hg2NM7bw=="}],"memo":""},"blockNum":"718776"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/bar","gno.land/r/onbloc/baz","3000","25037868506736684196722767383"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","5000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","497951696246"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/bar","gno.land/r/onbloc/baz","3000","-29940","-16080","5000000000000","497951696246","4975000000000","495461937765","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"AuD2dlLUY1CLpTB49EJInC29l35lP499sKCsN1ujU0EjJ3f07cEvO7l+0wsEcqHo4IWeaK3nfLulhmr0Mc3xbg=="}],"memo":""},"blockNum":"718794"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/baz","gno.land/r/onbloc/usdc","3000","55943889866178682795415489053"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","48376467592"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/baz","gno.land/r/onbloc/usdc","3000","-11760","-1920","100000000000","48376467592","99500000000","48134585254","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"q2KxMSmwT+Kw95Ap7tHLZeAJKqZZqo4ZJ9PULzwmuOx+peLAB5lJ9TIBTuoZ4BynZ8cQ1u6UOrIn3pEqReLCsw=="}],"memo":""},"blockNum":"718825"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/baz","gno.land/r/onbloc/usdc","3000","55943889866178682795415489053"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","48376467592"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/baz","gno.land/r/onbloc/usdc","3000","-11760","-1920","100000000000","48376467592","95000000000","45957644212","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"sWx3BCqO5FlyUssgP/PQgAzXjjjTa+NqXG0eugezxYRJTid6t3EraPB3991sF5BxlVL8gBxJH7WVNKdl9P2XoA=="}],"memo":""},"blockNum":"718830"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/qux","gno.land/r/gnoswap/v2/gns","3000","79228162514264337593543950336"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/qux","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","10000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","9999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/qux","gno.land/r/gnoswap/v2/gns","3000","-6960","6960","10000000000","9999999999","9950000000","9949999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"BjDFRnpufUPlVWtFZgahlaC+brVzrCi5GNs6xQy69GB1gMlfCf1ASheY73GJ+2z92CmFTujH5KoJzBWDpY9FOA=="}],"memo":""},"blockNum":"718872"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/obl","gno.land/r/onbloc/foo","3000","79228162514264337593543950336"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","10000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","9999999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/obl","gno.land/r/onbloc/foo","3000","-6960","6960","10000000000000","9999999999999","9950000000000","9949999999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"h4Ij8mQb1WZMUJAtU/Y44dUB4Wp00OSPt4lIPCkYVCQRlVZ1rAlZFYhgaQeAlzwy1zE0ODLOH09pUsZxy3rvMw=="}],"memo":""},"blockNum":"718880"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/foo","gno.land/r/demo/wugnot","3000","79228162514264337593543950336"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","99999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","99999999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"99999999999ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/foo","gnot","3000","-6960","6960","100000000000","99999999999","99500000000","99499999999","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"PWV6xmo5qNZWRgGmm2n0uKtaQkNQpaJCOM+Cv8unbhN7M5bpYhhmu9NWIO+zViFCjjaUliR8zMYPYt7g47SSiQ=="}],"memo":""},"blockNum":"718888"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","100000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/pool","func":"CreatePool","args":["gno.land/r/onbloc/usdc","gno.land/r/onbloc/obl","3000","137181432533526987591609206383"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1111111000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","3433605141559"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/usdc","gno.land/r/onbloc/obl","3000","3720","18000","1111111000000","3433605141559","1105555445000","3416437115851","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"dLfWUbOOhldJD5p4s0z8haMJbooL6kYFUsbAaOrDWGJL4egidLjEDqc1vgvuOtFkyWROHfgw1I3iYwJ8I7JexA=="}],"memo":""},"blockNum":"718900"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","1000000000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/demo/wugnot:gno.land/r/onbloc/foo:3000","gno.land/r/onbloc/foo","1000000000000","1723075200","1754611200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"nL9/fNR3MsER1ZuaNv1kPnlOYQic5YikV4RtwHiUVU4FQrr9x6lQrBWcnp8oWsHcByi7e2B/rzM7CgVHPvw5mA=="}],"memo":""},"blockNum":"718912"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","56123000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/demo/wugnot:gno.land/r/onbloc/foo:3000","gno.land/r/gnoswap/v2/gns","56123000000","1723075200","1730851200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"c9jHEoyK9lbnlUzbUOA7x18X3Zm2M9PjSEH6qCir4jt1hwwIyxMiE81OU5ZqLU3D2T7za03yJhCdps0KIbymVw=="}],"memo":""},"blockNum":"718918"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","67123000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"67123000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/demo/wugnot:gno.land/r/onbloc/foo:3000","gnot","67123000000","1723075200","1738627200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"P/gbY4ys4xy0ajDxfkDGtd0LTTwQmbM7Rj/wpP8KtMNfU/H8mPBaF6B4iL/vBH4tvKwys1cuH8VdAIw54gfxzg=="}],"memo":""},"blockNum":"718925"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"SetPoolTier","args":["gno.land/r/demo/wugnot:gno.land/r/onbloc/foo:3000","2"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"QwMWYPB+oExT+VptWHeJneorwWAXexSy8VtW/soscSt23OUn4sMRyy/kyPG/lTVZybYQT4VSLw4MW/AZ2v4SIA=="}],"memo":""},"blockNum":"718940"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"1000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/foo","1000000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000*POOL*gno.land/r/onbloc/obl:gno.land/r/onbloc/foo:3000","100","2950696310"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"NetQN05fiIrY0+9vPniqdCLjeFl4uKV3A9tKDX2HoSVn5RXMU75pnxy2+OQdDjgKPfm3AkXvL/lXeJOwXkVPMA=="}],"memo":""},"blockNum":"718972"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/usdc","gno.land/r/onbloc/foo","1000000000","EXACT_IN","gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000*POOL*gno.land/r/onbloc/obl:gno.land/r/onbloc/foo:3000","100","2957266062"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"84KEJ7H7+N/WPf51/tYe6BKe07nwat9Fwyg/VNWQ9p0H8MfdG21ZbzJmP7HKvZySRH1ZUanzXk7ThTBvplxnRw=="}],"memo":""},"blockNum":"718978"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/gnoswap/v2/gns","gno.land/r/onbloc/foo","163000000","EXACT_IN","gno.land/r/gnoswap/v2/gns:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000*POOL*gno.land/r/onbloc/obl:gno.land/r/onbloc/foo:3000","100","481594434"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"o7rA/5NR1IQG8QEpNqBWq1ONNck0puITY3bU/IHfOwEPS05mu6bOgNg/JmuRpGGajrPKXIBMJO2pnxxRGzTTeQ=="}],"memo":""},"blockNum":"718984"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gnot","1000000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000","100","987534040"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"4HJe/L8pjgog4Mgkaob91BIIjloeSnAmUxR2hFStd3U72/fnqXA54Zo5hzgaD876DXZkF66p6fVBp6wuLKFDiQ=="}],"memo":""},"blockNum":"719010"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gnot","1612000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000","100","1579812567"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"1pFMVWnYtP4MQd0paSV+5PB/6Tc+daSNHzFp+yfT4g4SXxBvlphJwcXe6LTQsPRvQ5pyQkN4WdxnMw1fJZfKIw=="}],"memo":""},"blockNum":"719014"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gno.land/r/gnoswap/v2/gns","6612000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000*POOL*gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","6307795941"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"tmPOY8aFOlglBln96UsAVVAfNAgGSpOm4w+3ap0OeOQ9UT70q/8EnFbG/qXFsN3UMvnQD4hZeDvoeec8ew0U7A=="}],"memo":""},"blockNum":"719020"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gno.land/r/gnoswap/v2/gns","1512000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000*POOL*gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","1408831296"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"tvMXx1U5zU1MbwVY2tNTqqUvZLqWpgFBeMJRAoy7CGttlaDmxfGNet93A6kuF86qjrHtdCa+yMXdpvKcbqZFjw=="}],"memo":""},"blockNum":"719026"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gno.land/r/onbloc/usdc","6611000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000*POOL*gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000","100","6022203402"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"/lOtkHzqgWP926GIstWYu9hK94L42WOnwKjVjeH6qcYF/LpToCL++kSYfK4Vu0mM3LL2T1+tH7txz5Rtv1MuEw=="}],"memo":""},"blockNum":"719029"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gno.land/r/onbloc/usdc","1115000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000*POOL*gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000","100","993706088"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"oCuuGLucRhkWCNIG5OGdoexmZ7zHoCpobYz+Zv+xQNVtH92782bYUejcNcxed8UEgKCTYdrRg96v8ftXV3pBBQ=="}],"memo":""},"blockNum":"719034"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gnot","1115000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000","100","990806369"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"6mnK+MqUEK3Am0BzkgWLMZArojjPxYqdRMveQ3YnZpBMqXLAJignSf9L9YHAGUEfc9nfpj25wNqEFpqW/bStSQ=="}],"memo":""},"blockNum":"719038"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gnot","861000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000","100","760918046"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"TWYPHHeb7k+5rsyuN7iiZRy5HXtwXk4evt2c0kGTQZ5eD/bw2M4Uos4hmAUKPxYZyICbpvSVtvF23CTaLjCLAA=="}],"memo":""},"blockNum":"719042"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gnot","5617000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000","100","4876534402"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"cYSFm9+3yvUUrKeiI2xrGfi0ldyDc/UlBSczU+u/a2slQfq8PCZwzzi2hSr6ZPTiKzGLt/DU9VYUo1JTMXdm3w=="}],"memo":""},"blockNum":"719046"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gno.land/r/gnoswap/v2/gns","1982000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000*POOL*gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","1679431745"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"fA9Wa5MzdEXiRXvuIlhVTaXTjgWLetCq6BG+XPID+Jwd8KVwaS02gjp64/PrhjaPklRM5XEtYutUbphFO+snCg=="}],"memo":""},"blockNum":"719049"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/foo","gnot","832000000","EXACT_IN","gno.land/r/onbloc/foo:gno.land/r/demo/wugnot:3000","100","702078467"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"a9qtK4QLPMIzU0562UE/UPvNcykZoaBZ6aIT+e6sUKVkCimBm8Qm/Cbj7nDyakpOKxJxrc8ITtn8rpKfN9mGCg=="}],"memo":""},"blockNum":"719054"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","512341000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","359518918569"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/foo","gno.land/r/onbloc/obl","3000","-660","960","512341000000","359518918569","509779295000","357721323976","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"4VQja6s430Td7LacgcMmR4Ll1KT+hB18cvYA2/O2nnca1jxwb6HfUbsSvgLa9HBLQIDtw56JhHZ4DSxv4vCXBg=="}],"memo":""},"blockNum":"719065"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1111560999999"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1112116891666"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gno.land/r/onbloc/foo","gno.land/r/onbloc/obl","3000","-887220","887220","1111560999999","1112116891666","1106003194999","1106556307208","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"SY3BreJtvKKDGQ3IxIxyhLm+AATphH2Zual+jprMWYMQfnQMHwv4ToAhveqnDt3mF7zp0BejWedIxt0c9bFUyA=="}],"memo":""},"blockNum":"719072"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","15111000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/onbloc/foo:gno.land/r/onbloc/obl:3000","gno.land/r/gnoswap/v2/gns","15111000000","1723075200","1754611200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"GHjFpRat6Q4OVlsMBRAeJKc1XDTF2V4L99r0wjSiZZR+0MAWLi4ayIrxzWpcGPTHQ+YN73PZn4j9FAjQoH96Rw=="}],"memo":""},"blockNum":"719083"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","697832000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/onbloc/foo:gno.land/r/onbloc/obl:3000","gno.land/r/onbloc/obl","697832000000","1723075200","1754611200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"cpN22qiyJgiSJszUZDuofv7VVACLvBBHcC85187+qAhczpMen+4/HSdQBg7dZe8oCjatjdzExqexv3dspjz74w=="}],"memo":""},"blockNum":"719088"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","999999000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/onbloc/foo:gno.land/r/onbloc/obl:3000","gno.land/r/onbloc/foo","999999000000","1723075200","1754611200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"T4I1fFhgk0dO4bnXR/usqpr5C4fdRuSP90R5INfEbuwyC6nR2BFjPdXTCLdVLmOZk0oP5vQvc7qtLXVDOLvvag=="}],"memo":""},"blockNum":"719093"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"SetPoolTier","args":["gno.land/r/onbloc/foo:gno.land/r/onbloc/obl:3000","3"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"//lrBE3Zj2BvUR4XH+Z9RafMg6uMFX2AoZb+ZFXHoX5nxIeo4bNDySF6s4knoTudv3vQi97kaV1xtc+lW42TaQ=="}],"memo":""},"blockNum":"719109"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","109673000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","139101139049"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","109673000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"109673000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/onbloc/foo","3000","-2280","5220","109673000000","139101139049","109124635000","138405633354","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"EiFTsb50x93MYZ67i/c42FdbRFHVouVYptHyrULDksZaahdNbpmiv8R+6K6jCkemUIszF37z4n3prnzYSQ7glQ=="}],"memo":""},"blockNum":"719118"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1567123000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1843624239642"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","1567123000000"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"1567123000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/onbloc/foo","3000","-887220","887220","1567123000000","1843624239642","1559287385000","1834406118444","7282571140","g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"ilNbkY9g9Cj66imwys+G8cRCvO+GB71z02LwGYirKvBsVK6LOgwkbdJzNZ7jQTMGFmt6S/oGMT2QFILejOsE+Q=="}],"memo":""},"blockNum":"719126"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","16"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["16"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","20"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["20"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","21"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["21"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"De0GbX9TInVH8Pl1doaV0GVd1s3wLBgiqm4g4zyyG74uOBwEtJ+3Aw9meq35pDgQEPFxUwu9Jt9+zXEMlSTR/g=="}],"memo":""},"blockNum":"719133"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","15"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["15"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","18"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["18"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","19"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"StakeToken","args":["19"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"b5GxMcUcVcUVzWllhtvnOL3+KE1BQ80jIXuMJWkZBtJ95VdlTST77sxXGRynhkK4/nHDwUYrY8W1C28KK16o5A=="}],"memo":""},"blockNum":"719217"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"1000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/obl","1000000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","2955562488"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"uSQECAJu5Cjz2FxEHJFtulzW4x9WoT50cKPwtXimvdR2rgYbGeDyl8+o58am5HEoML/PzEf2TM0o7obTyg8aYw=="}],"memo":""},"blockNum":"719233"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"156000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/obl","156000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","460913684"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"TiXxMPbjzhsO6FypwJs8II3dIDS5ETTF5YgRJnJ3RvgtydMaVtQJ+g3+H/jKzyjC2jAlWlfJe2pE+N99UadOQw=="}],"memo":""},"blockNum":"719238"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"301000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/obl","301000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","889209588"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"7vm7DnPk/bPxci0GvuahsDGNuqJWa5gWjs/miwZR07dIRLykz2zKQfDcgo8oHQOtch4PLqkUtX9XEsF98M0A4Q=="}],"memo":""},"blockNum":"719243"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"234000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/obl","234000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","691172333"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"wU8spP7W5M0a5MkS5TzQKMRSDF9OsANGHA/fveWY9IJ8k4DjuW1Nvhjcapp/HINU2Szb2+XIqb3Jucw9btwMXg=="}],"memo":""},"blockNum":"719246"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"735000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/obl","735000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","2170382182"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"udYUUA+S9kxNnf3vStND4TzhpW5595Gb1t5U7lrZcXJfQiIVRL35IAOVkKiNvQhNWX03xDJFhHaXCAcmz9aKEA=="}],"memo":""},"blockNum":"719251"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"821000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/obl","821000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","2423241971"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"R12oYWEOOZD7CLtoSE2BIieR/lP/AcNLBTwvJ1cpiM0HyyLGSviN9+lE/9m/ga97CEWVTKZPGGAjGBNirgy+GA=="}],"memo":""},"blockNum":"719258"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"443000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/obl","443000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","1307069760"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"jzKLxQwiIKi/IBs1xAT3KU1K2045GksiphMvQO6cUaszZQDcs9FBMv0x0CllDFhkldftx20cnjihfhpvw0oGcg=="}],"memo":""},"blockNum":"719261"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"141000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/obl","141000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","415949773"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"9Xjc4ur5bJN6q5Vc9rEXxFxhfmaOthiMuTwlVV0PiXZ54IO12+ZWyffyDoNQ0Hxhnzws+3U+iU7RM7G1IVrxRw=="}],"memo":""},"blockNum":"719269"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/gnoswap/v2/gns","gno.land/r/onbloc/obl","611000000","EXACT_IN","gno.land/r/gnoswap/v2/gns:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","1807458553"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"Z8oPRGPNAveD0n4zGveorFZ8txrpr6UQPR/16d9dXoNOfOfQDfCEanv1xpW5Ohqvr/GsGqp4W+rMmrgaLZKNug=="}],"memo":""},"blockNum":"719280"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/gnoswap/v2/gns","gno.land/r/onbloc/obl","612000000","EXACT_IN","gno.land/r/gnoswap/v2/gns:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000","100","1809803435"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"PwCkJQNqZcxfJXpZVyQ2deJCjgAjvEZOGuUNykxqjQI5XOc4xGPEczLkKOasZk4bI6OSiYBE6tejmUJfhGXr+A=="}],"memo":""},"blockNum":"719286"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["1"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["1"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["2"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["2"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["3"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["3"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["4"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["4"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["7"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["7"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["8"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["8"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["9"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["9"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["10"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["10"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["11"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["11"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["15"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["15"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["16"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["16"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["17"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["18"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["18"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/obl","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["19"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["19"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["20"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["20"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["21"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["21"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"bfu1JQry06RvksUhslbNJ4H3VgVGaO01cyigybjnfYoBBcLWGpaB803Tn04xikwJQcMOXcAzzJjWEEK1rD26+A=="}],"memo":""},"blockNum":"719380"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"10000000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/usdc","10000000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000","100","9898031187"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"E5fuoq1pYXfLRdy95vixKCJ+13O24ZbaOdFavuLCMvM4j87QptiW0+trDlF4u+hUWuFnAGbeqvti3V9mYq051g=="}],"memo":""},"blockNum":"719434"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"100000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","100000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/baz:3000*POOL*gno.land/r/onbloc/baz:gno.land/r/onbloc/bar:3000*POOL*gno.land/r/onbloc/bar:gno.land/r/gnoswap/v2/gns:3000","100","979968767"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"c0jRGjiOTh4nDKU5KnAwNBysxLBHxq7DvMeVlFYA6u14NHWO88A0tEvt5EXcBVYqVbKMnQpWi+5bBZCMCpPEOA=="}],"memo":""},"blockNum":"719450"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1xdw3r3rmrvdltn3m449m5ess3mchdcxgdckwtk","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"lKcXxEXDtsRdzlqPutRK7rCdFrdHBI/1JsnaogXBvhpZIylP0k03NexqGZitAsnarb1zVK43FwY1DYpA0e4y0A=="}],"memo":""},"blockNum":"719558"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"bridge1","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/bridge1","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge\n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom, std.CurrentRealm().Addr(), std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1, 10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"ydksXjVM01x4PbwvTgMVtA2SSVkSgMc9WzfeI64aYTZcKtEMutMnZeZJy9t0cw1p4l9oaz96wrSn0s6SYrbBjQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"719633"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"bridge","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/bridge","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"ozkVA/9dBoapyUCn7qG1gd6uMc0S+S9+7460kxH1cwdnX/qMb9fuLUfQOd/eNaevt9HD3Ej8GV9JjCmS0FdD2A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"719649"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"most","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/most","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"QE1ZeCyXOJDWy7nGJrlYcpE5G3bkAeqMzBSXxLgW1w9o82L0XQvy6+qc1X+HS4D0F3gRT5e/R3iO+4Lz+GZrew=="}],"memo":"Deployed through play.gno.land"},"blockNum":"719656"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"nekimost","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/nekimost","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"s27Clk9NlsH1S8yTNNkKpB1NULqP5wwb23LvFeU9NRZcdhJTtF8Oa1NRe6YLkZXgv/ezSyEaSeT1Q6gXrDhmBQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"719679"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"nekimost","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/nekimost","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"8DSqZZDQ6JrNvcef1vN4E7UdDb/AQmJ5YrRgChwZajV2N7ly/fgvXz7TAwu6MUwLRm8DQopzI622g2qN4huLcQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"719693"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"nekimostici","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/nekimostici","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"HbJeUVXQpJDZQSc61N+p+8w/qZ1kevGK65Lb0D8azxp8m6p7saZwDzz3fC1F8x7o+TmLzqPTqfYabFmlt3eHsw=="}],"memo":"Deployed through play.gno.land"},"blockNum":"719700"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"nekimostici","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/nekimostici","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"7oHlc63+lrRzqrNcwwk+rF5+utZ6quOyFwhj3D6hHI4odJom5Nzn37/xBBs4mceVXxpICT0NM4UZ8Ghb4gM7YA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"719721"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"nekimostici","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/nekimostici","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"vc5afM7D3AgW9zRZno57Q9ejZHeAcH2NSyFQVPBff14tJmlTw6niJNlnewH3sUD91tMyI5XQGuhEPyqo0Jz9zQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"719756"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1fsc90u89c498pen4xalry582npdcf2ycvzunm5","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"UpYvCMWolZorA4eo5PLY/Ef2VseveHh8gQJUx4YPQPtsvSmad1daC4BcUa+CtfBPwTLjhkhITkLhKFp2gEWlEg=="}],"memo":""},"blockNum":"720063"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"500000000000ugnot","pkg_path":"gno.land/r/demo/wugnot","func":"Deposit","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"fG8m3tF+j0aMuy4RxSiasL1uRnBEOggTAn1XU0DEgsI4oVSAMXHemCiziOi8sojrhwJ1t4lwi/xNy5tty1s8zg=="}],"memo":""},"blockNum":"720302"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/gnoswap/v2/gns","gnot","153000000","EXACT_OUT","gno.land/r/gnoswap/v2/gns:gno.land/r/demo/wugnot:3000","100","154376389"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"MQLgC1oS8sU8gYYVajXhV/CdDupNo0kRHXT8GW5ExSlpI/uTWFlkpe1Ac32kw7ZhIfWpP0HUS3d3UegNyuuSRw=="}],"memo":""},"blockNum":"720309"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["1"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["1"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["3"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["3"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["7"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["7"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"1ji6yUog36M4sLgOgIRTGkt6Mpl/zqaEjzlKJUuA9T9r0R1M/mieKCFqgBXa0PK5PlnxNB//GGP/jdrhjP5Ehw=="}],"memo":""},"blockNum":"720320"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["4"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["4"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["8"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["8"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["11"]},{"@type":"/vm.m_call","caller":"g1lmvrrrr4er2us84h2732sru76c9zl2nvknha8c","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["11"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AoTh14aoDz7iGb+UgHIlC5BuwrTQhiClW4UClIZSxdix"},"signature":"naYU3+Ac79gBCWq7RShukMXTtQkJRXO8V7IYxnKGLzVMPje1u9tTvaMbtp3EQn5LphxUhNTumyhwS0L40Ft7PA=="}],"memo":""},"blockNum":"720428"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"bridging","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/bridging","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge \n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\t\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tif balances[addressFrom] \u003c amount1 {\n\t\tpanic(\"Insufficient minted funds for deposit\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\tcoin1 := std.NewCoin(\"GETH\", amount1)\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\n\n\tamount1Str := strconv.FormatInt(amount1,10)\n\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"YAROArxBO5wNg/4IPII68dAIIUNxjHfofZlO9CGVkKlXpFKG4ik7OU0SFWrTa2RnmSKlIA4mIgG7rtTVftq+oA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721576"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"bridging","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/bridging","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge\n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\n//func Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address) {\n//\tif amount1 \u003c= 0 {\n//\t\tpanic(\"Amount can't be 0 or less\")\n//\t}\n\n//\tif balances[addressFrom] \u003c amount1 {\n//\t\tpanic(\"Insufficient minted funds for deposit\")\n//\t}\n\n//\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n//\tcoin1 := std.NewCoin(\"GETH\", amount1)\n//\tbanker.SendCoins(addressFrom, std.CurrentRealm().Addr(), std.NewCoins(coin1))\n\n//\tamount1Str := strconv.FormatInt(amount1, 10)\n\n//\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n//\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n//}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"g/p6RIqG8PtgATZwzLJwhArDjXdRiIebcUAOD1brl6JYOszzps4whTpAWLkJu81CwifzYWDQRSYn1ZCBiAuPjA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721597"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1x25uxmrusafwvgc8p4xemx39j77zt9su852hrp","amount":"5000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"A8sPSoL27uB8njo6AZjnIl94Hde4C9VgvdddThcgPsEW6fbqGkJFaxRJanhmpyVw5Arv4Pk5sj/qDTA83uqMlw=="}],"memo":""},"blockNum":"721598"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"bridginghh","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/bridginghh","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge\n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\n//func Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address) {\n//\tif amount1 \u003c= 0 {\n//\t\tpanic(\"Amount can't be 0 or less\")\n//\t}\n\n//\tif balances[addressFrom] \u003c amount1 {\n//\t\tpanic(\"Insufficient minted funds for deposit\")\n//\t}\n\n//\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n//\tcoin1 := std.NewCoin(\"GETH\", amount1)\n//\tbanker.SendCoins(addressFrom, std.CurrentRealm().Addr(), std.NewCoins(coin1))\n\n//\tamount1Str := strconv.FormatInt(amount1, 10)\n\n//\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n//\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n//}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"Sjz2BAJV3cA9ESU26Js0Y2RfHvAwNMY1oiq97ETySLwR+tGV1+ebMgf/PrGV9+6D2XnwolgSyBaBt1s2gIzkxg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721603"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"bridginghh","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/bridginghh","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge\n\nimport (\n\t\"std\"\n//\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\n//func Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address) {\n//\tif amount1 \u003c= 0 {\n//\t\tpanic(\"Amount can't be 0 or less\")\n//\t}\n\n//\tif balances[addressFrom] \u003c amount1 {\n//\t\tpanic(\"Insufficient minted funds for deposit\")\n//\t}\n\n//\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n//\tcoin1 := std.NewCoin(\"GETH\", amount1)\n//\tbanker.SendCoins(addressFrom, std.CurrentRealm().Addr(), std.NewCoins(coin1))\n\n//\tamount1Str := strconv.FormatInt(amount1, 10)\n\n//\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n//\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n//}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"QCD2rgEdf7ZDkBmcif+L2tgc0pf+2STxk0KmBXzVMUZYFhKCa/BcNkwOKViWxzu6WeX1pyUASDVgGe+ztzHnhQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721611"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"amar","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/amar","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge\n\nimport (\n\t\"std\"\n//\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\n//func Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address) {\n//\tif amount1 \u003c= 0 {\n//\t\tpanic(\"Amount can't be 0 or less\")\n//\t}\n\n//\tif balances[addressFrom] \u003c amount1 {\n//\t\tpanic(\"Insufficient minted funds for deposit\")\n//\t}\n\n//\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n//\tcoin1 := std.NewCoin(\"GETH\", amount1)\n//\tbanker.SendCoins(addressFrom, std.CurrentRealm().Addr(), std.NewCoins(coin1))\n\n//\tamount1Str := strconv.FormatInt(amount1, 10)\n\n//\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n//\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n//}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"AXHFmDarrHvaMX+plSh/ohfw8/fbyy9qkwFK5OJNmNBIeal+YRFg4H2eo0tqRJmRULcejk9ROhhq6cL0FkQC1g=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721617"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"draganeee","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/draganeee","files":[{"name":"package.gno","body":"// counter-app/r/counter/counter.gno\n\npackage bridge\n\nimport (\n\t\"std\"\n//\t\"strconv\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\t//coin := std.NewCoin(\"GETH\", amount1)\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n\n//func Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address) {\n//\tif amount1 \u003c= 0 {\n//\t\tpanic(\"Amount can't be 0 or less\")\n//\t}\n\n//\tif balances[addressFrom] \u003c amount1 {\n//\t\tpanic(\"Insufficient minted funds for deposit\")\n//\t}\n\n//\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n//\tcoin1 := std.NewCoin(\"GETH\", amount1)\n//\tbanker.SendCoins(addressFrom, std.CurrentRealm().Addr(), std.NewCoins(coin1))\n\n//\tamount1Str := strconv.FormatInt(amount1, 10)\n\n//\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\n\n//\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"GETH\", amount1)\n\n//}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"BV1YroBa91OylPivAn8uc84G5w3VHM2Wb0ptNQyT2Lkmxw2f8iBEmpULzGf+HohBpJ74uPAvLXeF/XoBTQxQbQ=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721621"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1x25uxmrusafwvgc8p4xemx39j77zt9su852hrp","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","5000000"]},{"@type":"/vm.m_call","caller":"g1x25uxmrusafwvgc8p4xemx39j77zt9su852hrp","send":"5000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/gnoswap/v2/gns:gno.land/r/onbloc/usdc:3000","gnot","5000000","1723075200","1730851200"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+EqRX1flNPLGpwQ0Ngba2yI7wflZdF/WZRo9K6nn3H2"},"signature":"VSNOESAnVBbRPMYSjPidGQiFnnUXbfvUD11qo+Rt+G40LRp6m9r1uUIq1bpcIDCkEgRWxupkHMw1HR28M4qcSA=="}],"memo":""},"blockNum":"721622"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"mostovi","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/mostovi","files":[{"name":"package.gno","body":"package bridge\n\nimport (\n\t\"std\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"GETH\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"a7tIiD1/0LDdzDVuezynQ3k+SIq3cFv8Av27BXvg14J8xjQuL5/VK3PBiIodiX16H0ngsI6V5LWWwtHkyCQCSA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721657"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"mostovii","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/mostovii","files":[{"name":"package.gno","body":"package bridge\n\nimport (\n\t\"std\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"geth\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"dH3qmo69HmCdB3v+64Oavfjmc9pJz1o2wcTWhpk43W9z0FPIbFkSvz4Jtcrdw0T3dbnDl/R9jPwYkOV3vGlGfA=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721669"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf","package":{"name":"bridge","path":"gno.land/r/g1tsudp7zn8f7qt5w9tjj7sxvfemj2dg93xwy7cf/bridge","files":[{"name":"package.gno","body":"package bridge\n\nimport (\n\t\"std\"\n)\n\nvar balances map[std.Address]int64\n\nfunc Mint(amount1 int64, addressTo std.Address) {\n\tif amount1 \u003c= 0 {\n\t\tpanic(\"Amount can't be 0 or less\")\n\t}\n\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\n\tbanker.IssueCoin(addressTo, \"geth\", amount1)\n\n\tbalances[addressTo] += amount1\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AugMuT3t1jbI62cjrYAMUm0kw2pnXkitfO7++pIS49kJ"},"signature":"X5f/bMFtq4ZOnxqD00TKkfnbs2QtVj4wnD7TvMTs0Y5GsNb2FJINaWkXou/RdtZXLTbdaaI148L4EZIsP701sg=="}],"memo":"Deployed through play.gno.land"},"blockNum":"721716"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","to_address":"g18syxa0vh0vmne90mwhtynjet0zgeqf6prh3ryy","amount":"1000000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"i8jB14zaXo3cgLZ3cTNjSS2C4n5OeT4/bZzWK4uqxYARVn5I8ZYs5ldMJLGArwgiXbm/AcUsYWiNhVDNLE+ZUA=="}],"memo":""},"blockNum":"721959"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1dmg852ek58jncpphrlgm6e8rzqlk8qnswnmn5z","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"psgkL6RakJTxjAZYkGnYEjh0LIYJyoR1Mi/TCaZxOuRHY3cY7g9We5Xpc6tY8ktZDufIlN2XBG0kdvn820IdGw=="}],"memo":""},"blockNum":"721988"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1gzawhexghw4nfajdzghw2ksx60ppd7juw334sr","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"4ZNuYmsUmFrQ9lQYaDRBOkDnDw5U0LF5IdTDLhidfp9/GSJlQZWsVoXuuwrKt8D/9WbYKOWf4uBEW9Ladpw1GA=="}],"memo":""},"blockNum":"722059"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","package":{"name":"profile","path":"gno.land/r/teritori/profile","files":[{"name":"profile.gno","body":"package profile\n\nimport (\n\t\"errors\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/mux\"\n)\n\nvar (\n\tfields = avl.NewTree()\n\trouter = mux.NewRouter()\n)\n\nconst (\n\tDisplayName        = \"DisplayName\"\n\tHomepage           = \"Homepage\"\n\tBio                = \"Bio\"\n\tAge                = \"Age\"\n\tLocation           = \"Location\"\n\tAvatar             = \"Avatar\"\n\tGravatarEmail      = \"GravatarEmail\"\n\tAvailableForHiring = \"AvailableForHiring\"\n\tInvalidField       = \"InvalidField\"\n)\n\nfunc init() {\n\trouter.HandleFunc(\"\", homeHandler)\n\trouter.HandleFunc(\"u/{addr}\", profileHandler)\n\trouter.HandleFunc(\"f/{addr}/{field}\", fieldHandler)\n}\n\n// list of supported string fields\nvar stringFields = map[string]bool{\n\tDisplayName:   true,\n\tHomepage:      true,\n\tBio:           true,\n\tLocation:      true,\n\tAvatar:        true,\n\tGravatarEmail: true,\n}\n\n// list of support int fields\nvar intFields = map[string]bool{\n\tAge: true,\n}\n\n// list of support bool fields\nvar boolFields = map[string]bool{\n\tAvailableForHiring: true,\n}\n\n// Setters\n\nfunc SetStringField(field, value string) error {\n\taddr := std.PrevRealm().Addr()\n\tif _, ok := stringFields[field]; !ok {\n\t\treturn errors.New(\"invalid string field\")\n\t}\n\n\tkey := addr.String() + \":\" + field\n\tfields.Set(key, value)\n\n\treturn nil\n}\n\nfunc SetIntField(field string, value int) error {\n\taddr := std.PrevRealm().Addr()\n\n\tif _, ok := intFields[field]; !ok {\n\t\treturn errors.New(\"invalid int field\")\n\t}\n\n\tkey := addr.String() + \":\" + field\n\tfields.Set(key, value)\n\n\treturn nil\n}\n\nfunc SetBoolField(field string, value bool) error {\n\taddr := std.PrevRealm().Addr()\n\n\tif _, ok := boolFields[field]; !ok {\n\t\treturn errors.New(\"invalid bool field\")\n\t}\n\n\tkey := addr.String() + \":\" + field\n\tfields.Set(key, value)\n\n\treturn nil\n}\n\n// Getters\n\nfunc GetStringField(addr std.Address, field, def string) string {\n\tkey := addr.String() + \":\" + field\n\tif value, ok := fields.Get(key); ok {\n\t\treturn value.(string)\n\t}\n\n\treturn def\n}\n\nfunc GetBoolField(addr std.Address, field string, def bool) bool {\n\tkey := addr.String() + \":\" + field\n\tif value, ok := fields.Get(key); ok {\n\t\treturn value.(bool)\n\t}\n\n\treturn def\n}\n\nfunc GetIntField(addr std.Address, field string, def int) int {\n\tkey := addr.String() + \":\" + field\n\tif value, ok := fields.Get(key); ok {\n\t\treturn value.(int)\n\t}\n\n\treturn def\n}\n"},{"name":"profile_test.gno","body":"package profile\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\n// Global addresses for test users\nvar (\n\talice   = testutils.TestAddress(\"alice\")\n\tbob     = testutils.TestAddress(\"bob\")\n\tcharlie = testutils.TestAddress(\"charlie\")\n\tdave    = testutils.TestAddress(\"dave\")\n\teve     = testutils.TestAddress(\"eve\")\n\tfrank   = testutils.TestAddress(\"frank\")\n\tuser1   = testutils.TestAddress(\"user1\")\n\tuser2   = testutils.TestAddress(\"user2\")\n)\n\nfunc TestStringFields(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(alice))\n\n\t// Get before setting\n\tname := GetStringField(alice, DisplayName, \"anon\")\n\tuassert.Equal(t, \"anon\", name)\n\n\t// Set\n\terr := SetStringField(DisplayName, \"Alice foo\")\n\tuassert.NoError(t, err)\n\terr = SetStringField(Homepage, \"https://example.com\")\n\tuassert.NoError(t, err)\n\n\t// Get after setting\n\tname = GetStringField(alice, DisplayName, \"anon\")\n\thomepage := GetStringField(alice, Homepage, \"\")\n\tbio := GetStringField(alice, Bio, \"42\")\n\n\tuassert.Equal(t, \"Alice foo\", name)\n\tuassert.Equal(t, \"https://example.com\", homepage)\n\tuassert.Equal(t, \"42\", bio)\n}\n\nfunc TestIntFields(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(bob))\n\n\t// Get before setting\n\tage := GetIntField(bob, Age, 25)\n\tuassert.Equal(t, 25, age)\n\n\t// Set\n\terr := SetIntField(Age, 30)\n\tuassert.NoError(t, err)\n\n\t// Get after setting\n\tage = GetIntField(bob, Age, 25)\n\tuassert.Equal(t, 30, age)\n}\n\nfunc TestBoolFields(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(charlie))\n\n\t// Get before setting\n\thiring := GetBoolField(charlie, AvailableForHiring, false)\n\tuassert.Equal(t, false, hiring)\n\n\t// Set\n\terr := SetBoolField(AvailableForHiring, true)\n\tuassert.NoError(t, err)\n\n\t// Get after setting\n\thiring = GetBoolField(charlie, AvailableForHiring, false)\n\tuassert.Equal(t, true, hiring)\n}\n\nfunc TestInvalidStringField(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(dave))\n\n\terr := SetStringField(InvalidField, \"test\")\n\tuassert.Error(t, err)\n}\n\nfunc TestInvalidIntField(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(eve))\n\n\terr := SetIntField(InvalidField, 123)\n\tuassert.Error(t, err)\n}\n\nfunc TestInvalidBoolField(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(frank))\n\n\terr := SetBoolField(InvalidField, true)\n\tuassert.Error(t, err)\n}\n\nfunc TestMultipleProfiles(t *testing.T) {\n\t// Set profile for user1\n\tstd.TestSetRealm(std.NewUserRealm(user1))\n\terr := SetStringField(DisplayName, \"User One\")\n\tuassert.NoError(t, err)\n\n\t// Set profile for user2\n\tstd.TestSetRealm(std.NewUserRealm(user2))\n\terr = SetStringField(DisplayName, \"User Two\")\n\tuassert.NoError(t, err)\n\n\t// Get profiles\n\tstd.TestSetRealm(std.NewUserRealm(user1)) // Switch back to user1\n\tname1 := GetStringField(user1, DisplayName, \"anon\")\n\tstd.TestSetRealm(std.NewUserRealm(user2)) // Switch back to user2\n\tname2 := GetStringField(user2, DisplayName, \"anon\")\n\n\tuassert.Equal(t, \"User One\", name1)\n\tuassert.Equal(t, \"User Two\", name2)\n}\n"},{"name":"render.gno","body":"package profile\n\nimport (\n\t\"bytes\"\n\t\"net/url\"\n\t\"std\"\n\n\t\"gno.land/p/demo/mux\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tBaseURL           = \"/r/demo/profile\"\n\tSetStringFieldURL = BaseURL + \"?help\u0026__func=SetStringField\u0026field=%s\"\n\tSetIntFieldURL    = BaseURL + \"?help\u0026__func=SetIntField\u0026field=%s\"\n\tSetBoolFieldURL   = BaseURL + \"?help\u0026__func=SetBoolField\u0026field=%s\"\n\tViewAllFieldsURL  = BaseURL + \":u/%s\"\n\tViewFieldURL      = BaseURL + \":f/%s/%s\"\n)\n\nfunc homeHandler(res *mux.ResponseWriter, req *mux.Request) {\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"## Setters\\n\")\n\tfor field := range stringFields {\n\t\tlink := ufmt.Sprintf(SetStringFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- [Set %s](%s)\\n\", field, link))\n\t}\n\n\tfor field := range intFields {\n\t\tlink := ufmt.Sprintf(SetIntFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- [Set %s](%s)\\n\", field, link))\n\t}\n\n\tfor field := range boolFields {\n\t\tlink := ufmt.Sprintf(SetBoolFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- [Set %s Field](%s)\\n\", field, link))\n\t}\n\n\tb.WriteString(\"\\n---\\n\\n\")\n\n\tres.Write(b.String())\n}\n\nfunc profileHandler(res *mux.ResponseWriter, req *mux.Request) {\n\tvar b bytes.Buffer\n\taddr := req.GetVar(\"addr\")\n\n\tb.WriteString(ufmt.Sprintf(\"# Profile %s\\n\", addr))\n\n\taddress := std.Address(addr)\n\n\tfor field := range stringFields {\n\t\tvalue := GetStringField(address, field, \"n/a\")\n\t\tlink := ufmt.Sprintf(SetStringFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- %s: %s [Edit](%s)\\n\", field, value, link))\n\t}\n\n\tfor field := range intFields {\n\t\tvalue := GetIntField(address, field, 0)\n\t\tlink := ufmt.Sprintf(SetIntFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- %s: %d [Edit](%s)\\n\", field, value, link))\n\t}\n\n\tfor field := range boolFields {\n\t\tvalue := GetBoolField(address, field, false)\n\t\tlink := ufmt.Sprintf(SetBoolFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- %s: %t [Edit](%s)\\n\", field, value, link))\n\t}\n\n\tres.Write(b.String())\n}\n\nfunc fieldHandler(res *mux.ResponseWriter, req *mux.Request) {\n\tvar b bytes.Buffer\n\taddr := req.GetVar(\"addr\")\n\tfield := req.GetVar(\"field\")\n\n\tb.WriteString(ufmt.Sprintf(\"# Field %s for %s\\n\", field, addr))\n\n\taddress := std.Address(addr)\n\tvalue := \"n/a\"\n\tvar editLink string\n\n\tif _, ok := stringFields[field]; ok {\n\t\tvalue = ufmt.Sprintf(\"%s\", GetStringField(address, field, \"n/a\"))\n\t\teditLink = ufmt.Sprintf(SetStringFieldURL+\"\u0026addr=%s\u0026value=%s\", field, addr, url.QueryEscape(value))\n\t} else if _, ok := intFields[field]; ok {\n\t\tvalue = ufmt.Sprintf(\"%d\", GetIntField(address, field, 0))\n\t\teditLink = ufmt.Sprintf(SetIntFieldURL+\"\u0026addr=%s\u0026value=%s\", field, addr, value)\n\t} else if _, ok := boolFields[field]; ok {\n\t\tvalue = ufmt.Sprintf(\"%t\", GetBoolField(address, field, false))\n\t\teditLink = ufmt.Sprintf(SetBoolFieldURL+\"\u0026addr=%s\u0026value=%s\", field, addr, value)\n\t}\n\n\tb.WriteString(ufmt.Sprintf(\"- %s: %s [Edit](%s)\\n\", field, value, editLink))\n\n\tres.Write(b.String())\n}\n\nfunc Render(path string) string {\n\treturn router.Render(path)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"KZslRaKOD+3Q5jasfrb/gYQDV83tfxgKf9wBK5Zirh4zaoVoJYIxET4NAG2Mm8EWyYD09XnytTeaaLy1Hx080A=="}],"memo":""},"blockNum":"722213"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","package":{"name":"profile","path":"gno.land/r/teritori/profile","files":[{"name":"profile.gno","body":"package profile\n\nimport (\n\t\"errors\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/mux\"\n)\n\nvar (\n\tfields = avl.NewTree()\n\trouter = mux.NewRouter()\n)\n\nconst (\n\tDisplayName        = \"DisplayName\"\n\tHomepage           = \"Homepage\"\n\tBio                = \"Bio\"\n\tAge                = \"Age\"\n\tLocation           = \"Location\"\n\tAvatar             = \"Avatar\"\n\tGravatarEmail      = \"GravatarEmail\"\n\tAvailableForHiring = \"AvailableForHiring\"\n\tInvalidField       = \"InvalidField\"\n)\n\nfunc init() {\n\trouter.HandleFunc(\"\", homeHandler)\n\trouter.HandleFunc(\"u/{addr}\", profileHandler)\n\trouter.HandleFunc(\"f/{addr}/{field}\", fieldHandler)\n}\n\n// list of supported string fields\nvar stringFields = map[string]bool{\n\tDisplayName:   true,\n\tHomepage:      true,\n\tBio:           true,\n\tLocation:      true,\n\tAvatar:        true,\n\tGravatarEmail: true,\n}\n\n// list of support int fields\nvar intFields = map[string]bool{\n\tAge: true,\n}\n\n// list of support bool fields\nvar boolFields = map[string]bool{\n\tAvailableForHiring: true,\n}\n\n// Setters\n\nfunc SetStringField(field, value string) error {\n\taddr := std.PrevRealm().Addr()\n\tif _, ok := stringFields[field]; !ok {\n\t\treturn errors.New(\"invalid string field\")\n\t}\n\n\tkey := addr.String() + \":\" + field\n\tfields.Set(key, value)\n\n\treturn nil\n}\n\nfunc SetIntField(field string, value int) error {\n\taddr := std.PrevRealm().Addr()\n\n\tif _, ok := intFields[field]; !ok {\n\t\treturn errors.New(\"invalid int field\")\n\t}\n\n\tkey := addr.String() + \":\" + field\n\tfields.Set(key, value)\n\n\treturn nil\n}\n\nfunc SetBoolField(field string, value bool) error {\n\taddr := std.PrevRealm().Addr()\n\n\tif _, ok := boolFields[field]; !ok {\n\t\treturn errors.New(\"invalid bool field\")\n\t}\n\n\tkey := addr.String() + \":\" + field\n\tfields.Set(key, value)\n\n\treturn nil\n}\n\n// Getters\n\nfunc GetStringField(addr std.Address, field, def string) string {\n\tkey := addr.String() + \":\" + field\n\tif value, ok := fields.Get(key); ok {\n\t\treturn value.(string)\n\t}\n\n\treturn def\n}\n\nfunc GetBoolField(addr std.Address, field string, def bool) bool {\n\tkey := addr.String() + \":\" + field\n\tif value, ok := fields.Get(key); ok {\n\t\treturn value.(bool)\n\t}\n\n\treturn def\n}\n\nfunc GetIntField(addr std.Address, field string, def int) int {\n\tkey := addr.String() + \":\" + field\n\tif value, ok := fields.Get(key); ok {\n\t\treturn value.(int)\n\t}\n\n\treturn def\n}\n"},{"name":"profile_test.gno","body":"package profile\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\n// Global addresses for test users\nvar (\n\talice   = testutils.TestAddress(\"alice\")\n\tbob     = testutils.TestAddress(\"bob\")\n\tcharlie = testutils.TestAddress(\"charlie\")\n\tdave    = testutils.TestAddress(\"dave\")\n\teve     = testutils.TestAddress(\"eve\")\n\tfrank   = testutils.TestAddress(\"frank\")\n\tuser1   = testutils.TestAddress(\"user1\")\n\tuser2   = testutils.TestAddress(\"user2\")\n)\n\nfunc TestStringFields(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(alice))\n\n\t// Get before setting\n\tname := GetStringField(alice, DisplayName, \"anon\")\n\tuassert.Equal(t, \"anon\", name)\n\n\t// Set\n\terr := SetStringField(DisplayName, \"Alice foo\")\n\tuassert.NoError(t, err)\n\terr = SetStringField(Homepage, \"https://example.com\")\n\tuassert.NoError(t, err)\n\n\t// Get after setting\n\tname = GetStringField(alice, DisplayName, \"anon\")\n\thomepage := GetStringField(alice, Homepage, \"\")\n\tbio := GetStringField(alice, Bio, \"42\")\n\n\tuassert.Equal(t, \"Alice foo\", name)\n\tuassert.Equal(t, \"https://example.com\", homepage)\n\tuassert.Equal(t, \"42\", bio)\n}\n\nfunc TestIntFields(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(bob))\n\n\t// Get before setting\n\tage := GetIntField(bob, Age, 25)\n\tuassert.Equal(t, 25, age)\n\n\t// Set\n\terr := SetIntField(Age, 30)\n\tuassert.NoError(t, err)\n\n\t// Get after setting\n\tage = GetIntField(bob, Age, 25)\n\tuassert.Equal(t, 30, age)\n}\n\nfunc TestBoolFields(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(charlie))\n\n\t// Get before setting\n\thiring := GetBoolField(charlie, AvailableForHiring, false)\n\tuassert.Equal(t, false, hiring)\n\n\t// Set\n\terr := SetBoolField(AvailableForHiring, true)\n\tuassert.NoError(t, err)\n\n\t// Get after setting\n\thiring = GetBoolField(charlie, AvailableForHiring, false)\n\tuassert.Equal(t, true, hiring)\n}\n\nfunc TestInvalidStringField(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(dave))\n\n\terr := SetStringField(InvalidField, \"test\")\n\tuassert.Error(t, err)\n}\n\nfunc TestInvalidIntField(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(eve))\n\n\terr := SetIntField(InvalidField, 123)\n\tuassert.Error(t, err)\n}\n\nfunc TestInvalidBoolField(t *testing.T) {\n\tstd.TestSetRealm(std.NewUserRealm(frank))\n\n\terr := SetBoolField(InvalidField, true)\n\tuassert.Error(t, err)\n}\n\nfunc TestMultipleProfiles(t *testing.T) {\n\t// Set profile for user1\n\tstd.TestSetRealm(std.NewUserRealm(user1))\n\terr := SetStringField(DisplayName, \"User One\")\n\tuassert.NoError(t, err)\n\n\t// Set profile for user2\n\tstd.TestSetRealm(std.NewUserRealm(user2))\n\terr = SetStringField(DisplayName, \"User Two\")\n\tuassert.NoError(t, err)\n\n\t// Get profiles\n\tstd.TestSetRealm(std.NewUserRealm(user1)) // Switch back to user1\n\tname1 := GetStringField(user1, DisplayName, \"anon\")\n\tstd.TestSetRealm(std.NewUserRealm(user2)) // Switch back to user2\n\tname2 := GetStringField(user2, DisplayName, \"anon\")\n\n\tuassert.Equal(t, \"User One\", name1)\n\tuassert.Equal(t, \"User Two\", name2)\n}\n"},{"name":"render.gno","body":"package profile\n\nimport (\n\t\"bytes\"\n\t\"net/url\"\n\t\"std\"\n\n\t\"gno.land/p/demo/mux\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tBaseURL           = \"/r/demo/profile\"\n\tSetStringFieldURL = BaseURL + \"?help\u0026__func=SetStringField\u0026field=%s\"\n\tSetIntFieldURL    = BaseURL + \"?help\u0026__func=SetIntField\u0026field=%s\"\n\tSetBoolFieldURL   = BaseURL + \"?help\u0026__func=SetBoolField\u0026field=%s\"\n\tViewAllFieldsURL  = BaseURL + \":u/%s\"\n\tViewFieldURL      = BaseURL + \":f/%s/%s\"\n)\n\nfunc homeHandler(res *mux.ResponseWriter, req *mux.Request) {\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"## Setters\\n\")\n\tfor field := range stringFields {\n\t\tlink := ufmt.Sprintf(SetStringFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- [Set %s](%s)\\n\", field, link))\n\t}\n\n\tfor field := range intFields {\n\t\tlink := ufmt.Sprintf(SetIntFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- [Set %s](%s)\\n\", field, link))\n\t}\n\n\tfor field := range boolFields {\n\t\tlink := ufmt.Sprintf(SetBoolFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- [Set %s Field](%s)\\n\", field, link))\n\t}\n\n\tb.WriteString(\"\\n---\\n\\n\")\n\n\tres.Write(b.String())\n}\n\nfunc profileHandler(res *mux.ResponseWriter, req *mux.Request) {\n\tvar b bytes.Buffer\n\taddr := req.GetVar(\"addr\")\n\n\tb.WriteString(ufmt.Sprintf(\"# Profile %s\\n\", addr))\n\n\taddress := std.Address(addr)\n\n\tfor field := range stringFields {\n\t\tvalue := GetStringField(address, field, \"n/a\")\n\t\tlink := ufmt.Sprintf(SetStringFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- %s: %s [Edit](%s)\\n\", field, value, link))\n\t}\n\n\tfor field := range intFields {\n\t\tvalue := GetIntField(address, field, 0)\n\t\tlink := ufmt.Sprintf(SetIntFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- %s: %d [Edit](%s)\\n\", field, value, link))\n\t}\n\n\tfor field := range boolFields {\n\t\tvalue := GetBoolField(address, field, false)\n\t\tlink := ufmt.Sprintf(SetBoolFieldURL, field)\n\t\tb.WriteString(ufmt.Sprintf(\"- %s: %t [Edit](%s)\\n\", field, value, link))\n\t}\n\n\tres.Write(b.String())\n}\n\nfunc fieldHandler(res *mux.ResponseWriter, req *mux.Request) {\n\tvar b bytes.Buffer\n\taddr := req.GetVar(\"addr\")\n\tfield := req.GetVar(\"field\")\n\n\tb.WriteString(ufmt.Sprintf(\"# Field %s for %s\\n\", field, addr))\n\n\taddress := std.Address(addr)\n\tvalue := \"n/a\"\n\tvar editLink string\n\n\tif _, ok := stringFields[field]; ok {\n\t\tvalue = ufmt.Sprintf(\"%s\", GetStringField(address, field, \"n/a\"))\n\t\teditLink = ufmt.Sprintf(SetStringFieldURL+\"\u0026addr=%s\u0026value=%s\", field, addr, url.QueryEscape(value))\n\t} else if _, ok := intFields[field]; ok {\n\t\tvalue = ufmt.Sprintf(\"%d\", GetIntField(address, field, 0))\n\t\teditLink = ufmt.Sprintf(SetIntFieldURL+\"\u0026addr=%s\u0026value=%s\", field, addr, value)\n\t} else if _, ok := boolFields[field]; ok {\n\t\tvalue = ufmt.Sprintf(\"%t\", GetBoolField(address, field, false))\n\t\teditLink = ufmt.Sprintf(SetBoolFieldURL+\"\u0026addr=%s\u0026value=%s\", field, addr, value)\n\t}\n\n\tb.WriteString(ufmt.Sprintf(\"- %s: %s [Edit](%s)\\n\", field, value, editLink))\n\n\tres.Write(b.String())\n}\n\nfunc Render(path string) string {\n\treturn router.Render(path)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"4HVaxkhQB0av5evJWhOCh5sxq6TT8ujH9ZqcdDqBjhUgYydhi1jqoAe9zpePSfi15MTnrWGKALUEnjH6BkkqQg=="}],"memo":""},"blockNum":"722217"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1dmg852ek58jncpphrlgm6e8rzqlk8qnswnmn5z","to_address":"g1kkhrcr7rnay67zsynmrrxmwrlfr7yfsuu669wk","amount":"7000000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Any7DQ/YvG7l6skmy1bhS3OwGQ7ZgYSWMkGOUNXaes3/"},"signature":"0eY+kWJyq4Bj/BCvLvaLuVNBy5FH9/KuaXDgwHksdlU62sMSVVMYLIepLTNrX6kg6jUA1OtV+gzFESkPIjNNyA=="}],"memo":""},"blockNum":"722266"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1dmg852ek58jncpphrlgm6e8rzqlk8qnswnmn5z","to_address":"g1kkhrcr7rnay67zsynmrrxmwrlfr7yfsuu669wk","amount":"758000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Any7DQ/YvG7l6skmy1bhS3OwGQ7ZgYSWMkGOUNXaes3/"},"signature":"S+dswvKa2jSbzdXOihPUgPJSCQANPRxzR30247T/ybY91wKRhjyoS1VXyiasJ31WqdPtRYQKuCUrsX7IC2iaJw=="}],"memo":""},"blockNum":"722285"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dmg852ek58jncpphrlgm6e8rzqlk8qnswnmn5z","send":"","pkg_path":"gno.land/r/gnoswap/gns","func":"Transfer","args":["g1kkhrcr7rnay67zsynmrrxmwrlfr7yfsuu669wk","1200000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Any7DQ/YvG7l6skmy1bhS3OwGQ7ZgYSWMkGOUNXaes3/"},"signature":"1bnPvp/LgcyWAVc9H25FSbqLbHYy07my7brr6S9luyUizB1ghTF9zC8cFBGHlnTF997KdWThfhRfLDlACFVUCw=="}],"memo":""},"blockNum":"722297"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm","amount":"5000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"Nckfjq++zHyc1thOMm8MpBGDzZrZWLJXBNYv5SwE+49wEOrQQkGgKnaURomRLYTLt0iHSCPiQWYqb+gSWFC9dQ=="}],"memo":""},"blockNum":"722307"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm","package":{"name":"bridge","path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v1/bridge","files":[{"name":"contract.gno","body":"package bridge \r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strconv\"\r\n)\r\n\r\nvar balances map[std.Address]int64\r\n\r\nfunc init() {\r\n\t// Initialize the map\r\n\tbalances = make(map[std.Address]int64)\r\n}\r\n\r\nfunc Mint(amount1 int64, addressTo std.Address){\r\n\tif amount1 \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\t\r\n\t//coin := std.NewCoin(\"GETH\", amount1)\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\r\n\tbanker.IssueCoin(addressTo, \"geth\", amount1)\r\n\r\n\tbalances[addressTo] += amount1\r\n}\r\n\r\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\r\n\tif amount1 \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\r\n\tif balances[addressFrom] \u003c amount1 {\r\n\t\tpanic(\"Insufficient minted funds for deposit\")\r\n\t}\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\r\n\tcoin1 := std.NewCoin(\"geth\", amount1)\r\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\r\n\r\n\tamount1Str := strconv.FormatInt(amount1,10)\r\n\r\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\r\n\r\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"geth\", amount1)\r\n\r\n}\r\n\r\n"}]},"deposit":""}],"fee":{"gas_wanted":"800000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnnVS+GhU92KHYSsK76ld7F1gFLICCuqb64lFzct4Q1E"},"signature":"csRA4oMIqlzP+NPpaV8wrYz2RQlBjGa1cRyoBQ6b1QcxHHk+XOzSaObz1lSptVOT2WhCM6Rx1Uv15PtbeWMtkQ=="}],"memo":""},"blockNum":"722375"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm","package":{"name":"bridge","path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v1/bridge","files":[{"name":"contract.gno","body":"package bridge \r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strconv\"\r\n)\r\n\r\nvar balances map[std.Address]int64\r\n\r\nfunc init() {\r\n\t// Initialize the map\r\n\tbalances = make(map[std.Address]int64)\r\n}\r\n\r\nfunc Mint(amount1 int64, addressTo std.Address){\r\n\tif amount1 \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\t\r\n\t//coin := std.NewCoin(\"GETH\", amount1)\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\r\n\tbanker.IssueCoin(addressTo, \"geth\", amount1)\r\n\r\n\tbalances[addressTo] += amount1\r\n}\r\n\r\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\r\n\tif amount1 \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\r\n\tif balances[addressFrom] \u003c amount1 {\r\n\t\tpanic(\"Insufficient minted funds for deposit\")\r\n\t}\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\r\n\tcoin1 := std.NewCoin(\"geth\", amount1)\r\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\r\n\r\n\tamount1Str := strconv.FormatInt(amount1,10)\r\n\r\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\r\n\r\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"geth\", amount1)\r\n\r\n}\r\n\r\n"}]},"deposit":""}],"fee":{"gas_wanted":"1000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnnVS+GhU92KHYSsK76ld7F1gFLICCuqb64lFzct4Q1E"},"signature":"yTQYlCgief5s0rqPhktZkneSQKRtv+zOsNe+XnZA9A5yOWZGgx0naQao7EzLJVAaAyIxc+Os11CUjtdhBZFWyQ=="}],"memo":""},"blockNum":"722389"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm","package":{"name":"bridge","path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v1/bridge","files":[{"name":"contract.gno","body":"package bridge \r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strconv\"\r\n)\r\n\r\nvar balances map[std.Address]int64\r\n\r\nfunc init() {\r\n\t// Initialize the map\r\n\tbalances = make(map[std.Address]int64)\r\n}\r\n\r\nfunc Mint(amount1 int64, addressTo std.Address){\r\n\tif amount1 \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\t\r\n\t//coin := std.NewCoin(\"GETH\", amount1)\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\r\n\tbanker.IssueCoin(addressTo, \"geth\", amount1)\r\n\r\n\tbalances[addressTo] += amount1\r\n}\r\n\r\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\r\n\tif amount1 \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\r\n\tif balances[addressFrom] \u003c amount1 {\r\n\t\tpanic(\"Insufficient minted funds for deposit\")\r\n\t}\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\r\n\tcoin1 := std.NewCoin(\"geth\", amount1)\r\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\r\n\r\n\tamount1Str := strconv.FormatInt(amount1,10)\r\n\r\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\r\n\r\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"geth\", amount1)\r\n\r\n}\r\n\r\n"}]},"deposit":""}],"fee":{"gas_wanted":"100000000","gas_fee":"10000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnnVS+GhU92KHYSsK76ld7F1gFLICCuqb64lFzct4Q1E"},"signature":"f4uWMXlWa9mPcE1AVQcsYA/INNEKTryzRLGi2BhaaLYE0aprsdNGiFwSBQi3g/AcGfUuvtEQxrOrxz1jQBwDSQ=="}],"memo":""},"blockNum":"722395"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","to_address":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","amount":"1000000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"3vasWeb8JOcphq1FzRnWXPGq0IheYzSXFm7rIy+u6GxadtkJRa6jldhs0JVSIC9UcQgbS8koJaGZj3j4lgag/A=="}],"memo":""},"blockNum":"722498"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","send":"200000000ugnot","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","normadn",""]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArDpFd2owLPsaNRQ2xWL/ELLJVVwo7OoPqIi0OtZJV7/"},"signature":"15sQDG8U+as3mHnxb8JGuFoCI1uojPXzcSeMQ+UQV2JMPe2vk3wQgl+h0c1TxAhc9NCIZ+PnKDRsFjLBo25z1Q=="}],"memo":""},"blockNum":"722509"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Norman",""]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArDpFd2owLPsaNRQ2xWL/ELLJVVwo7OoPqIi0OtZJV7/"},"signature":"f8I64qn/EzWUDNh1PxDyhJHrWC29Tkd7Y3Jbk5eQkaojpso3VNK9rd5CPxI9TP03HRPcw7aB7Y1pxh5ctPCi+g=="}],"memo":""},"blockNum":"722523"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["DisplayName","Norman"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArDpFd2owLPsaNRQ2xWL/ELLJVVwo7OoPqIi0OtZJV7/"},"signature":"+5yuQIHm2DavA4s3dGV/Fcl7KNkGPND2yLpkKjhwztxCJDlPppvL4Eic4A6OQCX75/jF7yqUn71yt8fzEkzr2Q=="}],"memo":""},"blockNum":"722530"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Bio","Some gnome"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArDpFd2owLPsaNRQ2xWL/ELLJVVwo7OoPqIi0OtZJV7/"},"signature":"AXCbi6LB38j/K6bhLRaYhHsiyExJdjcBVEOA5a09+NlbVKzOPmbqv1Nezlcqaxabx8D7y/IxeiWFOfK1Q5B6IQ=="}],"memo":""},"blockNum":"722570"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Avatar","https://t4.ftcdn.net/jpg/05/78/83/97/360_F_578839707_7WMpLoRzjDN8b1nwkUWJg82osH14Qpjo.jpg"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArDpFd2owLPsaNRQ2xWL/ELLJVVwo7OoPqIi0OtZJV7/"},"signature":"0YVhiyUE9B3/nIrx2pCdqkrSf0wzibTeKtidXdEEWSsrO5DHiKI/S4L3Dn48VT4RiDTrrvVOh22EIUp6rUZrWQ=="}],"memo":""},"blockNum":"722589"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","1000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/baz:3000*POOL*gno.land/r/onbloc/baz:gno.land/r/onbloc/bar:3000*POOL*gno.land/r/onbloc/bar:gno.land/r/gnoswap/v2/gns:3000","100","9740403"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A99ltyAQjiOY5vJ0zc6tBOj7KhicOfU9ISCnj1eGSiwa"},"signature":"iCAgW/69VCWDWhgV0Sup/OLoTJiEHfzuEsGuIc0xEm06G0Hd+XGGHM1gcr1m6NlyLdzamT3MrS1WViTMltOFGg=="}],"memo":""},"blockNum":"723319"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/gnoswap/v2/gns","gnot","1000000","EXACT_IN","gno.land/r/gnoswap/v2/gns:gno.land/r/demo/wugnot:3000","100","991051"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A99ltyAQjiOY5vJ0zc6tBOj7KhicOfU9ISCnj1eGSiwa"},"signature":"H95X10Ur/ZlzNrZaI13T0cZYe6swcaySajv7MkMhTfFTtkYQL8SER/weESbORHOtuQpJ8r3IQS7BiTxDezoJeA=="}],"memo":""},"blockNum":"723325"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1d84zm4gda0qj5r3h8w8xhzkawef0rxx40x3yyf","send":"","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gno.land/r/onbloc/baz","gno.land/r/gnoswap/v2/gns","1000000","EXACT_OUT","gno.land/r/onbloc/baz:gno.land/r/onbloc/bar:3000*POOL*gno.land/r/onbloc/bar:gno.land/r/gnoswap/v2/gns:3000","100","205275"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A99ltyAQjiOY5vJ0zc6tBOj7KhicOfU9ISCnj1eGSiwa"},"signature":"TzGMybHiEQiQCx0sPHzFfAHOT1Olx1i63nHBgfmDPS9HGca3t150aC1jcbkmEbop3ZAiygGESErushKE9FLGwQ=="}],"memo":""},"blockNum":"723331"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1thgp4e56dw9fjkt9643luwk88zqwkeg5f2gjvm","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"dT4vhA2GqKLWx0HlOKCda0dz7IRspeZzcqLn2vTZDjl327PO+8akr6BBEFHxD7Nck+7g4UN57XJk4VTSySWQwQ=="}],"memo":""},"blockNum":"723652"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1thgp4e56dw9fjkt9643luwk88zqwkeg5f2gjvm","send":"","pkg_path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v1/bridge","func":"Mint","args":["100","g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm"]}],"fee":{"gas_wanted":"60000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+HoKvyGvbYN7zv/vCdIPwNKKHSZXBQq4bqiTd/RjF9n"},"signature":"lPbMMQ7TeFkKwxKrnuPs50oZhJPjeJtSrUmN749Vqy1qdIncy1bkODilOhGSJKgfMaFiM2U5bCcQVnVJJww08A=="}],"memo":""},"blockNum":"723658"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1thgp4e56dw9fjkt9643luwk88zqwkeg5f2gjvm","send":"","pkg_path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v1/bridge","func":"Mint","args":["100","g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm"]}],"fee":{"gas_wanted":"60000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+HoKvyGvbYN7zv/vCdIPwNKKHSZXBQq4bqiTd/RjF9n"},"signature":"gpeM5ZRLi3xH1AdxSRHe1QLWTEiXD/1+wOAQNQSGIygZKBnyEGfdlOGwTMuGK/FvlE3QhlRtaKuFw6fo7ku/Zg=="}],"memo":""},"blockNum":"723704"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1thgp4e56dw9fjkt9643luwk88zqwkeg5f2gjvm","send":"","pkg_path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v1/bridge","func":"Mint","args":["100","g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm"]}],"fee":{"gas_wanted":"1000000","gas_fee":"100000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+HoKvyGvbYN7zv/vCdIPwNKKHSZXBQq4bqiTd/RjF9n"},"signature":"eOlvsT1Hh4t9wNFagwso6URKIdHd3kaAwTrMuY99xrZZAR30s0ukbcG/P9sKelutoN8WYYSlvN7FNjgUJk8VnA=="}],"memo":""},"blockNum":"723841"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1thgp4e56dw9fjkt9643luwk88zqwkeg5f2gjvm","send":"","pkg_path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v1/bridge","func":"Mint","args":["100","g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm"]}],"fee":{"gas_wanted":"1000000","gas_fee":"100000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+HoKvyGvbYN7zv/vCdIPwNKKHSZXBQq4bqiTd/RjF9n"},"signature":"JXH2s6ruE1bp9mUQyR1aVUJE7TyptEgAPJji2nAjfZZSTV4gwYRNimkj3QdLA+83nmcSQ+xFMV1zwez5COo0WA=="}],"memo":""},"blockNum":"723864"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"A1V14iHEv9KAdxxigMRv3gbimjbsPRrB44VWfX+tBKk0mGTmb2Ec7NHbim6y+isCEK3Da6olB810lQNJIKhTQg=="}],"memo":""},"blockNum":"724012"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm","package":{"name":"bridge","path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v2/bridge","files":[{"name":"contract.gno","body":"package bridge \r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strconv\"\r\n)\r\n\r\nvar balances map[std.Address]int64\r\n\r\nfunc init() {\r\n\t// Initialize the map\r\n\tbalances = make(map[std.Address]int64)\r\n}\r\n\r\nfunc Mint(amount int64, addressTo std.Address){\r\n\tif amount \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\t\r\n\t//coin := std.NewCoin(\"GETH\", amount1)\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\r\n\tbanker.IssueCoin(addressTo, \"geth\", amount)\r\n\r\n\tbalances[addressTo] += amount\r\n\r\n\tstd.Emit(\"Minted\", addressTo.String(), strconv.FormatInt(amount,10))\r\n}\r\n\r\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\r\n\tif amount1 \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\r\n\tif balances[addressFrom] \u003c amount1 {\r\n\t\tpanic(\"Insufficient minted funds for deposit\")\r\n\t}\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\r\n\tcoin1 := std.NewCoin(\"geth\", amount1)\r\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\r\n\r\n\tamount1Str := strconv.FormatInt(amount1,10)\r\n\r\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\r\n\r\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"geth\", amount1)\r\n\r\n}\r\n\r\n"}]},"deposit":""}],"fee":{"gas_wanted":"800000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnnVS+GhU92KHYSsK76ld7F1gFLICCuqb64lFzct4Q1E"},"signature":"i94IJmWOCxpgDWSHMCmHouIImOknlDNI9RTFLgkeaBN+n/MuUnbbPQgaVkPoBtg7TkidpuEu8xqnSqw7w6OTbA=="}],"memo":""},"blockNum":"724033"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","to_address":"g1pf6dv9fjk3rn0m4jjcne306ga4he3mzmupfjl6","amount":"500000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"jrwPXIHtjCnc6SWQmNTIt0NsUz/b/ZtgS8oyy6f2luw+qsbERjoLD5XBnRk7kVygB5GaDzhBmSCWxSwMB+sBMg=="}],"memo":""},"blockNum":"724065"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g125em6arxsnj49vx35f0n0z34putv5ty3376fg5","to_address":"g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm","amount":"500000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A4vbt/RTXs3UWUQZdg7W6glviY2ighS0MzoQ/HOb53Wy"},"signature":"USDAk6vGtZYUOfDGrgiAnG3QR1Wc2buOFatRaL6aaMoyzZuwr1fVQj6GKwSNHz3L92i4boOo5sZHVDbpx8dU0Q=="}],"memo":""},"blockNum":"724074"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm","package":{"name":"bridge","path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v2/bridge","files":[{"name":"contract.gno","body":"package bridge \r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strconv\"\r\n)\r\n\r\nvar balances map[std.Address]int64\r\n\r\nfunc init() {\r\n\t// Initialize the map\r\n\tbalances = make(map[std.Address]int64)\r\n}\r\n\r\nfunc Mint(amount int64, addressTo std.Address){\r\n\tif amount \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\t\r\n\t//coin := std.NewCoin(\"GETH\", amount1)\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeRealmIssue)\r\n\tbanker.IssueCoin(addressTo, \"geth\", amount)\r\n\r\n\tbalances[addressTo] += amount\r\n\r\n\tstd.Emit(\"Minted\", addressTo.String(), strconv.FormatInt(amount,10))\r\n}\r\n\r\nfunc Deposit(amount1 int64, addressFrom std.Address, addressTo std.Address){\r\n\tif amount1 \u003c= 0 {\r\n\t\tpanic(\"Amount can't be 0 or less\")\r\n\t}\r\n\r\n\tif balances[addressFrom] \u003c amount1 {\r\n\t\tpanic(\"Insufficient minted funds for deposit\")\r\n\t}\r\n\r\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\r\n\tcoin1 := std.NewCoin(\"geth\", amount1)\r\n\tbanker.SendCoins(addressFrom,std.CurrentRealm().Addr(),std.NewCoins(coin1))\r\n\r\n\tamount1Str := strconv.FormatInt(amount1,10)\r\n\r\n\tstd.Emit(\"Deposit\", addressFrom.String(), amount1Str)\r\n\r\n\tbanker.RemoveCoin(std.CurrentRealm().Addr(), \"geth\", amount1)\r\n\r\n}\r\n\r\n"}]},"deposit":""}],"fee":{"gas_wanted":"8000000","gas_fee":"10000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnnVS+GhU92KHYSsK76ld7F1gFLICCuqb64lFzct4Q1E"},"signature":"KcfKwpYjKOJ/XG7fj+NlBE39eSbOJ9t+6YX8hR8/UfBjUeQo7VY4j2tU0ev1NVrpfceOdgG1Yk0Pkq9NQPhCpQ=="}],"memo":""},"blockNum":"724076"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1thgp4e56dw9fjkt9643luwk88zqwkeg5f2gjvm","send":"","pkg_path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v2/bridge","func":"Mint","args":["100","g1lavlav7zwsjqlzzl3qdl3nl242qtf638vnhdjh"]}],"fee":{"gas_wanted":"1000000","gas_fee":"100000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+HoKvyGvbYN7zv/vCdIPwNKKHSZXBQq4bqiTd/RjF9n"},"signature":"GhjKvRaUnKNTb54ORsJIjzaCQ3ACws6mDTrMqblLjJ4oTbhEnzE5BOpqjoufqSRMqiRyLkA28HirhCtNvWp6EA=="}],"memo":""},"blockNum":"724166"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1jj8zxzlgg9env46klnsaxgge07aup852tsavd7","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"fb41Bg/w828cCo9kQ5zCA1q0VtqJw4gx3p7Tg1C9jtM0Z3kqHdCmgHBe+RSaeKiGCHm0j/j58ZJXj7oS5GAtmA=="}],"memo":""},"blockNum":"724586"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1jj8zxzlgg9env46klnsaxgge07aup852tsavd7","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"+LLLpTveKAWiFZYPyK2mSB0UQK3Lk876b844MieRMLRcCja5tEH20+KuM/k6X73kBBh0TiEVthHiVWwbGuKWqg=="}],"memo":""},"blockNum":"724592"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1thgp4e56dw9fjkt9643luwk88zqwkeg5f2gjvm","send":"","pkg_path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v2/bridge","func":"Mint","args":["100","g1xdw3r3rmrvdltn3m449m5ess3mchdcxgdckwtk"]}],"fee":{"gas_wanted":"1000000","gas_fee":"100000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+HoKvyGvbYN7zv/vCdIPwNKKHSZXBQq4bqiTd/RjF9n"},"signature":"zkmwS84aW5GOrAIzk8tuIVRvoslIeBt5ULUzQicCxuYklnBXLWqFZy0opJDHnXkfcEMn7pTIppOViay4pRHkJQ=="}],"memo":""},"blockNum":"725187"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1thgp4e56dw9fjkt9643luwk88zqwkeg5f2gjvm","send":"","pkg_path":"gno.land/r/g15mzjefvj9pt2ctv30l9ju03rewmfv9hken9wfm/v2/bridge","func":"Mint","args":["100","g1xdw3r3rmrvdltn3m449m5ess3mchdcxgdckwtk"]}],"fee":{"gas_wanted":"1000000","gas_fee":"100000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+HoKvyGvbYN7zv/vCdIPwNKKHSZXBQq4bqiTd/RjF9n"},"signature":"SR0IpfzQ6IBxopZLEABu0N+Ur7G5nG6+2y/smJTR5Wd21QImzm9ICe0o5/LcWJs/nO20zrGg7mQncEFj9I9ClQ=="}],"memo":""},"blockNum":"725583"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"CbiIRh12H0gi4Zb/7yhZ7t25AR8gqYEqVFQGxFoKJ3l+qUFx8zAzEy0JLCV1hokZgi0kzU5d2iyLayvh4gCCNw=="}],"memo":""},"blockNum":"725595"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","amount":"5000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"P+KxC66NCNzPMvu8RuHcCyIbftAV4pLtfg/vf7VV6QoOsN8h8juNsaggyOjc6dz6w/eW0uB0SuHmxZ7LTuHMmQ=="}],"memo":""},"blockNum":"725601"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"3000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","3000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/baz:3000*POOL*gno.land/r/onbloc/baz:gno.land/r/onbloc/bar:3000*POOL*gno.land/r/onbloc/bar:gno.land/r/gnoswap/v2/gns:3000","100","29213880"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+YL8mPUco6oL7G6ybre79Nl5vCj4dUhQHGPIkMjAhRi"},"signature":"cD7/8rMM4R6xiQfiEKHathITOTU1Q9j7qN4m0umuaatmkfwDK4DdPLLPQ6ZNgvRyG5s/mYxZhMM6GKnWLXKQZQ=="}],"memo":""},"blockNum":"725694"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/onbloc/baz","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/baz","1000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/baz:3000","100","1986399"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+YL8mPUco6oL7G6ybre79Nl5vCj4dUhQHGPIkMjAhRi"},"signature":"HrkGCR0kMrMbwHiCYMZ8JJFaXG69yzv8pde5fJOedPxJZmj12N7gBMhjL3PNpIG3I9ZjOFQwEjEssOttWunNYQ=="}],"memo":""},"blockNum":"725708"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/onbloc/bar","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/bar","1000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/baz:3000*POOL*gno.land/r/onbloc/baz:gno.land/r/onbloc/bar:3000","100","19825268"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+YL8mPUco6oL7G6ybre79Nl5vCj4dUhQHGPIkMjAhRi"},"signature":"IWydyic5RF1MK8GapQHb0jCLkKJBJuDMJ+pKa4wcU6gmBiLD6Z9EuLGNCsg2uLZGZ6FDEMHgbJBuKLAgWAikTw=="}],"memo":""},"blockNum":"725714"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","2983434"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","3000000"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","2983434"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"2983434ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/v2/gns","3000","-6960","6900","2983434","3000000","2968517","2985000","7282571140","g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+YL8mPUco6oL7G6ybre79Nl5vCj4dUhQHGPIkMjAhRi"},"signature":"9MUWZAMMzZRQZwPYxrHm8dYknp2zVrDN8Ry6Hua2y7k3jmB6bYnxg8mwgT+/b9pj9+al1krNIWw+YnGUvnYJmg=="}],"memo":""},"blockNum":"726091"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/foo","1000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000*POOL*gno.land/r/onbloc/usdc:gno.land/r/onbloc/obl:3000*POOL*gno.land/r/onbloc/obl:gno.land/r/onbloc/foo:3000","100","2936266"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+YL8mPUco6oL7G6ybre79Nl5vCj4dUhQHGPIkMjAhRi"},"signature":"3EB7ifBHabuNthY/Bir+4cagbQyqDS2KG4ZqSkRNp9VgvoA9vmJ9AR8gciCZXT7J7VE28w5O4EZoVc5xMxPK5Q=="}],"memo":""},"blockNum":"726104"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","2523626"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","2951023"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","2523626"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"2523626ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/onbloc/foo","3000","-5280","8580","2523626","2951023","2511008","2936268","7282571140","g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c"]},{"@type":"/vm.m_call","caller":"g1e9xg9qy30pkqzz2upga4mzg559p33hqj0spv6c","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+YL8mPUco6oL7G6ybre79Nl5vCj4dUhQHGPIkMjAhRi"},"signature":"YoFdSul8fqWslvilhAcQfzndn1RQ+FYmz7b5rrfyX/JZ2KqX5EPqTgCF7d/lFhPuDWW5QPsL/zCB2lrvh2mrcA=="}],"memo":""},"blockNum":"726130"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"tljnwFZohRgtPj5llN0oUAkHacI5mRWz1pHojRDfxIBzs5EWZbzFwxG6ZycVpjC/uZHUAcCEzpcnLz7SsRFWRw=="}],"memo":""},"blockNum":"728051"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","996177573"]},{"@type":"/vm.m_call","caller":"g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1000000000"]},{"@type":"/vm.m_call","caller":"g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","996177573"]},{"@type":"/vm.m_call","caller":"g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl","send":"996177573ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/onbloc/usdc","3000","-6960","6900","996177573","1000000000","991196685","995000000","7282571140","g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl"]},{"@type":"/vm.m_call","caller":"g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+eBjDB0SytELhwvEdaB1txb+1+RkyEUDU2k+lcVMppR"},"signature":"XNed5NFW1lzrI7eVqOCJuciG8KQ9IEmbYvtVzMAMWr5hRPEVSK5kqC0Z8T5QtvdHOr1OfdQzzZu51oJVKiywoQ=="}],"memo":""},"blockNum":"728085"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","500000000"]},{"@type":"/vm.m_call","caller":"g1mhnd9g3zcc8k9yh5lccjc9jtc2zk4w7n5gd0kl","send":"500000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CreateExternalIncentive","args":["gno.land/r/demo/wugnot:gno.land/r/onbloc/usdc:3000","gnot","500000000","1723161600","1730937600"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+eBjDB0SytELhwvEdaB1txb+1+RkyEUDU2k+lcVMppR"},"signature":"R+V84wSVKGATvm2A2Pd9KIWrIeR+GQ+yeUpIWHnq9bYjEjFNCknOUNlW/EU3QOm5RRWzvMY59UtKcorPhFwudQ=="}],"memo":""},"blockNum":"728115"}
