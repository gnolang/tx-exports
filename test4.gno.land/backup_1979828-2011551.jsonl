{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo/v403/grc/grc721","files":[{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"cfVpUL5QCbutK925509Dx3jRbnrVqy62qAxH2wNWfksWCWOXyX29TQRL2Ye9p9r9EzYclptZUSzXcMD+pyP+iw=="}],"memo":""},"blockNum":"1980653"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"domain","path":"gno.land/p/varmeta/demo/v403/domain","files":[{"name":"domain_metadata.gno","body":"package domain\n\nimport (\n\t\"time\"\n)\n\n// Trait represents a key-value pair with an optional display type for metadata attributes\ntype Trait struct {\n\tDisplayType string // Optional display type (e.g., \"date\", \"number\", etc.)\n\tTraitType   string // Type of the trait (e.g., \"age\", \"height\", etc.)\n\tValue       string // Value of the trait\n}\n\n// Metadata represents the metadata associated with a domain\ntype Metadata struct {\n\tAvatar           string    // URL or identifier for an avatar image\n\tRegistrationTime time.Time // The time when the domain was registered\n\tExpirationTime   time.Time // The time when the domain will be expire\n\tAttributes       []Trait   // Additional attributes of the domain\n\tDescription      string    // A description of the domain\n\tContactInfo      string    // Contact information for the domain owner\n\tRenewalFee       string    // The fee required to renew the domain, represented as a string\n}\n\n// NewMetadata creates a new Metadata instance\nfunc NewMetadata(avatar, description, contactInfo, renewalFee string,\n\tregistrationTime, expirationTime time.Time, attributes []Trait,\n) Metadata {\n\treturn Metadata{\n\t\tAvatar:           avatar,\n\t\tRegistrationTime: registrationTime,\n\t\tExpirationTime:   expirationTime,\n\t\tRenewalFee:       renewalFee,\n\t\tAttributes:       attributes,\n\t\tDescription:      description,\n\t\tContactInfo:      contactInfo,\n\t}\n}\n"},{"name":"domain_registry.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v403/grc/grc721\"\n)\n\n// domainRegistry represents a registry for domain names with metadata\ntype domainRegistry struct {\n\tdomains  grc721.IGRC721 // Interface for basic NFT functionality\n\tmetadata *avl.Tree      // AVL tree for storing domain metadata\n\texpDate  time.Time\n}\n\n// DomainRegistry defines the methods for managing domain names and metadata\ntype DomainRegistry interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(domainName string) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, domainName string) error\n\tTransferFrom(from, to std.Address, domainName string) error\n\tApprove(approved std.Address, domainName string) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(domainName string) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, domainName string) error\n\n\tRegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error\n\tSetDomainData(domainName string, metadata Metadata) error\n\tGetDomainData(domainName string, field MetadataField) (Metadata, error)\n\tGetDomainFields(domainName string, fields []MetadataField) (Metadata, error)\n\tRenewDomain(domainName string, additionalDuration time.Duration) error\n\tGetExpirationDate(domainName string) time.Time\n\tSetExpirationDate(domainName string, expDate time.Time) bool\n}\n\n// NewDomainRegistry creates a new domain registry with metadata extensions\nfunc NewDomainRegistry(name, symbol string) *domainRegistry {\n\tregistry := grc721.NewBasicNFT(name, symbol)\n\n\treturn \u0026domainRegistry{\n\t\tdomains:  registry,\n\t\tmetadata: avl.NewTree(),\n\t}\n}\n\n// RegisterDomain registers a new domain with the given metadata\nfunc (d *domainRegistry) RegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error {\n\terr := d.domains.Mint(owner, grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\td.expDate = time.Now().Add(dur)\n\td.metadata.Set(domainName, metadata)\n\n\treturn nil\n}\n\n// RenewDomain extends the expiration time of a domain name\nfunc (d *domainRegistry) RenewDomain(domainName string, additionalDuration time.Duration) error {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn ErrInvalidDomainName\n\t}\n\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\t// set new expiration date\n\td.expDate = d.expDate.Add(additionalDuration)\n\treturn nil\n}\n\n// SetDomainData sets the metadata for a given domain name\nfunc (d *domainRegistry) SetDomainData(domainName string, metadata Metadata) error {\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\td.metadata.Set(domainName, metadata)\n\treturn nil\n}\n\n// GetDomainFields retrieves multiple fields of metadata for a given domain\nfunc (d *domainRegistry) GetDomainFields(domainName string, fields []MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tif len(fields) == 0 {\n\t\treturn metadata, nil\n\t}\n\n\tvar result Metadata\n\tfor _, field := range fields {\n\t\tswitch field {\n\t\tcase FieldAvatar:\n\t\t\tresult.Avatar = metadata.Avatar\n\t\tcase FieldRegistrationTime:\n\t\t\tresult.RegistrationTime = metadata.RegistrationTime\n\t\tcase FieldExpirationTime:\n\t\t\tresult.ExpirationTime = metadata.ExpirationTime\n\t\tcase FieldRenewalFee:\n\t\t\tresult.RenewalFee = metadata.RenewalFee\n\t\tcase FieldAttributes:\n\t\t\tresult.Attributes = metadata.Attributes\n\t\tcase FieldDescription:\n\t\t\tresult.Description = metadata.Description\n\t\tcase FieldContactInfo:\n\t\t\tresult.ContactInfo = metadata.ContactInfo\n\t\tdefault:\n\t\t\treturn Metadata{}, ErrInvalidMetadataField\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// GetDomainData retrieves metadata for a given domain\nfunc (d *domainRegistry) GetDomainData(domainName string, field MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tswitch field {\n\tcase FieldAvatar:\n\t\treturn Metadata{\n\t\t\tAvatar: metadata.Avatar,\n\t\t}, nil\n\tcase FieldRegistrationTime:\n\t\treturn Metadata{\n\t\t\tRegistrationTime: metadata.RegistrationTime,\n\t\t}, nil\n\tcase FieldExpirationTime:\n\t\treturn Metadata{\n\t\t\tExpirationTime: metadata.ExpirationTime,\n\t\t}, nil\n\tcase FieldRenewalFee:\n\t\treturn Metadata{\n\t\t\tRenewalFee: metadata.RenewalFee,\n\t\t}, nil\n\tcase FieldAttributes:\n\t\treturn Metadata{\n\t\t\tAttributes: metadata.Attributes,\n\t\t}, nil\n\tcase FieldDescription:\n\t\treturn Metadata{\n\t\t\tDescription: metadata.Description,\n\t\t}, nil\n\tcase FieldContactInfo:\n\t\treturn Metadata{\n\t\t\tContactInfo: metadata.ContactInfo,\n\t\t}, nil\n\tdefault:\n\t\treturn Metadata{}, ErrInvalidMetadataField\n\t}\n}\n\n// BalanceOf returns the number of domains owned by a given address\nfunc (d *domainRegistry) BalanceOf(owner std.Address) (uint64, error) {\n\treturn d.domains.BalanceOf(owner)\n}\n\n// OwnerOf returns the owner of a given domain name\nfunc (d *domainRegistry) OwnerOf(domainName string) (std.Address, error) {\n\treturn d.domains.OwnerOf(grc721.TokenID(domainName))\n}\n\n// SafeTransferFrom safely transfers a domain from one address to another\nfunc (d *domainRegistry) SafeTransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.SafeTransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// TransferFrom transfers a domain from one address to another\nfunc (d *domainRegistry) TransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.TransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// Approve grants approval to another address to manage a specific domain\nfunc (d *domainRegistry) Approve(approved std.Address, domainName string) error {\n\treturn d.domains.Approve(approved, grc721.TokenID(domainName))\n}\n\n// SetApprovalForAll sets approval for an operator to manage all domains of the owner\nfunc (d *domainRegistry) SetApprovalForAll(operator std.Address, approved bool) error {\n\treturn d.domains.SetApprovalForAll(operator, approved)\n}\n\n// GetApproved returns the approved address for a specific domain\nfunc (d *domainRegistry) GetApproved(domainName string) (std.Address, error) {\n\treturn d.domains.GetApproved(grc721.TokenID(domainName))\n}\n\n// IsApprovedForAll checks if an operator is approved to manage all domains of the owner\nfunc (d *domainRegistry) IsApprovedForAll(owner, operator std.Address) bool {\n\treturn d.domains.IsApprovedForAll(owner, operator)\n}\n\n// Mint creates a new domain for a given address\nfunc (d *domainRegistry) Mint(to std.Address, domainName string) error {\n\treturn d.domains.Mint(to, grc721.TokenID(domainName))\n}\n\nfunc (d *domainRegistry) GetExpirationDate(domainName string) time.Time {\n\treturn d.expDate\n}\n\nfunc (d *domainRegistry) SetExpirationDate(domainName string, expDate time.Time) bool {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn false\n\t}\n\td.expDate = expDate\n\treturn true\n}\n"},{"name":"domain_registry_test.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/urequire\"\n\t\"gno.land/p/varmeta/demo/v403/grc/grc721\"\n)\n\nvar (\n\taddr1 = testutils.TestAddress(\"bob\")\n\taddr2 = testutils.TestAddress(\"alice\")\n)\n\nfunc TestRegisterDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Successful Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"contact@registered.com\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Duplicate Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\terr := registry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.owner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr1,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr2,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\t\t\terr := registry.SetDomainData(c.domainName, c.metadata)\n\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\tretrievedMetadata, err := registry.GetDomainData(c.domainName, FieldAvatar)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.metadata.Avatar, retrievedMetadata.Avatar)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRenewDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname           string\n\t\towner          std.Address\n\t\tcaller         std.Address\n\t\tdomainName     string\n\t\tadditionalTime time.Duration\n\t\texpectError    bool\n\t\texpectedExpiry time.Time\n\t}{\n\t\t{\n\t\t\tname:           \"Successful Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr1,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"Non-Owner Attempts Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr2,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A renewable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.RenewDomain(c.domainName, c.additionalTime)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\trenewedMetadata, err := registry.GetDomainData(c.domainName, FieldExpirationTime)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\t// urequire.True(t, renewedMetadata.ExpirationTime.After(metadata.ExpirationTime))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfield       MetadataField\n\t\texpectError bool\n\t\texpectedVal string\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Avatar\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: false,\n\t\t\texpectedVal: \"avatar_url\",\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain Name\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t_, err := registry.GetDomainData(c.domainName, c.field)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainFields(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfields      []MetadataField\n\t\texpectError bool\n\t\texpected    Metadata\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Multiple Fields\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar, FieldDescription, FieldContactInfo},\n\t\t\texpectError: false,\n\t\t\texpected: Metadata{\n\t\t\t\tAvatar:      \"avatar_url\",\n\t\t\t\tDescription: \"A test domain\",\n\t\t\t\tContactInfo: \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tretrievedMetadata, err := registry.GetDomainFields(c.domainName, c.fields)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.expected.Avatar, retrievedMetadata.Avatar)\n\t\t\t\turequire.Equal(t, c.expected.Description, retrievedMetadata.Description)\n\t\t\t\turequire.Equal(t, c.expected.ContactInfo, retrievedMetadata.ContactInfo)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTransferDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tnewOwner    std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"Successful Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr1,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Non-Owner Attempts Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr2,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A transferable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.TransferFrom(c.owner, c.newOwner, c.domainName)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), grc721.ErrTransferFromIncorrectOwner.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.newOwner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"errors.gno","body":"package domain\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnauthorized         = errors.New(\"caller is not domain owner\")\n\tErrInvalidDomainName    = errors.New(\"invalid domain name\")\n\tErrInvalidMetadataField = errors.New(\"invalid metadata field\")\n\tErrInsufficientFunds    = errors.New(\"insufficient funds for renewal\")\n)\n"},{"name":"utils.gno","body":"package domain\n\ntype MetadataField int\n\nconst (\n\tFieldAvatar MetadataField = iota\n\tFieldRegistrationTime\n\tFieldRenewalFee\n\tFieldExpirationTime\n\tFieldAttributes\n\tFieldDescription\n\tFieldContactInfo\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"6000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"RGqI5JSs9etNvTbmNS0gTDNW9BlnQIJ2gvT/L3/fTDIBeUbl58VI5CB/Z5sOBlVkCOCZ56ZT7zy9dZcc7DAmPw=="}],"memo":""},"blockNum":"1980661"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo/v403/domain/registrar","files":[{"name":"bidding.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t// \"gno.land/p/demo/mux\"\n\t\"gno.land/p/demo/avl\"\n)\n\n// I want to redesign this codebase\n\n// all keys are domainName\nvar bidStorages avl.Tree // dName \u003c- []bidRecV2\n\n// record new joined bid\nfunc record2Storage(domainName string) {\n\tcaller := std.GetOrigCaller()\n\tnow := time.Now().UnixMilli()\n\tnewRec := bidRecV2{\n\t\tBidder:     caller.String(),\n\t\tDomainName: domainName,\n\t\tStartTime:  now,\n\t\t//...\n\t}\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tbidStorages.Set(domainName, newRec)\n\t}\n\tbidRecList := data.([]bidRecV2)\n\toldStartTime := bidRecList[0].StartTime\n\tnewRec.StartTime = oldStartTime\n\tbidRecList = append(bidRecList, newRec)\n\tbidStorages.Set(domainName, bidRecList)\n}\n\n// GetJoinedBid returns the status of an user's joined bid session information\nfunc GetJoinedBid(caller string) []bidStatus {\n\tdNameList := []string{}\n\t// Iterate the bidStorages, which domainName has Bidder == caller -\u003e take domainNames\n\tbidStorages.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tdataList := value.([]bidRecV2)\n\t\tfor _, rec := range dataList {\n\t\t\tif rec.Bidder == caller {\n\t\t\t\tufmt.Println(\"key to append: \", key)\n\t\t\t\tdNameList = append(dNameList, key)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n\tufmt.Println(\"len: \", len(dNameList))\n\t// after get dNameList of a caller, we check status of each dName\n\tlistStatus := []bidStatus{}\n\tfor _, dName := range dNameList {\n\t\tstt := GetCurrentStatus(dName, caller)\n\t\t// get the time stamp in [0] element and assign it to status\n\t\tdata, _ := bidStorages.Get(dName)\n\t\tbidRec := data.([]bidRecV2)[0]\n\n\t\tsingleStt := bidStatus{\n\t\t\tDomainName:    dName,\n\t\t\tStatus:        stt,\n\t\t\tEndCommitTime: bidRec.EndCommitTime,\n\t\t\tEndPriceTime:  bidRec.EndPriceTime,\n\t\t}\n\t\tlistStatus = append(listStatus, singleStt)\n\t}\n\tufmt.Println(\"len of list status: \", len(listStatus))\n\treturn listStatus\n}\n\nfunc Get(domainName string) ([]string, []string, []int64) {\n\tdata, _ := bidStorages.Get(domainName)\n\tlist := data.([]bidRecV2)\n\tdNameList := []string{}\n\thashList := []string{}\n\tpList := []int64{}\n\tfor _, rec := range list {\n\t\tdNameList = append(dNameList, rec.Bidder)\n\t\thashList = append(hashList, rec.HashString)\n\t\tpList = append(pList, rec.Price)\n\t}\n\treturn dNameList, hashList, pList\n}\n\n/*\n\tI want the CommitHash and CommitPrice will change the status of the record, by this way, we can detect\n\tthe current state of a bidding session for each user\n*/\n\n// GetCurrentStatus returns the status of the bidding session about a domain name. This func requires caller to determine in case Committed or not (hash or price)\nfunc GetCurrentStatus(domainName string, caller string) string {\n\t// if there is record in joinedBid -\u003e user joined\n\t// check for tine.Now() and startTime\n\tnow := time.Now().UnixMilli()\n\t// if domain name is owned already\n\towner := GetOwner(domainName)\n\tif owner != \"\" {\n\t\treturn \"owned by \" + owner.String()\n\t}\n\t// find the record\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\t// no record in bidRec yet -\u003e not Committed -\u003e check if user started auction or not - if yes: new auction\n\t\treturn \"domain name is free\"\n\t}\n\trecList := data.([]bidRecV2)\n\trec0 := recList[0]\n\t// Auction closed with winner\n\tif rec0.EndPriceTime \u003c now \u0026\u0026 owner != \"\" {\n\t\treturn \"close\"\n\t}\n\t// find the record of the caller\n\tfor _, rec := range recList {\n\t\tswitch {\n\t\t// Waiting for hash commitment\n\t\tcase !rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.StartTime \u003c now \u0026\u0026 rec.EndCommitTime \u003e now:\n\t\t\treturn \"waiting hash\"\n\n\t\t// Committed hash\n\t\tcase rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.StartTime \u003c now \u0026\u0026 rec.EndCommitTime \u003e now:\n\t\t\treturn \"committed hash\"\n\n\t\t// Waiting for price commitment\n\t\tcase rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.EndCommitTime \u003c now \u0026\u0026 rec.EndPriceTime \u003e now:\n\t\t\treturn \"waiting price\"\n\n\t\t// Committed price\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 rec.EndCommitTime \u003c now \u0026\u0026 rec.EndPriceTime \u003e now:\n\t\t\treturn \"committed price\"\n\n\t\t// Winner claiming domain\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 rec.IsWinner \u0026\u0026 rec.EndPriceTime \u003c now:\n\t\t\treturn rec.Bidder + \" is claiming domain name: \" + domainName\n\t\t// find the winner\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 !rec.IsWinner \u0026\u0026 rec.EndPriceTime \u003c now:\n\t\t\t_, winnerRec := findTheWinner(domainName)\n\t\t\treturn winnerRec.Bidder + \" is claiming domain name: \" + domainName\n\t\t// Missed hash commitment deadline\n\t\tcase !rec.IsCommittedHash \u0026\u0026 rec.EndCommitTime \u003c now:\n\t\t\treturn \"waiting for hash\"\n\t\t}\n\t}\n\n\treturn \"undefined\"\n}\n\n// CommitHash consumes off-chain calculated hash string and the domain name that user want\nfunc CommitHash(domainName, hashString string) string {\n\tcaller := std.GetOrigCaller()\n\n\t// use now as int64 representation of time.Now()\n\tnow := time.Now().UnixMilli()\n\n\t// update the bid record\n\tdata, existed := bidStorages.Get(domainName)\n\n\t// if not existed -\u003e create new record\n\tif !existed {\n\t\t// for further getStatus\n\t\t// record2Storage(domainName)\n\n\t\tvar bidRec bidRecV2\n\t\tendCommitTime := now + defaultCommitHashTime.Milliseconds()\n\t\tendPriceTime := endCommitTime + defaultCommitPriceTime.Milliseconds()\n\t\tufmt.Println(\"[HASH]: request at: \", time.UnixMilli(now))\n\t\tufmt.Println(\"[HASH]: endCommitTime: \", time.UnixMilli(endCommitTime))\n\t\tufmt.Println(\"[HASH]: endPriceTime: \", time.UnixMilli(endPriceTime))\n\t\tbidRec = bidRecV2{\n\t\t\tDomainName:       domainName,\n\t\t\tBidder:           caller.String(),\n\t\t\tHashString:       hashString,\n\t\t\tStartTime:        now,\n\t\t\tEndCommitTime:    endCommitTime,\n\t\t\tEndPriceTime:     endPriceTime,\n\t\t\tIsCommittedHash:  true,\n\t\t\tIsCommittedPrice: false,\n\t\t\tIsWinner:         true,\n\t\t\tPrice:            0,\n\t\t}\n\t\tbidNewRec := []bidRecV2{bidRec}\n\t\tbidStorages.Set(domainName, bidNewRec)\n\n\t\t// charge fee\n\t\tchargeFee(fee.BidJoinFee, std.Address(caller))\n\t\treturn \"new session\"\n\t}\n\t// if existed\n\tbidRecList := data.([]bidRecV2)\n\tstartTime := bidRecList[0].StartTime\n\toldEndCommitTimeUnix := bidRecList[0].EndCommitTime\n\toldEndPriceTimeUnix := bidRecList[0].EndPriceTime\n\tif now \u003e oldEndCommitTimeUnix {\n\t\t// now := time.Now().UnixMilli()\n\t\t// ufmt.Println(\"[HASH]: now: \", time.UnixMilli(now))\n\t\tpanic(\"[HASH]: can not commit hash anymore\")\n\t}\n\tfor _, bR := range bidRecList {\n\t\tif bR.Bidder == caller.String() {\n\t\t\tpanic(\"[HASH]: you already committed hash\")\n\t\t}\n\t}\n\n\tnewRec := bidRecV2{\n\t\tDomainName:       domainName,\n\t\tHashString:       hashString,\n\t\tBidder:           caller.String(),\n\t\tStartTime:        startTime,\n\t\tEndCommitTime:    oldEndCommitTimeUnix,\n\t\tEndPriceTime:     oldEndPriceTimeUnix,\n\t\tIsCommittedHash:  true,\n\t\tIsCommittedPrice: false,\n\t\tIsWinner:         false,\n\t}\n\t// append the list, set it to storage\n\tbidRecList = append(bidRecList, newRec)\n\tufmt.Println(\"len bidRecList: \", len(bidRecList))\n\t// Save record\n\tbidStorages.Set(domainName, bidRecList)\n\t// charge commit hash fee\n\tufmt.Println(\"saved hash: \", hashString)\n\tchargeFee(fee.BidJoinFee, caller)\n\treturn \"existed\"\n}\n\n// for now we dont use panic because this will cause the permanent time.Now() stuck. IDK why // XXX fix me\n// CommitPrice consumes price and secret string that user used in calculating hash string from off-chain. This will re-calculate the hashstring and compare with the one Committed before\nfunc CommitPrice(price int64, secret string, domainName string) string {\n\t// compute the hash string, compare to saved hash string in record\n\t// use int64 representation of time.Now()\n\tnow := time.Now().UnixMilli()\n\tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n\tjoinedString := secret + strconv.Itoa(int(price))\n\tcomputedHashString := Get256String(joinedString)\n\tcaller := std.GetOrigCaller()\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"[PRICE]: domain name is invalid\")\n\t}\n\tbidRecList := data.([]bidRecV2)\n\n\tufmt.Println(\"[PRICE]: endPriceTime: \", time.UnixMilli(bidRecList[0].EndPriceTime))\n\t// case commit after end - consider panic or not\n\tif now \u003e bidRecList[0].EndPriceTime {\n\t\tufmt.Println(\"[PRICE]: commit price phase is ended\")\n\t\treturn \"ended\"\n\t}\n\t// case commit when price phase not started\n\tif now \u003c bidRecList[0].EndCommitTime {\n\t\tufmt.Println(\"[PRICE]: commit price phase is not started yet\")\n\t\treturn \"not started yet\"\n\t}\n\t// detect current winner by index and address\n\t_, currentWinnerRec := findTheWinner(domainName)\n\n\t// search for the corresponding hash\n\tfor index, rec := range bidRecList {\n\t\tufmt.Println(\"index \", index)\n\t\tufmt.Println(\"hash: \", rec.HashString)\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.IsCommittedPrice {\n\t\t\tufmt.Println(\"[PRICE] you already committed price\")\n\t\t\treturn \"committed\"\n\t\t}\n\t\t// panic because wrong price or wrong secret string\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.HashString != computedHashString {\n\t\t\tufmt.Println(\"[PRICE]: invalid hash string\")\n\t\t\treturn \"invalid hash string\"\n\t\t}\n\t\t// found it, update the price\n\t\tufmt.Println(\"checking for bid addr: \", rec.Bidder)\n\t\tufmt.Println(\"hash: \", rec.HashString)\n\t\tufmt.Println(\"caller: \", caller.String())\n\t\tufmt.Println(\"input hash: \", computedHashString)\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.HashString == computedHashString {\n\t\t\t// update record with a new list\n\t\t\t// find the winner\n\t\t\tif price \u003e currentWinnerRec.Price \u0026\u0026 now \u003c currentWinnerRec.EndPriceTime {\n\t\t\t\t// set others status to not winner\n\t\t\t\tdata, _ := bidStorages.Get(domainName)\n\t\t\t\tcurrentList := data.([]bidRecV2)\n\t\t\t\tnewList := []bidRecV2{}\n\t\t\t\tfor _, rec := range currentList {\n\t\t\t\t\trec.IsWinner = false\n\t\t\t\t\tnewList = append(newList, rec)\n\t\t\t\t}\n\n\t\t\t\t// update winner\n\t\t\t\tufmt.Println(\"[PRICE]: found new winner, setting up\")\n\t\t\t\tnewRec := bidRecV2{\n\t\t\t\t\tDomainName:       domainName,\n\t\t\t\t\tPrice:            price,\n\t\t\t\t\tIsCommittedHash:  true,\n\t\t\t\t\tIsCommittedPrice: true,\n\t\t\t\t\tIsWinner:         true,\n\t\t\t\t\tStartTime:        currentWinnerRec.StartTime,\n\t\t\t\t\tEndCommitTime:    currentWinnerRec.EndCommitTime,\n\t\t\t\t\tEndPriceTime:     currentWinnerRec.EndPriceTime,\n\t\t\t\t\tBidder:           caller.String(),\n\t\t\t\t\tHashString:       computedHashString,\n\t\t\t\t}\n\t\t\t\t// save records\n\t\t\t\tnewList[index] = newRec\n\t\t\t\tbidStorages.Set(domainName, newList)\n\t\t\t\treturn \"claim\"\n\t\t\t} \n\t\t\tif price \u003c= currentWinnerRec.Price \u0026\u0026 now \u003c currentWinnerRec.EndPriceTime {\n\t\t\t\tupdatedRec := bidRecV2{\n\t\t\t\t\tDomainName:       domainName,\n\t\t\t\t\tPrice:            price,\n\t\t\t\t\tIsCommittedHash:  true,\n\t\t\t\t\tIsCommittedPrice: true,\n\t\t\t\t\tIsWinner:         true,\n\t\t\t\t\tStartTime:        rec.StartTime,\n\t\t\t\t\tEndCommitTime:    rec.EndCommitTime,\n\t\t\t\t\tEndPriceTime:     rec.EndPriceTime,\n\t\t\t\t\tBidder:           caller.String(),\n\t\t\t\t\tHashString:       computedHashString,\n\t\t\t\t}\n\t\t\t\tdata, _ := bidStorages.Get(domainName)\n\t\t\t\tcurrentList := data.([]bidRecV2)\n\t\t\t\tcurrentList[index] = updatedRec\n\t\t\t\tbidStorages.Set(domainName, currentList)\n\t\t\t\treturn \"loser\"\n\t\t\t}\n\t\t\t// else {\n\t\t\t// \tupdatedList := bidRecList\n\t\t\t// \tupdatedList[index].Price = price\n\t\t\t// \tupdatedList[index].IsWinner = false\n\t\t\t// \tbidStorages.Set(domainName, updatedList)\n\t\t\t// \treturn \"loser\"\n\t\t\t// }\n\t\t}\n\t}\n\t// if not match above case, then you are not in list\n\tpanic(\"commit price failed\")\n}\n\n// GetCurrentWinner shows the current highest price user\nfunc GetCurrentWinner(domainName string) bidRecV2 {\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"no winner yet\")\n\t}\n\tlist := data.([]bidRecV2)\n\tfor _, bidRec := range list {\n\t\tif bidRec.IsWinner {\n\t\t\treturn bidRec\n\t\t}\n\t}\n\t// panic - should not happend\n\treturn bidRecV2{}\n}\n\n// find the highest bid in session - incase everyone Committed price\n// in old flow, we need to find the winner by retrievaling the bidStorage\nfunc findTheWinner(domainName string) (index int, winnerBid bidRecV2) {\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"invalid domain name\")\n\t}\n\tindex = 0\n\tbidRecList := data.([]bidRecV2)\n\twinnerBid = bidRecList[0]\n\tfor i, bidRec := range bidRecList {\n\t\tif bidRec.Price \u003e winnerBid.Price {\n\t\t\twinnerBid.Price = bidRec.Price\n\t\t\twinnerBid.Bidder = bidRec.Bidder\n\t\t\twinnerBid.HashString = bidRec.HashString\n\t\t\twinnerBid.StartTime = bidRec.StartTime\n\t\t\twinnerBid.EndCommitTime = bidRec.EndCommitTime\n\t\t\twinnerBid.EndPriceTime = bidRec.EndPriceTime\n\t\t\twinnerBid.IsCommittedHash = bidRec.IsCommittedHash\n\t\t\twinnerBid.IsCommittedPrice = bidRec.IsCommittedPrice\n\t\t\tindex = i\n\t\t}\n\t}\n\treturn index, winnerBid\n}\n\n// get all the price list that joined the bid for displaying in dapp\nfunc GetRecords(dName string) []bidRecV2 {\n\tdata, existed := bidStorages.Get(dName)\n\tif !existed {\n\t\tpanic(\"should not\")\n\t}\n\treturn data.([]bidRecV2)\n}\n\n// chargeFee will charge amount - send from this contract to admin\nfunc chargeFee(amount int64, from std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", amount)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tcoins := checkCoin(from)\n\tufmt.Println(\"check balances: \", coins)\n\t// ufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// pay fee and claim the domain name if you are winner\nfunc Claim(domainName string) bool {\n\tif !bidStorages.Has(domainName) {\n\t\tpanic(\"claim: invalid domain name\")\n\t}\n\tcaller := std.GetOrigCaller()\n\t_, winner := findTheWinner(domainName)\n\tif caller.String() != winner.Bidder {\n\t\tpanic(\"only winner can claim\")\n\t}\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       caller,\n\t\tMode:         \"native\",\n\t}\n\tresult := executeRegister(requestInfo)\n\tif !result.Success {\n\t\tpanic(result.ResultDetails.Error())\n\t}\n\t// register done. Now charge the fee\n\tchargeFee(winner.Price, caller)\n\tfeeProcess(requestInfo)\n\treturn true\n}\n\n// expose winner price - amount of fee that user need to pay in Claim phase\nfunc GetWinnerPrice(dName string) int64 {\n\trec := GetCurrentWinner(dName)\n\treturn rec.Price\n}\n"},{"name":"bidding_model.gno","body":"package registrar\n\nimport \"std\"\n\ntype bidStatus struct {\n\tDomainName    string\n\tStatus        string\n\tEndCommitTime int64\n\tEndPriceTime  int64\n}\n\ntype bidRecord struct {\n\tDomainName       string\n\tBidder           std.Address\n\tHashString       string\n\tPrice            int64\n\tStartTime        int64\n\tEndCommitTime    int64\n\tEndPriceTime     int64\n\tIsCommittedPrice bool\n\t// CurrentPhase  actionCode\n}\ntype bidRecV2 struct {\n\tDomainName       string\n\tBidder           string\n\tHashString       string\n\tPrice            int64\n\tStartTime        int64\n\tEndCommitTime    int64\n\tEndPriceTime     int64\n\tIsCommittedPrice bool\n\tIsCommittedHash  bool\n\tIsWinner         bool\n}\n"},{"name":"bidding_v39.gno","body":"package registrar\n\n// import (\n// \t\"std\"\n// \t\"strconv\"\n// \t\"time\"\n\n// \t\"gno.land/p/demo/ufmt\"\n// \t// \"gno.land/p/demo/mux\"\n// \t\"gno.land/p/demo/avl\"\n// )\n\n// var (\n// \tbidStorage *avl.Tree // bidRecord \u003c- []bidRec\n// \twinnerRec  *avl.Tree // dName \u003c- bidRec\n// \tjoinedBid  *avl.Tree // address \u003c- []string DomainName\n// )\n\n// func recordJoinedBid(domainName string) {\n// \tcaller := std.GetOrigCaller()\n// \tdList := []string{}\n// \tdata, existed := joinedBid.Get(caller.String())\n// \tif !existed {\n// \t\tdList = []string{domainName}\n// \t\tjoinedBid.Set(caller.String(), dList)\n// \t\treturn\n// \t}\n// \tdList = data.([]string)\n// \tdList = append(dList, domainName)\n// \tjoinedBid.Set(caller.String(), dList)\n// \treturn\n// }\n\n// // GetJoinedBid returns the status of an user's joined bid session information\n// func GetJoinedBid(caller string) []bidStatus {\n// \tdata, existed := joinedBid.Get(caller)\n// \tif !existed {\n// \t\treturn []bidStatus{}\n// \t}\n// \tlist := data.([]string)\n// \tlistStatus := []bidStatus{}\n// \tfor _, dName := range list {\n// \t\tstt := GetCurrentStatus(dName, caller)\n\n// \t\t// get the time stamp in [0] element and assign it to status\n// \t\tdata, _ := bidStorage.Get(dName)\n// \t\tbidRec := data.([]bidRecord)[0]\n\n// \t\tsingleStt := bidStatus{\n// \t\t\tDomainName:    dName,\n// \t\t\tStatus:        stt,\n// \t\t\tEndCommitTime: bidRec.EndCommitTime,\n// \t\t\tEndPriceTime:  bidRec.EndPriceTime,\n// \t\t}\n// \t\tlistStatus = append(listStatus, singleStt)\n// \t}\n// \treturn listStatus\n// }\n\n// // GetCurrentStatus returns the status of the bidding session about a domain name. This func requires caller to determine in case commited or not (hash or price)\n// func GetCurrentStatus(domainName string, caller string) string {\n// \t// if there is record in joinedBid -\u003e user joined\n// \t// check for tine.Now() and startTime\n// \tnow := time.Now().UnixMilli()\n// \towner := GetOwner(domainName)\n// \tif owner != \"\" {\n// \t\treturn \"owned by \" + owner.String()\n// \t}\n// \t// find the record\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\t// no record in bidRec yet -\u003e not commited -\u003e check if user started auction or not - if yes: new auction\n// \t\tif dataJoined, existedInRegister := joinedBid.Get(caller); existedInRegister {\n// \t\t\tdNameList := dataJoined.([]string)\n// \t\t\tfor _, dName := range dNameList {\n// \t\t\t\tif dName == domainName {\n// \t\t\t\t\treturn \"waiting for hash\"\n// \t\t\t\t}\n// \t\t\t\treturn \"domain name is free\"\n// \t\t\t}\n// \t\t}\n// \t\treturn \"domain name is free\"\n// \t}\n\n// \t// commited yet\n// \trecList := data.([]bidRecord)\n// \trec := recList[0]\n// \tendCommitTimeUnix := rec.EndCommitTime\n// \tendPriceTimeUnix := rec.EndPriceTime\n// \tif now \u003c endCommitTimeUnix {\n// \t\tif rec.HashString != \"\" {\n// \t\t\treturn \"commited hash\"\n// \t\t} else {\n// \t\t\treturn \"hash\"\n// \t\t}\n// \t}\n\n// \tufmt.Println(\"now: \", time.UnixMilli(now))\n// \tufmt.Println(\"endPriceTime: \", time.UnixMilli(endPriceTimeUnix))\n// \tif now \u003c endPriceTimeUnix \u0026\u0026 now \u003e endCommitTimeUnix {\n// \t\t// check if commited price\n// \t\tdata, _ := bidStorage.Get(domainName)\n// \t\tbidRecList := data.([]bidRecord)\n// \t\tthisRec := bidRecord{}\n// \t\tfor _, bidRec := range bidRecList {\n// \t\t\tif bidRec.Bidder.String() == caller {\n// \t\t\t\tthisRec = bidRec\n// \t\t\t}\n// \t\t}\n// \t\tif thisRec.IsCommittedPrice {\n// \t\t\treturn \"committed price\"\n// \t\t}\n// \t\treturn \"price\"\n// \t}\n// \tif now \u003e rec.EndPriceTime {\n// \t\t// check if dName is claiming by winner - check if winner existed\n// \t\tif data, existed := winnerRec.Get(domainName); existed {\n// \t\t\twinner := data.(bidRecord)\n// \t\t\treturn winner.Bidder.String() + \" is claiming domain name: \" + domainName\n// \t\t}\n// \t\treturn \"closed\"\n// \t}\n// \treturn \"undefined\"\n// }\n\n// // Render() renders welcome message :D\n// func Render(path string) string {\n// \treturn \"welcome to varmeta domain name service\"\n// }\n\n// // CommitHash consumes off-chain calculated hash string and the domain name that user want\n// func CommitHash(domainName, hashString string) string {\n// \tcaller := std.GetOrigCaller()\n\n// \t// use now as int64 representation of time.Now()\n// \tnow := time.Now().UnixMilli()\n\n// \t// update the bid record\n// \tdata, existed := bidStorage.Get(domainName)\n\n// \t// if not existed -\u003e create new record\n// \tif !existed {\n// \t\t// for further getStatus\n// \t\trecordJoinedBid(domainName)\n\n// \t\tvar bidRec bidRecord\n// \t\tendCommitTime := now + defaultCommitHashTime.Milliseconds()\n// \t\tendPriceTime := endCommitTime + defaultCommitPriceTime.Milliseconds()\n// \t\tufmt.Println(\"[HASH]: request at: \", time.UnixMilli(now))\n// \t\tufmt.Println(\"[HASH]: endCommitTime: \", time.UnixMilli(endCommitTime))\n// \t\tufmt.Println(\"[HASH]: endPriceTime: \", time.UnixMilli(endPriceTime))\n// \t\tbidRec = bidRecord{\n// \t\t\tDomainName:    domainName,\n// \t\t\tBidder:        caller,\n// \t\t\tHashString:    hashString,\n// \t\t\tStartTime:     now,\n// \t\t\tEndCommitTime: endCommitTime,\n// \t\t\tEndPriceTime:  endPriceTime,\n// \t\t}\n// \t\tbidRecList := []bidRecord{bidRec}\n// \t\tbidStorage.Set(domainName, bidRecList)\n\n// \t\t// charge fee\n// \t\tchargeFee(fee.BidJoinFee, caller)\n// \t\treturn \"new session\"\n// \t}\n// \t// if existed\n// \tbidRecList := data.([]bidRecord)\n// \tstartTime := bidRecList[0].StartTime\n// \toldEndCommitTimeUnix := bidRecList[0].EndCommitTime\n// \toldEndPriceTimeUnix := bidRecList[0].EndPriceTime\n// \tif now \u003e oldEndCommitTimeUnix {\n// \t\t// now := time.Now().UnixMilli()\n// \t\t// ufmt.Println(\"[HASH]: now: \", time.UnixMilli(now))\n// \t\tpanic(\"[HASH]: can not commit hash anymore\")\n// \t}\n// \tfor _, bR := range bidRecList {\n// \t\tif bR.Bidder == caller {\n// \t\t\tpanic(\"[HASH]: you already commited hash\")\n// \t\t}\n// \t}\n\n// \tbidRec := bidRecord{\n// \t\tDomainName:    domainName,\n// \t\tHashString:    hashString,\n// \t\tBidder:        caller,\n// \t\tStartTime:     startTime,\n// \t\tEndCommitTime: oldEndCommitTimeUnix,\n// \t\tEndPriceTime:  oldEndPriceTimeUnix,\n// \t}\n// \tbidRecList = append(bidRecList, bidRec)\n// \t// Save record\n// \tbidStorage.Set(domainName, bidRecList)\n// \t// charge commit hash fee\n// \tchargeFee(fee.BidJoinFee, caller)\n// \treturn \"existed\"\n// }\n\n// // for now we dont use panic because this will cause the permanent time.Now() stuck. IDK why // XXX fix me\n// // CommitPrice consumes price and secret string that user used in calculating hash string from off-chain. This will re-calculate the hashstring and compare with the one commited before\n// func CommitPrice(price int64, secret string, domainName string) string {\n// \t// compute the hash string, compare to saved hash string in record\n// \t// use int64 representation of time.Now()\n// \tnow := time.Now().UnixMilli()\n// \tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n// \tjoinedString := secret + strconv.Itoa(int(price))\n// \tcomputedHashString := Get256String(joinedString)\n// \tcaller := std.GetOrigCaller()\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"[PRICE]: domain name is invalid\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \twinnerRec.Set(domainName, bidRecList[len(bidRecList)-1])\n// \tufmt.Println(\"[PRICE] current winner set to: \", bidRecList[len(bidRecList)-1].Bidder.String())\n\n// \tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n// \tufmt.Println(\"[PRICE]: endPriceTime: \", time.UnixMilli(bidRecList[0].EndPriceTime))\n// \t// case commit after end - consider panic or not\n// \tif now \u003e bidRecList[0].EndPriceTime {\n// \t\tufmt.Println(\"[PRICE]: commit price phase is ended\")\n// \t\treturn \"ended\"\n// \t}\n// \t// case commit when price phase not started\n// \tif now \u003c= bidRecList[0].EndCommitTime {\n// \t\tufmt.Println(\"[PRICE]: commit price phase is not started yet\")\n// \t\treturn \"not started yet\"\n// \t}\n\n// \t// search for the corresponding hash\n// \tfor index, bidRec := range bidRecList {\n// \t\t// panic because wrong price or wrong secret string\n// \t\tif bidRec.Bidder == caller \u0026\u0026 bidRec.HashString != computedHashString {\n// \t\t\tpanic(\"[PRICE]: invalid hash string\")\n// \t\t}\n// \t\t// found it, update the winner price\n// \t\tif bidRec.Bidder == caller \u0026\u0026 bidRec.HashString == computedHashString {\n// \t\t\tdata, _ := winnerRec.Get(domainName)\n// \t\t\tcurrentWinnerRec := data.(bidRecord)\n// \t\t\tif price \u003e currentWinnerRec.Price \u0026\u0026 now \u003c currentWinnerRec.EndPriceTime {\n// \t\t\t\tufmt.Println(\"[PRICE]: found new winner, setting up\")\n// \t\t\t\tcurrentWinnerRec.Price = price\n// \t\t\t\tcurrentWinnerRec.Bidder = bidRec.Bidder\n// \t\t\t\tcurrentWinnerRec.HashString = bidRec.HashString\n// \t\t\t\tcurrentWinnerRec.StartTime = bidRec.StartTime\n// \t\t\t\tcurrentWinnerRec.EndCommitTime = bidRec.EndCommitTime\n// \t\t\t\tcurrentWinnerRec.EndPriceTime = bidRec.EndPriceTime\n// \t\t\t\twinnerRec.Set(domainName, currentWinnerRec)\n// \t\t\t\tufmt.Println(\"[PRICE] current winner set to: \", currentWinnerRec.Bidder)\n// \t\t\t\tbidRec.IsCommittedPrice = true\n// \t\t\t\t// set new bidRecord into bidRecList and save into storage\n// \t\t\t\tbidRecList[index] = bidRec\n// \t\t\t\tbidStorage.Set(domainName, bidRecList)\n// \t\t\t\treturn \"claim\"\n// \t\t\t}\n// \t\t}\n// \t}\n// \t// if not match above case, then panic\n// \tpanic(\"commit price failed\")\n// }\n\n// // GetCurrentWinner shows the current highest price user\n// func GetCurrentWinner(domainName string) bidRecord {\n// \tdata, existed := winnerRec.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"no winner yet\")\n// \t}\n// \treturn data.(bidRecord)\n// }\n\n// // find the highest bid in session - incase everyone commited price\n// // in old flow, we need to find the winner by retrievaling the bidStorage\n// func findTheWinner(domainName string) bidRecord {\n// \tvar winnerBid bidRecord\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"invalid domain name\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \twinnerBid = bidRecList[0]\n// \tfor _, bidRec := range bidRecList {\n// \t\tif bidRec.Price \u003e winnerBid.Price {\n// \t\t\twinnerBid = bidRec\n// \t\t}\n// \t}\n// \treturn winnerBid\n// }\n\n// // register the domain for winner\n// func registerForWinner(domainName string, winnerRec bidRecord) bool {\n// \twinnerAddr := winnerRec.Bidder\n// \trequestInfo := RequestInfo{\n// \t\tWantedDomain: domainName,\n// \t\tCaller:       winnerAddr,\n// \t\tMode:         \"native\",\n// \t}\n// \tresult := executeRegister(requestInfo)\n// \tif !result.Success {\n// \t\tpanic(result.ResultDetails.Error())\n// \t}\n// \t// register done. Now charge the fee\n// \tfeeProcess(requestInfo)\n// \treturn false\n// }\n\n// // everyone can call EndBid()\n// // this EndBid checks endTime -\u003e end the auction\n// func EndBid(domainName string) error {\n// \tnow := time.Now().UnixMilli()\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\treturn ufmt.Errorf(\"endbid: invalid domain name\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \tfirstBidRec := bidRecList[0]\n// \tif now \u003c firstBidRec.EndPriceTime {\n// \t\treturn ufmt.Errorf(\"endbid: this session can not end before the end time\")\n// \t}\n// \t// change all state\n// \t// for _, bidRec := range bidRecList {\n// \t// \tbidRec.IsOpen = false\n// \t// }\n// \tok := bidStorage.Set(domainName, bidRecList)\n// \tif !ok {\n// \t\treturn ufmt.Errorf(\"endbid: can not change bid record state\")\n// \t}\n// \t// need more conditions for findTheWinner()\n// \tfindTheWinner(domainName)\n// \treturn nil\n// }\n\n// // get all the price list that joined the bid for displaying in dapp\n// func GetRecords(dName string) []bidRecord {\n// \tdata, existed := bidStorage.Get(dName)\n// \tif !existed {\n// \t\tpanic(\"should not\")\n// \t}\n// \treturn data.([]bidRecord)\n// }\n\n// // chargeFee will charge amount - send from this contract to admin\n// func chargeFee(amount int64, from std.Address) {\n// \tbankerContract := std.CurrentRealm().Addr()\n// \tugnotCoin := std.NewCoin(\"ugnot\", amount)\n// \tcoinsToTransfer := std.NewCoins(ugnotCoin)\n// \tcoins := checkCoin(from)\n// \tufmt.Println(\"check balances: \", coins)\n// \t// ufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n// \tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n// }\n\n// // pay fee and claim the domain name if you are winner\n// func Claim(domainName string) bool {\n// \tdata, existed := winnerRec.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"claim: invalid domain name\")\n// \t}\n// \tcaller := std.GetOrigCaller()\n// \trec := data.(bidRecord)\n// \tif caller != rec.Bidder {\n// \t\tpanic(\"only winner can claim\")\n// \t}\n// \trequestInfo := RequestInfo{\n// \t\tWantedDomain: domainName,\n// \t\tCaller:       rec.Bidder,\n// \t\tMode:         \"native\",\n// \t}\n// \tresult := executeRegister(requestInfo)\n// \tif !result.Success {\n// \t\tpanic(result.ResultDetails.Error())\n// \t}\n// \t// register done. Now charge the fee\n// \tchargeFee(rec.Price, caller)\n// \tfeeProcess(requestInfo)\n// \treturn true\n// }\n\n// // expose winner price - amount of fee that user need to pay in Claim phase\n// func GetWinnerPrice(dName string) int64 {\n// \trec := GetCurrentWinner(dName)\n// \treturn rec.Price\n// }"},{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n\tBidJoinFee          int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\n// Admin set register fee and renewal fee\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tcaller := std.GetOrigCaller()\n\tcoins := checkCoin(caller)\n\tufmt.Println(\"check: \", coins)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(3)\n\terr := ufmt.Sprintf(\"unauthorize with caller: %s\\n\", caller)\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(err)\n\t}\n}\n\n// checking for availble coins\nfunc checkCoin(from std.Address) std.Coins {\n\t// caller := std.GetOrigCaller()\n\treturn bankerUser.GetCoins(from)\n}\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"hashstring.gno","body":"package registrar\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n)\n\nfunc Get256String(input string) string {\n\tdata := []byte(input)\n\thashed := sha256.Sum256(data)\n\thashedBytes := hashed[:]\n\treturn hex.EncodeToString(hashedBytes)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo/v403/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n\tMessage       string\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v403/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\t// bidStorage = avl.NewTree()\n\t// winnerRec = avl.NewTree()\n\t// joinedBid = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     100,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t\tBidJoinFee:          100,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n// changelogs 2: v2 - added sealed bidding logic - with default time xxx mins for each session\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v403/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\t// changelogs v2: we are using sealed bidding now\n\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := metadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"time\"\n)\n\nvar (\n\tdefaultCommitHashTime  = time.Second * 30\n\tdefaultCommitPriceTime = time.Second * 30\n\tdefaultExpireTime      = time.Hour // 30 days\n\treName                 = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tassertIsAdmin()\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n\nfunc SetCommitPhaseTime(duration int) {\n\tdefaultCommitHashTime = time.Duration(duration) * time.Second\n}\n\nfunc SetCommitPriceTime(duration int) {\n\tdefaultCommitPriceTime = time.Duration(duration) * time.Second\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"rrBLmopLgoB2PqiR5XygtkqH3Tt4wWPD7j+3RVdcRgY8stnpkJCkBec8mNvIma6P73Kh1vtkuKUDyJUf59Z79g=="}],"memo":""},"blockNum":"1980710"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"resolver","path":"gno.land/r/varmeta/demo/v403/domain/resolver","files":[{"name":"checks_resolver.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage resolver\n\nimport (\n\t\"regexp\"\n\t\"time\"\n\n\t\"gno.land/r/varmeta/demo/v403/domain/registrar\"\n)\n\n// const (\n// \tadmin std.Address = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\" // -\u003e @thinhnx\n// )\n\nvar reName = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc isExpired(dName string) bool {\n\texpDate := registrar.GetExpirationDate(dName)\n\treturn expDate.Before(time.Now())\n}\n"},{"name":"errors.gno","body":"package resolver\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrNotFound          = errors.New(\"not found\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"invalid domain name to register\")\n)\n"},{"name":"resolver.gno","body":"/*\nThe goal of the Resolver contract is keep track of the address for each ICNS name in a stateful manner.\nIt serves the purpose of \"resolving\" the ICNS Name\nto the correct address (e.g \"alice.gno\" -\u003e g1xxx).\n*/\n// changelogs: move Register feature into this resolver package\n// changelogs2: Removed local storage of resolver as cache, and every querires we query to registrar to get the result\n\npackage resolver\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/varmeta/demo/v403/domain/registrar\"\n)\n\ntype Record struct {\n\tOwner    std.Address\n\tIsValid  bool\n\tMemo     string // no more need this\n\tPriority int\n}\n\n// retrieve the record list to get the onchain address\nfunc Resolve(domainName string) *Record {\n\tif !isValidDomain(domainName) {\n\t\tpanic(\"bad domain name\")\n\t}\n\trecord := \u0026Record{}\n\n\towner := getOwnerFromDomainStorage(domainName)\n\tif owner == \"\" {\n\t\trecord.Memo = \"not found\"\n\t\trecord.IsValid = false\n\t\treturn record\n\t}\n\n\tif !isExpired(domainName) {\n\t\trecord.IsValid = true\n\t\trecord.Owner = owner\n\t} else {\n\t\trecord.IsValid = false\n\t}\n\treturn record\n}\n\nfunc GetDomainName(addr string) []string {\n\treturn registrar.GetDomainName(addr)\n}\n\n/*\nIf query in local storage not found\nQuery to DomainStorage by domainName -\u003e get the registry -\u003e use that registry to get the Owner()\nand check the validation time?\n*/\n\nfunc existedInDomainStorage(domainName string) bool {\n\treturn registrar.AlreadyRegistered(domainName)\n}\n\nfunc getOwnerFromDomainStorage(domainName string) std.Address {\n\treturn registrar.GetOwner(domainName)\n}\n"},{"name":"resolver_metadata.gno","body":"package resolver\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v403/domain\"\n)\n\n// Metadata wrapper\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcrrTime := time.Now()\n\texpTime := crrTime.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", crrTime, expTime, []domain.Trait{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"oHdLoevJwLjW1lGQmr5DDCYDNeY53W5Zwp/XDcUMtlVhQSxMVeCi4Tns10e+X23aPDnq6aqJ5o86al+tcG8FEA=="}],"memo":""},"blockNum":"1980717"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitHash","args":["thinhnx.gno","0f20b9ec70116a97c44395b05a224d87eb7240350eedd860448cfaa78d2587d7"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"QkTjwZKICaMC9nYs8dPKdW9EbotkLnmZUvAJxHgVDoxbsZNcPLvhekKtfzdsbQfMoomgk6TC79AH5HFKLtdj2w=="}],"memo":""},"blockNum":"1980740"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitPrice","args":["10","thinh","thinhnx.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"21Q6VOpBBEOR1hUhiedArAk0Xa4qQd1YxApVzOdj6l5u+U2OurOLFdv3e5Nb6jaLkh7ZfhGe/fd03mjls06jqg=="}],"memo":""},"blockNum":"1980761"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitPrice","args":["10","thinh","thinhnx.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"nvPivKtDh3uBWCKQBikVvxFZFQW3PNwoF7IJTPzvhowr0V+b7M3wengHTkvQ37QNg+hlBHzR6qa5hYp2kX2CzA=="}],"memo":""},"blockNum":"1980775"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"Claim","args":["thinhnx.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"kyQvNXMXf1SnKEatxzpAJI416G3cGwl8U27VqFsidOAAPx7zQ1l+hs4y6E5HXeTfZIXSOdeh20Bpw9qKJVQNXA=="}],"memo":""},"blockNum":"1980799"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"Claim","args":["thinhnx.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"IoMt45Mm2ze/ATo2CrMRUtZJvNmHZFWQkoq39E96XkYa7PF3VKLPv6EQ/S9amZpCnuCFUV5in3yzASiAz7T2/Q=="}],"memo":""},"blockNum":"1980808"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"Claim","args":["thinhnx.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"oPi3f0S8hUzJWkUD63sMDDSgbdxXoxiobcHp+ClJVj4zzo5QThyqkkfKaf7/h6+PHgYtN9e6u9sHMcE3P5ayRA=="}],"memo":""},"blockNum":"1980819"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"10000ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"Claim","args":["thinhnx.gno"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"nADjedW18HCb7x/0O5HqHL1yn9gPauUXkakZCotx9vRbfosjyc0F7G9SuMKqOs4AfjH/M4N1k5FdL+S+gbFXjA=="}],"memo":""},"blockNum":"1980888"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitHash","args":["ngoc.gno","ea56fa8022639bfbf045c8d9cd37068cef58dd4669e61c913d1ab4dfe417d213"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"fOzRemJ3pF+DdVyR4BKOK9ZwHtu6VpP8B414qwtQPpVHf7kPuLXMd1QaWH+hgDye+CHnPYOoDvKgVy2WMPyqxw=="}],"memo":""},"blockNum":"1980970"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitPrice","args":["1","ngoc","ngoc.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"3l3FUBFXWmq6zznA+QenfrwhFcTSjP4pzB95h6wA60gbABounttYuricOoYjYavwxFxHCXQfHPLbr5nVqP8HiQ=="}],"memo":""},"blockNum":"1980995"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitHash","args":["testthinh.gno","1b4f0e9851971998e732078544c96b36c3d01cedf7caa332359d6f1d83567014"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"9zLbk7jMaRUBnzlCfPKpB33CusZfsBYhOnDbkI4iizlH2xnJRkHTS40xQMVg+mpYim9O9dDafza/id42Y4veQA=="}],"memo":""},"blockNum":"1981055"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitPrice","args":["10","test","testthinh.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"OD6UoCv2SmsTEbq7hevSZe0SIJZqLr0QtvyppULGkYs1XtFfpJa+IlblQ+JdwN6C2iXo0BwFqnkvcBimDcP3hQ=="}],"memo":""},"blockNum":"1981079"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitHash","args":["ngoc3.gno","d2b17a191bdd828a6f1ca6fe8757dd4c6b95b653307bb148aa665a8c3ab24ffa"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"CR3C7sJ+wM66nF5UxLq7UgIyLcHeY5CicL7h9x/M4WoAe6xnCbUQ2IHvxw3EBzO3mh5TDSeL52OfHVxIbge9Jw=="}],"memo":""},"blockNum":"1981132"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitPrice","args":["100","ngoc","ngoc3.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"d+0hIR2/1JDCqrNU5RU8u1hTM9A/KdiPEv82mu0M47ZxKZqVwZdSFeXp5wMHBDF0fCbUsiHFuWhOP7P2mMwEiA=="}],"memo":""},"blockNum":"1981153"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"Claim","args":["ngoc3.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"nGyKG3GcJzehOmOFtoHG0ZAOOS1vFenK2U3IKBWZfmppU0/I9uHXpnMSXdZpsPtkWdPwu3U5zPPt1WrQMkByCw=="}],"memo":""},"blockNum":"1981168"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v402/domain/registrar","func":"GetJoinedBid","args":["g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"1A/GTzslMVub2EhN+AhEF2FmFXWYWvE/37RTrZAVvSovdXOCcEU3gLKMe6P8STZCtAm71KXckDExUf9Xldt2AQ=="}],"memo":""},"blockNum":"1981210"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"GetJoinedBid","args":["g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"tSwAw9g6nB+bpD/MEYPsmBUkB+ubwbIdKd79HjNoZ1B7P/EQqScNO4trLLggg/9QKP9r+WKvGOi+jRWhERTC8A=="}],"memo":""},"blockNum":"1981215"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"GetCurrentStatus","args":["thinhnx.gno","g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"vncDq6uXnpKlYAt5I8pAwGYItJFzG/qL8eSw8pNslpdm5c8F3+qFXtXg9IcPCXZr3xJuK0wCIoKpEbnIfQZm8w=="}],"memo":""},"blockNum":"1981229"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"GetJoinedBid","args":["g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"NE3m/sCYjCzt0Q7LPdjEsJHLm3P0FwVbQDqYIbvvYeMh6kS0X7tHkveIBp3kn2enNpOdhqGR93JosVqx6q4bKw=="}],"memo":""},"blockNum":"1981235"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"GetCurrentStatus","args":["testthinh.gno","g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"fbw5tM4pXWJ1txFhIBe/kraM9Eggm0AdEdpxWcOosbIAhW0Il/FOyCaW3RmU1GIsYnxexO/HvP7Z9haMzfuQfw=="}],"memo":""},"blockNum":"1981247"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"Get","args":["testthinh.gno"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"IN2Vwp4Gsaij4e5x/KoOtN6+dZyPFrtQH2q09tgv/UlNlaXDmDSTEupNow+EHEenCKnpG/FJ8AqRSDnuvRfSjw=="}],"memo":""},"blockNum":"1981290"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitPrice","args":["10","test","testthinh.gno"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"2SdOS4nmoLLVxBWZCTnO2YxS9DS0kizwD2zelKW0y8kRO48nQ79hqBzvxlAYS4eNbprJzoq4prXOsIXP8Tennw=="}],"memo":""},"blockNum":"1981331"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"GetCurrentStatus","args":["testthinh.gno","g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"fTN8CJawOLA2Z2WMKn9hFk1f8ps4TQ52TrDZEck5qWM7oADK9DSEzgIEWgloFp+ffAOkWBMVwEgnpiWrA6USSw=="}],"memo":""},"blockNum":"1981339"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitHash","args":["thinhnx1.gno","abf6b6dd7af43c462b66d1472bdbbb8e784bf8d357212f9bd7f340023cfc19b1"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"WQVJ5EIH9iOEOm4WXq+Hoe0vsOx77bi28vYszZ2Kdv9lbNN9lJ4stYbdfKVKJknU16kal3+FJds0JYgLBpC4zw=="}],"memo":""},"blockNum":"1981476"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"CommitPrice","args":["1","thinhnx1","thinhnx1.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"3tVTvLeMOdu6wW4Nt+TDvxSCWS0tjcqrHNU4ORNO4LpnLt65jiew/e9p3UbkY3dQtKJuDwtSm8eMooNqwXQDIQ=="}],"memo":""},"blockNum":"1981494"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"10000ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"Claim","args":["thinhnx1.gno"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"QgfATFrb12yogC03IZ13uyB1HXDSD+OR1mcpwskP8U0TeApnbm1CBzKbjGfjb+Uf05JMwoVkGorWxp1xIbfaSw=="}],"memo":""},"blockNum":"1981548"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v403/domain/registrar","func":"Get","args":["testthinh.gno"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"4C65QuzhSCzWENr8CTh9IWEVkWcaT8zlCJRRYLpFUQ8kJbSotc4qZkWsz22BvXaegYBBOfKplnqR4Z0fKTmMSw=="}],"memo":""},"blockNum":"1981608"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo/v404/grc/grc721","files":[{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"p/qBRQehAAec83P6FGyuFZYN5v482EqCGYhg6y7pIYkwgMfvMA2DO7ISsVeZI7PVzTJWpYeI8iGQ/OHqH0sCvA=="}],"memo":""},"blockNum":"1981719"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"domain","path":"gno.land/p/varmeta/demo/v404/domain","files":[{"name":"domain_metadata.gno","body":"package domain\n\nimport (\n\t\"time\"\n)\n\n// Trait represents a key-value pair with an optional display type for metadata attributes\ntype Trait struct {\n\tDisplayType string // Optional display type (e.g., \"date\", \"number\", etc.)\n\tTraitType   string // Type of the trait (e.g., \"age\", \"height\", etc.)\n\tValue       string // Value of the trait\n}\n\n// Metadata represents the metadata associated with a domain\ntype Metadata struct {\n\tAvatar           string    // URL or identifier for an avatar image\n\tRegistrationTime time.Time // The time when the domain was registered\n\tExpirationTime   time.Time // The time when the domain will be expire\n\tAttributes       []Trait   // Additional attributes of the domain\n\tDescription      string    // A description of the domain\n\tContactInfo      string    // Contact information for the domain owner\n\tRenewalFee       string    // The fee required to renew the domain, represented as a string\n}\n\n// NewMetadata creates a new Metadata instance\nfunc NewMetadata(avatar, description, contactInfo, renewalFee string,\n\tregistrationTime, expirationTime time.Time, attributes []Trait,\n) Metadata {\n\treturn Metadata{\n\t\tAvatar:           avatar,\n\t\tRegistrationTime: registrationTime,\n\t\tExpirationTime:   expirationTime,\n\t\tRenewalFee:       renewalFee,\n\t\tAttributes:       attributes,\n\t\tDescription:      description,\n\t\tContactInfo:      contactInfo,\n\t}\n}\n"},{"name":"domain_registry.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v404/grc/grc721\"\n)\n\n// domainRegistry represents a registry for domain names with metadata\ntype domainRegistry struct {\n\tdomains  grc721.IGRC721 // Interface for basic NFT functionality\n\tmetadata *avl.Tree      // AVL tree for storing domain metadata\n\texpDate  time.Time\n}\n\n// DomainRegistry defines the methods for managing domain names and metadata\ntype DomainRegistry interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(domainName string) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, domainName string) error\n\tTransferFrom(from, to std.Address, domainName string) error\n\tApprove(approved std.Address, domainName string) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(domainName string) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, domainName string) error\n\n\tRegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error\n\tSetDomainData(domainName string, metadata Metadata) error\n\tGetDomainData(domainName string, field MetadataField) (Metadata, error)\n\tGetDomainFields(domainName string, fields []MetadataField) (Metadata, error)\n\tRenewDomain(domainName string, additionalDuration time.Duration) error\n\tGetExpirationDate(domainName string) time.Time\n\tSetExpirationDate(domainName string, expDate time.Time) bool\n}\n\n// NewDomainRegistry creates a new domain registry with metadata extensions\nfunc NewDomainRegistry(name, symbol string) *domainRegistry {\n\tregistry := grc721.NewBasicNFT(name, symbol)\n\n\treturn \u0026domainRegistry{\n\t\tdomains:  registry,\n\t\tmetadata: avl.NewTree(),\n\t}\n}\n\n// RegisterDomain registers a new domain with the given metadata\nfunc (d *domainRegistry) RegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error {\n\terr := d.domains.Mint(owner, grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\td.expDate = time.Now().Add(dur)\n\td.metadata.Set(domainName, metadata)\n\n\treturn nil\n}\n\n// RenewDomain extends the expiration time of a domain name\nfunc (d *domainRegistry) RenewDomain(domainName string, additionalDuration time.Duration) error {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn ErrInvalidDomainName\n\t}\n\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\t// set new expiration date\n\td.expDate = d.expDate.Add(additionalDuration)\n\treturn nil\n}\n\n// SetDomainData sets the metadata for a given domain name\nfunc (d *domainRegistry) SetDomainData(domainName string, metadata Metadata) error {\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\td.metadata.Set(domainName, metadata)\n\treturn nil\n}\n\n// GetDomainFields retrieves multiple fields of metadata for a given domain\nfunc (d *domainRegistry) GetDomainFields(domainName string, fields []MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tif len(fields) == 0 {\n\t\treturn metadata, nil\n\t}\n\n\tvar result Metadata\n\tfor _, field := range fields {\n\t\tswitch field {\n\t\tcase FieldAvatar:\n\t\t\tresult.Avatar = metadata.Avatar\n\t\tcase FieldRegistrationTime:\n\t\t\tresult.RegistrationTime = metadata.RegistrationTime\n\t\tcase FieldExpirationTime:\n\t\t\tresult.ExpirationTime = metadata.ExpirationTime\n\t\tcase FieldRenewalFee:\n\t\t\tresult.RenewalFee = metadata.RenewalFee\n\t\tcase FieldAttributes:\n\t\t\tresult.Attributes = metadata.Attributes\n\t\tcase FieldDescription:\n\t\t\tresult.Description = metadata.Description\n\t\tcase FieldContactInfo:\n\t\t\tresult.ContactInfo = metadata.ContactInfo\n\t\tdefault:\n\t\t\treturn Metadata{}, ErrInvalidMetadataField\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// GetDomainData retrieves metadata for a given domain\nfunc (d *domainRegistry) GetDomainData(domainName string, field MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tswitch field {\n\tcase FieldAvatar:\n\t\treturn Metadata{\n\t\t\tAvatar: metadata.Avatar,\n\t\t}, nil\n\tcase FieldRegistrationTime:\n\t\treturn Metadata{\n\t\t\tRegistrationTime: metadata.RegistrationTime,\n\t\t}, nil\n\tcase FieldExpirationTime:\n\t\treturn Metadata{\n\t\t\tExpirationTime: metadata.ExpirationTime,\n\t\t}, nil\n\tcase FieldRenewalFee:\n\t\treturn Metadata{\n\t\t\tRenewalFee: metadata.RenewalFee,\n\t\t}, nil\n\tcase FieldAttributes:\n\t\treturn Metadata{\n\t\t\tAttributes: metadata.Attributes,\n\t\t}, nil\n\tcase FieldDescription:\n\t\treturn Metadata{\n\t\t\tDescription: metadata.Description,\n\t\t}, nil\n\tcase FieldContactInfo:\n\t\treturn Metadata{\n\t\t\tContactInfo: metadata.ContactInfo,\n\t\t}, nil\n\tdefault:\n\t\treturn Metadata{}, ErrInvalidMetadataField\n\t}\n}\n\n// BalanceOf returns the number of domains owned by a given address\nfunc (d *domainRegistry) BalanceOf(owner std.Address) (uint64, error) {\n\treturn d.domains.BalanceOf(owner)\n}\n\n// OwnerOf returns the owner of a given domain name\nfunc (d *domainRegistry) OwnerOf(domainName string) (std.Address, error) {\n\treturn d.domains.OwnerOf(grc721.TokenID(domainName))\n}\n\n// SafeTransferFrom safely transfers a domain from one address to another\nfunc (d *domainRegistry) SafeTransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.SafeTransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// TransferFrom transfers a domain from one address to another\nfunc (d *domainRegistry) TransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.TransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// Approve grants approval to another address to manage a specific domain\nfunc (d *domainRegistry) Approve(approved std.Address, domainName string) error {\n\treturn d.domains.Approve(approved, grc721.TokenID(domainName))\n}\n\n// SetApprovalForAll sets approval for an operator to manage all domains of the owner\nfunc (d *domainRegistry) SetApprovalForAll(operator std.Address, approved bool) error {\n\treturn d.domains.SetApprovalForAll(operator, approved)\n}\n\n// GetApproved returns the approved address for a specific domain\nfunc (d *domainRegistry) GetApproved(domainName string) (std.Address, error) {\n\treturn d.domains.GetApproved(grc721.TokenID(domainName))\n}\n\n// IsApprovedForAll checks if an operator is approved to manage all domains of the owner\nfunc (d *domainRegistry) IsApprovedForAll(owner, operator std.Address) bool {\n\treturn d.domains.IsApprovedForAll(owner, operator)\n}\n\n// Mint creates a new domain for a given address\nfunc (d *domainRegistry) Mint(to std.Address, domainName string) error {\n\treturn d.domains.Mint(to, grc721.TokenID(domainName))\n}\n\nfunc (d *domainRegistry) GetExpirationDate(domainName string) time.Time {\n\treturn d.expDate\n}\n\nfunc (d *domainRegistry) SetExpirationDate(domainName string, expDate time.Time) bool {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn false\n\t}\n\td.expDate = expDate\n\treturn true\n}\n"},{"name":"domain_registry_test.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/urequire\"\n\t\"gno.land/p/varmeta/demo/v404/grc/grc721\"\n)\n\nvar (\n\taddr1 = testutils.TestAddress(\"bob\")\n\taddr2 = testutils.TestAddress(\"alice\")\n)\n\nfunc TestRegisterDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Successful Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"contact@registered.com\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Duplicate Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\terr := registry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.owner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr1,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr2,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\t\t\terr := registry.SetDomainData(c.domainName, c.metadata)\n\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\tretrievedMetadata, err := registry.GetDomainData(c.domainName, FieldAvatar)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.metadata.Avatar, retrievedMetadata.Avatar)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRenewDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname           string\n\t\towner          std.Address\n\t\tcaller         std.Address\n\t\tdomainName     string\n\t\tadditionalTime time.Duration\n\t\texpectError    bool\n\t\texpectedExpiry time.Time\n\t}{\n\t\t{\n\t\t\tname:           \"Successful Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr1,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"Non-Owner Attempts Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr2,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A renewable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.RenewDomain(c.domainName, c.additionalTime)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\trenewedMetadata, err := registry.GetDomainData(c.domainName, FieldExpirationTime)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\t// urequire.True(t, renewedMetadata.ExpirationTime.After(metadata.ExpirationTime))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfield       MetadataField\n\t\texpectError bool\n\t\texpectedVal string\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Avatar\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: false,\n\t\t\texpectedVal: \"avatar_url\",\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain Name\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t_, err := registry.GetDomainData(c.domainName, c.field)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainFields(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfields      []MetadataField\n\t\texpectError bool\n\t\texpected    Metadata\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Multiple Fields\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar, FieldDescription, FieldContactInfo},\n\t\t\texpectError: false,\n\t\t\texpected: Metadata{\n\t\t\t\tAvatar:      \"avatar_url\",\n\t\t\t\tDescription: \"A test domain\",\n\t\t\t\tContactInfo: \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tretrievedMetadata, err := registry.GetDomainFields(c.domainName, c.fields)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.expected.Avatar, retrievedMetadata.Avatar)\n\t\t\t\turequire.Equal(t, c.expected.Description, retrievedMetadata.Description)\n\t\t\t\turequire.Equal(t, c.expected.ContactInfo, retrievedMetadata.ContactInfo)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTransferDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tnewOwner    std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"Successful Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr1,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Non-Owner Attempts Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr2,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A transferable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.TransferFrom(c.owner, c.newOwner, c.domainName)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), grc721.ErrTransferFromIncorrectOwner.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.newOwner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"errors.gno","body":"package domain\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnauthorized         = errors.New(\"caller is not domain owner\")\n\tErrInvalidDomainName    = errors.New(\"invalid domain name\")\n\tErrInvalidMetadataField = errors.New(\"invalid metadata field\")\n\tErrInsufficientFunds    = errors.New(\"insufficient funds for renewal\")\n)\n"},{"name":"utils.gno","body":"package domain\n\ntype MetadataField int\n\nconst (\n\tFieldAvatar MetadataField = iota\n\tFieldRegistrationTime\n\tFieldRenewalFee\n\tFieldExpirationTime\n\tFieldAttributes\n\tFieldDescription\n\tFieldContactInfo\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"6000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"HxEybDU2uSncq98vhO2vQLRaianZInUlPrQm1OiF/jFzFgOfFsnpaMVPxjp6KvXuWYY32zM+HD6aWF3AEHQ+Pw=="}],"memo":""},"blockNum":"1981728"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo/v404/domain/registrar","files":[{"name":"bidding.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t// \"gno.land/p/demo/mux\"\n\t\"gno.land/p/demo/avl\"\n)\n\n// I want to redesign this codebase\n\n// all keys are domainName\nvar bidStorages avl.Tree // dName \u003c=- []bidRecV2\n\n// record new joined bid\nfunc record2Storage(domainName string) {\n\tcaller := std.GetOrigCaller()\n\tnow := time.Now().UnixMilli()\n\tnewRec := bidRecV2{\n\t\tBidder:     caller.String(),\n\t\tDomainName: domainName,\n\t\tStartTime:  now,\n\t\t//...\n\t}\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tbidStorages.Set(domainName, newRec)\n\t}\n\tbidRecList := data.([]bidRecV2)\n\toldStartTime := bidRecList[0].StartTime\n\tnewRec.StartTime = oldStartTime\n\tbidRecList = append(bidRecList, newRec)\n\tbidStorages.Set(domainName, bidRecList)\n}\n\n// GetJoinedBid returns the status of an user's joined bid session information\nfunc GetJoinedBid(caller string) []bidStatus {\n\tdNameList := []string{}\n\t// Iterate the bidStorages, which domainName has Bidder == caller -\u003e take domainNames\n\tbidStorages.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tdataList := value.([]bidRecV2)\n\t\tfor _, rec := range dataList {\n\t\t\tif rec.Bidder == caller {\n\t\t\t\tufmt.Println(\"key to append: \", key)\n\t\t\t\tdNameList = append(dNameList, key)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n\tufmt.Println(\"len: \", len(dNameList))\n\t// after get dNameList of a caller, we check status of each dName\n\tlistStatus := []bidStatus{}\n\tfor _, dName := range dNameList {\n\t\tstt := GetCurrentStatus(dName, caller)\n\t\t// get the time stamp in [0] element and assign it to status\n\t\tdata, _ := bidStorages.Get(dName)\n\t\tbidRec := data.([]bidRecV2)[0]\n\n\t\tsingleStt := bidStatus{\n\t\t\tDomainName:    dName,\n\t\t\tStatus:        stt,\n\t\t\tEndCommitTime: bidRec.EndCommitTime,\n\t\t\tEndPriceTime:  bidRec.EndPriceTime,\n\t\t}\n\t\tlistStatus = append(listStatus, singleStt)\n\t}\n\tufmt.Println(\"len of list status: \", len(listStatus))\n\treturn listStatus\n}\n\nfunc Get(domainName string) ([]string, []string, []int64) {\n\tdata, _ := bidStorages.Get(domainName)\n\tlist := data.([]bidRecV2)\n\tdNameList := []string{}\n\thashList := []string{}\n\tpList := []int64{}\n\tfor _, rec := range list {\n\t\tdNameList = append(dNameList, rec.Bidder)\n\t\thashList = append(hashList, rec.HashString)\n\t\tpList = append(pList, rec.Price)\n\t}\n\treturn dNameList, hashList, pList\n}\n\n/*\n\tI want the CommitHash and CommitPrice will change the status of the record, by this way, we can detect\n\tthe current state of a bidding session for each user\n*/\n\n// GetCurrentStatus returns the status of the bidding session about a domain name. This func requires caller to determine in case Committed or not (hash or price)\nfunc GetCurrentStatus(domainName string, caller string) string {\n\t// if there is record in joinedBid -\u003e user joined\n\t// check for tine.Now() and startTime\n\tnow := time.Now().UnixMilli()\n\t// if domain name is owned already\n\towner := GetOwner(domainName)\n\tif owner != \"\" {\n\t\treturn \"owned by \" + owner.String()\n\t}\n\t// find the record\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\t// no record in bidRec yet -\u003e not Committed -\u003e check if user started auction or not - if yes: new auction\n\t\treturn \"domain name is free\"\n\t}\n\trecList := data.([]bidRecV2)\n\trec0 := recList[0]\n\t// Auction closed with winner\n\tif rec0.EndPriceTime \u003c= now \u0026\u0026 owner != \"\" {\n\t\treturn \"close\"\n\t}\n\t// find the record of the caller\n\tfor _, rec := range recList {\n\t\tswitch {\n\t\t// Waiting for hash commitment\n\t\tcase !rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.StartTime \u003c= now \u0026\u0026 rec.EndCommitTime \u003e now:\n\t\t\treturn \"waiting hash\"\n\n\t\t// Committed hash\n\t\tcase rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.StartTime \u003c= now \u0026\u0026 rec.EndCommitTime \u003e now:\n\t\t\treturn \"committed hash\"\n\n\t\t// Waiting for price commitment\n\t\tcase rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.EndCommitTime \u003c= now \u0026\u0026 rec.EndPriceTime \u003e now:\n\t\t\treturn \"waiting price\"\n\n\t\t// Committed price\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 rec.EndCommitTime \u003c= now \u0026\u0026 rec.EndPriceTime \u003e now:\n\t\t\treturn \"committed price\"\n\n\t\t// Winner claiming domain\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 rec.IsWinner \u0026\u0026 rec.EndPriceTime \u003c= now:\n\t\t\treturn rec.Bidder + \" is claiming domain name: \" + domainName\n\t\t// find the winner\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 !rec.IsWinner \u0026\u0026 rec.EndPriceTime \u003c= now:\n\t\t\t_, winnerRec := findTheWinner(domainName)\n\t\t\treturn winnerRec.Bidder + \" is claiming domain name: \" + domainName\n\t\t// Missed hash commitment deadline\n\t\tcase !rec.IsCommittedHash \u0026\u0026 rec.EndCommitTime \u003c= now:\n\t\t\treturn \"waiting for hash\"\n\t\t}\n\t}\n\n\treturn \"undefined\"\n}\n\n// CommitHash consumes off-chain calculated hash string and the domain name that user want\nfunc CommitHash(domainName, hashString string) string {\n\tcaller := std.GetOrigCaller()\n\n\t// use now as int64 representation of time.Now()\n\tnow := time.Now().UnixMilli()\n\n\t// update the bid record\n\tdata, existed := bidStorages.Get(domainName)\n\n\t// if not existed -\u003e create new record\n\tif !existed {\n\t\t// for further getStatus\n\t\t// record2Storage(domainName)\n\n\t\tvar bidRec bidRecV2\n\t\tendCommitTime := now + defaultCommitHashTime.Milliseconds()\n\t\tendPriceTime := endCommitTime + defaultCommitPriceTime.Milliseconds()\n\t\tufmt.Println(\"[HASH]: request at: \", time.UnixMilli(now))\n\t\tufmt.Println(\"[HASH]: endCommitTime: \", time.UnixMilli(endCommitTime))\n\t\tufmt.Println(\"[HASH]: endPriceTime: \", time.UnixMilli(endPriceTime))\n\t\tbidRec = bidRecV2{\n\t\t\tDomainName:       domainName,\n\t\t\tBidder:           caller.String(),\n\t\t\tHashString:       hashString,\n\t\t\tStartTime:        now,\n\t\t\tEndCommitTime:    endCommitTime,\n\t\t\tEndPriceTime:     endPriceTime,\n\t\t\tIsCommittedHash:  true,\n\t\t\tIsCommittedPrice: false,\n\t\t\tIsWinner:         true,\n\t\t\tPrice:            0,\n\t\t}\n\t\tbidNewRec := []bidRecV2{bidRec}\n\t\tbidStorages.Set(domainName, bidNewRec)\n\n\t\t// charge fee\n\t\tchargeFee(fee.BidJoinFee, std.Address(caller))\n\t\treturn \"new session\"\n\t}\n\t// if existed\n\tbidRecList := data.([]bidRecV2)\n\tstartTime := bidRecList[0].StartTime\n\toldEndCommitTimeUnix := bidRecList[0].EndCommitTime\n\toldEndPriceTimeUnix := bidRecList[0].EndPriceTime\n\tif now \u003e oldEndCommitTimeUnix {\n\t\t// now := time.Now().UnixMilli()\n\t\t// ufmt.Println(\"[HASH]: now: \", time.UnixMilli(now))\n\t\tpanic(\"[HASH]: can not commit hash anymore\")\n\t}\n\tfor _, bR := range bidRecList {\n\t\tif bR.Bidder == caller.String() {\n\t\t\tpanic(\"[HASH]: you already committed hash\")\n\t\t}\n\t}\n\n\tnewRec := bidRecV2{\n\t\tDomainName:       domainName,\n\t\tHashString:       hashString,\n\t\tBidder:           caller.String(),\n\t\tStartTime:        startTime,\n\t\tEndCommitTime:    oldEndCommitTimeUnix,\n\t\tEndPriceTime:     oldEndPriceTimeUnix,\n\t\tIsCommittedHash:  true,\n\t\tIsCommittedPrice: false,\n\t\tIsWinner:         false,\n\t}\n\t// append the list, set it to storage\n\tbidRecList = append(bidRecList, newRec)\n\tufmt.Println(\"len bidRecList: \", len(bidRecList))\n\t// Save record\n\tbidStorages.Set(domainName, bidRecList)\n\t// charge commit hash fee\n\tufmt.Println(\"saved hash: \", hashString)\n\tchargeFee(fee.BidJoinFee, caller)\n\treturn \"existed\"\n}\n\n// for now we dont use panic because this will cause the permanent time.Now() stuck. IDK why // XXX fix me\n// CommitPrice consumes price and secret string that user used in calculating hash string from off-chain. This will re-calculate the hashstring and compare with the one Committed before\nfunc CommitPrice(price int64, secret string, domainName string) string {\n\t// compute the hash string, compare to saved hash string in record\n\t// use int64 representation of time.Now()\n\tnow := time.Now().UnixMilli()\n\tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n\tjoinedString := secret + strconv.Itoa(int(price))\n\tcomputedHashString := Get256String(joinedString)\n\tcaller := std.GetOrigCaller()\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"[PRICE]: domain name is invalid\")\n\t}\n\tbidRecList := data.([]bidRecV2)\n\n\tufmt.Println(\"[PRICE]: endPriceTime: \", time.UnixMilli(bidRecList[0].EndPriceTime))\n\t// case commit after end - consider panic or not\n\tif now \u003e bidRecList[0].EndPriceTime {\n\t\tufmt.Println(\"[PRICE]: commit price phase is ended\")\n\t\treturn \"ended\"\n\t}\n\t// case commit when price phase not started\n\tif now \u003c= bidRecList[0].EndCommitTime {\n\t\tufmt.Println(\"[PRICE]: commit price phase is not started yet\")\n\t\treturn \"not started yet\"\n\t}\n\t// detect current winner by index and address\n\t_, currentWinnerRec := findTheWinner(domainName)\n\n\t// search for the corresponding hash\n\tfor index, rec := range bidRecList {\n\t\tufmt.Println(\"index \", index)\n\t\tufmt.Println(\"hash: \", rec.HashString)\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.IsCommittedPrice {\n\t\t\tufmt.Println(\"[PRICE] you already committed price\")\n\t\t\treturn \"committed\"\n\t\t}\n\t\t// panic because wrong price or wrong secret string\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.HashString != computedHashString {\n\t\t\tufmt.Println(\"[PRICE]: invalid hash string\")\n\t\t\treturn \"invalid hash string\"\n\t\t}\n\t\t// found it, update the price\n\t\tufmt.Println(\"checking for bid addr: \", rec.Bidder)\n\t\tufmt.Println(\"hash: \", rec.HashString)\n\t\tufmt.Println(\"caller: \", caller.String())\n\t\tufmt.Println(\"input hash: \", computedHashString)\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.HashString == computedHashString {\n\t\t\t// update record with a new list\n\t\t\t// find the winner\n\t\t\tif price \u003e currentWinnerRec.Price \u0026\u0026 now \u003c= currentWinnerRec.EndPriceTime {\n\t\t\t\t// set others status to not winner\n\t\t\t\tdata, _ := bidStorages.Get(domainName)\n\t\t\t\tcurrentList := data.([]bidRecV2)\n\t\t\t\tnewList := []bidRecV2{}\n\t\t\t\tfor _, rec := range currentList {\n\t\t\t\t\trec.IsWinner = false\n\t\t\t\t\tnewList = append(newList, rec)\n\t\t\t\t}\n\n\t\t\t\t// update winner\n\t\t\t\tufmt.Println(\"[PRICE]: found new winner, setting up\")\n\t\t\t\tnewRec := bidRecV2{\n\t\t\t\t\tDomainName:       domainName,\n\t\t\t\t\tPrice:            price,\n\t\t\t\t\tIsCommittedHash:  true,\n\t\t\t\t\tIsCommittedPrice: true,\n\t\t\t\t\tIsWinner:         true,\n\t\t\t\t\tStartTime:        currentWinnerRec.StartTime,\n\t\t\t\t\tEndCommitTime:    currentWinnerRec.EndCommitTime,\n\t\t\t\t\tEndPriceTime:     currentWinnerRec.EndPriceTime,\n\t\t\t\t\tBidder:           caller.String(),\n\t\t\t\t\tHashString:       computedHashString,\n\t\t\t\t}\n\t\t\t\t// save records\n\t\t\t\tnewList[index] = newRec\n\t\t\t\tbidStorages.Set(domainName, newList)\n\t\t\t\treturn \"claim\"\n\t\t\t}\n\t\t\t// if not the winner, update record \n\t\t\tif price \u003c= currentWinnerRec.Price \u0026\u0026 now \u003c= currentWinnerRec.EndPriceTime {\n\t\t\t\tupdatedRec := bidRecV2{\n\t\t\t\t\tDomainName:       domainName,\n\t\t\t\t\tPrice:            price,\n\t\t\t\t\tIsCommittedHash:  true,\n\t\t\t\t\tIsCommittedPrice: true,\n\t\t\t\t\tIsWinner:         false,\n\t\t\t\t\tStartTime:        rec.StartTime,\n\t\t\t\t\tEndCommitTime:    rec.EndCommitTime,\n\t\t\t\t\tEndPriceTime:     rec.EndPriceTime,\n\t\t\t\t\tBidder:           caller.String(),\n\t\t\t\t\tHashString:       computedHashString,\n\t\t\t\t}\n\t\t\t\tdata, _ := bidStorages.Get(domainName)\n\t\t\t\tcurrentList := data.([]bidRecV2)\n\t\t\t\tcurrentList[index] = updatedRec\n\t\t\t\tbidStorages.Set(domainName, currentList)\n\t\t\t\treturn \"loser\"\n\t\t\t}\n\t\t}\n\t}\n\t// if not match above case, then you are not in list\n\tpanic(\"commit price failed\")\n}\n\n// GetCurrentWinner shows the current highest price user\nfunc GetCurrentWinner(domainName string) bidRecV2 {\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"no winner yet\")\n\t}\n\tlist := data.([]bidRecV2)\n\tfor _, bidRec := range list {\n\t\tif bidRec.IsWinner {\n\t\t\treturn bidRec\n\t\t}\n\t}\n\t// panic - should not happend\n\treturn bidRecV2{}\n}\n\n// find the highest bid in session - incase everyone Committed price\n// in old flow, we need to find the winner by retrievaling the bidStorage\nfunc findTheWinner(domainName string) (index int, winnerBid bidRecV2) {\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"invalid domain name\")\n\t}\n\tindex = 0\n\tbidRecList := data.([]bidRecV2)\n\twinnerBid = bidRecList[0]\n\tfor i, bidRec := range bidRecList {\n\t\tif bidRec.Price \u003e winnerBid.Price {\n\t\t\twinnerBid.Price = bidRec.Price\n\t\t\twinnerBid.Bidder = bidRec.Bidder\n\t\t\twinnerBid.HashString = bidRec.HashString\n\t\t\twinnerBid.StartTime = bidRec.StartTime\n\t\t\twinnerBid.EndCommitTime = bidRec.EndCommitTime\n\t\t\twinnerBid.EndPriceTime = bidRec.EndPriceTime\n\t\t\twinnerBid.IsCommittedHash = bidRec.IsCommittedHash\n\t\t\twinnerBid.IsCommittedPrice = bidRec.IsCommittedPrice\n\t\t\tindex = i\n\t\t}\n\t}\n\treturn index, winnerBid\n}\n\n// get all the price list that joined the bid for displaying in dapp\nfunc GetRecords(dName string) []bidRecV2 {\n\tdata, existed := bidStorages.Get(dName)\n\tif !existed {\n\t\tpanic(\"should not\")\n\t}\n\treturn data.([]bidRecV2)\n}\n\n// chargeFee will charge amount - send from this contract to admin\nfunc chargeFee(amount int64, from std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", amount)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tcoins := checkCoin(from)\n\tufmt.Println(\"check balances: \", coins)\n\t// ufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// pay fee and claim the domain name if you are winner\nfunc Claim(domainName string) bool {\n\tif !bidStorages.Has(domainName) {\n\t\tpanic(\"claim: invalid domain name\")\n\t}\n\tcaller := std.GetOrigCaller()\n\t_, winner := findTheWinner(domainName)\n\tif caller.String() != winner.Bidder {\n\t\tpanic(\"only winner can claim\")\n\t}\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       caller,\n\t\tMode:         \"native\",\n\t}\n\tresult := executeRegister(requestInfo)\n\tif !result.Success {\n\t\tpanic(result.ResultDetails.Error())\n\t}\n\t// register done. Now charge the fee\n\tchargeFee(winner.Price, caller)\n\tfeeProcess(requestInfo)\n\treturn true\n}\n\n// expose winner price - amount of fee that user need to pay in Claim phase\nfunc GetWinnerPrice(dName string) int64 {\n\trec := GetCurrentWinner(dName)\n\treturn rec.Price\n}\n"},{"name":"bidding_model.gno","body":"package registrar\n\nimport \"std\"\n\ntype bidStatus struct {\n\tDomainName    string\n\tStatus        string\n\tEndCommitTime int64\n\tEndPriceTime  int64\n}\n\ntype bidRecord struct {\n\tDomainName       string\n\tBidder           std.Address\n\tHashString       string\n\tPrice            int64\n\tStartTime        int64\n\tEndCommitTime    int64\n\tEndPriceTime     int64\n\tIsCommittedPrice bool\n\t// CurrentPhase  actionCode\n}\ntype bidRecV2 struct {\n\tDomainName       string\n\tBidder           string\n\tHashString       string\n\tPrice            int64\n\tStartTime        int64\n\tEndCommitTime    int64\n\tEndPriceTime     int64\n\tIsCommittedPrice bool\n\tIsCommittedHash  bool\n\tIsWinner         bool\n}\n"},{"name":"bidding_v39.gno","body":"package registrar\n\n// import (\n// \t\"std\"\n// \t\"strconv\"\n// \t\"time\"\n\n// \t\"gno.land/p/demo/ufmt\"\n// \t// \"gno.land/p/demo/mux\"\n// \t\"gno.land/p/demo/avl\"\n// )\n\n// var (\n// \tbidStorage *avl.Tree // bidRecord \u003c- []bidRec\n// \twinnerRec  *avl.Tree // dName \u003c- bidRec\n// \tjoinedBid  *avl.Tree // address \u003c- []string DomainName\n// )\n\n// func recordJoinedBid(domainName string) {\n// \tcaller := std.GetOrigCaller()\n// \tdList := []string{}\n// \tdata, existed := joinedBid.Get(caller.String())\n// \tif !existed {\n// \t\tdList = []string{domainName}\n// \t\tjoinedBid.Set(caller.String(), dList)\n// \t\treturn\n// \t}\n// \tdList = data.([]string)\n// \tdList = append(dList, domainName)\n// \tjoinedBid.Set(caller.String(), dList)\n// \treturn\n// }\n\n// // GetJoinedBid returns the status of an user's joined bid session information\n// func GetJoinedBid(caller string) []bidStatus {\n// \tdata, existed := joinedBid.Get(caller)\n// \tif !existed {\n// \t\treturn []bidStatus{}\n// \t}\n// \tlist := data.([]string)\n// \tlistStatus := []bidStatus{}\n// \tfor _, dName := range list {\n// \t\tstt := GetCurrentStatus(dName, caller)\n\n// \t\t// get the time stamp in [0] element and assign it to status\n// \t\tdata, _ := bidStorage.Get(dName)\n// \t\tbidRec := data.([]bidRecord)[0]\n\n// \t\tsingleStt := bidStatus{\n// \t\t\tDomainName:    dName,\n// \t\t\tStatus:        stt,\n// \t\t\tEndCommitTime: bidRec.EndCommitTime,\n// \t\t\tEndPriceTime:  bidRec.EndPriceTime,\n// \t\t}\n// \t\tlistStatus = append(listStatus, singleStt)\n// \t}\n// \treturn listStatus\n// }\n\n// // GetCurrentStatus returns the status of the bidding session about a domain name. This func requires caller to determine in case commited or not (hash or price)\n// func GetCurrentStatus(domainName string, caller string) string {\n// \t// if there is record in joinedBid -\u003e user joined\n// \t// check for tine.Now() and startTime\n// \tnow := time.Now().UnixMilli()\n// \towner := GetOwner(domainName)\n// \tif owner != \"\" {\n// \t\treturn \"owned by \" + owner.String()\n// \t}\n// \t// find the record\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\t// no record in bidRec yet -\u003e not commited -\u003e check if user started auction or not - if yes: new auction\n// \t\tif dataJoined, existedInRegister := joinedBid.Get(caller); existedInRegister {\n// \t\t\tdNameList := dataJoined.([]string)\n// \t\t\tfor _, dName := range dNameList {\n// \t\t\t\tif dName == domainName {\n// \t\t\t\t\treturn \"waiting for hash\"\n// \t\t\t\t}\n// \t\t\t\treturn \"domain name is free\"\n// \t\t\t}\n// \t\t}\n// \t\treturn \"domain name is free\"\n// \t}\n\n// \t// commited yet\n// \trecList := data.([]bidRecord)\n// \trec := recList[0]\n// \tendCommitTimeUnix := rec.EndCommitTime\n// \tendPriceTimeUnix := rec.EndPriceTime\n// \tif now \u003c endCommitTimeUnix {\n// \t\tif rec.HashString != \"\" {\n// \t\t\treturn \"commited hash\"\n// \t\t} else {\n// \t\t\treturn \"hash\"\n// \t\t}\n// \t}\n\n// \tufmt.Println(\"now: \", time.UnixMilli(now))\n// \tufmt.Println(\"endPriceTime: \", time.UnixMilli(endPriceTimeUnix))\n// \tif now \u003c endPriceTimeUnix \u0026\u0026 now \u003e endCommitTimeUnix {\n// \t\t// check if commited price\n// \t\tdata, _ := bidStorage.Get(domainName)\n// \t\tbidRecList := data.([]bidRecord)\n// \t\tthisRec := bidRecord{}\n// \t\tfor _, bidRec := range bidRecList {\n// \t\t\tif bidRec.Bidder.String() == caller {\n// \t\t\t\tthisRec = bidRec\n// \t\t\t}\n// \t\t}\n// \t\tif thisRec.IsCommittedPrice {\n// \t\t\treturn \"committed price\"\n// \t\t}\n// \t\treturn \"price\"\n// \t}\n// \tif now \u003e rec.EndPriceTime {\n// \t\t// check if dName is claiming by winner - check if winner existed\n// \t\tif data, existed := winnerRec.Get(domainName); existed {\n// \t\t\twinner := data.(bidRecord)\n// \t\t\treturn winner.Bidder.String() + \" is claiming domain name: \" + domainName\n// \t\t}\n// \t\treturn \"closed\"\n// \t}\n// \treturn \"undefined\"\n// }\n\n// // Render() renders welcome message :D\n// func Render(path string) string {\n// \treturn \"welcome to varmeta domain name service\"\n// }\n\n// // CommitHash consumes off-chain calculated hash string and the domain name that user want\n// func CommitHash(domainName, hashString string) string {\n// \tcaller := std.GetOrigCaller()\n\n// \t// use now as int64 representation of time.Now()\n// \tnow := time.Now().UnixMilli()\n\n// \t// update the bid record\n// \tdata, existed := bidStorage.Get(domainName)\n\n// \t// if not existed -\u003e create new record\n// \tif !existed {\n// \t\t// for further getStatus\n// \t\trecordJoinedBid(domainName)\n\n// \t\tvar bidRec bidRecord\n// \t\tendCommitTime := now + defaultCommitHashTime.Milliseconds()\n// \t\tendPriceTime := endCommitTime + defaultCommitPriceTime.Milliseconds()\n// \t\tufmt.Println(\"[HASH]: request at: \", time.UnixMilli(now))\n// \t\tufmt.Println(\"[HASH]: endCommitTime: \", time.UnixMilli(endCommitTime))\n// \t\tufmt.Println(\"[HASH]: endPriceTime: \", time.UnixMilli(endPriceTime))\n// \t\tbidRec = bidRecord{\n// \t\t\tDomainName:    domainName,\n// \t\t\tBidder:        caller,\n// \t\t\tHashString:    hashString,\n// \t\t\tStartTime:     now,\n// \t\t\tEndCommitTime: endCommitTime,\n// \t\t\tEndPriceTime:  endPriceTime,\n// \t\t}\n// \t\tbidRecList := []bidRecord{bidRec}\n// \t\tbidStorage.Set(domainName, bidRecList)\n\n// \t\t// charge fee\n// \t\tchargeFee(fee.BidJoinFee, caller)\n// \t\treturn \"new session\"\n// \t}\n// \t// if existed\n// \tbidRecList := data.([]bidRecord)\n// \tstartTime := bidRecList[0].StartTime\n// \toldEndCommitTimeUnix := bidRecList[0].EndCommitTime\n// \toldEndPriceTimeUnix := bidRecList[0].EndPriceTime\n// \tif now \u003e oldEndCommitTimeUnix {\n// \t\t// now := time.Now().UnixMilli()\n// \t\t// ufmt.Println(\"[HASH]: now: \", time.UnixMilli(now))\n// \t\tpanic(\"[HASH]: can not commit hash anymore\")\n// \t}\n// \tfor _, bR := range bidRecList {\n// \t\tif bR.Bidder == caller {\n// \t\t\tpanic(\"[HASH]: you already commited hash\")\n// \t\t}\n// \t}\n\n// \tbidRec := bidRecord{\n// \t\tDomainName:    domainName,\n// \t\tHashString:    hashString,\n// \t\tBidder:        caller,\n// \t\tStartTime:     startTime,\n// \t\tEndCommitTime: oldEndCommitTimeUnix,\n// \t\tEndPriceTime:  oldEndPriceTimeUnix,\n// \t}\n// \tbidRecList = append(bidRecList, bidRec)\n// \t// Save record\n// \tbidStorage.Set(domainName, bidRecList)\n// \t// charge commit hash fee\n// \tchargeFee(fee.BidJoinFee, caller)\n// \treturn \"existed\"\n// }\n\n// // for now we dont use panic because this will cause the permanent time.Now() stuck. IDK why // XXX fix me\n// // CommitPrice consumes price and secret string that user used in calculating hash string from off-chain. This will re-calculate the hashstring and compare with the one commited before\n// func CommitPrice(price int64, secret string, domainName string) string {\n// \t// compute the hash string, compare to saved hash string in record\n// \t// use int64 representation of time.Now()\n// \tnow := time.Now().UnixMilli()\n// \tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n// \tjoinedString := secret + strconv.Itoa(int(price))\n// \tcomputedHashString := Get256String(joinedString)\n// \tcaller := std.GetOrigCaller()\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"[PRICE]: domain name is invalid\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \twinnerRec.Set(domainName, bidRecList[len(bidRecList)-1])\n// \tufmt.Println(\"[PRICE] current winner set to: \", bidRecList[len(bidRecList)-1].Bidder.String())\n\n// \tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n// \tufmt.Println(\"[PRICE]: endPriceTime: \", time.UnixMilli(bidRecList[0].EndPriceTime))\n// \t// case commit after end - consider panic or not\n// \tif now \u003e bidRecList[0].EndPriceTime {\n// \t\tufmt.Println(\"[PRICE]: commit price phase is ended\")\n// \t\treturn \"ended\"\n// \t}\n// \t// case commit when price phase not started\n// \tif now \u003c= bidRecList[0].EndCommitTime {\n// \t\tufmt.Println(\"[PRICE]: commit price phase is not started yet\")\n// \t\treturn \"not started yet\"\n// \t}\n\n// \t// search for the corresponding hash\n// \tfor index, bidRec := range bidRecList {\n// \t\t// panic because wrong price or wrong secret string\n// \t\tif bidRec.Bidder == caller \u0026\u0026 bidRec.HashString != computedHashString {\n// \t\t\tpanic(\"[PRICE]: invalid hash string\")\n// \t\t}\n// \t\t// found it, update the winner price\n// \t\tif bidRec.Bidder == caller \u0026\u0026 bidRec.HashString == computedHashString {\n// \t\t\tdata, _ := winnerRec.Get(domainName)\n// \t\t\tcurrentWinnerRec := data.(bidRecord)\n// \t\t\tif price \u003e currentWinnerRec.Price \u0026\u0026 now \u003c currentWinnerRec.EndPriceTime {\n// \t\t\t\tufmt.Println(\"[PRICE]: found new winner, setting up\")\n// \t\t\t\tcurrentWinnerRec.Price = price\n// \t\t\t\tcurrentWinnerRec.Bidder = bidRec.Bidder\n// \t\t\t\tcurrentWinnerRec.HashString = bidRec.HashString\n// \t\t\t\tcurrentWinnerRec.StartTime = bidRec.StartTime\n// \t\t\t\tcurrentWinnerRec.EndCommitTime = bidRec.EndCommitTime\n// \t\t\t\tcurrentWinnerRec.EndPriceTime = bidRec.EndPriceTime\n// \t\t\t\twinnerRec.Set(domainName, currentWinnerRec)\n// \t\t\t\tufmt.Println(\"[PRICE] current winner set to: \", currentWinnerRec.Bidder)\n// \t\t\t\tbidRec.IsCommittedPrice = true\n// \t\t\t\t// set new bidRecord into bidRecList and save into storage\n// \t\t\t\tbidRecList[index] = bidRec\n// \t\t\t\tbidStorage.Set(domainName, bidRecList)\n// \t\t\t\treturn \"claim\"\n// \t\t\t}\n// \t\t}\n// \t}\n// \t// if not match above case, then panic\n// \tpanic(\"commit price failed\")\n// }\n\n// // GetCurrentWinner shows the current highest price user\n// func GetCurrentWinner(domainName string) bidRecord {\n// \tdata, existed := winnerRec.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"no winner yet\")\n// \t}\n// \treturn data.(bidRecord)\n// }\n\n// // find the highest bid in session - incase everyone commited price\n// // in old flow, we need to find the winner by retrievaling the bidStorage\n// func findTheWinner(domainName string) bidRecord {\n// \tvar winnerBid bidRecord\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"invalid domain name\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \twinnerBid = bidRecList[0]\n// \tfor _, bidRec := range bidRecList {\n// \t\tif bidRec.Price \u003e winnerBid.Price {\n// \t\t\twinnerBid = bidRec\n// \t\t}\n// \t}\n// \treturn winnerBid\n// }\n\n// // register the domain for winner\n// func registerForWinner(domainName string, winnerRec bidRecord) bool {\n// \twinnerAddr := winnerRec.Bidder\n// \trequestInfo := RequestInfo{\n// \t\tWantedDomain: domainName,\n// \t\tCaller:       winnerAddr,\n// \t\tMode:         \"native\",\n// \t}\n// \tresult := executeRegister(requestInfo)\n// \tif !result.Success {\n// \t\tpanic(result.ResultDetails.Error())\n// \t}\n// \t// register done. Now charge the fee\n// \tfeeProcess(requestInfo)\n// \treturn false\n// }\n\n// // everyone can call EndBid()\n// // this EndBid checks endTime -\u003e end the auction\n// func EndBid(domainName string) error {\n// \tnow := time.Now().UnixMilli()\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\treturn ufmt.Errorf(\"endbid: invalid domain name\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \tfirstBidRec := bidRecList[0]\n// \tif now \u003c firstBidRec.EndPriceTime {\n// \t\treturn ufmt.Errorf(\"endbid: this session can not end before the end time\")\n// \t}\n// \t// change all state\n// \t// for _, bidRec := range bidRecList {\n// \t// \tbidRec.IsOpen = false\n// \t// }\n// \tok := bidStorage.Set(domainName, bidRecList)\n// \tif !ok {\n// \t\treturn ufmt.Errorf(\"endbid: can not change bid record state\")\n// \t}\n// \t// need more conditions for findTheWinner()\n// \tfindTheWinner(domainName)\n// \treturn nil\n// }\n\n// // get all the price list that joined the bid for displaying in dapp\n// func GetRecords(dName string) []bidRecord {\n// \tdata, existed := bidStorage.Get(dName)\n// \tif !existed {\n// \t\tpanic(\"should not\")\n// \t}\n// \treturn data.([]bidRecord)\n// }\n\n// // chargeFee will charge amount - send from this contract to admin\n// func chargeFee(amount int64, from std.Address) {\n// \tbankerContract := std.CurrentRealm().Addr()\n// \tugnotCoin := std.NewCoin(\"ugnot\", amount)\n// \tcoinsToTransfer := std.NewCoins(ugnotCoin)\n// \tcoins := checkCoin(from)\n// \tufmt.Println(\"check balances: \", coins)\n// \t// ufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n// \tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n// }\n\n// // pay fee and claim the domain name if you are winner\n// func Claim(domainName string) bool {\n// \tdata, existed := winnerRec.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"claim: invalid domain name\")\n// \t}\n// \tcaller := std.GetOrigCaller()\n// \trec := data.(bidRecord)\n// \tif caller != rec.Bidder {\n// \t\tpanic(\"only winner can claim\")\n// \t}\n// \trequestInfo := RequestInfo{\n// \t\tWantedDomain: domainName,\n// \t\tCaller:       rec.Bidder,\n// \t\tMode:         \"native\",\n// \t}\n// \tresult := executeRegister(requestInfo)\n// \tif !result.Success {\n// \t\tpanic(result.ResultDetails.Error())\n// \t}\n// \t// register done. Now charge the fee\n// \tchargeFee(rec.Price, caller)\n// \tfeeProcess(requestInfo)\n// \treturn true\n// }\n\n// // expose winner price - amount of fee that user need to pay in Claim phase\n// func GetWinnerPrice(dName string) int64 {\n// \trec := GetCurrentWinner(dName)\n// \treturn rec.Price\n// }"},{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n\tBidJoinFee          int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\n// Admin set register fee and renewal fee\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tcaller := std.GetOrigCaller()\n\tcoins := checkCoin(caller)\n\tufmt.Println(\"check: \", coins)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(3)\n\terr := ufmt.Sprintf(\"unauthorize with caller: %s\\n\", caller)\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(err)\n\t}\n}\n\n// checking for availble coins\nfunc checkCoin(from std.Address) std.Coins {\n\t// caller := std.GetOrigCaller()\n\treturn bankerUser.GetCoins(from)\n}\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"hashstring.gno","body":"package registrar\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n)\n\nfunc Get256String(input string) string {\n\tdata := []byte(input)\n\thashed := sha256.Sum256(data)\n\thashedBytes := hashed[:]\n\treturn hex.EncodeToString(hashedBytes)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo/v404/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n\tMessage       string\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v404/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\t// bidStorage = avl.NewTree()\n\t// winnerRec = avl.NewTree()\n\t// joinedBid = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     100,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t\tBidJoinFee:          100,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n// changelogs 2: v2 - added sealed bidding logic - with default time xxx mins for each session\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v404/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\t// changelogs v2: we are using sealed bidding now\n\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := metadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"time\"\n)\n\nvar (\n\tdefaultCommitHashTime  = time.Second * 30\n\tdefaultCommitPriceTime = time.Second * 30\n\tdefaultExpireTime      = time.Hour // 30 days\n\treName                 = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tassertIsAdmin()\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n\nfunc SetCommitPhaseTime(duration int) {\n\tdefaultCommitHashTime = time.Duration(duration) * time.Second\n}\n\nfunc SetCommitPriceTime(duration int) {\n\tdefaultCommitPriceTime = time.Duration(duration) * time.Second\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"MIuQ2UPINetO5iutvMUyw4I31VZAU8Fq4oTmFJCT6llnk0fmGtXXG29WeLd3yYZLb28mJ9BvBxpVsR4qWKkc9A=="}],"memo":""},"blockNum":"1981734"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"resolver","path":"gno.land/r/varmeta/demo/v404/domain/resolver","files":[{"name":"checks_resolver.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage resolver\n\nimport (\n\t\"regexp\"\n\t\"time\"\n\n\t\"gno.land/r/varmeta/demo/v404/domain/registrar\"\n)\n\n// const (\n// \tadmin std.Address = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\" // -\u003e @thinhnx\n// )\n\nvar reName = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc isExpired(dName string) bool {\n\texpDate := registrar.GetExpirationDate(dName)\n\treturn expDate.Before(time.Now())\n}\n"},{"name":"errors.gno","body":"package resolver\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrNotFound          = errors.New(\"not found\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"invalid domain name to register\")\n)\n"},{"name":"resolver.gno","body":"/*\nThe goal of the Resolver contract is keep track of the address for each ICNS name in a stateful manner.\nIt serves the purpose of \"resolving\" the ICNS Name\nto the correct address (e.g \"alice.gno\" -\u003e g1xxx).\n*/\n// changelogs: move Register feature into this resolver package\n// changelogs2: Removed local storage of resolver as cache, and every querires we query to registrar to get the result\n\npackage resolver\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/varmeta/demo/v404/domain/registrar\"\n)\n\ntype Record struct {\n\tOwner    std.Address\n\tIsValid  bool\n\tMemo     string // no more need this\n\tPriority int\n}\n\n// retrieve the record list to get the onchain address\nfunc Resolve(domainName string) *Record {\n\tif !isValidDomain(domainName) {\n\t\tpanic(\"bad domain name\")\n\t}\n\trecord := \u0026Record{}\n\n\towner := getOwnerFromDomainStorage(domainName)\n\tif owner == \"\" {\n\t\trecord.Memo = \"not found\"\n\t\trecord.IsValid = false\n\t\treturn record\n\t}\n\n\tif !isExpired(domainName) {\n\t\trecord.IsValid = true\n\t\trecord.Owner = owner\n\t} else {\n\t\trecord.IsValid = false\n\t}\n\treturn record\n}\n\nfunc GetDomainName(addr string) []string {\n\treturn registrar.GetDomainName(addr)\n}\n\n/*\nIf query in local storage not found\nQuery to DomainStorage by domainName -\u003e get the registry -\u003e use that registry to get the Owner()\nand check the validation time?\n*/\n\nfunc existedInDomainStorage(domainName string) bool {\n\treturn registrar.AlreadyRegistered(domainName)\n}\n\nfunc getOwnerFromDomainStorage(domainName string) std.Address {\n\treturn registrar.GetOwner(domainName)\n}\n"},{"name":"resolver_metadata.gno","body":"package resolver\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v404/domain\"\n)\n\n// Metadata wrapper\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcrrTime := time.Now()\n\texpTime := crrTime.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", crrTime, expTime, []domain.Trait{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"Afgft454qVQg0bo7kjeiHjpwMTDFEr4vqTVhNQIMs2hnopUwsl9BWfmk3LyKEzD/6mYFQvt9xg4YBlWpHVjXVg=="}],"memo":""},"blockNum":"1981747"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo/v405/grc/grc721","files":[{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"AwXmKo8NbtayoS04lydrUqPvgeJ6EFwMUTno7ocOvSh7ve3x1M3Tij9cVMMZ7gw5scEaSTdMaMuyiZ5OjqLIEA=="}],"memo":""},"blockNum":"1981896"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"domain","path":"gno.land/p/varmeta/demo/v405/domain","files":[{"name":"domain_metadata.gno","body":"package domain\n\nimport (\n\t\"time\"\n)\n\n// Trait represents a key-value pair with an optional display type for metadata attributes\ntype Trait struct {\n\tDisplayType string // Optional display type (e.g., \"date\", \"number\", etc.)\n\tTraitType   string // Type of the trait (e.g., \"age\", \"height\", etc.)\n\tValue       string // Value of the trait\n}\n\n// Metadata represents the metadata associated with a domain\ntype Metadata struct {\n\tAvatar           string    // URL or identifier for an avatar image\n\tRegistrationTime time.Time // The time when the domain was registered\n\tExpirationTime   time.Time // The time when the domain will be expire\n\tAttributes       []Trait   // Additional attributes of the domain\n\tDescription      string    // A description of the domain\n\tContactInfo      string    // Contact information for the domain owner\n\tRenewalFee       string    // The fee required to renew the domain, represented as a string\n}\n\n// NewMetadata creates a new Metadata instance\nfunc NewMetadata(avatar, description, contactInfo, renewalFee string,\n\tregistrationTime, expirationTime time.Time, attributes []Trait,\n) Metadata {\n\treturn Metadata{\n\t\tAvatar:           avatar,\n\t\tRegistrationTime: registrationTime,\n\t\tExpirationTime:   expirationTime,\n\t\tRenewalFee:       renewalFee,\n\t\tAttributes:       attributes,\n\t\tDescription:      description,\n\t\tContactInfo:      contactInfo,\n\t}\n}\n"},{"name":"domain_registry.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v405/grc/grc721\"\n)\n\n// domainRegistry represents a registry for domain names with metadata\ntype domainRegistry struct {\n\tdomains  grc721.IGRC721 // Interface for basic NFT functionality\n\tmetadata *avl.Tree      // AVL tree for storing domain metadata\n\texpDate  time.Time\n}\n\n// DomainRegistry defines the methods for managing domain names and metadata\ntype DomainRegistry interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(domainName string) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, domainName string) error\n\tTransferFrom(from, to std.Address, domainName string) error\n\tApprove(approved std.Address, domainName string) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(domainName string) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, domainName string) error\n\n\tRegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error\n\tSetDomainData(domainName string, metadata Metadata) error\n\tGetDomainData(domainName string, field MetadataField) (Metadata, error)\n\tGetDomainFields(domainName string, fields []MetadataField) (Metadata, error)\n\tRenewDomain(domainName string, additionalDuration time.Duration) error\n\tGetExpirationDate(domainName string) time.Time\n\tSetExpirationDate(domainName string, expDate time.Time) bool\n}\n\n// NewDomainRegistry creates a new domain registry with metadata extensions\nfunc NewDomainRegistry(name, symbol string) *domainRegistry {\n\tregistry := grc721.NewBasicNFT(name, symbol)\n\n\treturn \u0026domainRegistry{\n\t\tdomains:  registry,\n\t\tmetadata: avl.NewTree(),\n\t}\n}\n\n// RegisterDomain registers a new domain with the given metadata\nfunc (d *domainRegistry) RegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error {\n\terr := d.domains.Mint(owner, grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\td.expDate = time.Now().Add(dur)\n\td.metadata.Set(domainName, metadata)\n\n\treturn nil\n}\n\n// RenewDomain extends the expiration time of a domain name\nfunc (d *domainRegistry) RenewDomain(domainName string, additionalDuration time.Duration) error {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn ErrInvalidDomainName\n\t}\n\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\t// set new expiration date\n\td.expDate = d.expDate.Add(additionalDuration)\n\treturn nil\n}\n\n// SetDomainData sets the metadata for a given domain name\nfunc (d *domainRegistry) SetDomainData(domainName string, metadata Metadata) error {\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\td.metadata.Set(domainName, metadata)\n\treturn nil\n}\n\n// GetDomainFields retrieves multiple fields of metadata for a given domain\nfunc (d *domainRegistry) GetDomainFields(domainName string, fields []MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tif len(fields) == 0 {\n\t\treturn metadata, nil\n\t}\n\n\tvar result Metadata\n\tfor _, field := range fields {\n\t\tswitch field {\n\t\tcase FieldAvatar:\n\t\t\tresult.Avatar = metadata.Avatar\n\t\tcase FieldRegistrationTime:\n\t\t\tresult.RegistrationTime = metadata.RegistrationTime\n\t\tcase FieldExpirationTime:\n\t\t\tresult.ExpirationTime = metadata.ExpirationTime\n\t\tcase FieldRenewalFee:\n\t\t\tresult.RenewalFee = metadata.RenewalFee\n\t\tcase FieldAttributes:\n\t\t\tresult.Attributes = metadata.Attributes\n\t\tcase FieldDescription:\n\t\t\tresult.Description = metadata.Description\n\t\tcase FieldContactInfo:\n\t\t\tresult.ContactInfo = metadata.ContactInfo\n\t\tdefault:\n\t\t\treturn Metadata{}, ErrInvalidMetadataField\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// GetDomainData retrieves metadata for a given domain\nfunc (d *domainRegistry) GetDomainData(domainName string, field MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tswitch field {\n\tcase FieldAvatar:\n\t\treturn Metadata{\n\t\t\tAvatar: metadata.Avatar,\n\t\t}, nil\n\tcase FieldRegistrationTime:\n\t\treturn Metadata{\n\t\t\tRegistrationTime: metadata.RegistrationTime,\n\t\t}, nil\n\tcase FieldExpirationTime:\n\t\treturn Metadata{\n\t\t\tExpirationTime: metadata.ExpirationTime,\n\t\t}, nil\n\tcase FieldRenewalFee:\n\t\treturn Metadata{\n\t\t\tRenewalFee: metadata.RenewalFee,\n\t\t}, nil\n\tcase FieldAttributes:\n\t\treturn Metadata{\n\t\t\tAttributes: metadata.Attributes,\n\t\t}, nil\n\tcase FieldDescription:\n\t\treturn Metadata{\n\t\t\tDescription: metadata.Description,\n\t\t}, nil\n\tcase FieldContactInfo:\n\t\treturn Metadata{\n\t\t\tContactInfo: metadata.ContactInfo,\n\t\t}, nil\n\tdefault:\n\t\treturn Metadata{}, ErrInvalidMetadataField\n\t}\n}\n\n// BalanceOf returns the number of domains owned by a given address\nfunc (d *domainRegistry) BalanceOf(owner std.Address) (uint64, error) {\n\treturn d.domains.BalanceOf(owner)\n}\n\n// OwnerOf returns the owner of a given domain name\nfunc (d *domainRegistry) OwnerOf(domainName string) (std.Address, error) {\n\treturn d.domains.OwnerOf(grc721.TokenID(domainName))\n}\n\n// SafeTransferFrom safely transfers a domain from one address to another\nfunc (d *domainRegistry) SafeTransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.SafeTransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// TransferFrom transfers a domain from one address to another\nfunc (d *domainRegistry) TransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.TransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// Approve grants approval to another address to manage a specific domain\nfunc (d *domainRegistry) Approve(approved std.Address, domainName string) error {\n\treturn d.domains.Approve(approved, grc721.TokenID(domainName))\n}\n\n// SetApprovalForAll sets approval for an operator to manage all domains of the owner\nfunc (d *domainRegistry) SetApprovalForAll(operator std.Address, approved bool) error {\n\treturn d.domains.SetApprovalForAll(operator, approved)\n}\n\n// GetApproved returns the approved address for a specific domain\nfunc (d *domainRegistry) GetApproved(domainName string) (std.Address, error) {\n\treturn d.domains.GetApproved(grc721.TokenID(domainName))\n}\n\n// IsApprovedForAll checks if an operator is approved to manage all domains of the owner\nfunc (d *domainRegistry) IsApprovedForAll(owner, operator std.Address) bool {\n\treturn d.domains.IsApprovedForAll(owner, operator)\n}\n\n// Mint creates a new domain for a given address\nfunc (d *domainRegistry) Mint(to std.Address, domainName string) error {\n\treturn d.domains.Mint(to, grc721.TokenID(domainName))\n}\n\nfunc (d *domainRegistry) GetExpirationDate(domainName string) time.Time {\n\treturn d.expDate\n}\n\nfunc (d *domainRegistry) SetExpirationDate(domainName string, expDate time.Time) bool {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn false\n\t}\n\td.expDate = expDate\n\treturn true\n}\n"},{"name":"domain_registry_test.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/urequire\"\n\t\"gno.land/p/varmeta/demo/v405/grc/grc721\"\n)\n\nvar (\n\taddr1 = testutils.TestAddress(\"bob\")\n\taddr2 = testutils.TestAddress(\"alice\")\n)\n\nfunc TestRegisterDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Successful Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"contact@registered.com\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Duplicate Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\terr := registry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.owner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr1,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr2,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\t\t\terr := registry.SetDomainData(c.domainName, c.metadata)\n\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\tretrievedMetadata, err := registry.GetDomainData(c.domainName, FieldAvatar)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.metadata.Avatar, retrievedMetadata.Avatar)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRenewDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname           string\n\t\towner          std.Address\n\t\tcaller         std.Address\n\t\tdomainName     string\n\t\tadditionalTime time.Duration\n\t\texpectError    bool\n\t\texpectedExpiry time.Time\n\t}{\n\t\t{\n\t\t\tname:           \"Successful Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr1,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"Non-Owner Attempts Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr2,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A renewable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.RenewDomain(c.domainName, c.additionalTime)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\trenewedMetadata, err := registry.GetDomainData(c.domainName, FieldExpirationTime)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\t// urequire.True(t, renewedMetadata.ExpirationTime.After(metadata.ExpirationTime))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfield       MetadataField\n\t\texpectError bool\n\t\texpectedVal string\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Avatar\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: false,\n\t\t\texpectedVal: \"avatar_url\",\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain Name\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t_, err := registry.GetDomainData(c.domainName, c.field)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainFields(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfields      []MetadataField\n\t\texpectError bool\n\t\texpected    Metadata\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Multiple Fields\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar, FieldDescription, FieldContactInfo},\n\t\t\texpectError: false,\n\t\t\texpected: Metadata{\n\t\t\t\tAvatar:      \"avatar_url\",\n\t\t\t\tDescription: \"A test domain\",\n\t\t\t\tContactInfo: \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tretrievedMetadata, err := registry.GetDomainFields(c.domainName, c.fields)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.expected.Avatar, retrievedMetadata.Avatar)\n\t\t\t\turequire.Equal(t, c.expected.Description, retrievedMetadata.Description)\n\t\t\t\turequire.Equal(t, c.expected.ContactInfo, retrievedMetadata.ContactInfo)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTransferDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tnewOwner    std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"Successful Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr1,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Non-Owner Attempts Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr2,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A transferable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.TransferFrom(c.owner, c.newOwner, c.domainName)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), grc721.ErrTransferFromIncorrectOwner.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.newOwner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"errors.gno","body":"package domain\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnauthorized         = errors.New(\"caller is not domain owner\")\n\tErrInvalidDomainName    = errors.New(\"invalid domain name\")\n\tErrInvalidMetadataField = errors.New(\"invalid metadata field\")\n\tErrInsufficientFunds    = errors.New(\"insufficient funds for renewal\")\n)\n"},{"name":"utils.gno","body":"package domain\n\ntype MetadataField int\n\nconst (\n\tFieldAvatar MetadataField = iota\n\tFieldRegistrationTime\n\tFieldRenewalFee\n\tFieldExpirationTime\n\tFieldAttributes\n\tFieldDescription\n\tFieldContactInfo\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"6000000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"Z2Ef5HJlU4/7r+KZXbbdkhjxTTF+x4p+zFlirwN8eBN1Fq6sqrGWlsCLGYGGycnuwCyUUw7o5AhxEVdaoUpxeA=="}],"memo":""},"blockNum":"1981974"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo/v405/domain/registrar","files":[{"name":"bidding.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t// \"gno.land/p/demo/mux\"\n\t\"gno.land/p/demo/avl\"\n)\n\n// I want to redesign this codebase\n\n// all keys are domainName\nvar bidStorages avl.Tree // dName \u003c=- []bidRecV2\n\n// record new joined bid\nfunc record2Storage(domainName string) {\n\tcaller := std.GetOrigCaller()\n\tnow := time.Now().UnixMilli()\n\tnewRec := bidRecV2{\n\t\tBidder:     caller.String(),\n\t\tDomainName: domainName,\n\t\tStartTime:  now,\n\t\t//...\n\t}\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tbidStorages.Set(domainName, newRec)\n\t}\n\tbidRecList := data.([]bidRecV2)\n\toldStartTime := bidRecList[0].StartTime\n\tnewRec.StartTime = oldStartTime\n\tbidRecList = append(bidRecList, newRec)\n\tbidStorages.Set(domainName, bidRecList)\n}\n\n// GetJoinedBid returns the status of an user's joined bid session information\nfunc GetJoinedBid(caller string) []bidStatus {\n\tdNameList := []string{}\n\t// Iterate the bidStorages, which domainName has Bidder == caller -\u003e take domainNames\n\tbidStorages.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tdataList := value.([]bidRecV2)\n\t\tfor _, rec := range dataList {\n\t\t\tif rec.Bidder == caller {\n\t\t\t\tufmt.Println(\"key to append: \", key)\n\t\t\t\tdNameList = append(dNameList, key)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n\tufmt.Println(\"len: \", len(dNameList))\n\t// after get dNameList of a caller, we check status of each dName\n\tlistStatus := []bidStatus{}\n\tfor _, dName := range dNameList {\n\t\tstt := GetCurrentStatus(dName, caller)\n\t\t// get the time stamp in [0] element and assign it to status\n\t\tdata, _ := bidStorages.Get(dName)\n\t\tbidRec := data.([]bidRecV2)[0]\n\n\t\tsingleStt := bidStatus{\n\t\t\tDomainName:    dName,\n\t\t\tStatus:        stt,\n\t\t\tEndCommitTime: bidRec.EndCommitTime,\n\t\t\tEndPriceTime:  bidRec.EndPriceTime,\n\t\t}\n\t\tlistStatus = append(listStatus, singleStt)\n\t}\n\tufmt.Println(\"len of list status: \", len(listStatus))\n\treturn listStatus\n}\n\nfunc Get(domainName string) ([]string, []string, []int64) {\n\tdata, _ := bidStorages.Get(domainName)\n\tlist := data.([]bidRecV2)\n\tdNameList := []string{}\n\thashList := []string{}\n\tpList := []int64{}\n\tfor _, rec := range list {\n\t\tdNameList = append(dNameList, rec.Bidder)\n\t\thashList = append(hashList, rec.HashString)\n\t\tpList = append(pList, rec.Price)\n\t}\n\treturn dNameList, hashList, pList\n}\n\n/*\n\tI want the CommitHash and CommitPrice will change the status of the record, by this way, we can detect\n\tthe current state of a bidding session for each user\n*/\n\n// GetCurrentStatus returns the status of the bidding session about a domain name. This func requires caller to determine in case Committed or not (hash or price)\nfunc GetCurrentStatus(domainName string, caller string) string {\n\t// if there is record in joinedBid -\u003e user joined\n\t// check for tine.Now() and startTime\n\tnow := time.Now().UnixMilli()\n\t// if domain name is owned already\n\towner := GetOwner(domainName)\n\tif owner != \"\" {\n\t\treturn \"owned by \" + owner.String()\n\t}\n\t// find the record\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\t// no record in bidRec yet -\u003e not Committed -\u003e check if user started auction or not - if yes: new auction\n\t\treturn \"domain name is free\"\n\t}\n\trecList := data.([]bidRecV2)\n\trec0 := recList[0]\n\t// Auction closed with winner\n\tif rec0.EndPriceTime \u003c= now \u0026\u0026 owner != \"\" {\n\t\treturn \"close\"\n\t}\n\t// find the record of the caller\n\tfor _, rec := range recList {\n\t\tswitch {\n\t\t// Waiting for hash commitment\n\t\tcase !rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.StartTime \u003c= now \u0026\u0026 rec.EndCommitTime \u003e now:\n\t\t\treturn \"waiting hash\"\n\n\t\t// Committed hash\n\t\tcase rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.StartTime \u003c= now \u0026\u0026 rec.EndCommitTime \u003e now:\n\t\t\treturn \"committed hash\"\n\n\t\t// Waiting for price commitment\n\t\tcase rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.EndCommitTime \u003c= now \u0026\u0026 rec.EndPriceTime \u003e now:\n\t\t\treturn \"waiting price\"\n\n\t\t// Committed price\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 rec.EndCommitTime \u003c= now \u0026\u0026 rec.EndPriceTime \u003e now:\n\t\t\treturn \"committed price\"\n\n\t\t// Winner claiming domain\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 rec.IsWinner \u0026\u0026 rec.EndPriceTime \u003c= now:\n\t\t\treturn rec.Bidder + \" is claiming domain name: \" + domainName\n\t\t// find the winner\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 !rec.IsWinner \u0026\u0026 rec.EndPriceTime \u003c= now:\n\t\t\t_, winnerRec := findTheWinner(domainName)\n\t\t\treturn winnerRec.Bidder + \" is claiming domain name: \" + domainName\n\t\t// Missed hash commitment deadline\n\t\tcase !rec.IsCommittedHash \u0026\u0026 rec.EndCommitTime \u003c= now:\n\t\t\treturn \"waiting for hash\"\n\t\t}\n\t}\n\n\treturn \"undefined\"\n}\n\n// CommitHash consumes off-chain calculated hash string and the domain name that user want\nfunc CommitHash(domainName, hashString string) string {\n\tcaller := std.GetOrigCaller()\n\n\t// use now as int64 representation of time.Now()\n\tnow := time.Now().UnixMilli()\n\n\t// update the bid record\n\tdata, existed := bidStorages.Get(domainName)\n\n\t// if not existed -\u003e create new record\n\tif !existed {\n\t\t// for further getStatus\n\t\t// record2Storage(domainName)\n\n\t\tvar bidRec bidRecV2\n\t\tendCommitTime := now + defaultCommitHashTime.Milliseconds()\n\t\tendPriceTime := endCommitTime + defaultCommitPriceTime.Milliseconds()\n\t\tufmt.Println(\"[HASH]: request at: \", time.UnixMilli(now))\n\t\tufmt.Println(\"[HASH]: endCommitTime: \", time.UnixMilli(endCommitTime))\n\t\tufmt.Println(\"[HASH]: endPriceTime: \", time.UnixMilli(endPriceTime))\n\t\tbidRec = bidRecV2{\n\t\t\tDomainName:       domainName,\n\t\t\tBidder:           caller.String(),\n\t\t\tHashString:       hashString,\n\t\t\tStartTime:        now,\n\t\t\tEndCommitTime:    endCommitTime,\n\t\t\tEndPriceTime:     endPriceTime,\n\t\t\tIsCommittedHash:  true,\n\t\t\tIsCommittedPrice: false,\n\t\t\tIsWinner:         true,\n\t\t\tPrice:            0,\n\t\t}\n\t\tbidNewRec := []bidRecV2{bidRec}\n\t\tbidStorages.Set(domainName, bidNewRec)\n\n\t\t// charge fee\n\t\tchargeFee(fee.BidJoinFee, std.Address(caller))\n\t\treturn \"new session\"\n\t}\n\t// if existed\n\tbidRecList := data.([]bidRecV2)\n\tstartTime := bidRecList[0].StartTime\n\toldEndCommitTimeUnix := bidRecList[0].EndCommitTime\n\toldEndPriceTimeUnix := bidRecList[0].EndPriceTime\n\tif now \u003e oldEndCommitTimeUnix {\n\t\t// now := time.Now().UnixMilli()\n\t\t// ufmt.Println(\"[HASH]: now: \", time.UnixMilli(now))\n\t\tpanic(\"[HASH]: can not commit hash anymore\")\n\t}\n\tfor _, bR := range bidRecList {\n\t\tif bR.Bidder == caller.String() {\n\t\t\tpanic(\"[HASH]: you already committed hash\")\n\t\t}\n\t}\n\n\tnewRec := bidRecV2{\n\t\tDomainName:       domainName,\n\t\tHashString:       hashString,\n\t\tBidder:           caller.String(),\n\t\tStartTime:        startTime,\n\t\tEndCommitTime:    oldEndCommitTimeUnix,\n\t\tEndPriceTime:     oldEndPriceTimeUnix,\n\t\tIsCommittedHash:  true,\n\t\tIsCommittedPrice: false,\n\t\tIsWinner:         false,\n\t}\n\t// append the list, set it to storage\n\tbidRecList = append(bidRecList, newRec)\n\tufmt.Println(\"len bidRecList: \", len(bidRecList))\n\t// Save record\n\tbidStorages.Set(domainName, bidRecList)\n\t// charge commit hash fee\n\tufmt.Println(\"saved hash: \", hashString)\n\tchargeFee(fee.BidJoinFee, caller)\n\treturn \"existed\"\n}\n\n// for now we dont use panic because this will cause the permanent time.Now() stuck. IDK why // XXX fix me\n// CommitPrice consumes price and secret string that user used in calculating hash string from off-chain. This will re-calculate the hashstring and compare with the one Committed before\nfunc CommitPrice(price int64, secret string, domainName string) string {\n\t// compute the hash string, compare to saved hash string in record\n\t// use int64 representation of time.Now()\n\tnow := time.Now().UnixMilli()\n\tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n\tjoinedString := secret + strconv.Itoa(int(price))\n\tcomputedHashString := Get256String(joinedString)\n\tcaller := std.GetOrigCaller()\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"[PRICE]: domain name is invalid\")\n\t}\n\tbidRecList := data.([]bidRecV2)\n\n\tufmt.Println(\"[PRICE]: endPriceTime: \", time.UnixMilli(bidRecList[0].EndPriceTime))\n\t// case commit after end - consider panic or not\n\tif now \u003e bidRecList[0].EndPriceTime {\n\t\tufmt.Println(\"[PRICE]: commit price phase is ended\")\n\t\treturn \"ended\"\n\t}\n\t// case commit when price phase not started\n\tif now \u003c= bidRecList[0].EndCommitTime {\n\t\tufmt.Println(\"[PRICE]: commit price phase is not started yet\")\n\t\treturn \"not started yet\"\n\t}\n\t// detect current winner by index and address\n\t_, currentWinnerRec := findTheWinner(domainName)\n\n\t// search for the corresponding hash\n\tfor index, rec := range bidRecList {\n\t\tufmt.Println(\"index \", index)\n\t\tufmt.Println(\"hash: \", rec.HashString)\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.IsCommittedPrice {\n\t\t\tufmt.Println(\"[PRICE] you already committed price\")\n\t\t\treturn \"committed\"\n\t\t}\n\t\t// panic because wrong price or wrong secret string\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.HashString != computedHashString {\n\t\t\tufmt.Println(\"[PRICE]: invalid hash string\")\n\t\t\treturn \"invalid hash string\"\n\t\t}\n\t\t// found it, update the price\n\t\tufmt.Println(\"checking for bid addr: \", rec.Bidder)\n\t\tufmt.Println(\"hash: \", rec.HashString)\n\t\tufmt.Println(\"caller: \", caller.String())\n\t\tufmt.Println(\"input hash: \", computedHashString)\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.HashString == computedHashString {\n\t\t\t// update record with a new list\n\t\t\t// find the winner\n\t\t\tif price \u003e currentWinnerRec.Price \u0026\u0026 now \u003c= currentWinnerRec.EndPriceTime {\n\t\t\t\t// set others status to not winner\n\t\t\t\tdata, _ := bidStorages.Get(domainName)\n\t\t\t\tcurrentList := data.([]bidRecV2)\n\t\t\t\tnewList := []bidRecV2{}\n\t\t\t\tfor _, rec := range currentList {\n\t\t\t\t\trec.IsWinner = false\n\t\t\t\t\tnewList = append(newList, rec)\n\t\t\t\t}\n\n\t\t\t\t// update winner\n\t\t\t\tufmt.Println(\"[PRICE]: found new winner, setting up\")\n\t\t\t\tnewRec := bidRecV2{\n\t\t\t\t\tDomainName:       domainName,\n\t\t\t\t\tPrice:            price,\n\t\t\t\t\tIsCommittedHash:  true,\n\t\t\t\t\tIsCommittedPrice: true,\n\t\t\t\t\tIsWinner:         true,\n\t\t\t\t\tStartTime:        currentWinnerRec.StartTime,\n\t\t\t\t\tEndCommitTime:    currentWinnerRec.EndCommitTime,\n\t\t\t\t\tEndPriceTime:     currentWinnerRec.EndPriceTime,\n\t\t\t\t\tBidder:           caller.String(),\n\t\t\t\t\tHashString:       computedHashString,\n\t\t\t\t}\n\t\t\t\t// save records\n\t\t\t\tnewList[index] = newRec\n\t\t\t\tbidStorages.Set(domainName, newList)\n\t\t\t\treturn \"claim\"\n\t\t\t}\n\t\t\t// if not the winner, update record \n\t\t\tif price \u003c= currentWinnerRec.Price \u0026\u0026 now \u003c= currentWinnerRec.EndPriceTime {\n\t\t\t\tupdatedRec := bidRecV2{\n\t\t\t\t\tDomainName:       domainName,\n\t\t\t\t\tPrice:            price,\n\t\t\t\t\tIsCommittedHash:  true,\n\t\t\t\t\tIsCommittedPrice: true,\n\t\t\t\t\tIsWinner:         false,\n\t\t\t\t\tStartTime:        rec.StartTime,\n\t\t\t\t\tEndCommitTime:    rec.EndCommitTime,\n\t\t\t\t\tEndPriceTime:     rec.EndPriceTime,\n\t\t\t\t\tBidder:           caller.String(),\n\t\t\t\t\tHashString:       computedHashString,\n\t\t\t\t}\n\t\t\t\tdata, _ := bidStorages.Get(domainName)\n\t\t\t\tcurrentList := data.([]bidRecV2)\n\t\t\t\tcurrentList[index] = updatedRec\n\t\t\t\tbidStorages.Set(domainName, currentList)\n\t\t\t\treturn \"loser\"\n\t\t\t}\n\t\t}\n\t}\n\t// if not match above case, then you are not in list\n\tpanic(\"commit price failed\")\n}\n\n// GetCurrentWinner shows the current highest price user\nfunc GetCurrentWinner(domainName string) bidRecV2 {\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"no winner yet\")\n\t}\n\tlist := data.([]bidRecV2)\n\tfor _, bidRec := range list {\n\t\tif bidRec.IsWinner {\n\t\t\treturn bidRec\n\t\t}\n\t}\n\t// panic - should not happend\n\treturn bidRecV2{}\n}\n\n// find the highest bid in session - incase everyone Committed price\n// in old flow, we need to find the winner by retrievaling the bidStorage\nfunc findTheWinner(domainName string) (index int, winnerBid bidRecV2) {\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"invalid domain name\")\n\t}\n\tindex = 0\n\tbidRecList := data.([]bidRecV2)\n\twinnerBid = bidRecList[0]\n\tfor i, bidRec := range bidRecList {\n\t\tif bidRec.Price \u003e winnerBid.Price {\n\t\t\twinnerBid.Price = bidRec.Price\n\t\t\twinnerBid.Bidder = bidRec.Bidder\n\t\t\twinnerBid.HashString = bidRec.HashString\n\t\t\twinnerBid.StartTime = bidRec.StartTime\n\t\t\twinnerBid.EndCommitTime = bidRec.EndCommitTime\n\t\t\twinnerBid.EndPriceTime = bidRec.EndPriceTime\n\t\t\twinnerBid.IsCommittedHash = bidRec.IsCommittedHash\n\t\t\twinnerBid.IsCommittedPrice = bidRec.IsCommittedPrice\n\t\t\tindex = i\n\t\t}\n\t}\n\treturn index, winnerBid\n}\n\n// get all the price list that joined the bid for displaying in dapp\nfunc GetRecords(dName string) []bidRecV2 {\n\tdata, existed := bidStorages.Get(dName)\n\tif !existed {\n\t\tpanic(\"should not\")\n\t}\n\treturn data.([]bidRecV2)\n}\n\n// chargeFee will charge amount - send from this contract to admin\nfunc chargeFee(amount int64, from std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", amount)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tcoins := checkCoin(from)\n\tufmt.Println(\"check balances: \", coins)\n\t// ufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// pay fee and claim the domain name if you are winner\nfunc Claim(domainName string) bool {\n\tif !bidStorages.Has(domainName) {\n\t\tpanic(\"claim: invalid domain name\")\n\t}\n\tcaller := std.GetOrigCaller()\n\t_, winner := findTheWinner(domainName)\n\tif caller.String() != winner.Bidder {\n\t\tpanic(\"only winner can claim\")\n\t}\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       caller,\n\t\tMode:         \"native\",\n\t}\n\tresult := executeRegister(requestInfo)\n\tif !result.Success {\n\t\tpanic(result.ResultDetails.Error())\n\t}\n\t// register done. Now charge the fee\n\tchargeFee(winner.Price, caller)\n\tfeeProcess(requestInfo)\n\treturn true\n}\n\n// expose winner price - amount of fee that user need to pay in Claim phase\nfunc GetWinnerPrice(dName string) int64 {\n\trec := GetCurrentWinner(dName)\n\tbaseRegisterFee := GetRegisterFee(dName)\n\treturn rec.Price + baseRegisterFee\n}\n"},{"name":"bidding_model.gno","body":"package registrar\n\nimport \"std\"\n\ntype bidStatus struct {\n\tDomainName    string\n\tStatus        string\n\tEndCommitTime int64\n\tEndPriceTime  int64\n}\n\ntype bidRecord struct {\n\tDomainName       string\n\tBidder           std.Address\n\tHashString       string\n\tPrice            int64\n\tStartTime        int64\n\tEndCommitTime    int64\n\tEndPriceTime     int64\n\tIsCommittedPrice bool\n\t// CurrentPhase  actionCode\n}\ntype bidRecV2 struct {\n\tDomainName       string\n\tBidder           string\n\tHashString       string\n\tPrice            int64\n\tStartTime        int64\n\tEndCommitTime    int64\n\tEndPriceTime     int64\n\tIsCommittedPrice bool\n\tIsCommittedHash  bool\n\tIsWinner         bool\n}\n"},{"name":"bidding_v39.gno","body":"package registrar\n\n// import (\n// \t\"std\"\n// \t\"strconv\"\n// \t\"time\"\n\n// \t\"gno.land/p/demo/ufmt\"\n// \t// \"gno.land/p/demo/mux\"\n// \t\"gno.land/p/demo/avl\"\n// )\n\n// var (\n// \tbidStorage *avl.Tree // bidRecord \u003c- []bidRec\n// \twinnerRec  *avl.Tree // dName \u003c- bidRec\n// \tjoinedBid  *avl.Tree // address \u003c- []string DomainName\n// )\n\n// func recordJoinedBid(domainName string) {\n// \tcaller := std.GetOrigCaller()\n// \tdList := []string{}\n// \tdata, existed := joinedBid.Get(caller.String())\n// \tif !existed {\n// \t\tdList = []string{domainName}\n// \t\tjoinedBid.Set(caller.String(), dList)\n// \t\treturn\n// \t}\n// \tdList = data.([]string)\n// \tdList = append(dList, domainName)\n// \tjoinedBid.Set(caller.String(), dList)\n// \treturn\n// }\n\n// // GetJoinedBid returns the status of an user's joined bid session information\n// func GetJoinedBid(caller string) []bidStatus {\n// \tdata, existed := joinedBid.Get(caller)\n// \tif !existed {\n// \t\treturn []bidStatus{}\n// \t}\n// \tlist := data.([]string)\n// \tlistStatus := []bidStatus{}\n// \tfor _, dName := range list {\n// \t\tstt := GetCurrentStatus(dName, caller)\n\n// \t\t// get the time stamp in [0] element and assign it to status\n// \t\tdata, _ := bidStorage.Get(dName)\n// \t\tbidRec := data.([]bidRecord)[0]\n\n// \t\tsingleStt := bidStatus{\n// \t\t\tDomainName:    dName,\n// \t\t\tStatus:        stt,\n// \t\t\tEndCommitTime: bidRec.EndCommitTime,\n// \t\t\tEndPriceTime:  bidRec.EndPriceTime,\n// \t\t}\n// \t\tlistStatus = append(listStatus, singleStt)\n// \t}\n// \treturn listStatus\n// }\n\n// // GetCurrentStatus returns the status of the bidding session about a domain name. This func requires caller to determine in case commited or not (hash or price)\n// func GetCurrentStatus(domainName string, caller string) string {\n// \t// if there is record in joinedBid -\u003e user joined\n// \t// check for tine.Now() and startTime\n// \tnow := time.Now().UnixMilli()\n// \towner := GetOwner(domainName)\n// \tif owner != \"\" {\n// \t\treturn \"owned by \" + owner.String()\n// \t}\n// \t// find the record\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\t// no record in bidRec yet -\u003e not commited -\u003e check if user started auction or not - if yes: new auction\n// \t\tif dataJoined, existedInRegister := joinedBid.Get(caller); existedInRegister {\n// \t\t\tdNameList := dataJoined.([]string)\n// \t\t\tfor _, dName := range dNameList {\n// \t\t\t\tif dName == domainName {\n// \t\t\t\t\treturn \"waiting for hash\"\n// \t\t\t\t}\n// \t\t\t\treturn \"domain name is free\"\n// \t\t\t}\n// \t\t}\n// \t\treturn \"domain name is free\"\n// \t}\n\n// \t// commited yet\n// \trecList := data.([]bidRecord)\n// \trec := recList[0]\n// \tendCommitTimeUnix := rec.EndCommitTime\n// \tendPriceTimeUnix := rec.EndPriceTime\n// \tif now \u003c endCommitTimeUnix {\n// \t\tif rec.HashString != \"\" {\n// \t\t\treturn \"commited hash\"\n// \t\t} else {\n// \t\t\treturn \"hash\"\n// \t\t}\n// \t}\n\n// \tufmt.Println(\"now: \", time.UnixMilli(now))\n// \tufmt.Println(\"endPriceTime: \", time.UnixMilli(endPriceTimeUnix))\n// \tif now \u003c endPriceTimeUnix \u0026\u0026 now \u003e endCommitTimeUnix {\n// \t\t// check if commited price\n// \t\tdata, _ := bidStorage.Get(domainName)\n// \t\tbidRecList := data.([]bidRecord)\n// \t\tthisRec := bidRecord{}\n// \t\tfor _, bidRec := range bidRecList {\n// \t\t\tif bidRec.Bidder.String() == caller {\n// \t\t\t\tthisRec = bidRec\n// \t\t\t}\n// \t\t}\n// \t\tif thisRec.IsCommittedPrice {\n// \t\t\treturn \"committed price\"\n// \t\t}\n// \t\treturn \"price\"\n// \t}\n// \tif now \u003e rec.EndPriceTime {\n// \t\t// check if dName is claiming by winner - check if winner existed\n// \t\tif data, existed := winnerRec.Get(domainName); existed {\n// \t\t\twinner := data.(bidRecord)\n// \t\t\treturn winner.Bidder.String() + \" is claiming domain name: \" + domainName\n// \t\t}\n// \t\treturn \"closed\"\n// \t}\n// \treturn \"undefined\"\n// }\n\n// // Render() renders welcome message :D\n// func Render(path string) string {\n// \treturn \"welcome to varmeta domain name service\"\n// }\n\n// // CommitHash consumes off-chain calculated hash string and the domain name that user want\n// func CommitHash(domainName, hashString string) string {\n// \tcaller := std.GetOrigCaller()\n\n// \t// use now as int64 representation of time.Now()\n// \tnow := time.Now().UnixMilli()\n\n// \t// update the bid record\n// \tdata, existed := bidStorage.Get(domainName)\n\n// \t// if not existed -\u003e create new record\n// \tif !existed {\n// \t\t// for further getStatus\n// \t\trecordJoinedBid(domainName)\n\n// \t\tvar bidRec bidRecord\n// \t\tendCommitTime := now + defaultCommitHashTime.Milliseconds()\n// \t\tendPriceTime := endCommitTime + defaultCommitPriceTime.Milliseconds()\n// \t\tufmt.Println(\"[HASH]: request at: \", time.UnixMilli(now))\n// \t\tufmt.Println(\"[HASH]: endCommitTime: \", time.UnixMilli(endCommitTime))\n// \t\tufmt.Println(\"[HASH]: endPriceTime: \", time.UnixMilli(endPriceTime))\n// \t\tbidRec = bidRecord{\n// \t\t\tDomainName:    domainName,\n// \t\t\tBidder:        caller,\n// \t\t\tHashString:    hashString,\n// \t\t\tStartTime:     now,\n// \t\t\tEndCommitTime: endCommitTime,\n// \t\t\tEndPriceTime:  endPriceTime,\n// \t\t}\n// \t\tbidRecList := []bidRecord{bidRec}\n// \t\tbidStorage.Set(domainName, bidRecList)\n\n// \t\t// charge fee\n// \t\tchargeFee(fee.BidJoinFee, caller)\n// \t\treturn \"new session\"\n// \t}\n// \t// if existed\n// \tbidRecList := data.([]bidRecord)\n// \tstartTime := bidRecList[0].StartTime\n// \toldEndCommitTimeUnix := bidRecList[0].EndCommitTime\n// \toldEndPriceTimeUnix := bidRecList[0].EndPriceTime\n// \tif now \u003e oldEndCommitTimeUnix {\n// \t\t// now := time.Now().UnixMilli()\n// \t\t// ufmt.Println(\"[HASH]: now: \", time.UnixMilli(now))\n// \t\tpanic(\"[HASH]: can not commit hash anymore\")\n// \t}\n// \tfor _, bR := range bidRecList {\n// \t\tif bR.Bidder == caller {\n// \t\t\tpanic(\"[HASH]: you already commited hash\")\n// \t\t}\n// \t}\n\n// \tbidRec := bidRecord{\n// \t\tDomainName:    domainName,\n// \t\tHashString:    hashString,\n// \t\tBidder:        caller,\n// \t\tStartTime:     startTime,\n// \t\tEndCommitTime: oldEndCommitTimeUnix,\n// \t\tEndPriceTime:  oldEndPriceTimeUnix,\n// \t}\n// \tbidRecList = append(bidRecList, bidRec)\n// \t// Save record\n// \tbidStorage.Set(domainName, bidRecList)\n// \t// charge commit hash fee\n// \tchargeFee(fee.BidJoinFee, caller)\n// \treturn \"existed\"\n// }\n\n// // for now we dont use panic because this will cause the permanent time.Now() stuck. IDK why // XXX fix me\n// // CommitPrice consumes price and secret string that user used in calculating hash string from off-chain. This will re-calculate the hashstring and compare with the one commited before\n// func CommitPrice(price int64, secret string, domainName string) string {\n// \t// compute the hash string, compare to saved hash string in record\n// \t// use int64 representation of time.Now()\n// \tnow := time.Now().UnixMilli()\n// \tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n// \tjoinedString := secret + strconv.Itoa(int(price))\n// \tcomputedHashString := Get256String(joinedString)\n// \tcaller := std.GetOrigCaller()\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"[PRICE]: domain name is invalid\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \twinnerRec.Set(domainName, bidRecList[len(bidRecList)-1])\n// \tufmt.Println(\"[PRICE] current winner set to: \", bidRecList[len(bidRecList)-1].Bidder.String())\n\n// \tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n// \tufmt.Println(\"[PRICE]: endPriceTime: \", time.UnixMilli(bidRecList[0].EndPriceTime))\n// \t// case commit after end - consider panic or not\n// \tif now \u003e bidRecList[0].EndPriceTime {\n// \t\tufmt.Println(\"[PRICE]: commit price phase is ended\")\n// \t\treturn \"ended\"\n// \t}\n// \t// case commit when price phase not started\n// \tif now \u003c= bidRecList[0].EndCommitTime {\n// \t\tufmt.Println(\"[PRICE]: commit price phase is not started yet\")\n// \t\treturn \"not started yet\"\n// \t}\n\n// \t// search for the corresponding hash\n// \tfor index, bidRec := range bidRecList {\n// \t\t// panic because wrong price or wrong secret string\n// \t\tif bidRec.Bidder == caller \u0026\u0026 bidRec.HashString != computedHashString {\n// \t\t\tpanic(\"[PRICE]: invalid hash string\")\n// \t\t}\n// \t\t// found it, update the winner price\n// \t\tif bidRec.Bidder == caller \u0026\u0026 bidRec.HashString == computedHashString {\n// \t\t\tdata, _ := winnerRec.Get(domainName)\n// \t\t\tcurrentWinnerRec := data.(bidRecord)\n// \t\t\tif price \u003e currentWinnerRec.Price \u0026\u0026 now \u003c currentWinnerRec.EndPriceTime {\n// \t\t\t\tufmt.Println(\"[PRICE]: found new winner, setting up\")\n// \t\t\t\tcurrentWinnerRec.Price = price\n// \t\t\t\tcurrentWinnerRec.Bidder = bidRec.Bidder\n// \t\t\t\tcurrentWinnerRec.HashString = bidRec.HashString\n// \t\t\t\tcurrentWinnerRec.StartTime = bidRec.StartTime\n// \t\t\t\tcurrentWinnerRec.EndCommitTime = bidRec.EndCommitTime\n// \t\t\t\tcurrentWinnerRec.EndPriceTime = bidRec.EndPriceTime\n// \t\t\t\twinnerRec.Set(domainName, currentWinnerRec)\n// \t\t\t\tufmt.Println(\"[PRICE] current winner set to: \", currentWinnerRec.Bidder)\n// \t\t\t\tbidRec.IsCommittedPrice = true\n// \t\t\t\t// set new bidRecord into bidRecList and save into storage\n// \t\t\t\tbidRecList[index] = bidRec\n// \t\t\t\tbidStorage.Set(domainName, bidRecList)\n// \t\t\t\treturn \"claim\"\n// \t\t\t}\n// \t\t}\n// \t}\n// \t// if not match above case, then panic\n// \tpanic(\"commit price failed\")\n// }\n\n// // GetCurrentWinner shows the current highest price user\n// func GetCurrentWinner(domainName string) bidRecord {\n// \tdata, existed := winnerRec.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"no winner yet\")\n// \t}\n// \treturn data.(bidRecord)\n// }\n\n// // find the highest bid in session - incase everyone commited price\n// // in old flow, we need to find the winner by retrievaling the bidStorage\n// func findTheWinner(domainName string) bidRecord {\n// \tvar winnerBid bidRecord\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"invalid domain name\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \twinnerBid = bidRecList[0]\n// \tfor _, bidRec := range bidRecList {\n// \t\tif bidRec.Price \u003e winnerBid.Price {\n// \t\t\twinnerBid = bidRec\n// \t\t}\n// \t}\n// \treturn winnerBid\n// }\n\n// // register the domain for winner\n// func registerForWinner(domainName string, winnerRec bidRecord) bool {\n// \twinnerAddr := winnerRec.Bidder\n// \trequestInfo := RequestInfo{\n// \t\tWantedDomain: domainName,\n// \t\tCaller:       winnerAddr,\n// \t\tMode:         \"native\",\n// \t}\n// \tresult := executeRegister(requestInfo)\n// \tif !result.Success {\n// \t\tpanic(result.ResultDetails.Error())\n// \t}\n// \t// register done. Now charge the fee\n// \tfeeProcess(requestInfo)\n// \treturn false\n// }\n\n// // everyone can call EndBid()\n// // this EndBid checks endTime -\u003e end the auction\n// func EndBid(domainName string) error {\n// \tnow := time.Now().UnixMilli()\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\treturn ufmt.Errorf(\"endbid: invalid domain name\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \tfirstBidRec := bidRecList[0]\n// \tif now \u003c firstBidRec.EndPriceTime {\n// \t\treturn ufmt.Errorf(\"endbid: this session can not end before the end time\")\n// \t}\n// \t// change all state\n// \t// for _, bidRec := range bidRecList {\n// \t// \tbidRec.IsOpen = false\n// \t// }\n// \tok := bidStorage.Set(domainName, bidRecList)\n// \tif !ok {\n// \t\treturn ufmt.Errorf(\"endbid: can not change bid record state\")\n// \t}\n// \t// need more conditions for findTheWinner()\n// \tfindTheWinner(domainName)\n// \treturn nil\n// }\n\n// // get all the price list that joined the bid for displaying in dapp\n// func GetRecords(dName string) []bidRecord {\n// \tdata, existed := bidStorage.Get(dName)\n// \tif !existed {\n// \t\tpanic(\"should not\")\n// \t}\n// \treturn data.([]bidRecord)\n// }\n\n// // chargeFee will charge amount - send from this contract to admin\n// func chargeFee(amount int64, from std.Address) {\n// \tbankerContract := std.CurrentRealm().Addr()\n// \tugnotCoin := std.NewCoin(\"ugnot\", amount)\n// \tcoinsToTransfer := std.NewCoins(ugnotCoin)\n// \tcoins := checkCoin(from)\n// \tufmt.Println(\"check balances: \", coins)\n// \t// ufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n// \tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n// }\n\n// // pay fee and claim the domain name if you are winner\n// func Claim(domainName string) bool {\n// \tdata, existed := winnerRec.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"claim: invalid domain name\")\n// \t}\n// \tcaller := std.GetOrigCaller()\n// \trec := data.(bidRecord)\n// \tif caller != rec.Bidder {\n// \t\tpanic(\"only winner can claim\")\n// \t}\n// \trequestInfo := RequestInfo{\n// \t\tWantedDomain: domainName,\n// \t\tCaller:       rec.Bidder,\n// \t\tMode:         \"native\",\n// \t}\n// \tresult := executeRegister(requestInfo)\n// \tif !result.Success {\n// \t\tpanic(result.ResultDetails.Error())\n// \t}\n// \t// register done. Now charge the fee\n// \tchargeFee(rec.Price, caller)\n// \tfeeProcess(requestInfo)\n// \treturn true\n// }\n\n// // expose winner price - amount of fee that user need to pay in Claim phase\n// func GetWinnerPrice(dName string) int64 {\n// \trec := GetCurrentWinner(dName)\n// \treturn rec.Price\n// }"},{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n\tBidJoinFee          int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\n// Admin set register fee and renewal fee\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tcaller := std.GetOrigCaller()\n\tcoins := checkCoin(caller)\n\tufmt.Println(\"check: \", coins)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(3)\n\terr := ufmt.Sprintf(\"unauthorize with caller: %s\\n\", caller)\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(err)\n\t}\n}\n\n// checking for availble coins\nfunc checkCoin(from std.Address) std.Coins {\n\t// caller := std.GetOrigCaller()\n\treturn bankerUser.GetCoins(from)\n}\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"hashstring.gno","body":"package registrar\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n)\n\nfunc Get256String(input string) string {\n\tdata := []byte(input)\n\thashed := sha256.Sum256(data)\n\thashedBytes := hashed[:]\n\treturn hex.EncodeToString(hashedBytes)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo/v405/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n\tMessage       string\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v405/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\t// bidStorage = avl.NewTree()\n\t// winnerRec = avl.NewTree()\n\t// joinedBid = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     100,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t\tBidJoinFee:          100,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n// changelogs 2: v2 - added sealed bidding logic - with default time xxx mins for each session\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v405/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\t// changelogs v2: we are using sealed bidding now\n\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := metadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"time\"\n)\n\nvar (\n\tdefaultCommitHashTime  = time.Second * 30\n\tdefaultCommitPriceTime = time.Second * 30\n\tdefaultExpireTime      = time.Hour // 30 days\n\treName                 = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tassertIsAdmin()\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n\nfunc SetCommitPhaseTime(duration int) {\n\tdefaultCommitHashTime = time.Duration(duration) * time.Second\n}\n\nfunc SetCommitPriceTime(duration int) {\n\tdefaultCommitPriceTime = time.Duration(duration) * time.Second\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"hDrXCnf4Skw0XMxlr24brmhYC9yoznqW6LsGu4nsUlsWeX1UkY72n3mFsxgELWPt+707PGDK32V7xVAmUFiZAg=="}],"memo":""},"blockNum":"1982177"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"resolver","path":"gno.land/r/varmeta/demo/v405/domain/resolver","files":[{"name":"checks_resolver.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage resolver\n\nimport (\n\t\"regexp\"\n\t\"time\"\n\n\t\"gno.land/r/varmeta/demo/v405/domain/registrar\"\n)\n\n// const (\n// \tadmin std.Address = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\" // -\u003e @thinhnx\n// )\n\nvar reName = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc isExpired(dName string) bool {\n\texpDate := registrar.GetExpirationDate(dName)\n\treturn expDate.Before(time.Now())\n}\n"},{"name":"errors.gno","body":"package resolver\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrNotFound          = errors.New(\"not found\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"invalid domain name to register\")\n)\n"},{"name":"resolver.gno","body":"/*\nThe goal of the Resolver contract is keep track of the address for each ICNS name in a stateful manner.\nIt serves the purpose of \"resolving\" the ICNS Name\nto the correct address (e.g \"alice.gno\" -\u003e g1xxx).\n*/\n// changelogs: move Register feature into this resolver package\n// changelogs2: Removed local storage of resolver as cache, and every querires we query to registrar to get the result\n\npackage resolver\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/varmeta/demo/v405/domain/registrar\"\n)\n\ntype Record struct {\n\tOwner    std.Address\n\tIsValid  bool\n\tMemo     string // no more need this\n\tPriority int\n}\n\n// retrieve the record list to get the onchain address\nfunc Resolve(domainName string) *Record {\n\tif !isValidDomain(domainName) {\n\t\tpanic(\"bad domain name\")\n\t}\n\trecord := \u0026Record{}\n\n\towner := getOwnerFromDomainStorage(domainName)\n\tif owner == \"\" {\n\t\trecord.Memo = \"not found\"\n\t\trecord.IsValid = false\n\t\treturn record\n\t}\n\n\tif !isExpired(domainName) {\n\t\trecord.IsValid = true\n\t\trecord.Owner = owner\n\t} else {\n\t\trecord.IsValid = false\n\t}\n\treturn record\n}\n\nfunc GetDomainName(addr string) []string {\n\treturn registrar.GetDomainName(addr)\n}\n\n/*\nIf query in local storage not found\nQuery to DomainStorage by domainName -\u003e get the registry -\u003e use that registry to get the Owner()\nand check the validation time?\n*/\n\nfunc existedInDomainStorage(domainName string) bool {\n\treturn registrar.AlreadyRegistered(domainName)\n}\n\nfunc getOwnerFromDomainStorage(domainName string) std.Address {\n\treturn registrar.GetOwner(domainName)\n}\n"},{"name":"resolver_metadata.gno","body":"package resolver\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v405/domain\"\n)\n\n// Metadata wrapper\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcrrTime := time.Now()\n\texpTime := crrTime.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", crrTime, expTime, []domain.Trait{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"TNstBr8UZEWiPe2aSAcAzQ0K+Rr5snxzufVvPuP6TN1yl0HY+fsaMJrTJfM52V18VzcBOKDu7w92LB+i82IocA=="}],"memo":""},"blockNum":"1982191"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["ngoc.gno","ea56fa8022639bfbf045c8d9cd37068cef58dd4669e61c913d1ab4dfe417d213"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"snWCcd783K9Eo/+ExmltxUBtAxbEnAH2CnosXx14vnhdu7ypjU3PSvPXLPv5gKikprwlQZWWOBsMKeTGZ85DHw=="}],"memo":""},"blockNum":"1982453"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["1","ngoc","ngoc.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"1YGSdth0Hdtncw6/36C/v3l5zjqh4PXSnUfv8JOTbZQlp8g6qAHDFpAuEztSvZ4N/d8ug5poadaNYP7QsEseUA=="}],"memo":""},"blockNum":"1982472"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["thinhnx.gno","5b82e76889397175ae86e58a633b4181d1a1f396f37fa2ed1c05423ec02da5b6"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"dE6BLYnLBpZ6kkobIOAw7xEAfY04WjHGDu+iRyJLgv4NK/0O5CSmyUaZfplKFzxGFnlWhc7/49XElV6twoEEWg=="}],"memo":""},"blockNum":"1982512"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["10","thinhnx","thinhnx.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"oPdxn06R+bB9BrL4Ra5zwTmhtZqxSC1EumqzkcP8JC5JqAmZqTtcK30h8jPKqsVA/oCkhoyhAW4Ow0CTSnDoKg=="}],"memo":""},"blockNum":"1982533"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"101ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"Claim","args":["ngoc.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"Utr9+JzTSdt5dI/2/qzedNgAsLk1zGcShfBez6yDpglDwau8eLF/VJdoO6zZ+rzxYFpwU7JpC0iQI7uDfinDKA=="}],"memo":""},"blockNum":"1982756"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["test10.gno","13321f6694db039f2cfc90e78420a401765b4e0185e7b80b5222a87d63c18c7c"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"ypsE92e/c0iNG0gmMxa0bHmujvJK9LWGOBwKezHRtNdgsHqRY55W0Q9RHPjk7jMXezgXqyB6P9ecyZz/UpyUmA=="}],"memo":""},"blockNum":"1982919"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["test10.gno","f6116854aa14ff95c17e3859924f3c07271c8426b116237859b393e0a89861ac"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"2igZfXURrFL30bbQLklUoi3oNyqOfnwtWEDGFIiXAzsLWqwDJo3vGHmzzZotxTPCJ2js7Tcwe+7AQLZp2SNeyA=="}],"memo":""},"blockNum":"1982920"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["1000","ngoc","test10.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"qtsIyKw/14Yn+uluJPmhBv51JbNqDWfD4RffRzOxni98WDtChyUzBHZnVsIgAbqN6V+2v0UONZQttNgntYCh7A=="}],"memo":""},"blockNum":"1982935"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["101","thinh","test10.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"ybPDMWEWv5bJiyohEhocotScClILWimrpVMfKB0m4KsGqQjDfFjVaXO2ZbKmLaHaTQ04WyZ/0VzpTkfzgAdOIg=="}],"memo":""},"blockNum":"1982937"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"1100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"Claim","args":["test10.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"gVXbxioTW6ogEKFpTmVd0nhBifJlUSgbDeyOgBIcrTlZEC2RYuJary9PYIb15mFulw5LX+Ihfyj3yXT/kUD5yw=="}],"memo":""},"blockNum":"1982980"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"KMDK3UT8W2c4sADtGysh7qOvb2S3uLBTkzKZIbOWIopVYBdbbfQXTFEMtVmI7xOqVLIUOSgAliGvofLJQGN60Q=="}],"memo":""},"blockNum":"1983251"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"GetJoinedBid","args":["g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"QHStVrr8IYABnL9O8+aaO/iOXNe0eygHVDqdZorJYAJJkgW88tvCIEviJ/J9FF6aZtrSRfWXSs64/svgfFwVng=="}],"memo":""},"blockNum":"1983878"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"grc721","path":"gno.land/p/varmeta/demo/v406/grc/grc721","files":[{"name":"basic_nft.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\nfunc (s *basicNFT) SetTokenURI(tid TokenID, tURI TokenURI) (bool, error) {\n\t// check for invalid TokenID\n\tif !s.exists(tid) {\n\t\treturn false, ErrInvalidTokenId\n\t}\n\n\t// check for the right owner\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn false, ErrCallerIsNotOwner\n\t}\n\ts.tokenURIs.Set(string(tid), string(tURI))\n\treturn true, nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.PrevRealm().Addr()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"},{"name":"basic_nft_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/uassert\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tname := dummy.Name()\n\tuassert.Equal(t, dummyNFTName, name)\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tsymbol := dummy.Symbol()\n\tuassert.Equal(t, dummyNFTSymbol, symbol)\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcount := dummy.TokenCount()\n\tuassert.Equal(t, uint64(0), count)\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tuassert.Equal(t, uint64(2), count)\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(0), balanceAddr1)\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr1, TokenID(\"2\"))\n\tdummy.mint(addr2, TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tbalanceAddr2, err := dummy.BalanceOf(addr2)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tuassert.Equal(t, uint64(2), balanceAddr1)\n\tuassert.Equal(t, uint64(1), balanceAddr2)\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\tdummy.mint(addr2, TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr2.String(), owner.String())\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tuassert.False(t, isApprovedForAll)\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tuassert.False(t, isApprovedForAll)\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tuassert.True(t, isApprovedForAll)\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n\n\terr = dummy.Approve(addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), approvedAddr.String())\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\tcaller := std.PrevRealm().Addr()\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfCaller)\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr)\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, uint64(1), balanceOfAddr)\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr.String(), owner.String())\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1, TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr1, TokenID(\"2\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\terr = dummy.Mint(addr2, TokenID(\"3\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2, TokenID(\"1\"))\n\tuassert.Error(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\tuassert.Equal(t, addr1.String(), owner.String())\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr, TokenID(\"1\"))\n\tdummy.mint(addr, TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"should not result in error\")\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tuassert.Error(t, err, \"should result in error\")\n}\n\nfunc TestSetTokenURI(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := std.Address(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\ttokenURI := \"http://example.com/token\"\n\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\t_, derr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI))\n\tuassert.NoError(t, derr, \"should not result in error\")\n\n\t// Test case: Invalid token ID\n\t_, err := dummy.SetTokenURI(TokenID(\"3\"), TokenURI(tokenURI))\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(std.Address(addr2)) // addr2\n\n\t_, cerr := dummy.SetTokenURI(TokenID(\"1\"), TokenURI(tokenURI)) // addr2 trying to set URI for token 1\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Retrieving TokenURI\n\tstd.TestSetOrigCaller(std.Address(addr1)) // addr1\n\n\tdummyTokenURI, err := dummy.TokenURI(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"TokenURI error\")\n\tuassert.Equal(t, string(tokenURI), string(dummyTokenURI))\n}\n"},{"name":"errors.gno","body":"package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n\n\t// ERC721Royalty\n\tErrInvalidRoyaltyPercentage     = errors.New(\"invalid royalty percentage\")\n\tErrInvalidRoyaltyPaymentAddress = errors.New(\"invalid royalty paymentAddress\")\n\tErrCannotCalculateRoyaltyAmount = errors.New(\"cannot calculate royalty amount\")\n)\n"},{"name":"grc721_metadata.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// metadataNFT represents an NFT with metadata extensions.\ntype metadataNFT struct {\n\t*basicNFT            // Embedded basicNFT struct for basic NFT functionality\n\textensions *avl.Tree // AVL tree for storing metadata extensions\n}\n\n// Ensure that metadataNFT implements the IGRC721MetadataOnchain interface.\nvar _ IGRC721MetadataOnchain = (*metadataNFT)(nil)\n\n// NewNFTWithMetadata creates a new basic NFT with metadata extensions.\nfunc NewNFTWithMetadata(name string, symbol string) *metadataNFT {\n\t// Create a new basic NFT\n\tnft := NewBasicNFT(name, symbol)\n\n\t// Return a metadataNFT with basicNFT embedded and an empty AVL tree for extensions\n\treturn \u0026metadataNFT{\n\t\tbasicNFT:   nft,\n\t\textensions: avl.NewTree(),\n\t}\n}\n\n// SetTokenMetadata sets metadata for a given token ID.\nfunc (s *metadataNFT) SetTokenMetadata(tid TokenID, metadata Metadata) error {\n\t// Check if the caller is the owner of the token\n\towner, err := s.basicNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set the metadata for the token ID in the extensions AVL tree\n\ts.extensions.Set(string(tid), metadata)\n\treturn nil\n}\n\n// TokenMetadata retrieves metadata for a given token ID.\nfunc (s *metadataNFT) TokenMetadata(tid TokenID) (Metadata, error) {\n\t// Retrieve metadata from the extensions AVL tree\n\tmetadata, found := s.extensions.Get(string(tid))\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidTokenId\n\t}\n\n\treturn metadata.(Metadata), nil\n}\n\n// mint mints a new token and assigns it to the specified address.\nfunc (s *metadataNFT) mint(to std.Address, tid TokenID) error {\n\t// Check if the address is valid\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the token ID already exists\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.basicNFT.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check if the token ID was minted by beforeTokenTransfer\n\tif s.basicNFT.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\t// Increment balance of the recipient address\n\ttoBalance, err := s.basicNFT.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.basicNFT.balances.Set(to.String(), toBalance)\n\n\t// Set owner of the token ID to the recipient address\n\ts.basicNFT.owners.Set(string(tid), to)\n\n\t// Emit transfer event\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.basicNFT.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n"},{"name":"grc721_metadata_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetMetadata(t *testing.T) {\n\t// Create a new dummy NFT with metadata\n\tdummy := NewNFTWithMetadata(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\t// Define addresses for testing purposes\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\t// Define metadata attributes\n\tname := \"test\"\n\tdescription := \"test\"\n\timage := \"test\"\n\timageData := \"test\"\n\texternalURL := \"test\"\n\tattributes := []Trait{}\n\tbackgroundColor := \"test\"\n\tanimationURL := \"test\"\n\tyoutubeURL := \"test\"\n\n\t// Set the original caller to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Mint a new token for addr1\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\t// Set metadata for token 1\n\tderr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if there was an error setting metadata\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenMetadata(TokenID(\"3\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, err, ErrInvalidTokenId)\n\n\t// Set the original caller to addr2\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\t// Try to set metadata for token 1 from addr2 (should fail)\n\tcerr := dummy.SetTokenMetadata(TokenID(\"1\"), Metadata{\n\t\tName:            name,\n\t\tDescription:     description,\n\t\tImage:           image,\n\t\tImageData:       imageData,\n\t\tExternalURL:     externalURL,\n\t\tAttributes:      attributes,\n\t\tBackgroundColor: backgroundColor,\n\t\tAnimationURL:    animationURL,\n\t\tYoutubeURL:      youtubeURL,\n\t})\n\n\t// Check if the error returned matches the expected error\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Set the original caller back to addr1\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\t// Retrieve metadata for token 1\n\tdummyMetadata, err := dummy.TokenMetadata(TokenID(\"1\"))\n\tuassert.NoError(t, err, \"Metadata error\")\n\n\t// Check if metadata attributes match expected values\n\tuassert.Equal(t, image, dummyMetadata.Image)\n\tuassert.Equal(t, imageData, dummyMetadata.ImageData)\n\tuassert.Equal(t, externalURL, dummyMetadata.ExternalURL)\n\tuassert.Equal(t, description, dummyMetadata.Description)\n\tuassert.Equal(t, name, dummyMetadata.Name)\n\tuassert.Equal(t, len(attributes), len(dummyMetadata.Attributes))\n\tuassert.Equal(t, backgroundColor, dummyMetadata.BackgroundColor)\n\tuassert.Equal(t, animationURL, dummyMetadata.AnimationURL)\n\tuassert.Equal(t, youtubeURL, dummyMetadata.YoutubeURL)\n}\n"},{"name":"grc721_royalty.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// royaltyNFT represents a non-fungible token (NFT) with royalty functionality.\ntype royaltyNFT struct {\n\t*metadataNFT                   // Embedding metadataNFT for NFT functionality\n\ttokenRoyaltyInfo     *avl.Tree // AVL tree to store royalty information for each token\n\tmaxRoyaltyPercentage uint64    // maxRoyaltyPercentage represents the maximum royalty percentage that can be charged every sale\n}\n\n// Ensure that royaltyNFT implements the IGRC2981 interface.\nvar _ IGRC2981 = (*royaltyNFT)(nil)\n\n// NewNFTWithRoyalty creates a new royalty NFT with the specified name, symbol, and royalty calculator.\nfunc NewNFTWithRoyalty(name string, symbol string) *royaltyNFT {\n\t// Create a new NFT with metadata\n\tnft := NewNFTWithMetadata(name, symbol)\n\n\treturn \u0026royaltyNFT{\n\t\tmetadataNFT:          nft,\n\t\ttokenRoyaltyInfo:     avl.NewTree(),\n\t\tmaxRoyaltyPercentage: 100,\n\t}\n}\n\n// SetTokenRoyalty sets the royalty information for a specific token ID.\nfunc (r *royaltyNFT) SetTokenRoyalty(tid TokenID, royaltyInfo RoyaltyInfo) error {\n\t// Validate the payment address\n\tif err := isValidAddress(royaltyInfo.PaymentAddress); err != nil {\n\t\treturn ErrInvalidRoyaltyPaymentAddress\n\t}\n\n\t// Check if royalty percentage exceeds maxRoyaltyPercentage\n\tif royaltyInfo.Percentage \u003e r.maxRoyaltyPercentage {\n\t\treturn ErrInvalidRoyaltyPercentage\n\t}\n\n\t// Check if the caller is the owner of the token\n\towner, err := r.metadataNFT.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrCallerIsNotOwner\n\t}\n\n\t// Set royalty information for the token\n\tr.tokenRoyaltyInfo.Set(string(tid), royaltyInfo)\n\n\treturn nil\n}\n\n// RoyaltyInfo returns the royalty information for the given token ID and sale price.\nfunc (r *royaltyNFT) RoyaltyInfo(tid TokenID, salePrice uint64) (std.Address, uint64, error) {\n\t// Retrieve royalty information for the token\n\tval, found := r.tokenRoyaltyInfo.Get(string(tid))\n\tif !found {\n\t\treturn \"\", 0, ErrInvalidTokenId\n\t}\n\n\troyaltyInfo := val.(RoyaltyInfo)\n\n\t// Calculate royalty amount\n\troyaltyAmount, _ := r.calculateRoyaltyAmount(salePrice, royaltyInfo.Percentage)\n\n\treturn royaltyInfo.PaymentAddress, royaltyAmount, nil\n}\n\nfunc (r *royaltyNFT) calculateRoyaltyAmount(salePrice, percentage uint64) (uint64, error) {\n\troyaltyAmount := (salePrice * percentage) / 100\n\treturn royaltyAmount, nil\n}\n"},{"name":"grc721_royalty_test.gno","body":"package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/uassert\"\n)\n\nfunc TestSetTokenRoyalty(t *testing.T) {\n\tdummy := NewNFTWithRoyalty(dummyNFTName, dummyNFTSymbol)\n\tuassert.True(t, dummy != nil, \"should not be nil\")\n\n\taddr1 := testutils.TestAddress(\"alice\")\n\taddr2 := testutils.TestAddress(\"bob\")\n\n\tpaymentAddress := testutils.TestAddress(\"john\")\n\tpercentage := uint64(10) // 10%\n\n\tsalePrice := uint64(1000)\n\texpectRoyaltyAmount := uint64(100)\n\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummy.mint(addr1, TokenID(\"1\"))\n\n\tderr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.NoError(t, derr, \"Should not result in error\")\n\n\t// Test case: Invalid token ID\n\terr := dummy.SetTokenRoyalty(TokenID(\"3\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, derr, ErrInvalidTokenId)\n\n\tstd.TestSetOrigCaller(addr2) // addr2\n\n\tcerr := dummy.SetTokenRoyalty(TokenID(\"1\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, cerr, ErrCallerIsNotOwner)\n\n\t// Test case: Invalid payment address\n\taerr := dummy.SetTokenRoyalty(TokenID(\"4\"), RoyaltyInfo{\n\t\tPaymentAddress: std.Address(\"###\"), // invalid address\n\t\tPercentage:     percentage,\n\t})\n\tuassert.ErrorIs(t, aerr, ErrInvalidRoyaltyPaymentAddress)\n\n\t// Test case: Invalid percentage\n\tperr := dummy.SetTokenRoyalty(TokenID(\"5\"), RoyaltyInfo{\n\t\tPaymentAddress: paymentAddress,\n\t\tPercentage:     uint64(200), // over maxRoyaltyPercentage\n\t})\n\tuassert.ErrorIs(t, perr, ErrInvalidRoyaltyPercentage)\n\n\t// Test case: Retrieving Royalty Info\n\tstd.TestSetOrigCaller(addr1) // addr1\n\n\tdummyPaymentAddress, dummyRoyaltyAmount, rerr := dummy.RoyaltyInfo(TokenID(\"1\"), salePrice)\n\tuassert.NoError(t, rerr, \"RoyaltyInfo error\")\n\tuassert.Equal(t, paymentAddress, dummyPaymentAddress)\n\tuassert.Equal(t, expectRoyaltyAmount, dummyRoyaltyAmount)\n}\n"},{"name":"igrc721.gno","body":"package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSetTokenURI(tid TokenID, tURI TokenURI) (bool, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, tid TokenID) error\n}\n\ntype (\n\tTokenID  string\n\tTokenURI string\n)\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"},{"name":"igrc721_metadata.gno","body":"package grc721\n\n// IGRC721CollectionMetadata describes basic information about an NFT collection.\ntype IGRC721CollectionMetadata interface {\n\tName() string   // Name returns the name of the collection.\n\tSymbol() string // Symbol returns the symbol of the collection.\n}\n\n// IGRC721Metadata follows the Ethereum standard\ntype IGRC721Metadata interface {\n\tIGRC721CollectionMetadata\n\tTokenURI(tid TokenID) (string, error) // TokenURI returns the URI of a specific token.\n}\n\n// IGRC721Metadata follows the OpenSea metadata standard\ntype IGRC721MetadataOnchain interface {\n\tIGRC721CollectionMetadata\n\tTokenMetadata(tid TokenID) (Metadata, error)\n}\n\ntype Trait struct {\n\tDisplayType string\n\tTraitType   string\n\tValue       string\n}\n\n// see: https://docs.opensea.io/docs/metadata-standards\ntype Metadata struct {\n\tImage           string  // URL to the image of the item. Can be any type of image (including SVGs, which will be cached into PNGs by OpenSea), IPFS or Arweave URLs or paths. We recommend using a minimum 3000 x 3000 image.\n\tImageData       string  // Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.\n\tExternalURL     string  // URL that will appear below the asset's image on OpenSea and will allow users to leave OpenSea and view the item on your site.\n\tDescription     string  // Human-readable description of the item. Markdown is supported.\n\tName            string  // Name of the item.\n\tAttributes      []Trait // Attributes for the item, which will show up on the OpenSea page for the item.\n\tBackgroundColor string  // Background color of the item on OpenSea. Must be a six-character hexadecimal without a pre-pended #\n\tAnimationURL    string  // URL to a multimedia attachment for the item. Supported file extensions: GLTF, GLB, WEBM, MP4, M4V, OGV, OGG, MP3, WAV, OGA, HTML (for rich experiences and interactive NFTs using JavaScript canvas, WebGL, etc.). Scripts and relative paths within the HTML page are now supported. Access to browser extensions is not supported.\n\tYoutubeURL      string  // URL to a YouTube video (only used if animation_url is not provided).\n}\n"},{"name":"igrc721_royalty.gno","body":"package grc721\n\nimport \"std\"\n\n// IGRC2981 follows the Ethereum standard\ntype IGRC2981 interface {\n\t// RoyaltyInfo retrieves royalty information for a tokenID and salePrice.\n\t// It returns the payment address, royalty amount, and an error if any.\n\tRoyaltyInfo(tokenID TokenID, salePrice uint64) (std.Address, uint64, error)\n}\n\n// RoyaltyInfo represents royalty information for a token.\ntype RoyaltyInfo struct {\n\tPaymentAddress std.Address // PaymentAddress is the address where royalty payment should be sent.\n\tPercentage     uint64      // Percentage is the royalty percentage. It indicates the percentage of royalty to be paid for each sale. For example : Percentage = 10 =\u003e 10%\n}\n"},{"name":"util.gno","body":"package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif !addr.IsValid() {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"GUXO7uOXLFp/oK1idfHcL9O10ao0NLfvsP5ISI3OzFJADA5Oi4kC5QsR1Bjciqvsvw68FNylmTnavUb6FkQmZw=="}],"memo":""},"blockNum":"1983911"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"domain","path":"gno.land/p/varmeta/demo/v406/domain","files":[{"name":"domain_metadata.gno","body":"package domain\n\nimport (\n\t\"time\"\n)\n\n// Trait represents a key-value pair with an optional display type for metadata attributes\ntype Trait struct {\n\tDisplayType string // Optional display type (e.g., \"date\", \"number\", etc.)\n\tTraitType   string // Type of the trait (e.g., \"age\", \"height\", etc.)\n\tValue       string // Value of the trait\n}\n\n// Metadata represents the metadata associated with a domain\ntype Metadata struct {\n\tAvatar           string    // URL or identifier for an avatar image\n\tRegistrationTime time.Time // The time when the domain was registered\n\tExpirationTime   time.Time // The time when the domain will be expire\n\tAttributes       []Trait   // Additional attributes of the domain\n\tDescription      string    // A description of the domain\n\tContactInfo      string    // Contact information for the domain owner\n\tRenewalFee       string    // The fee required to renew the domain, represented as a string\n}\n\n// NewMetadata creates a new Metadata instance\nfunc NewMetadata(avatar, description, contactInfo, renewalFee string,\n\tregistrationTime, expirationTime time.Time, attributes []Trait,\n) Metadata {\n\treturn Metadata{\n\t\tAvatar:           avatar,\n\t\tRegistrationTime: registrationTime,\n\t\tExpirationTime:   expirationTime,\n\t\tRenewalFee:       renewalFee,\n\t\tAttributes:       attributes,\n\t\tDescription:      description,\n\t\tContactInfo:      contactInfo,\n\t}\n}\n"},{"name":"domain_registry.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v406/grc/grc721\"\n)\n\n// domainRegistry represents a registry for domain names with metadata\ntype domainRegistry struct {\n\tdomains  grc721.IGRC721 // Interface for basic NFT functionality\n\tmetadata *avl.Tree      // AVL tree for storing domain metadata\n\texpDate  time.Time\n}\n\n// DomainRegistry defines the methods for managing domain names and metadata\ntype DomainRegistry interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(domainName string) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, domainName string) error\n\tTransferFrom(from, to std.Address, domainName string) error\n\tApprove(approved std.Address, domainName string) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(domainName string) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n\tMint(to std.Address, domainName string) error\n\n\tRegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error\n\tSetDomainData(domainName string, metadata Metadata) error\n\tGetDomainData(domainName string, field MetadataField) (Metadata, error)\n\tGetDomainFields(domainName string, fields []MetadataField) (Metadata, error)\n\tRenewDomain(domainName string, additionalDuration time.Duration) error\n\tGetExpirationDate(domainName string) time.Time\n\tSetExpirationDate(domainName string, expDate time.Time) bool\n}\n\n// NewDomainRegistry creates a new domain registry with metadata extensions\nfunc NewDomainRegistry(name, symbol string) *domainRegistry {\n\tregistry := grc721.NewBasicNFT(name, symbol)\n\n\treturn \u0026domainRegistry{\n\t\tdomains:  registry,\n\t\tmetadata: avl.NewTree(),\n\t}\n}\n\n// RegisterDomain registers a new domain with the given metadata\nfunc (d *domainRegistry) RegisterDomain(owner std.Address, domainName string, metadata Metadata, dur time.Duration) error {\n\terr := d.domains.Mint(owner, grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\td.expDate = time.Now().Add(dur)\n\td.metadata.Set(domainName, metadata)\n\n\treturn nil\n}\n\n// RenewDomain extends the expiration time of a domain name\nfunc (d *domainRegistry) RenewDomain(domainName string, additionalDuration time.Duration) error {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn ErrInvalidDomainName\n\t}\n\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\t// set new expiration date\n\td.expDate = d.expDate.Add(additionalDuration)\n\treturn nil\n}\n\n// SetDomainData sets the metadata for a given domain name\nfunc (d *domainRegistry) SetDomainData(domainName string, metadata Metadata) error {\n\towner, err := d.domains.OwnerOf(grc721.TokenID(domainName))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaller := std.PrevRealm().Addr()\n\tif caller != owner {\n\t\treturn ErrUnauthorized\n\t}\n\n\td.metadata.Set(domainName, metadata)\n\treturn nil\n}\n\n// GetDomainFields retrieves multiple fields of metadata for a given domain\nfunc (d *domainRegistry) GetDomainFields(domainName string, fields []MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tif len(fields) == 0 {\n\t\treturn metadata, nil\n\t}\n\n\tvar result Metadata\n\tfor _, field := range fields {\n\t\tswitch field {\n\t\tcase FieldAvatar:\n\t\t\tresult.Avatar = metadata.Avatar\n\t\tcase FieldRegistrationTime:\n\t\t\tresult.RegistrationTime = metadata.RegistrationTime\n\t\tcase FieldExpirationTime:\n\t\t\tresult.ExpirationTime = metadata.ExpirationTime\n\t\tcase FieldRenewalFee:\n\t\t\tresult.RenewalFee = metadata.RenewalFee\n\t\tcase FieldAttributes:\n\t\t\tresult.Attributes = metadata.Attributes\n\t\tcase FieldDescription:\n\t\t\tresult.Description = metadata.Description\n\t\tcase FieldContactInfo:\n\t\t\tresult.ContactInfo = metadata.ContactInfo\n\t\tdefault:\n\t\t\treturn Metadata{}, ErrInvalidMetadataField\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// GetDomainData retrieves metadata for a given domain\nfunc (d *domainRegistry) GetDomainData(domainName string, field MetadataField) (Metadata, error) {\n\tdata, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn Metadata{}, ErrInvalidDomainName\n\t}\n\n\tmetadata := data.(Metadata)\n\n\tswitch field {\n\tcase FieldAvatar:\n\t\treturn Metadata{\n\t\t\tAvatar: metadata.Avatar,\n\t\t}, nil\n\tcase FieldRegistrationTime:\n\t\treturn Metadata{\n\t\t\tRegistrationTime: metadata.RegistrationTime,\n\t\t}, nil\n\tcase FieldExpirationTime:\n\t\treturn Metadata{\n\t\t\tExpirationTime: metadata.ExpirationTime,\n\t\t}, nil\n\tcase FieldRenewalFee:\n\t\treturn Metadata{\n\t\t\tRenewalFee: metadata.RenewalFee,\n\t\t}, nil\n\tcase FieldAttributes:\n\t\treturn Metadata{\n\t\t\tAttributes: metadata.Attributes,\n\t\t}, nil\n\tcase FieldDescription:\n\t\treturn Metadata{\n\t\t\tDescription: metadata.Description,\n\t\t}, nil\n\tcase FieldContactInfo:\n\t\treturn Metadata{\n\t\t\tContactInfo: metadata.ContactInfo,\n\t\t}, nil\n\tdefault:\n\t\treturn Metadata{}, ErrInvalidMetadataField\n\t}\n}\n\n// BalanceOf returns the number of domains owned by a given address\nfunc (d *domainRegistry) BalanceOf(owner std.Address) (uint64, error) {\n\treturn d.domains.BalanceOf(owner)\n}\n\n// OwnerOf returns the owner of a given domain name\nfunc (d *domainRegistry) OwnerOf(domainName string) (std.Address, error) {\n\treturn d.domains.OwnerOf(grc721.TokenID(domainName))\n}\n\n// SafeTransferFrom safely transfers a domain from one address to another\nfunc (d *domainRegistry) SafeTransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.SafeTransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// TransferFrom transfers a domain from one address to another\nfunc (d *domainRegistry) TransferFrom(from, to std.Address, domainName string) error {\n\treturn d.domains.TransferFrom(from, to, grc721.TokenID(domainName))\n}\n\n// Approve grants approval to another address to manage a specific domain\nfunc (d *domainRegistry) Approve(approved std.Address, domainName string) error {\n\treturn d.domains.Approve(approved, grc721.TokenID(domainName))\n}\n\n// SetApprovalForAll sets approval for an operator to manage all domains of the owner\nfunc (d *domainRegistry) SetApprovalForAll(operator std.Address, approved bool) error {\n\treturn d.domains.SetApprovalForAll(operator, approved)\n}\n\n// GetApproved returns the approved address for a specific domain\nfunc (d *domainRegistry) GetApproved(domainName string) (std.Address, error) {\n\treturn d.domains.GetApproved(grc721.TokenID(domainName))\n}\n\n// IsApprovedForAll checks if an operator is approved to manage all domains of the owner\nfunc (d *domainRegistry) IsApprovedForAll(owner, operator std.Address) bool {\n\treturn d.domains.IsApprovedForAll(owner, operator)\n}\n\n// Mint creates a new domain for a given address\nfunc (d *domainRegistry) Mint(to std.Address, domainName string) error {\n\treturn d.domains.Mint(to, grc721.TokenID(domainName))\n}\n\nfunc (d *domainRegistry) GetExpirationDate(domainName string) time.Time {\n\treturn d.expDate\n}\n\nfunc (d *domainRegistry) SetExpirationDate(domainName string, expDate time.Time) bool {\n\t_, found := d.metadata.Get(domainName)\n\tif !found {\n\t\treturn false\n\t}\n\td.expDate = expDate\n\treturn true\n}\n"},{"name":"domain_registry_test.gno","body":"package domain\n\nimport (\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/p/demo/urequire\"\n\t\"gno.land/p/varmeta/demo/v406/grc/grc721\"\n)\n\nvar (\n\taddr1 = testutils.TestAddress(\"bob\")\n\taddr2 = testutils.TestAddress(\"alice\")\n)\n\nfunc TestRegisterDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Successful Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"contact@registered.com\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Duplicate Registration\",\n\t\t\towner:      addr1,\n\t\t\tdomainName: \"registered.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A registered domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\terr := registry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.owner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\tmetadata    Metadata\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:       \"Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr1,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-Owner Sets Metadata\",\n\t\t\towner:      addr1,\n\t\t\tcaller:     addr2,\n\t\t\tdomainName: \"test.gno\",\n\t\t\tmetadata: Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, c.metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\t\t\terr := registry.SetDomainData(c.domainName, c.metadata)\n\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\tretrievedMetadata, err := registry.GetDomainData(c.domainName, FieldAvatar)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.metadata.Avatar, retrievedMetadata.Avatar)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRenewDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname           string\n\t\towner          std.Address\n\t\tcaller         std.Address\n\t\tdomainName     string\n\t\tadditionalTime time.Duration\n\t\texpectError    bool\n\t\texpectedExpiry time.Time\n\t}{\n\t\t{\n\t\t\tname:           \"Successful Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr1,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"Non-Owner Attempts Renewal\",\n\t\t\towner:          addr1,\n\t\t\tcaller:         addr2,\n\t\t\tdomainName:     \"renewable.gno\",\n\t\t\tadditionalTime: 30 * 24 * time.Hour,\n\t\t\texpectError:    true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A renewable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.RenewDomain(c.domainName, c.additionalTime)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrUnauthorized.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\trenewedMetadata, err := registry.GetDomainData(c.domainName, FieldExpirationTime)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\t// urequire.True(t, renewedMetadata.ExpirationTime.After(metadata.ExpirationTime))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainData(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfield       MetadataField\n\t\texpectError bool\n\t\texpectedVal string\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Avatar\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: false,\n\t\t\texpectedVal: \"avatar_url\",\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain Name\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfield:       FieldAvatar,\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t_, err := registry.GetDomainData(c.domainName, c.field)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDomainFields(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\tdomainName  string\n\t\tfields      []MetadataField\n\t\texpectError bool\n\t\texpected    Metadata\n\t}{\n\t\t{\n\t\t\tname:        \"Retrieve Multiple Fields\",\n\t\t\tdomainName:  \"test.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar, FieldDescription, FieldContactInfo},\n\t\t\texpectError: false,\n\t\t\texpected: Metadata{\n\t\t\t\tAvatar:      \"avatar_url\",\n\t\t\t\tDescription: \"A test domain\",\n\t\t\t\tContactInfo: \"gno_name_service@gno.land\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid Domain\",\n\t\t\tdomainName:  \"invalid.gno\",\n\t\t\tfields:      []MetadataField{FieldAvatar},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif !c.expectError {\n\t\t\t\towner := addr1\n\t\t\t\tstd.TestSetRealm(std.NewUserRealm(owner))\n\t\t\t\tstd.TestSetOrigCaller(owner)\n\n\t\t\t\tmetadata := Metadata{\n\t\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\t\tDescription:      \"A test domain\",\n\t\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t\t}\n\n\t\t\t\terr := registry.RegisterDomain(owner, c.domainName, metadata)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t}\n\n\t\t\tretrievedMetadata, err := registry.GetDomainFields(c.domainName, c.fields)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), ErrInvalidDomainName.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.expected.Avatar, retrievedMetadata.Avatar)\n\t\t\t\turequire.Equal(t, c.expected.Description, retrievedMetadata.Description)\n\t\t\t\turequire.Equal(t, c.expected.ContactInfo, retrievedMetadata.ContactInfo)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTransferDomain(t *testing.T) {\n\tregistry := NewDomainRegistry(\"GNO Name Service\", \"GNS\")\n\n\tcases := []struct {\n\t\tname        string\n\t\towner       std.Address\n\t\tnewOwner    std.Address\n\t\tcaller      std.Address\n\t\tdomainName  string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"Successful Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr1,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Non-Owner Attempts Transfer\",\n\t\t\towner:       addr1,\n\t\t\tnewOwner:    addr2,\n\t\t\tcaller:      addr2,\n\t\t\tdomainName:  \"transfer.gno\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.owner))\n\t\t\tstd.TestSetOrigCaller(c.owner)\n\n\t\t\tmetadata := Metadata{\n\t\t\t\tAvatar:           \"avatar_url\",\n\t\t\t\tRegistrationTime: time.Now(),\n\t\t\t\tExpirationTime:   time.Now().Add(365 * 24 * time.Hour),\n\t\t\t\tDescription:      \"A transferable domain\",\n\t\t\t\tContactInfo:      \"gno_name_service@gno.land\",\n\t\t\t}\n\n\t\t\tregistry.RegisterDomain(c.owner, c.domainName, metadata)\n\n\t\t\tstd.TestSetRealm(std.NewUserRealm(c.caller))\n\t\t\tstd.TestSetOrigCaller(c.caller)\n\n\t\t\terr := registry.TransferFrom(c.owner, c.newOwner, c.domainName)\n\t\t\tif c.expectError {\n\t\t\t\turequire.Error(t, err)\n\t\t\t\turequire.Equal(t, err.Error(), grc721.ErrTransferFromIncorrectOwner.Error())\n\t\t\t} else {\n\t\t\t\turequire.NoError(t, err)\n\n\t\t\t\tretrievedOwner, err := registry.OwnerOf(c.domainName)\n\t\t\t\turequire.NoError(t, err)\n\t\t\t\turequire.Equal(t, c.newOwner, retrievedOwner)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"errors.gno","body":"package domain\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnauthorized         = errors.New(\"caller is not domain owner\")\n\tErrInvalidDomainName    = errors.New(\"invalid domain name\")\n\tErrInvalidMetadataField = errors.New(\"invalid metadata field\")\n\tErrInsufficientFunds    = errors.New(\"insufficient funds for renewal\")\n)\n"},{"name":"utils.gno","body":"package domain\n\ntype MetadataField int\n\nconst (\n\tFieldAvatar MetadataField = iota\n\tFieldRegistrationTime\n\tFieldRenewalFee\n\tFieldExpirationTime\n\tFieldAttributes\n\tFieldDescription\n\tFieldContactInfo\n)\n"}]},"deposit":""}],"fee":{"gas_wanted":"6000000","gas_fee":"100ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"R48Q5CryfBtiGGCqNbnBNMYaTgdZOOVYmFp72JwMIF0TS3iYpnadcOucHGy2YMvJoFsoVN+mZoTS3tkFdCIiag=="}],"memo":""},"blockNum":"1983929"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"registrar","path":"gno.land/r/varmeta/demo/v406/domain/registrar","files":[{"name":"bidding.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\t// \"gno.land/p/demo/mux\"\n\t\"gno.land/p/demo/avl\"\n)\n\n// I want to redesign this codebase\n\n// all keys are domainName\nvar bidStorages avl.Tree // dName \u003c=- []bidRecV2\n\n// record new joined bid\nfunc record2Storage(domainName string) {\n\tcaller := std.GetOrigCaller()\n\tnow := time.Now().UnixMilli()\n\tnewRec := bidRecV2{\n\t\tBidder:     caller.String(),\n\t\tDomainName: domainName,\n\t\tStartTime:  now,\n\t\t//...\n\t}\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tbidStorages.Set(domainName, newRec)\n\t}\n\tbidRecList := data.([]bidRecV2)\n\toldStartTime := bidRecList[0].StartTime\n\tnewRec.StartTime = oldStartTime\n\tbidRecList = append(bidRecList, newRec)\n\tbidStorages.Set(domainName, bidRecList)\n}\n\n// GetJoinedBid returns the status of an user's joined bid session information\nfunc GetJoinedBid(caller string) []bidStatus {\n\tdNameList := []string{}\n\t// Iterate the bidStorages, which domainName has Bidder == caller -\u003e take domainNames\n\tbidStorages.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tdataList := value.([]bidRecV2)\n\t\tfor _, rec := range dataList {\n\t\t\tif rec.Bidder == caller {\n\t\t\t\tufmt.Println(\"key to append: \", key)\n\t\t\t\tdNameList = append(dNameList, key)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n\tufmt.Println(\"len: \", len(dNameList))\n\t// after get dNameList of a caller, we check status of each dName\n\tlistStatus := []bidStatus{}\n\tfor _, dName := range dNameList {\n\t\tstt := GetCurrentStatus(dName, caller)\n\t\t// get the time stamp in [0] element and assign it to status\n\t\tdata, _ := bidStorages.Get(dName)\n\t\tbidRec := data.([]bidRecV2)[0]\n\t\tactiveCount := getActiveCount(dName)\n\t\tsingleStt := bidStatus{\n\t\t\tDomainName:    dName,\n\t\t\tStatus:        stt,\n\t\t\tEndCommitTime: bidRec.EndCommitTime,\n\t\t\tEndPriceTime:  bidRec.EndPriceTime,\n\t\t\tActiveUsers:   activeCount,\n\t\t}\n\t\tlistStatus = append(listStatus, singleStt)\n\t}\n\tufmt.Println(\"len of list status: \", len(listStatus))\n\treturn listStatus\n}\n\nfunc Get(domainName string) ([]string, []string, []int64) {\n\tdata, _ := bidStorages.Get(domainName)\n\tlist := data.([]bidRecV2)\n\tdNameList := []string{}\n\thashList := []string{}\n\tpList := []int64{}\n\tfor _, rec := range list {\n\t\tdNameList = append(dNameList, rec.Bidder)\n\t\thashList = append(hashList, rec.HashString)\n\t\tpList = append(pList, rec.Price)\n\t}\n\treturn dNameList, hashList, pList\n}\n\n/*\n\tI want the CommitHash and CommitPrice will change the status of the record, by this way, we can detect\n\tthe current state of a bidding session for each user\n*/\n\n// GetCurrentStatus returns the status of the bidding session about a domain name. This func requires caller to determine in case Committed or not (hash or price)\nfunc GetCurrentStatus(domainName string, caller string) string {\n\t// if there is record in joinedBid -\u003e user joined\n\t// check for tine.Now() and startTime\n\tnow := time.Now().UnixMilli()\n\t// if domain name is owned already\n\towner := GetOwner(domainName)\n\tif owner != \"\" {\n\t\treturn \"owned by \" + owner.String()\n\t}\n\t// find the record\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\t// no record in bidRec yet -\u003e not Committed -\u003e check if user started auction or not - if yes: new auction\n\t\treturn \"domain name is free\"\n\t}\n\trecList := data.([]bidRecV2)\n\trec0 := recList[0]\n\t// Auction closed with winner\n\tif rec0.EndPriceTime \u003c= now \u0026\u0026 owner != \"\" {\n\t\treturn \"close\"\n\t}\n\t// find the record of the caller\n\tfor _, rec := range recList {\n\t\tswitch {\n\t\t// Waiting for hash commitment\n\t\tcase !rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.StartTime \u003c= now \u0026\u0026 rec.EndCommitTime \u003e now:\n\t\t\treturn \"waiting hash\"\n\n\t\t// Committed hash\n\t\tcase rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.StartTime \u003c= now \u0026\u0026 rec.EndCommitTime \u003e now:\n\t\t\treturn \"committed hash\"\n\n\t\t// Waiting for price commitment\n\t\tcase rec.IsCommittedHash \u0026\u0026 !rec.IsCommittedPrice \u0026\u0026 rec.EndCommitTime \u003c= now \u0026\u0026 rec.EndPriceTime \u003e now:\n\t\t\treturn \"waiting price\"\n\n\t\t// Committed price\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 rec.EndCommitTime \u003c= now \u0026\u0026 rec.EndPriceTime \u003e now:\n\t\t\treturn \"committed price\"\n\n\t\t// Winner claiming domain\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 rec.IsWinner \u0026\u0026 rec.EndPriceTime \u003c= now:\n\t\t\treturn rec.Bidder + \" is claiming domain name: \" + domainName\n\t\t// find the winner\n\t\tcase rec.IsCommittedHash \u0026\u0026 rec.IsCommittedPrice \u0026\u0026 !rec.IsWinner \u0026\u0026 rec.EndPriceTime \u003c= now:\n\t\t\t_, winnerRec := findTheWinner(domainName)\n\t\t\treturn winnerRec.Bidder + \" is claiming domain name: \" + domainName\n\t\t// Missed hash commitment deadline\n\t\tcase !rec.IsCommittedHash \u0026\u0026 rec.EndCommitTime \u003c= now:\n\t\t\treturn \"waiting for hash\"\n\t\t}\n\t}\n\n\treturn \"undefined\"\n}\n\n// CommitHash consumes off-chain calculated hash string and the domain name that user want\nfunc CommitHash(domainName, hashString string) string {\n\tcaller := std.GetOrigCaller()\n\n\t// use now as int64 representation of time.Now()\n\tnow := time.Now().UnixMilli()\n\n\t// update the bid record\n\tdata, existed := bidStorages.Get(domainName)\n\n\t// if not existed -\u003e create new record\n\tif !existed {\n\t\t// for further getStatus\n\t\t// record2Storage(domainName)\n\n\t\tvar bidRec bidRecV2\n\t\tendCommitTime := now + defaultCommitHashTime.Milliseconds()\n\t\tendPriceTime := endCommitTime + defaultCommitPriceTime.Milliseconds()\n\t\tufmt.Println(\"[HASH]: request at: \", time.UnixMilli(now))\n\t\tufmt.Println(\"[HASH]: endCommitTime: \", time.UnixMilli(endCommitTime))\n\t\tufmt.Println(\"[HASH]: endPriceTime: \", time.UnixMilli(endPriceTime))\n\t\tbidRec = bidRecV2{\n\t\t\tDomainName:       domainName,\n\t\t\tBidder:           caller.String(),\n\t\t\tHashString:       hashString,\n\t\t\tStartTime:        now,\n\t\t\tEndCommitTime:    endCommitTime,\n\t\t\tEndPriceTime:     endPriceTime,\n\t\t\tIsCommittedHash:  true,\n\t\t\tIsCommittedPrice: false,\n\t\t\tIsWinner:         true,\n\t\t\tPrice:            0,\n\t\t}\n\t\tbidNewRec := []bidRecV2{bidRec}\n\t\tbidStorages.Set(domainName, bidNewRec)\n\n\t\t// charge fee\n\t\tchargeFee(fee.BidJoinFee, std.Address(caller))\n\t\treturn \"new session\"\n\t}\n\t// if existed\n\tbidRecList := data.([]bidRecV2)\n\tstartTime := bidRecList[0].StartTime\n\toldEndCommitTimeUnix := bidRecList[0].EndCommitTime\n\toldEndPriceTimeUnix := bidRecList[0].EndPriceTime\n\tif now \u003e oldEndCommitTimeUnix {\n\t\t// now := time.Now().UnixMilli()\n\t\t// ufmt.Println(\"[HASH]: now: \", time.UnixMilli(now))\n\t\tpanic(\"[HASH]: can not commit hash anymore\")\n\t}\n\tfor _, bR := range bidRecList {\n\t\tif bR.Bidder == caller.String() {\n\t\t\tpanic(\"[HASH]: you already committed hash\")\n\t\t}\n\t}\n\n\tnewRec := bidRecV2{\n\t\tDomainName:       domainName,\n\t\tHashString:       hashString,\n\t\tBidder:           caller.String(),\n\t\tStartTime:        startTime,\n\t\tEndCommitTime:    oldEndCommitTimeUnix,\n\t\tEndPriceTime:     oldEndPriceTimeUnix,\n\t\tIsCommittedHash:  true,\n\t\tIsCommittedPrice: false,\n\t\tIsWinner:         false,\n\t}\n\t// append the list, set it to storage\n\tbidRecList = append(bidRecList, newRec)\n\tufmt.Println(\"len bidRecList: \", len(bidRecList))\n\t// Save record\n\tbidStorages.Set(domainName, bidRecList)\n\t// charge commit hash fee\n\tufmt.Println(\"saved hash: \", hashString)\n\tchargeFee(fee.BidJoinFee, caller)\n\treturn \"existed\"\n}\n\n// for now we dont use panic because this will cause the permanent time.Now() stuck. IDK why // XXX fix me\n// CommitPrice consumes price and secret string that user used in calculating hash string from off-chain. This will re-calculate the hashstring and compare with the one Committed before\nfunc CommitPrice(price int64, secret string, domainName string) string {\n\t// compute the hash string, compare to saved hash string in record\n\t// use int64 representation of time.Now()\n\tnow := time.Now().UnixMilli()\n\tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n\tjoinedString := secret + strconv.Itoa(int(price))\n\tcomputedHashString := Get256String(joinedString)\n\tcaller := std.GetOrigCaller()\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"[PRICE]: domain name is invalid\")\n\t}\n\tbidRecList := data.([]bidRecV2)\n\n\tufmt.Println(\"[PRICE]: endPriceTime: \", time.UnixMilli(bidRecList[0].EndPriceTime))\n\t// case commit after end - consider panic or not\n\tif now \u003e bidRecList[0].EndPriceTime {\n\t\tufmt.Println(\"[PRICE]: commit price phase is ended\")\n\t\treturn \"ended\"\n\t}\n\t// case commit when price phase not started\n\tif now \u003c= bidRecList[0].EndCommitTime {\n\t\tufmt.Println(\"[PRICE]: commit price phase is not started yet\")\n\t\treturn \"not started yet\"\n\t}\n\t// detect current winner by index and address\n\t_, currentWinnerRec := findTheWinner(domainName)\n\n\t// search for the corresponding hash\n\tfor index, rec := range bidRecList {\n\t\tufmt.Println(\"index \", index)\n\t\tufmt.Println(\"hash: \", rec.HashString)\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.IsCommittedPrice {\n\t\t\tufmt.Println(\"[PRICE] you already committed price\")\n\t\t\treturn \"committed\"\n\t\t}\n\t\t// panic because wrong price or wrong secret string\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.HashString != computedHashString {\n\t\t\tufmt.Println(\"[PRICE]: invalid hash string\")\n\t\t\treturn \"invalid hash string\"\n\t\t}\n\t\t// found it, update the price\n\t\tufmt.Println(\"checking for bid addr: \", rec.Bidder)\n\t\tufmt.Println(\"hash: \", rec.HashString)\n\t\tufmt.Println(\"caller: \", caller.String())\n\t\tufmt.Println(\"input hash: \", computedHashString)\n\t\tif rec.Bidder == caller.String() \u0026\u0026 rec.HashString == computedHashString {\n\t\t\t// update record with a new list\n\t\t\t// find the winner\n\t\t\tif price \u003e currentWinnerRec.Price \u0026\u0026 now \u003c= currentWinnerRec.EndPriceTime {\n\t\t\t\t// set others status to not winner\n\t\t\t\tdata, _ := bidStorages.Get(domainName)\n\t\t\t\tcurrentList := data.([]bidRecV2)\n\t\t\t\tnewList := []bidRecV2{}\n\t\t\t\tfor _, rec := range currentList {\n\t\t\t\t\trec.IsWinner = false\n\t\t\t\t\tnewList = append(newList, rec)\n\t\t\t\t}\n\n\t\t\t\t// update winner\n\t\t\t\tufmt.Println(\"[PRICE]: found new winner, setting up\")\n\t\t\t\tnewRec := bidRecV2{\n\t\t\t\t\tDomainName:       domainName,\n\t\t\t\t\tPrice:            price,\n\t\t\t\t\tIsCommittedHash:  true,\n\t\t\t\t\tIsCommittedPrice: true,\n\t\t\t\t\tIsWinner:         true,\n\t\t\t\t\tStartTime:        currentWinnerRec.StartTime,\n\t\t\t\t\tEndCommitTime:    currentWinnerRec.EndCommitTime,\n\t\t\t\t\tEndPriceTime:     currentWinnerRec.EndPriceTime,\n\t\t\t\t\tBidder:           caller.String(),\n\t\t\t\t\tHashString:       computedHashString,\n\t\t\t\t}\n\t\t\t\t// save records\n\t\t\t\tnewList[index] = newRec\n\t\t\t\tbidStorages.Set(domainName, newList)\n\t\t\t\treturn \"claim\"\n\t\t\t}\n\t\t\t// if not the winner, update record\n\t\t\tif price \u003c= currentWinnerRec.Price \u0026\u0026 now \u003c= currentWinnerRec.EndPriceTime {\n\t\t\t\tupdatedRec := bidRecV2{\n\t\t\t\t\tDomainName:       domainName,\n\t\t\t\t\tPrice:            price,\n\t\t\t\t\tIsCommittedHash:  true,\n\t\t\t\t\tIsCommittedPrice: true,\n\t\t\t\t\tIsWinner:         false,\n\t\t\t\t\tStartTime:        rec.StartTime,\n\t\t\t\t\tEndCommitTime:    rec.EndCommitTime,\n\t\t\t\t\tEndPriceTime:     rec.EndPriceTime,\n\t\t\t\t\tBidder:           caller.String(),\n\t\t\t\t\tHashString:       computedHashString,\n\t\t\t\t}\n\t\t\t\tdata, _ := bidStorages.Get(domainName)\n\t\t\t\tcurrentList := data.([]bidRecV2)\n\t\t\t\tcurrentList[index] = updatedRec\n\t\t\t\tbidStorages.Set(domainName, currentList)\n\t\t\t\treturn \"loser\"\n\t\t\t}\n\t\t}\n\t}\n\t// if not match above case, then you are not in list\n\tpanic(\"commit price failed\")\n}\n\n// GetCurrentWinner shows the current highest price user\nfunc GetCurrentWinner(domainName string) bidRecV2 {\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"no winner yet\")\n\t}\n\tlist := data.([]bidRecV2)\n\tfor _, bidRec := range list {\n\t\tif bidRec.IsWinner {\n\t\t\treturn bidRec\n\t\t}\n\t}\n\t// panic - should not happend\n\treturn bidRecV2{}\n}\n\n// find the highest bid in session - incase everyone Committed price\n// in old flow, we need to find the winner by retrievaling the bidStorage\nfunc findTheWinner(domainName string) (index int, winnerBid bidRecV2) {\n\tdata, existed := bidStorages.Get(domainName)\n\tif !existed {\n\t\tpanic(\"invalid domain name\")\n\t}\n\tindex = 0\n\tbidRecList := data.([]bidRecV2)\n\twinnerBid = bidRecList[0]\n\tfor i, bidRec := range bidRecList {\n\t\tif bidRec.Price \u003e winnerBid.Price {\n\t\t\twinnerBid.Price = bidRec.Price\n\t\t\twinnerBid.Bidder = bidRec.Bidder\n\t\t\twinnerBid.HashString = bidRec.HashString\n\t\t\twinnerBid.StartTime = bidRec.StartTime\n\t\t\twinnerBid.EndCommitTime = bidRec.EndCommitTime\n\t\t\twinnerBid.EndPriceTime = bidRec.EndPriceTime\n\t\t\twinnerBid.IsCommittedHash = bidRec.IsCommittedHash\n\t\t\twinnerBid.IsCommittedPrice = bidRec.IsCommittedPrice\n\t\t\tindex = i\n\t\t}\n\t}\n\treturn index, winnerBid\n}\n\n// get all the price list that joined the bid for displaying in dapp\nfunc GetRecords(dName string) []bidRecV2 {\n\tdata, existed := bidStorages.Get(dName)\n\tif !existed {\n\t\tpanic(\"should not\")\n\t}\n\treturn data.([]bidRecV2)\n}\n\n// chargeFee will charge amount - send from this contract to admin\nfunc chargeFee(amount int64, from std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", amount)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tcoins := checkCoin(from)\n\tufmt.Println(\"check balances: \", coins)\n\t// ufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// pay fee and claim the domain name if you are winner\nfunc Claim(domainName string) bool {\n\tif !bidStorages.Has(domainName) {\n\t\tpanic(\"claim: invalid domain name\")\n\t}\n\tcaller := std.GetOrigCaller()\n\t_, winner := findTheWinner(domainName)\n\tif caller.String() != winner.Bidder {\n\t\tpanic(\"only winner can claim\")\n\t}\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       caller,\n\t\tMode:         \"native\",\n\t}\n\tresult := executeRegister(requestInfo)\n\tif !result.Success {\n\t\tpanic(result.ResultDetails.Error())\n\t}\n\t// register done. Now charge the fee\n\tchargeFee(winner.Price, caller)\n\tfeeProcess(requestInfo)\n\treturn true\n}\n\n// expose winner price - amount of fee that user need to pay in Claim phase\nfunc GetWinnerPrice(dName string) int64 {\n\trec := GetCurrentWinner(dName)\n\tbaseRegisterFee := GetRegisterFee(dName)\n\treturn rec.Price + baseRegisterFee\n}\n\n// get current active bidders\nfunc getActiveCount(dName string) int64 {\n\tdata, _ := bidStorages.Get(dName)\n\trecList := data.([]bidRecV2)\n\treturn int64(len(recList))\n}\n"},{"name":"bidding_model.gno","body":"package registrar\n\nimport \"std\"\n\ntype bidStatus struct {\n\tDomainName    string\n\tStatus        string\n\tEndCommitTime int64\n\tEndPriceTime  int64\n\tActiveUsers   int64\n}\n\ntype bidRecord struct {\n\tDomainName       string\n\tBidder           std.Address\n\tHashString       string\n\tPrice            int64\n\tStartTime        int64\n\tEndCommitTime    int64\n\tEndPriceTime     int64\n\tIsCommittedPrice bool\n\t// CurrentPhase  actionCode\n}\ntype bidRecV2 struct {\n\tDomainName       string\n\tBidder           string\n\tHashString       string\n\tPrice            int64\n\tStartTime        int64\n\tEndCommitTime    int64\n\tEndPriceTime     int64\n\tIsCommittedPrice bool\n\tIsCommittedHash  bool\n\tIsWinner         bool\n}\n"},{"name":"bidding_v39.gno","body":"package registrar\n\n// import (\n// \t\"std\"\n// \t\"strconv\"\n// \t\"time\"\n\n// \t\"gno.land/p/demo/ufmt\"\n// \t// \"gno.land/p/demo/mux\"\n// \t\"gno.land/p/demo/avl\"\n// )\n\n// var (\n// \tbidStorage *avl.Tree // bidRecord \u003c- []bidRec\n// \twinnerRec  *avl.Tree // dName \u003c- bidRec\n// \tjoinedBid  *avl.Tree // address \u003c- []string DomainName\n// )\n\n// func recordJoinedBid(domainName string) {\n// \tcaller := std.GetOrigCaller()\n// \tdList := []string{}\n// \tdata, existed := joinedBid.Get(caller.String())\n// \tif !existed {\n// \t\tdList = []string{domainName}\n// \t\tjoinedBid.Set(caller.String(), dList)\n// \t\treturn\n// \t}\n// \tdList = data.([]string)\n// \tdList = append(dList, domainName)\n// \tjoinedBid.Set(caller.String(), dList)\n// \treturn\n// }\n\n// // GetJoinedBid returns the status of an user's joined bid session information\n// func GetJoinedBid(caller string) []bidStatus {\n// \tdata, existed := joinedBid.Get(caller)\n// \tif !existed {\n// \t\treturn []bidStatus{}\n// \t}\n// \tlist := data.([]string)\n// \tlistStatus := []bidStatus{}\n// \tfor _, dName := range list {\n// \t\tstt := GetCurrentStatus(dName, caller)\n\n// \t\t// get the time stamp in [0] element and assign it to status\n// \t\tdata, _ := bidStorage.Get(dName)\n// \t\tbidRec := data.([]bidRecord)[0]\n\n// \t\tsingleStt := bidStatus{\n// \t\t\tDomainName:    dName,\n// \t\t\tStatus:        stt,\n// \t\t\tEndCommitTime: bidRec.EndCommitTime,\n// \t\t\tEndPriceTime:  bidRec.EndPriceTime,\n// \t\t}\n// \t\tlistStatus = append(listStatus, singleStt)\n// \t}\n// \treturn listStatus\n// }\n\n// // GetCurrentStatus returns the status of the bidding session about a domain name. This func requires caller to determine in case commited or not (hash or price)\n// func GetCurrentStatus(domainName string, caller string) string {\n// \t// if there is record in joinedBid -\u003e user joined\n// \t// check for tine.Now() and startTime\n// \tnow := time.Now().UnixMilli()\n// \towner := GetOwner(domainName)\n// \tif owner != \"\" {\n// \t\treturn \"owned by \" + owner.String()\n// \t}\n// \t// find the record\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\t// no record in bidRec yet -\u003e not commited -\u003e check if user started auction or not - if yes: new auction\n// \t\tif dataJoined, existedInRegister := joinedBid.Get(caller); existedInRegister {\n// \t\t\tdNameList := dataJoined.([]string)\n// \t\t\tfor _, dName := range dNameList {\n// \t\t\t\tif dName == domainName {\n// \t\t\t\t\treturn \"waiting for hash\"\n// \t\t\t\t}\n// \t\t\t\treturn \"domain name is free\"\n// \t\t\t}\n// \t\t}\n// \t\treturn \"domain name is free\"\n// \t}\n\n// \t// commited yet\n// \trecList := data.([]bidRecord)\n// \trec := recList[0]\n// \tendCommitTimeUnix := rec.EndCommitTime\n// \tendPriceTimeUnix := rec.EndPriceTime\n// \tif now \u003c endCommitTimeUnix {\n// \t\tif rec.HashString != \"\" {\n// \t\t\treturn \"commited hash\"\n// \t\t} else {\n// \t\t\treturn \"hash\"\n// \t\t}\n// \t}\n\n// \tufmt.Println(\"now: \", time.UnixMilli(now))\n// \tufmt.Println(\"endPriceTime: \", time.UnixMilli(endPriceTimeUnix))\n// \tif now \u003c endPriceTimeUnix \u0026\u0026 now \u003e endCommitTimeUnix {\n// \t\t// check if commited price\n// \t\tdata, _ := bidStorage.Get(domainName)\n// \t\tbidRecList := data.([]bidRecord)\n// \t\tthisRec := bidRecord{}\n// \t\tfor _, bidRec := range bidRecList {\n// \t\t\tif bidRec.Bidder.String() == caller {\n// \t\t\t\tthisRec = bidRec\n// \t\t\t}\n// \t\t}\n// \t\tif thisRec.IsCommittedPrice {\n// \t\t\treturn \"committed price\"\n// \t\t}\n// \t\treturn \"price\"\n// \t}\n// \tif now \u003e rec.EndPriceTime {\n// \t\t// check if dName is claiming by winner - check if winner existed\n// \t\tif data, existed := winnerRec.Get(domainName); existed {\n// \t\t\twinner := data.(bidRecord)\n// \t\t\treturn winner.Bidder.String() + \" is claiming domain name: \" + domainName\n// \t\t}\n// \t\treturn \"closed\"\n// \t}\n// \treturn \"undefined\"\n// }\n\n// // Render() renders welcome message :D\n// func Render(path string) string {\n// \treturn \"welcome to varmeta domain name service\"\n// }\n\n// // CommitHash consumes off-chain calculated hash string and the domain name that user want\n// func CommitHash(domainName, hashString string) string {\n// \tcaller := std.GetOrigCaller()\n\n// \t// use now as int64 representation of time.Now()\n// \tnow := time.Now().UnixMilli()\n\n// \t// update the bid record\n// \tdata, existed := bidStorage.Get(domainName)\n\n// \t// if not existed -\u003e create new record\n// \tif !existed {\n// \t\t// for further getStatus\n// \t\trecordJoinedBid(domainName)\n\n// \t\tvar bidRec bidRecord\n// \t\tendCommitTime := now + defaultCommitHashTime.Milliseconds()\n// \t\tendPriceTime := endCommitTime + defaultCommitPriceTime.Milliseconds()\n// \t\tufmt.Println(\"[HASH]: request at: \", time.UnixMilli(now))\n// \t\tufmt.Println(\"[HASH]: endCommitTime: \", time.UnixMilli(endCommitTime))\n// \t\tufmt.Println(\"[HASH]: endPriceTime: \", time.UnixMilli(endPriceTime))\n// \t\tbidRec = bidRecord{\n// \t\t\tDomainName:    domainName,\n// \t\t\tBidder:        caller,\n// \t\t\tHashString:    hashString,\n// \t\t\tStartTime:     now,\n// \t\t\tEndCommitTime: endCommitTime,\n// \t\t\tEndPriceTime:  endPriceTime,\n// \t\t}\n// \t\tbidRecList := []bidRecord{bidRec}\n// \t\tbidStorage.Set(domainName, bidRecList)\n\n// \t\t// charge fee\n// \t\tchargeFee(fee.BidJoinFee, caller)\n// \t\treturn \"new session\"\n// \t}\n// \t// if existed\n// \tbidRecList := data.([]bidRecord)\n// \tstartTime := bidRecList[0].StartTime\n// \toldEndCommitTimeUnix := bidRecList[0].EndCommitTime\n// \toldEndPriceTimeUnix := bidRecList[0].EndPriceTime\n// \tif now \u003e oldEndCommitTimeUnix {\n// \t\t// now := time.Now().UnixMilli()\n// \t\t// ufmt.Println(\"[HASH]: now: \", time.UnixMilli(now))\n// \t\tpanic(\"[HASH]: can not commit hash anymore\")\n// \t}\n// \tfor _, bR := range bidRecList {\n// \t\tif bR.Bidder == caller {\n// \t\t\tpanic(\"[HASH]: you already commited hash\")\n// \t\t}\n// \t}\n\n// \tbidRec := bidRecord{\n// \t\tDomainName:    domainName,\n// \t\tHashString:    hashString,\n// \t\tBidder:        caller,\n// \t\tStartTime:     startTime,\n// \t\tEndCommitTime: oldEndCommitTimeUnix,\n// \t\tEndPriceTime:  oldEndPriceTimeUnix,\n// \t}\n// \tbidRecList = append(bidRecList, bidRec)\n// \t// Save record\n// \tbidStorage.Set(domainName, bidRecList)\n// \t// charge commit hash fee\n// \tchargeFee(fee.BidJoinFee, caller)\n// \treturn \"existed\"\n// }\n\n// // for now we dont use panic because this will cause the permanent time.Now() stuck. IDK why // XXX fix me\n// // CommitPrice consumes price and secret string that user used in calculating hash string from off-chain. This will re-calculate the hashstring and compare with the one commited before\n// func CommitPrice(price int64, secret string, domainName string) string {\n// \t// compute the hash string, compare to saved hash string in record\n// \t// use int64 representation of time.Now()\n// \tnow := time.Now().UnixMilli()\n// \tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n// \tjoinedString := secret + strconv.Itoa(int(price))\n// \tcomputedHashString := Get256String(joinedString)\n// \tcaller := std.GetOrigCaller()\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"[PRICE]: domain name is invalid\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \twinnerRec.Set(domainName, bidRecList[len(bidRecList)-1])\n// \tufmt.Println(\"[PRICE] current winner set to: \", bidRecList[len(bidRecList)-1].Bidder.String())\n\n// \tufmt.Println(\"[PRICE]: request at: \", time.UnixMilli(now))\n// \tufmt.Println(\"[PRICE]: endPriceTime: \", time.UnixMilli(bidRecList[0].EndPriceTime))\n// \t// case commit after end - consider panic or not\n// \tif now \u003e bidRecList[0].EndPriceTime {\n// \t\tufmt.Println(\"[PRICE]: commit price phase is ended\")\n// \t\treturn \"ended\"\n// \t}\n// \t// case commit when price phase not started\n// \tif now \u003c= bidRecList[0].EndCommitTime {\n// \t\tufmt.Println(\"[PRICE]: commit price phase is not started yet\")\n// \t\treturn \"not started yet\"\n// \t}\n\n// \t// search for the corresponding hash\n// \tfor index, bidRec := range bidRecList {\n// \t\t// panic because wrong price or wrong secret string\n// \t\tif bidRec.Bidder == caller \u0026\u0026 bidRec.HashString != computedHashString {\n// \t\t\tpanic(\"[PRICE]: invalid hash string\")\n// \t\t}\n// \t\t// found it, update the winner price\n// \t\tif bidRec.Bidder == caller \u0026\u0026 bidRec.HashString == computedHashString {\n// \t\t\tdata, _ := winnerRec.Get(domainName)\n// \t\t\tcurrentWinnerRec := data.(bidRecord)\n// \t\t\tif price \u003e currentWinnerRec.Price \u0026\u0026 now \u003c currentWinnerRec.EndPriceTime {\n// \t\t\t\tufmt.Println(\"[PRICE]: found new winner, setting up\")\n// \t\t\t\tcurrentWinnerRec.Price = price\n// \t\t\t\tcurrentWinnerRec.Bidder = bidRec.Bidder\n// \t\t\t\tcurrentWinnerRec.HashString = bidRec.HashString\n// \t\t\t\tcurrentWinnerRec.StartTime = bidRec.StartTime\n// \t\t\t\tcurrentWinnerRec.EndCommitTime = bidRec.EndCommitTime\n// \t\t\t\tcurrentWinnerRec.EndPriceTime = bidRec.EndPriceTime\n// \t\t\t\twinnerRec.Set(domainName, currentWinnerRec)\n// \t\t\t\tufmt.Println(\"[PRICE] current winner set to: \", currentWinnerRec.Bidder)\n// \t\t\t\tbidRec.IsCommittedPrice = true\n// \t\t\t\t// set new bidRecord into bidRecList and save into storage\n// \t\t\t\tbidRecList[index] = bidRec\n// \t\t\t\tbidStorage.Set(domainName, bidRecList)\n// \t\t\t\treturn \"claim\"\n// \t\t\t}\n// \t\t}\n// \t}\n// \t// if not match above case, then panic\n// \tpanic(\"commit price failed\")\n// }\n\n// // GetCurrentWinner shows the current highest price user\n// func GetCurrentWinner(domainName string) bidRecord {\n// \tdata, existed := winnerRec.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"no winner yet\")\n// \t}\n// \treturn data.(bidRecord)\n// }\n\n// // find the highest bid in session - incase everyone commited price\n// // in old flow, we need to find the winner by retrievaling the bidStorage\n// func findTheWinner(domainName string) bidRecord {\n// \tvar winnerBid bidRecord\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"invalid domain name\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \twinnerBid = bidRecList[0]\n// \tfor _, bidRec := range bidRecList {\n// \t\tif bidRec.Price \u003e winnerBid.Price {\n// \t\t\twinnerBid = bidRec\n// \t\t}\n// \t}\n// \treturn winnerBid\n// }\n\n// // register the domain for winner\n// func registerForWinner(domainName string, winnerRec bidRecord) bool {\n// \twinnerAddr := winnerRec.Bidder\n// \trequestInfo := RequestInfo{\n// \t\tWantedDomain: domainName,\n// \t\tCaller:       winnerAddr,\n// \t\tMode:         \"native\",\n// \t}\n// \tresult := executeRegister(requestInfo)\n// \tif !result.Success {\n// \t\tpanic(result.ResultDetails.Error())\n// \t}\n// \t// register done. Now charge the fee\n// \tfeeProcess(requestInfo)\n// \treturn false\n// }\n\n// // everyone can call EndBid()\n// // this EndBid checks endTime -\u003e end the auction\n// func EndBid(domainName string) error {\n// \tnow := time.Now().UnixMilli()\n// \tdata, existed := bidStorage.Get(domainName)\n// \tif !existed {\n// \t\treturn ufmt.Errorf(\"endbid: invalid domain name\")\n// \t}\n// \tbidRecList := data.([]bidRecord)\n// \tfirstBidRec := bidRecList[0]\n// \tif now \u003c firstBidRec.EndPriceTime {\n// \t\treturn ufmt.Errorf(\"endbid: this session can not end before the end time\")\n// \t}\n// \t// change all state\n// \t// for _, bidRec := range bidRecList {\n// \t// \tbidRec.IsOpen = false\n// \t// }\n// \tok := bidStorage.Set(domainName, bidRecList)\n// \tif !ok {\n// \t\treturn ufmt.Errorf(\"endbid: can not change bid record state\")\n// \t}\n// \t// need more conditions for findTheWinner()\n// \tfindTheWinner(domainName)\n// \treturn nil\n// }\n\n// // get all the price list that joined the bid for displaying in dapp\n// func GetRecords(dName string) []bidRecord {\n// \tdata, existed := bidStorage.Get(dName)\n// \tif !existed {\n// \t\tpanic(\"should not\")\n// \t}\n// \treturn data.([]bidRecord)\n// }\n\n// // chargeFee will charge amount - send from this contract to admin\n// func chargeFee(amount int64, from std.Address) {\n// \tbankerContract := std.CurrentRealm().Addr()\n// \tugnotCoin := std.NewCoin(\"ugnot\", amount)\n// \tcoinsToTransfer := std.NewCoins(ugnotCoin)\n// \tcoins := checkCoin(from)\n// \tufmt.Println(\"check balances: \", coins)\n// \t// ufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n// \tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n// }\n\n// // pay fee and claim the domain name if you are winner\n// func Claim(domainName string) bool {\n// \tdata, existed := winnerRec.Get(domainName)\n// \tif !existed {\n// \t\tpanic(\"claim: invalid domain name\")\n// \t}\n// \tcaller := std.GetOrigCaller()\n// \trec := data.(bidRecord)\n// \tif caller != rec.Bidder {\n// \t\tpanic(\"only winner can claim\")\n// \t}\n// \trequestInfo := RequestInfo{\n// \t\tWantedDomain: domainName,\n// \t\tCaller:       rec.Bidder,\n// \t\tMode:         \"native\",\n// \t}\n// \tresult := executeRegister(requestInfo)\n// \tif !result.Success {\n// \t\tpanic(result.ResultDetails.Error())\n// \t}\n// \t// register done. Now charge the fee\n// \tchargeFee(rec.Price, caller)\n// \tfeeProcess(requestInfo)\n// \treturn true\n// }\n\n// // expose winner price - amount of fee that user need to pay in Claim phase\n// func GetWinnerPrice(dName string) int64 {\n// \trec := GetCurrentWinner(dName)\n// \treturn rec.Price\n// }"},{"name":"errors.gno","body":"package registrar\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrUnknown           = errors.New(\"unknow errors\")\n\tErrOK                = errors.New(\"ok\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"ErrInvalidDomainName\")\n\tErrAlreadyRegistered = errors.New(\"this domain is registered\")\n\tErrCrossRealms       = errors.New(\"cross realms function error\")\n\tErrNotFound          = errors.New(\"domain not found\")\n)\n"},{"name":"fee.gno","body":"package registrar\n\nimport (\n\t\"time\"\n)\n\n// only admin can set Fee, other just can read only\ntype feeInfo struct {\n\tRegisterBaseFee     int64\n\tRenewalFee          int64\n\tRegisterAdditionFee int64\n\tBidJoinFee          int64\n}\n\nfunc GetRegisterFee(dName string) int64 {\n\treturn fee.RegisterBaseFee\n}\n\nfunc GetRenewalFee(dName string, amount time.Duration) int64 {\n\treturn fee.RenewalFee\n}\n\n// Admin set register fee and renewal fee\nfunc AdminSetFee(regFee int64, renewFee int64) {\n\t// consider logic\n\tassertIsAdmin()\n\tfee.RegisterBaseFee = regFee\n\tfee.RenewalFee = renewFee\n}\n\n// simple err check\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"fee_checks.gno","body":"package registrar\n\n// import (\n// \t\"\"\n// \t// \"std\"\n// \t// \"time\"\n// )\n\n\n"},{"name":"fee_native.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// admin access only\nfunc AdminWithdraw(amount int64) {\n\tassertIsAdmin()\n\tthisContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tsuperBanker.SendCoins(thisContract, admin, coinsToTransfer)\n}\n\nfunc nativeProcess() {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToTransfer := std.NewCoins(ugnotCoin)\n\tcaller := std.GetOrigCaller()\n\tcoins := checkCoin(caller)\n\tufmt.Println(\"check: \", coins)\n\tufmt.Println(\"send from contract \", bankerContract.String(), \" to admin \", admin.String(), \" amount: \", ugnotCoin)\n\tbankerUser.SendCoins(bankerContract, admin, coinsToTransfer)\n}\n\n// RevertTransfer will revert the transaction - send amount of coin to user\nfunc revertTransfer(userAddr std.Address) {\n\tbankerContract := std.CurrentRealm().Addr()\n\tugnotCoin := std.NewCoin(\"ugnot\", fee.RegisterBaseFee)\n\tcoinsToReturn := std.NewCoins(ugnotCoin)\n\tufmt.Println(\"return coins from contract \", bankerContract.String(), \" to \", userAddr.String())\n\tbankerUser.SendCoins(bankerContract, userAddr, coinsToReturn)\n}\n\n// simple check for admin call\nfunc assertIsAdmin() {\n\t// check if GetCallerAt 2 or 3 when deployed\n\tcaller := std.GetCallerAt(3)\n\terr := ufmt.Sprintf(\"unauthorize with caller: %s\\n\", caller)\n\tif caller != admin \u0026\u0026 caller != adminVar {\n\t\tpanic(err)\n\t}\n}\n\n// checking for availble coins\nfunc checkCoin(from std.Address) std.Coins {\n\t// caller := std.GetOrigCaller()\n\treturn bankerUser.GetCoins(from)\n}\n"},{"name":"fee_token.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n\tpusers \"gno.land/p/demo/users\"\n\t\"gno.land/r/varmeta/demo1/domain/vmt\"\n)\n\n// expected approved already from client -\u003e transfer from caller to admin\nfunc tokenProcess(dName string, callerStd std.Address) {\n\tcaller := pusers.AddressOrName(callerStd.String())\n\n\tnow := std.CurrentRealm().Addr()\n\tnowAddr := pusers.AddressOrName(now.String())\n\tufmt.Println(\"current realm transfer: \", now.String())\n\tcallerAllowance := vmt.Allowance(caller, nowAddr)\n\tcallerAllowanceString := ufmt.Sprintf(\"%d\", callerAllowance)\n\tufmt.Println(\"caller allowance \", callerAllowanceString)\n\n\tadminAddr := pusers.AddressOrName(admin.String())\n\tufmt.Println(\"admin: \", admin.String())\n\tvmt.TransferFrom(caller, adminAddr, 1)\n}\n"},{"name":"hashstring.gno","body":"package registrar\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n)\n\nfunc Get256String(input string) string {\n\tdata := []byte(input)\n\thashed := sha256.Sum256(data)\n\thashedBytes := hashed[:]\n\treturn hex.EncodeToString(hashedBytes)\n}\n"},{"name":"metadata_wrapper.gno","body":"package registrar\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/varmeta/demo/v406/domain\"\n)\n\n// Metadata wrapper\n// func NewMetadata(avatar, description, contactInfo, renewalFee string, registrationTime, expirationTime time.Time, attributes []Trait)\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcreatedAt := time.Now()\n\texpTime := createdAt.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", createdAt, expTime, []domain.Trait{})\n}\n\ntype remapMetadata struct {\n\tAvatar           string         // avatar - URL or identifier for an avatar image\n\tRegistrationTime string         // regtime - The time when the domain was registered\n\tExpirationTime   string         // exptime - The time when the domain will be expire\n\tAttributes       []domain.Trait // atts - Additional attributes of the domain\n\tDescription      string         // des - A description of the domain\n\tContactInfo      string         // contacts - Contact information for the domain owner\n\tRenewalFee       string         // renewalfee - The fee required to renew the domain, represented as a string\n}\n\n// currently not support for arrays\nfunc (m remapMetadata) MarshalJSON() ([]byte, error) {\n\tjson := new(bytes.Buffer)\n\tif m.Attributes == nil {\n\t\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, \"empty\", m.Description, m.ContactInfo, m.RenewalFee))\n\t\treturn json.Bytes(), nil\n\t}\n\tjson.WriteString(ufmt.Sprintf(`{\"avatar\": %s, \"regtime\": %s, \"exptime\": %s, \"atts\": %s, \"des\": %s, \"contacts\": %s, \"renewalfee\": %s}`, m.Avatar, m.RegistrationTime, m.ExpirationTime, m.Attributes[0], m.Description, m.ContactInfo, m.RenewalFee))\n\treturn json.Bytes(), nil\n}\n"},{"name":"models.gno","body":"package registrar\n\nimport (\n\t\"std\"\n)\n\ntype RequestInfo struct {\n\tMode         string\n\tWantedDomain string\n\tCaller       std.Address\n\tTransInfo    TransferInfo\n\t// xxx extendTime, renew...\n}\ntype TransferInfo struct {\n\tFrom std.Address\n\tTo   std.Address\n}\ntype ExecuteResult struct {\n\tSuccess       bool\n\tResultDetails error\n\tMessage       string\n}\n"},{"name":"prestep.gno","body":"package registrar\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/varmeta/demo/v406/domain\"\n)\n\nvar (\n\tdomainStorage *avl.Tree // domainName -\u003e std.Address\n\trootRegistry  domain.DomainRegistry\n\n\t// fee\n\tsuperBanker std.Banker // full access to coins that the realm itself owns, including the ones sent with the transaction\n\tbankerUser  std.Banker // full access to coins sent with the transaction that called the banker\n\n\tadmin    std.Address // admin\n\tadminVar std.Address // admin in server\n\tfee      feeInfo\n)\n\nfunc init() {\n\tdomainStorage = avl.NewTree()\n\t// bidStorage = avl.NewTree()\n\t// winnerRec = avl.NewTree()\n\t// joinedBid = avl.NewTree()\n\trootRegistry = domain.NewDomainRegistry(\"Varmeta\", \"vmt\")\n\n\t// fee init\n\tadmin = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\"    //@thinhnx\n\tadminVar = \"g1p3ylc5w42lrt5345eh7h5l9gcd7qpeyvcl5qjx\" //@varmeta-sponsorkey\n\t// ugnot\n\tfee = feeInfo{\n\t\tRegisterBaseFee:     100,\n\t\tRenewalFee:          100,\n\t\tRegisterAdditionFee: 0,\n\t\tBidJoinFee:          100,\n\t}\n\tsuperBanker = std.GetBanker(std.BankerTypeRealmSend)\n\tbankerUser = std.GetBanker(std.BankerTypeOrigSend)\n}\n"},{"name":"registrar.gno","body":"/*\nThis package contains functions that will actually execute the request from user\nFeatures: Domain Registration, Domain Renewal, Domain Transfer, Domain Deletion...\n*/\n// changelogs 1: move fee mgnt to registrar module, in oder to manage the coins sent from user to realm.\n// changelogs 2: v2 - added sealed bidding logic - with default time xxx mins for each session\n\n// currently we dont using too much panic because we dont have defer functions to revert the state of storage\npackage registrar\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v406/domain\"\n)\n\n// XXX: consider using panic instead of return string or errors\nfunc Register(domainName string, mode string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t\tMode:         mode,\n\t}\n\n\tregResult := executeRegister(requestInfo)\n\n\t// calling panic to stop paying fee\n\tif !regResult.Success {\n\t\tpanic(regResult.ResultDetails.Error())\n\t}\n\t// pay fee with panic inside\n\tfeeProcess(requestInfo)\n\treturn \"Register Done\"\n}\n\nfunc executeRegister(req RequestInfo) ExecuteResult {\n\t// check if domain name is regex valid\n\tvar execRes ExecuteResult\n\tif !isValidDomain(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrInvalidDomainName\n\t\treturn execRes\n\t}\n\n\t// check if dName is registered\n\tif AlreadyRegistered(req.WantedDomain) {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrAlreadyRegistered\n\t\treturn execRes\n\t}\n\n\t// execute register domain - mint the nft\n\t// changelogs v2: we are using sealed bidding now\n\n\tcaller := req.Caller\n\tttl := defaultExpireTime\n\tmetadata := metadataWrapper(caller, req.WantedDomain, ttl)\n\t// create a new registry instance to save metadata and mint the NFT\n\terrRegister := rootRegistry.RegisterDomain(caller, req.WantedDomain, metadata, ttl)\n\tif errRegister != nil {\n\t\texecRes.Success = false\n\t\texecRes.ResultDetails = ErrCrossRealms\n\t\treturn execRes\n\t}\n\t// now save caller to corressponding tree to manage\n\tdomainStorage.Set(req.WantedDomain, caller)\n\n\texecRes.Success = true\n\treturn execRes\n}\n\nfunc feeProcess(req RequestInfo) {\n\tif req.Mode == \"token\" {\n\t\ttokenProcess(req.WantedDomain, req.Caller)\n\t} else {\n\t\tnativeProcess()\n\t}\n}\n\nfunc AlreadyRegistered(domainName string) bool {\n\t// if can get owner -\u003e existed\n\taddr, err := rootRegistry.OwnerOf(domainName)\n\tif err == nil \u0026\u0026 addr != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetOwner(domainName string) std.Address {\n\tvl, existed := domainStorage.Get(domainName)\n\tif !existed {\n\t\treturn \"\"\n\t}\n\treturn vl.(std.Address)\n}\n\nfunc Search(domainName string) (remapMetadata, string) {\n\tvalidMetadata := remapMetadata{}\n\tmd, err := getMetadata(domainName)\n\tif err != nil {\n\t\t// return validMetadata, err.Error()\n\t\tpanic(err)\n\t}\n\tvalidMetadata.RegistrationTime = md.RegistrationTime.Format(time.RFC3339)\n\tvalidMetadata.ExpirationTime = md.ExpirationTime.Format(time.RFC3339)\n\t// jsonData, _ := validMetadata.MarshalJSON()\n\treturn validMetadata, \"Search Success\"\n}\n\nfunc getMetadata(wantedDomain string) (domain.Metadata, error) {\n\t// confirm the method? -\u003e get all the fields if the fields slice is empty\n\tmetadata, err := rootRegistry.GetDomainFields(wantedDomain, []domain.MetadataField{})\n\tif err != nil {\n\t\treturn metadata, err\n\t}\n\treturn metadata, nil\n}\n\n// Transfer\nfunc TransferDomain(from, to, domainName string) string {\n\trequestInfo := RequestInfo{\n\t\tWantedDomain: domainName,\n\t\tCaller:       std.PrevRealm().Addr(),\n\t}\n\tif err := excuteTransfer(requestInfo); err != \"\" {\n\t\tpanic(err)\n\t}\n\treturn \"Transfer Done\"\n}\n\nfunc excuteTransfer(req RequestInfo) string {\n\tif !AlreadyRegistered(req.WantedDomain) {\n\t\treturn ErrAlreadyRegistered.Error()\n\t}\n\trootRegistry.TransferFrom(req.TransInfo.From, req.TransInfo.To, req.WantedDomain)\n\treturn \"\"\n}\n\nfunc GetDomainName(addr string) []string {\n\tdomainList := []string{}\n\t// search from local storage\n\tdomainStorage.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcaller := value.(std.Address)\n\t\t// not checking isExpired\n\t\tif caller.String() == addr {\n\t\t\tdomainList = append(domainList, key)\n\t\t}\n\t\treturn false\n\t})\n\treturn domainList\n}\n"},{"name":"registrar_test.gno","body":"package registrar\n\n// import (\n// \t\"fmt\"\n// \t\"std\"\n// \t\"testing\"\n// )\n\n// func TestRegisterDomain(t *testing.T) {\n// \ttcs := []struct {\n// \t\tinput    string\n// \t\texpected string\n// \t}{\n// \t\t{\"thinhnx\", \"Register done\"},\n// \t}\n// \tfor tc := range tcs {\n// \t\tname := tc.input\n// \t\tt.Run(name, func(t *testing.T) {\n// \t\t\toutput := Register(tc.input)\n// \t\t\tif output != tc.expected {\n// \t\t\t\tt.Errorf(\"Expected '%q, but got %q\", tc.expected, output)\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n"},{"name":"utils.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage registrar\n\nimport (\n\t\"regexp\"\n\t\"time\"\n)\n\nvar (\n\tdefaultCommitHashTime  = time.Second * 30\n\tdefaultCommitPriceTime = time.Second * 30\n\tdefaultExpireTime      = time.Hour // 30 days\n\treName                 = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc GetExpirationDate(dName string) time.Time {\n\treturn rootRegistry.GetExpirationDate(dName)\n}\n\n// for now, this function only let admin set\nfunc SetExpirationDate(dName string, expDate time.Time) bool {\n\tassertIsAdmin()\n\treturn rootRegistry.SetExpirationDate(dName, expDate)\n}\n\nfunc SetCommitPhaseTime(duration int) {\n\tdefaultCommitHashTime = time.Duration(duration) * time.Second\n}\n\nfunc SetCommitPriceTime(duration int) {\n\tdefaultCommitPriceTime = time.Duration(duration) * time.Second\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"N+sjrQBTPMPXi4VoJr9B3fx8Yub+V5asYx0dsRuNPeAMmJ3wmblVi4YboUzeQvgx4xsj3yW3KhysFwLPzBPC9w=="}],"memo":""},"blockNum":"1983940"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","package":{"name":"resolver","path":"gno.land/r/varmeta/demo/v406/domain/resolver","files":[{"name":"checks_resolver.gno","body":"/*\nThis check module contains function to do the checking stuffs\n*/\npackage resolver\n\nimport (\n\t\"regexp\"\n\t\"time\"\n\n\t\"gno.land/r/varmeta/demo/v406/domain/registrar\"\n)\n\n// const (\n// \tadmin std.Address = \"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9\" // -\u003e @thinhnx\n// )\n\nvar reName = regexp.MustCompile(`^[a-zA-Z0-9]{1,124}\\.gno$`)\n\n// check for registering process\nfunc isValidDomain(d string) bool {\n\treturn reName.MatchString(d)\n}\n\nfunc isExpired(dName string) bool {\n\texpDate := registrar.GetExpirationDate(dName)\n\treturn expDate.Before(time.Now())\n}\n"},{"name":"errors.gno","body":"package resolver\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrNotFound          = errors.New(\"not found\")\n\tErrBadCall           = errors.New(\"bad call\")\n\tErrInvalidDomainName = errors.New(\"invalid domain name to register\")\n)\n"},{"name":"resolver.gno","body":"/*\nThe goal of the Resolver contract is keep track of the address for each ICNS name in a stateful manner.\nIt serves the purpose of \"resolving\" the ICNS Name\nto the correct address (e.g \"alice.gno\" -\u003e g1xxx).\n*/\n// changelogs: move Register feature into this resolver package\n// changelogs2: Removed local storage of resolver as cache, and every querires we query to registrar to get the result\n\npackage resolver\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/varmeta/demo/v406/domain/registrar\"\n)\n\ntype Record struct {\n\tOwner    std.Address\n\tIsValid  bool\n\tMemo     string // no more need this\n\tPriority int\n}\n\n// retrieve the record list to get the onchain address\nfunc Resolve(domainName string) *Record {\n\tif !isValidDomain(domainName) {\n\t\tpanic(\"bad domain name\")\n\t}\n\trecord := \u0026Record{}\n\n\towner := getOwnerFromDomainStorage(domainName)\n\tif owner == \"\" {\n\t\trecord.Memo = \"not found\"\n\t\trecord.IsValid = false\n\t\treturn record\n\t}\n\n\tif !isExpired(domainName) {\n\t\trecord.IsValid = true\n\t\trecord.Owner = owner\n\t} else {\n\t\trecord.IsValid = false\n\t}\n\treturn record\n}\n\nfunc GetDomainName(addr string) []string {\n\treturn registrar.GetDomainName(addr)\n}\n\n/*\nIf query in local storage not found\nQuery to DomainStorage by domainName -\u003e get the registry -\u003e use that registry to get the Owner()\nand check the validation time?\n*/\n\nfunc existedInDomainStorage(domainName string) bool {\n\treturn registrar.AlreadyRegistered(domainName)\n}\n\nfunc getOwnerFromDomainStorage(domainName string) std.Address {\n\treturn registrar.GetOwner(domainName)\n}\n"},{"name":"resolver_metadata.gno","body":"package resolver\n\nimport (\n\t\"std\"\n\t\"time\"\n\n\t\"gno.land/p/varmeta/demo/v406/domain\"\n)\n\n// Metadata wrapper\nfunc metadataWrapper(owner std.Address, name string, ttl time.Duration) domain.Metadata {\n\tcrrTime := time.Now()\n\texpTime := crrTime.Add(ttl)\n\treturn domain.NewMetadata(\"\", name, \"\", \"\", crrTime, expTime, []domain.Trait{})\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"60000000","gas_fee":"1000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"n4UahS+tpuhdL1Hv1ARe3z9jnGSn78xNYX0dkttn2d4KinGuqNllNcsMgxEpBxBnaaimo4wRspnroY41TY58gw=="}],"memo":""},"blockNum":"1983956"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1330dfff36jyy44rgq68y33mzxx9uhrgzyq88wh","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v406/domain/registrar","func":"CommitHash","args":["ngoc.gno","ea56fa8022639bfbf045c8d9cd37068cef58dd4669e61c913d1ab4dfe417d213"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AhsU4msjmCnK33Q/QPsxJX7LgQYk2CD9tgtpMSntVe1F"},"signature":"BNaXLDK8tTEZthlGmC7/WcaNCbNzavhd9cNsBQvuIG8BTUdZxSGIKEsDZuLtj59D/41jXbq5haKwL4wvyG08rw=="}],"memo":""},"blockNum":"1987055"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"6Vl+5HPp422+eD4GBzG3oC0OwskvO9Cv6Wbhyu+u5csypl9zL/TK/B+PfMVH5b9ha6q06AakoiBCD4YCd8nuXg=="}],"memo":""},"blockNum":"1990556"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","2","{\"message\":\"yo\",\"files\":[],\"gifs\":[],\"hashtags\":[],\"mentions\":[],\"title\":\"\",\"location\":[48.8566,2.3522],\"createdAt\":\"2024-09-27T09:40:48.067Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5WtMzcfxMAsafRXhSwe3WR2ZqJBQJNghi4WovOZ83RY"},"signature":"8ng6Cm11RvvthSPu0Fs1+B/tJmY7gN/DDJ+ZSXgoFf8c2cd/r2vOrovQVw+Ys0uLXWDEUD8lI75XgIBvVTF1rg=="}],"memo":""},"blockNum":"1990580"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","2","{\"message\":\"sssssssssssloooooooooooooooowwwwwwwwwwwwwwww\",\"files\":[],\"gifs\":[],\"hashtags\":[],\"mentions\":[],\"title\":\"\",\"location\":[48.8566,2.3522],\"createdAt\":\"2024-09-27T09:41:23.373Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5WtMzcfxMAsafRXhSwe3WR2ZqJBQJNghi4WovOZ83RY"},"signature":"yDWl2ta5FcBau6cGnkK5PQYh/rTSPuuFi38wipo3FawRzFd7xNNmbLV6LIbr7DLZObEjTaxJTqbH+AVnhcqVeg=="}],"memo":""},"blockNum":"1990592"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","2","{\"message\":\"sssssssssssloooooooooooooooowwwwwwwwwwwwwwww\",\"files\":[],\"gifs\":[],\"hashtags\":[],\"mentions\":[],\"title\":\"\",\"location\":[48.8566,2.3522],\"createdAt\":\"2024-09-27T09:41:29.255Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5WtMzcfxMAsafRXhSwe3WR2ZqJBQJNghi4WovOZ83RY"},"signature":"Nn0OxcrXCRrhfM2AgdHZnUWXmgsR6nwcF8gU7mVWGrA2DA1996nd+//OmY5I82jbXyjkEgf7MJrDPV/TGrFC7Q=="}],"memo":""},"blockNum":"1990594"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"110ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"Claim","args":["thinhnx.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"wrg0eG2Pqq/MMqvShx3VKYcVTOHWG4ILmQnMPZZ7EigBTHs3DXGGWPy7ZMgUvG9JdYuqPVt/2YJbJdKNIbksSg=="}],"memo":""},"blockNum":"1991452"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","1000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","1000640"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5WtMzcfxMAsafRXhSwe3WR2ZqJBQJNghi4WovOZ83RY"},"signature":"r8YmU4QZo0fA41hgttOE/kVpdHg7EccL4AztfQzJ6EZgRmw4Wi9E7H9Ntt4KTyndVefcagILWC3pfz8ebhMVtA=="}],"memo":""},"blockNum":"1991535"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"+2povuQLBvg6NBvdeagNH/DKB+ka+u0h5iqam+NrJmBV/1DpNZEzyMM0xVzbXpAkDDS111yVdG++K8ogDxQb4A=="}],"memo":""},"blockNum":"1994274"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","986987"]},{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1000000"]},{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","986987"]},{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"986987ugnot","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/v2/gns","3000","-6840","7020","986987","1000000","982052","995000","7282571140","g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa"]},{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5VVQOKuIJduYT53isYRljsPqVIOmvoodigS0VTlJJpd"},"signature":"bfv0yFjVOpOYFa1iyUABav8ZIBkfGVJ058AhuVsAeo1EncOdTlEqF5lQFLvN/AkDN/3du8HfYUiUE3t14Xa3YA=="}],"memo":""},"blockNum":"1994324"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","send":"3000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","3000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","3001923"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5VVQOKuIJduYT53isYRljsPqVIOmvoodigS0VTlJJpd"},"signature":"K5L+yP4g7yX9ppx38h3wjlNxan3SCyHxteFc5Y3iMIsk/VlqeFQ1xM1h1J2sn+r6NLAme8FG/ujklbd8A/sXtQ=="}],"memo":""},"blockNum":"1994347"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1p7k7ynth69x7ldm7fllgc0umaqvyytfj6ka7rx","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","2","{\"message\":\"wtf don't see on multi net select \",\"files\":[],\"gifs\":[],\"hashtags\":[],\"mentions\":[],\"title\":\"\",\"location\":[48.8566,2.3522],\"createdAt\":\"2024-09-27T14:44:32.240Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5WtMzcfxMAsafRXhSwe3WR2ZqJBQJNghi4WovOZ83RY"},"signature":"UA/IbUU9CilEFzwIrefHP6Qi6MOtLutUvoCECgf4xgkelVw8NHpr38vCELTJZP68NTf2Y1QhzyFNlNyPFbQyYA=="}],"memo":""},"blockNum":"1997263"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdefjerk4vxk9g56yhm9hcwqf0mj5yvq64vmw3","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1xdefjerk4vxk9g56yhm9hcwqf0mj5yvq64vmw3","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1xdefjerk4vxk9g56yhm9hcwqf0mj5yvq64vmw3","send":"","pkg_path":"gno.land/r/onbloc/usdc","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1xdefjerk4vxk9g56yhm9hcwqf0mj5yvq64vmw3","send":"5000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/onbloc/usdc","5000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000*POOL*gno.land/r/gnoswap/v2/gns:gno.land/r/onbloc/usdc:3000","100","5024714"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A12gP9yAK/9qaDgkJiemR4ZOsyuj9mgwFyhHUH8wb5TQ"},"signature":"q+x/W/VKtGbT+44H8+OfP6xFNUwb4OpzjAUMIvzWAeMT3MSDkVWX/P1V90xSntBoDBVIBbSwhQrnW6XNcjsXyA=="}],"memo":""},"blockNum":"1999619"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1m4apaa0zs90u8pmyjqxtljmzfxx6h0zn0xvhzr","amount":"5000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"K0A/E411SHaB7eDzGumK8Jq0yfVI3l3kvFwZebuAflYkzcpYuk5XhFCoNnmnOTTety8x0UkLkEp6BNueHLzoSw=="}],"memo":""},"blockNum":"2000373"}
