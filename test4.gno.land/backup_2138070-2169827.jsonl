{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"ENbsf8+7GfNHm+rH0r23bMb9bY80JHAPSTT/V0sOoNgArnAqV/4l2HtOKLGJyG0Uu5APmDCCB8gRDf8QGQuObw=="}],"memo":""},"blockNum":"2138890"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","send":"1000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","1000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","1000629"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au72itL2h4pEETcRtnLk/nQzRgcok47xuueKP0ZbEA09"},"signature":"TRwUIX5gf0gxeVxkvhfq7SEWJ8Vx9u9/muFCia+RUtZQRB0V0PLos8uZHb1nX4MM1tCpyqU19sxZrAbfcX8Abg=="}],"memo":""},"blockNum":"2138924"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","1005659"]},{"@type":"/vm.m_call","caller":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1vsm68lq9cpn7x507s6gh59anmx86kxfhzyszu2","0"]},{"@type":"/vm.m_call","caller":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"Mint","args":["gnot","gno.land/r/gnoswap/v2/gns","3000","-6840","60","0","1005659","0","1000631","7282571140","g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv"]},{"@type":"/vm.m_call","caller":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","send":"","pkg_path":"gno.land/r/gnoswap/v2/gnft","func":"SetTokenURILast","args":null}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au72itL2h4pEETcRtnLk/nQzRgcok47xuueKP0ZbEA09"},"signature":"S0dOzOpw+dRA12BisQjhtw64HXlsnN56ZNfLcILf8xZ1MG2wYZ9XQLbmMQh3eLsGrYNK9XSXs+JAX8y+tiWAkA=="}],"memo":""},"blockNum":"2138987"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1k5apa2pxkug7nfaxcs2lp0cxc86yrczfjmpsv2","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"jOF2cBIHGekLaaKNloHvhQjI0MSyjbJ1nWlP5qP84ctPpQkzQzZqyL2x0WdXyl/Jldk4gpwe/TXc81O0ReGcdg=="}],"memo":""},"blockNum":"2139205"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1k5apa2pxkug7nfaxcs2lp0cxc86yrczfjmpsv2","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1k5apa2pxkug7nfaxcs2lp0cxc86yrczfjmpsv2","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1k5apa2pxkug7nfaxcs2lp0cxc86yrczfjmpsv2","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g1k5apa2pxkug7nfaxcs2lp0cxc86yrczfjmpsv2","send":"2000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","2000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","2001259"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ah7oD2O8JiGXYOfh6jBoNDwnm+zREMCLh7EMKi5gBLrr"},"signature":"WIxLCZbHVD9l/5QXxNDrMRoScvMxp13WQl1eNF6xsUcHdBWscIsASK6KKpMbNkkb2T+ippqoLlAgwVD7urrvEQ=="}],"memo":""},"blockNum":"2139228"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["testgno.gno","1292630f4972d506163b95de3e83a4c9cbcb31b38093825687419a9eb95eca56"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"ox+GRye9dLFYUYQM0PLN1k2sEG64FhYFd6XlNYafmqwwRDIqO2GFSYco+PlHWMpSTfavZpWbn781y/acHbjxtQ=="}],"memo":""},"blockNum":"2145240"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["1","testgno","testgno.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"dCK90yKFPCl3sMAKzGJuao+zS0Np+5d5mPatyBIdboUX99Lh/zZgPIi+QAnlZE/qWLBAYypxtn0kmgQWTYG5Lg=="}],"memo":""},"blockNum":"2145255"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"101ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"Claim","args":["testgno.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"P2+8HNmrZrnn2NRSGI/rFXLbu19cFR1lYiaF6gfZgXtqtPzZyFi3IQgMTvfab4tRu6hGvCuJfeEkAPBrqV1anw=="}],"memo":""},"blockNum":"2145273"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","package":{"name":"gnome","path":"gno.land/r/ecodevx/dao/pre1","files":[{"name":"LICENSE","body":"Copyright (c) 2024. All rights reserved.\n\nProject Owner:\nNewTendermint, LLC\n\nProject Maintainer:\nİlker Göktuğ ÖZTÜRK. \u003cilker@ilgooz.com\u003e, \u003cilkergoktugozturk@gmail.com\u003e\n\nYour access to this Project and your contributions to this Project are subject\nto the following terms:\n\n* You hereby grant to the listed Owner and Maintainer of this Project the\nworldwide, irrevocable and royalty-free right to use, publish, relicense and\nsublicense your contributions under any non-exclusive license of their\nchoosing for commercial and non-commercial purposes.\n* You shall not attempt to bring any intellectual property infringement or\nmisappropriation claims against the Owner or Maintainer of this Project\nrelating to or arising from your contributions.\n* You represent that you are the sole owner of all rights in your\ncontributions and that no third party has any rights or interests therein.\n\nFOR THE SCOPE OF THIS LICENSE, A CONTRIBUTION IS DEFINED TO INCLUDE ANY WORKS,\nIDEAS, CODE, PROCESSES, OR APIS MADE AVAILABLE TO VIEW BY THE GENERAL PUBLIC\n(INCLUDING ANY PUBLICLY ACCESSIBLE INTERNET FORUMS AND CHAT SERVERS WHERE\nACCESS IS AVAILABLE FOR FREE WITH REGISTRATION) OR PRIVATELY TO THIS PROJECT'S\nOWNER AND MAINTAINERS; INCLUDING WORKS, IDEAS, CODE, PROCESSES, AND APIS THAT\nARE ABOUT THIS PROJECT AND ITS CONTRIBUTIONS, OR MENTIONED IN REFERENCE TO\nTHIS PROJECT, WHERE SUCH WORKS, IDEAS, CODE, PROCESSES, AND APIS ARE MATERIAL\nTO THE SUCCESS, IMPROVEMENT, OR COMPLETION OF THIS PROJECT, AS DETERMINED BY\nTHE OWNER OF THIS PROJECT.\n\nContributions may come in any form, and include (but are not limited to):\n\n* pull requests\n* diff patches\n* commentary\n* example code\n\nIf you do not want your contribution to become incorporated into this Project,\ndo not make contributions to this Project. The creation of contributions that\nmay in the future become known to this Project's Owner and Maintainer\nconstitutes a willing contribution to this Project in accordance with this\nlicense.\n\nTHIS PROJECT AND THE WORKS AVAILABLE THROUGH THIS PROJECT ARE PROVIDED “AS IS”\nAND WITHOUT WARRANTY OF ANY KIND. IN NO EVENT SHALL THE OWNER OR MAINTAINER OF\nTHIS PROJECT BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THIS PROJECT OR THE WORKS AVAILABLE THROUGH\nTHIS PROJECT. YOU AGREED TO INDEMNIFY, DEFEND AND HOLD THE OWNER AND\nMAINTAINER FROM AND AGAINST ANY CLAIMS, LOSSES OR DAMAGES ARISING FROM YOUR\nUSE OF THIS PROJECT OR THE WORKS AVAILABLE THROUGH THIS PROJECT.\n\nThis license is subject to change at any time by the Project Owner or\nMaintainer.\n\nYour continued access to or use of this Project or any works\navailable through this Project shall be subject to the then-current version\nof this license.\n\nThe Project Owner and Maintainer reserve the right to change this license\nwithout needing the consent of the contributors to this Project.\n"},{"name":"gnome.gno","body":"package gnome\n\nimport (\n\t\"strings\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// Names of the initial DAOs.\nconst (\n\tnameCouncilDAO = \"council\"\n\tnameMainDAO    = \"main\"\n)\n\n// Member roles.\nconst (\n\tRoleAdmin  gnome.Role = \"admin\"\n\tRoleEcoDev gnome.Role = \"eco-dev\"\n\tRoleDev    gnome.Role = \"dev\"\n\tRoleRealm  gnome.Role = \"realm\"\n)\n\n// The \"Gno.me\" DAO defines an initial root DAO with a single sub DAO, where the root is\n// the council DAO and the child is the main DAO. Council DAO members are hard coded and\n// can't be modified. Main DAO members can be modified anytime though a modify DAO members\n// proposals.\n//\n// The main DAO must have a minimum of three members at all time to be able to apply 2/3s\n// voting majority criteria required for some proposal types allowed for the main DAO.\n//\n// Sub DAOs can be created though sub DAO add proposals but its members can't be modified\n// once the sub DAO is created. Sub DAOs must be dismissed though a proposal and a new sub\n// DAO must be created if its members must be modified.\nvar gnomeDAO = gnome.MustNew(\n\tnameCouncilDAO,\n\t\"Council\",\n\tgnome.WithManifest(\"Gnomes are thinking\"),\n\tgnome.AssignAsSuperCouncil(),\n\tgnome.WithMembers(\n\t\tgnome.NewMember(\"g1lyzcpa7duh69lk04nahxup484xrz4k6k2nqdun\", RoleDev),\n\t\tgnome.NewMember(\"g125t352u4pmdrr57emc4pe04y40sknr5ztng5mt\", RoleDev),\n\t\tgnome.NewMember(\"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\", RoleEcoDev),\n\t),\n\tgnome.WithSubDAO(\n\t\tgnome.MustNew(\n\t\t\tnameMainDAO,\n\t\t\t\"Main\",\n\t\t\tgnome.WithManifest(\"Gnomes are building\"),\n\t\t\tgnome.WithMembers(\n\t\t\t\tgnome.NewMember(\"g1lyzcpa7duh69lk04nahxup484xrz4k6k2nqdun\", RoleDev),\n\t\t\t\tgnome.NewMember(\"g125t352u4pmdrr57emc4pe04y40sknr5ztng5mt\", RoleDev),\n\t\t\t\tgnome.NewMember(\"g1778y2yphxs2wpuaflsy5y9qwcd4gttn4g5yjx5\", RoleEcoDev),\n\t\t\t),\n\t\t),\n\t),\n)\n\nfunc mustGetDAO(path string) *gnome.DAO {\n\tif strings.TrimSpace(path) == \"\" {\n\t\tpanic(\"DAO path is empty\")\n\t}\n\n\tdao, found := daos.GetByPath(path)\n\tif !found {\n\t\tpanic(\"DAO not found\")\n\t}\n\treturn dao\n}\n"},{"name":"indexes.gno","body":"package gnome\n\nimport (\n\t\"gno.land/p/demo/avl\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nvar (\n\tdaos           daoIndex\n\tproposals      proposalIndex\n\tlastProposalID gnome.ID\n)\n\nfunc init() {\n\t// Index initial council and main DAO\n\tmainDAO := gnomeDAO.SubDAOs()[0]\n\tdaos.IndexByPath(gnomeDAO)\n\tdaos.IndexByPath(mainDAO)\n}\n\nfunc genProposalID() gnome.ID {\n\tlastProposalID += 1\n\treturn lastProposalID\n}\n\n// TODO: Deprecate DAO index in favor of using DAO methods\ntype daoIndex struct {\n\tindex avl.Tree // string(DAO path) -\u003e *gnome.DAO\n}\n\n// IndexByPath indexes a DAO by its path.\nfunc (x *daoIndex) IndexByPath(dao *gnome.DAO) bool {\n\treturn x.index.Set(dao.Path(), dao)\n}\n\n// GetByPath gets a DAO by its path.\nfunc (x daoIndex) GetByPath(path string) (*gnome.DAO, bool) {\n\tif v, ok := x.index.Get(path); ok {\n\t\treturn v.(*gnome.DAO), true\n\t}\n\treturn nil, false\n}\n\n// HasPathKey checks if a key with a DAO path exists.\nfunc (x daoIndex) HasPathKey(path string) bool {\n\treturn x.index.Has(path)\n}\n\ntype proposalIndex struct {\n\tindex  avl.Tree // string(binary gnome.ID) -\u003e *gnome.Proposal\n\tgroups avl.Tree // string(DAO path) -\u003e []*gnome.Proposal\n}\n\n// Index indexes a proposal by its ID and DAO.\nfunc (x *proposalIndex) Index(p *gnome.Proposal) {\n\tx.IndexByID(p)\n\tx.IndexByDAO(p)\n}\n\n// IndexByID indexes a proposal by its ID.\nfunc (x *proposalIndex) IndexByID(p *gnome.Proposal) bool {\n\treturn x.index.Set(p.ID().Key(), p)\n}\n\n// IndexByDAO indexes a proposal for a DAO.\nfunc (x *proposalIndex) IndexByDAO(p *gnome.Proposal) bool {\n\tdaoPath := p.DAO().Path()\n\tproposals := x.GetAllByDAO(daoPath)\n\tproposals = append([]*gnome.Proposal{p}, proposals...) // reverse append\n\treturn x.groups.Set(daoPath, proposals)\n}\n\n// GetByID gets a proposal by its ID.\nfunc (x proposalIndex) GetByID(id gnome.ID) (*gnome.Proposal, bool) {\n\tif v, exists := x.index.Get(id.Key()); exists {\n\t\treturn v.(*gnome.Proposal), true\n\t}\n\treturn nil, false\n}\n\n// GetAllByDAO gets all proposals of a DAO.\nfunc (x proposalIndex) GetAllByDAO(daoPath string) []*gnome.Proposal {\n\tif v, exists := x.groups.Get(daoPath); exists {\n\t\treturn v.([]*gnome.Proposal)\n\t}\n\treturn nil\n}\n\n// Iterate iterates proposals starting from the oldest one.\nfunc (x proposalIndex) Iterate(fn gnome.ProposalIterFn) bool {\n\treturn x.index.Iterate(\"\", \"\", func(_ string, v interface{}) bool {\n\t\treturn fn(v.(*gnome.Proposal))\n\t})\n}\n\n// ReverseIterate iterates proposals starting from the latest one.\nfunc (x proposalIndex) ReverseIterate(fn gnome.ProposalIterFn) bool {\n\treturn x.index.ReverseIterate(\"\", \"\", func(_ string, v interface{}) bool {\n\t\treturn fn(v.(*gnome.Proposal))\n\t})\n}\n"},{"name":"params.gno","body":"package gnome\n\nimport (\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// Day defines the duration of a day.\nconst Day = time.Hour * 24\n\n// Names for the different strategy types.\nconst (\n\tStrategyNameSubDAOCreation         = \"sub-dao-creation\"\n\tStrategyNameSubDAODismissal        = \"sub-dao-dismissal\"\n\tStrategyNameDAOMembersModification = \"dao-members-modification\"\n\tStrategyNameBudget                 = \"budget\"\n\tStrategyNameGeneral                = \"general\"\n\tStrategyNameLocking                = \"locking\"\n\tStrategyNameParamsUpdate           = \"params-update\"\n)\n\nvar parameters struct {\n\t// VotingPeriods contains the current voting period for each proposal type.\n\tVotingPeriods gnome.DurationParams\n\n\t// ReviewDeadline defines the time after which a proposal can't be withdrawed by the proposer.\n\t// Proposal can only be voted on after this deadline but not before.\n\t// This greace period gives the proposer the chance to withdraw a proposal if there is a mistake.\n\tReviewDeadline time.Duration\n}\n\nfunc init() {\n\t// Initial voting periods for each proposal type.\n\t// Periods can be changed by sumitting a params update proposal.\n\tparameters.VotingPeriods.Set(StrategyNameSubDAOCreation, time.Minute*10)\n\tparameters.VotingPeriods.Set(StrategyNameSubDAODismissal, Day*7)\n\tparameters.VotingPeriods.Set(StrategyNameDAOMembersModification, time.Minute*30)\n\tparameters.VotingPeriods.Set(StrategyNameBudget, Day*7)\n\tparameters.VotingPeriods.Set(StrategyNameGeneral, Day*2)\n\tparameters.VotingPeriods.Set(StrategyNameLocking, Day*2)\n\tparameters.VotingPeriods.Set(StrategyNameParamsUpdate, time.Minute*10)\n\n\t// Initial review deadline\n\tparameters.ReviewDeadline = time.Second\n}\n"},{"name":"public.gno","body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n\t\"gno.land/p/ecodevx/router\"\n)\n\n// Render returns a Markdown string with DAO or proposal details.\n// By default it renders the Council DAO details view.\n//\n// Paths:\n//   - `dao/DAO_PATH` =\u003e Renders DAO or sub DAO details\n//   - `proposal/PROPOSAL_ID` =\u003e Renders details for a proposal\n//   - `proposals/DAO_PATH` =\u003e Renders the list of proposals for a DAO\nfunc Render(path string) string {\n\tr := router.New()\n\n\tr.HandleFunc(\"\", renderDAO)\n\tr.HandleFunc(\"dao\", renderDAO)\n\tr.HandleFunc(\"proposal\", renderProposal)\n\tr.HandleFunc(\"proposals\", renderProposals)\n\tr.HandleFunc(\"params\", renderParams)\n\n\t// Render global alerts before proposal states are updated within the handlers\n\treturn renderAlerts() + r.Render(path)\n}\n\n// GetDAO returns an invariant reference to a DAO.\n// Council DAO is returned when path is empty.\nfunc GetDAO(path string) (_ gnome.InvarDAO, found bool) {\n\tif path == \"\" {\n\t\tpath = nameCouncilDAO\n\t}\n\n\tif dao, found := daos.GetByPath(path); found {\n\t\treturn gnome.NewInvarDAO(dao), true\n\t}\n\treturn gnome.InvarDAO{}, false\n}\n\n// GetProposal returns an invariant reference to a proposal.\nfunc GetProposal(id gnome.ID) (_ gnome.InvarProposal, found bool) {\n\tif p, found := proposals.GetByID(id); found {\n\t\treturn gnome.NewInvarProposal(p), true\n\t}\n\treturn gnome.InvarProposal{}, false\n}\n\n// IterateProposals iterates DAO proposals by ascending IDs.\nfunc IterateProposals(fn func(gnome.InvarProposal) bool) {\n\t// TODO: Add pagination support (start/end)\n\tproposals.Iterate(func(p *gnome.Proposal) bool {\n\t\treturn fn(gnome.NewInvarProposal(p))\n\t})\n}\n\n// CheckMemberHasRole checks if a DAO member has a role assigned.\nfunc CheckMemberHasRole(daoPath string, member std.Address, r gnome.Role) error {\n\tdao, found := gnomeDAO.GetDAO(daoPath)\n\tif !found {\n\t\treturn ufmt.Errorf(\"%s DAO not found\", dao.Name())\n\t}\n\n\tm, found := dao.GetMember(member)\n\tif !found {\n\t\treturn ufmt.Errorf(\"address is not a member of %s DAO: %s\", dao.Name(), member)\n\t}\n\n\tif !m.HasRole(RoleAdmin) {\n\t\treturn errors.New(\"member doesn't have admin role: \" + member.String())\n\t}\n\treturn nil\n}\n\n// WithdrawProposal withdraws a proposal.\n// Proposals can only be withdrawed by the account that creates it when the state is \"review\".\n// They can't be withdrawed once the review deadline of one hour after creation is met.\nfunc WithdrawProposal(proposalID uint64) string {\n\tassertDAOIsNotLocked()\n\n\tp := mustGetProposal(proposalID)\n\tassertCallerCanWithdraw(p)\n\n\tif err := p.Withdraw(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tAdvanceProposals()\n\n\treturn \"Proposal withdrawed\"\n}\n\n// Vote submits a vote for a proposal.\n//\n// Parameters:\n// - proposalID: ID of the proposal to vote (required)\n// - vote: Voting choice, true=Yes, false=No (required)\n// - reason: Text with the reason for the vote\n// - daoPath: Path of the DAO where the voting account belongs to\n//\n// Reason is in general optional but might be required for some proposals when voting No.\n//\n// DAO name is optional and by default is the one that the proposal belongs to.\n// Only parents of the proposal's DAO are allowed as `daoPath` values.\n// Child votes are not tallied when a member of a parent DAO votes on a child's proposal.\nfunc Vote(proposalID uint64, vote bool, reason, daoPath string) string {\n\tassertDAOIsNotLocked()\n\n\t// Make sure proposal states are up to date before submitting the vote\n\tAdvanceProposals()\n\n\t// Get proposal and check that current status accepts votes\n\tp := mustGetProposal(proposalID)\n\tif s := p.Status(); s.IsFinal() {\n\t\tpanic(\"proposal status doesn't allow new vote submissions: \" + s.String())\n\t}\n\n\t// When a DAO name is availalable check that it matches one of the proposal's DAO parents\n\t// and if so promote the proposal to a parent DAO. Promoting a proposal invalidates the votes\n\t// submitted by current DAO's members and moves voting responsibility to the parent DAO members.\n\tdaoPath = strings.TrimSpace(daoPath)\n\tif daoPath != \"\" \u0026\u0026 p.DAO().Path() != daoPath {\n\t\t// Check that the path belongs to a parent DAO.\n\t\t// Path separator is added to the prefix to make sure that similar prefixes don't match.\n\t\tif !strings.HasPrefix(p.DAO().Path(), daoPath+gnome.PathSeparator) {\n\t\t\tpanic(`path \"` + daoPath + `\" is not a parent of the proposal's DAO path`)\n\t\t}\n\n\t\t// Promote the active proposal's DAO to a parent DAO\n\t\tparentDAO := mustGetDAO(daoPath)\n\t\tif err := p.Promote(parentDAO); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\t// Reindex the proposal so its available under the parent DAO proposals. Child DAO will also\n\t\t// keep the promoted proposal indexed so it can be listed within the child DAO's proposals.\n\t\tproposals.Index(p)\n\t}\n\n\t// When proposal has \"review\" status check if deadline is met and if so activate it\n\tif p.Status() == gnome.StatusReview {\n\t\tif !p.HasReviewDeadlinePassed() {\n\t\t\tpanic(\"votes are not allowed until \" + p.ReviewDeadline().UTC().Format(\"2006-01-02 15:04 MST\"))\n\t\t}\n\n\t\tif err := p.Activate(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tvar choice gnome.VoteChoice\n\tif vote {\n\t\tchoice = gnome.ChoiceYes\n\t} else {\n\t\tchoice = gnome.ChoiceNo\n\t}\n\n\t// Submit vote\n\tcaller := std.GetOrigCaller() // TODO: Check that caller is member of the DAO\n\terr := p.Vote(caller, gnome.VoteChoice(choice), reason)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn \"Vote submitted for proposal \" + makeProposalURI(gnome.ID(proposalID), false)\n}\n\n// AdvanceProposals iterates review and active proposals and tallies proposals that met their deadlines.\n// Proposals in review status are activated to allow voting.\n// Active proposals are tallied which means the number of votes is counted and status changed accordingly.\n// Active executable proposals are executed when the proposal status changes to \"passed\".\nfunc AdvanceProposals() string {\n\tassertDAOIsNotLocked()\n\n\tadvanceProposals()\n\n\treturn \"Proposals advanced for realm \" + makeRealmURL(\"\")\n}\n\n// IsProposalsAdvanceNeeded checks if a call to `AdvanceProposals()` is required to update proposals.\nfunc IsProposalsAdvanceNeeded() bool {\n\tif gnomeDAO.IsLocked() {\n\t\treturn false\n\t}\n\n\treturn proposals.ReverseIterate(func(p *gnome.Proposal) bool {\n\t\tswitch p.Status() {\n\t\tcase gnome.StatusReview:\n\t\t\tif p.HasReviewDeadlinePassed() {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase gnome.StatusActive:\n\t\t\tif p.HasVotingDeadlinePassed() {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\nfunc advanceProposals() {\n\t// TODO: Use unix timestamp as part of proposal IDs to avoid iterating older tallied proposals\n\tproposals.Iterate(func(p *gnome.Proposal) bool {\n\t\tstatus := p.Status()\n\t\tif status == gnome.StatusReview \u0026\u0026 p.HasReviewDeadlinePassed() {\n\t\t\tp.Activate()\n\t\t\tstatus = p.Status()\n\t\t}\n\n\t\tif p.Status() == gnome.StatusActive \u0026\u0026 p.HasVotingDeadlinePassed() {\n\t\t\tp.Tally()\n\n\t\t\t// Change proposal status to failed when execution fails\n\t\t\tif err := p.Execute(); gnome.IsExecutionError(err) {\n\t\t\t\tp.Fail(\"failed due to conflicts: \" + err.Error())\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\nfunc mustGetProposal(id uint64) *gnome.Proposal {\n\tp, found := proposals.GetByID(gnome.ID(id))\n\tif !found {\n\t\tpanic(\"proposal not found\")\n\t}\n\treturn p\n}\n\nfunc assertCallerCanWithdraw(p *gnome.Proposal) {\n\tif p.Proposer() != std.GetOrigCaller() {\n\t\tpanic(\"proposals can only be withdrawed by the proposer\")\n\t}\n\n\tif p.Status() != gnome.StatusReview {\n\t\tpanic(`proposals can only be withdrawed when status is \"review\"`)\n\t} else if p.HasReviewDeadlinePassed() {\n\t\tpanic(\"withdrawal not allowed, withdrawal deadline expired\")\n\t}\n}\n"},{"name":"public_proposals.gno","body":"package gnome\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// SubmitCustomProposal submits a new proposal of a custom type.\n//\n// This function allows other realms to submit custom proposal types.\n//\n// Parameters:\n// - title: A title for the proposal (required)\n// - description: A description of the proposal\n// - strategy: A strategy for the new proposal (required)\n// - daoPath: Path of the DAO where the proposal should be created (required)\nfunc SubmitCustomProposal(title, description string, s gnome.ProposalStrategy, daoPath string) gnome.ID {\n\tassertDAOIsNotLocked()\n\n\tdao := mustGetDAO(daoPath)\n\tassertDAOIsNotDismissed(dao)\n\n\tcaller := std.GetOrigCaller()\n\tassertCanCreateProposal(caller, dao)\n\n\tid := genProposalID()\n\tp, err := gnome.NewProposal(\n\t\tid,\n\t\ts,\n\t\tcaller,\n\t\tdao,\n\t\ttitle,\n\t\tgnome.WithDescription(description),\n\t\tgnome.WithReviewDeadline(time.Now().Add(parameters.ReviewDeadline)),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tproposals.Index(p)\n\treturn p.ID()\n}\n\n// SubmitGeneralProposal submits a new general proposal.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal (required)\n// - daoPath: Path of the DAO where the proposal should be created (required)\n// - votingDeadline: Number of days until the voting period ends\n//\n// The name of the DAO where the proposal is created is a slug, where \"council\"\n// is the Council DAO and \"main\" is the name of the Main DAO.\n//\n// The voting period deadline for the proposal must be between 2 and 10 days.\n// It defaults to 2 days when `votingDeadline` value is 0.\nfunc SubmitGeneralProposal(\n\tproposalTitle,\n\tproposalDescription,\n\tdaoPath string,\n\tvotingDeadline uint,\n) uint64 {\n\tassertDAOIsNotLocked()\n\n\topts := []gnome.ProposalOption{\n\t\tgnome.WithDescription(proposalDescription),\n\t\tgnome.WithReviewDeadline(time.Now().Add(parameters.ReviewDeadline)),\n\t}\n\n\tif votingDeadline != 0 {\n\t\tif votingDeadline \u003c 2 || votingDeadline \u003e 10 {\n\t\t\tpanic(\"voting period deadline must be between 2 and 10 days\")\n\t\t}\n\n\t\tdeadline := time.Now().Add(time.Hour * 24 * time.Duration(votingDeadline))\n\t\topts = append(opts, gnome.WithVotingDeadline(deadline))\n\t}\n\n\tdao := mustGetDAO(daoPath)\n\tassertDAOIsNotDismissed(dao)\n\n\tcaller := std.GetOrigCaller()\n\tassertCanCreateProposal(caller, dao)\n\n\tp, err := gnome.NewProposal(genProposalID(), newGeneralStrategy(), caller, dao, proposalTitle, opts...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tproposals.Index(p)\n\tAdvanceProposals()\n\n\treturn uint64(p.ID())\n}\n\n// SubmitSubDAOCreationProposal submits a new proposal to add a sub DAO to an existing DAO.\n//\n// Proposal requires the participation of all DAO members, otherwise the outcome will be low participation.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - parentDAOPath: Path of the sub DAO's parent (required)\n// - subDAOName: Slug name of the new sub DAO (required)\n// - subDAOTitle: A title for the new sub DAO (required)\n// - subDAOManifest: Sub DAO manifest (required)\n// - subDAOMembers: List of sub DAO member addresses (required)\n//\n// Sub DAO name must be a slug allows letters from \"a\" to \"z\", numbers, \"-\" and \"_\" as valid characters.\n//\n// The list of sub DAO members must be a newline separated list of addresses, with a minimum of 2 addresses.\n// Each line must contain an address and optionally be followed by one or more DAO member roles:\n// ```\n// g187982000zsc493znqt828s90cmp6hcp2erhu6m foo\n// g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5 bar foo\n// ```\nfunc SubmitSubDAOCreationProposal(\n\tproposalTitle,\n\tproposalDescription,\n\tparentDAOPath,\n\tsubDAOName,\n\tsubDAOTitle,\n\tsubDAOManifest,\n\tsubDAOMembers string,\n) uint64 {\n\tassertDAOIsNotLocked()\n\n\tdao := mustGetDAO(parentDAOPath)\n\tassertDAOIsNotDismissed(dao)\n\n\tsubDAOPath := dao.Path() + gnome.PathSeparator + subDAOName\n\tif daos.HasPathKey(subDAOPath) {\n\t\tpanic(\"sub DAO name is already taken by another DAO\")\n\t}\n\n\tcaller := std.GetOrigCaller()\n\tassertCanCreateProposal(caller, dao)\n\n\tmembers := gnome.MustParseStringToMembers(subDAOMembers)\n\tstrategy := newSubDAOCreationStrategy(daos, subDAOName, subDAOTitle, subDAOManifest, members)\n\tp, err := gnome.NewProposal(\n\t\tgenProposalID(),\n\t\tstrategy,\n\t\tcaller,\n\t\tdao,\n\t\tproposalTitle,\n\t\tgnome.WithDescription(proposalDescription),\n\t\tgnome.WithReviewDeadline(time.Now().Add(parameters.ReviewDeadline)),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tproposals.Index(p)\n\tAdvanceProposals()\n\n\treturn uint64(p.ID())\n}\n\n// SubmitSubDAODismissalProposal submits a new proposal to dismiss a sub DAO.\n//\n// Dismissing a sub DAO also dismisses all active proposals and any sub DAO below the dismissed DAO tree.\n// Only the direct parent of a DAO can create a proposal to dismiss any of its fist level sub DAOs.\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by plurality.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - daoPath: Path of the DAO where the proposal should be created (required)\n// - subDAOName: Slug name of the sub DAO to dismiss (required)\nfunc SubmitSubDAODismissalProposal(proposalTitle, daoPath, subDAOName string) uint64 {\n\tassertDAOIsNotLocked()\n\n\tdao := mustGetDAO(daoPath)\n\tassertDAOIsNotDismissed(dao)\n\n\tsubDAOPath := dao.Path() + gnome.PathSeparator + subDAOName\n\tsubDAO := mustGetDAO(subDAOPath)\n\tassertDAOIsNotDismissed(subDAO)\n\n\tcaller := std.GetOrigCaller()\n\tstrategy := newSubDAODismissalStrategy(subDAO, proposals)\n\tp, err := gnome.NewProposal(\n\t\tgenProposalID(),\n\t\tstrategy,\n\t\tcaller,\n\t\tdao,\n\t\tproposalTitle,\n\t\tgnome.WithReviewDeadline(time.Now().Add(parameters.ReviewDeadline)),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tproposals.Index(p)\n\tAdvanceProposals()\n\n\treturn uint64(p.ID())\n}\n\n// SubmitDAOMembersModificationProposal submits a new proposal to modify the members of a DAO.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by super majority with a 2/3s threshold. Abstentions are not considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - daoPath: Path of the DAO where the proposal should be created (required)\n// - newMembers: List of member addresses to add to Main DAO\n// - removeMembers: List of member addresses to remove from the Main DAO\n//\n// At leat one member address is required either to be added or removed from the DAO.\n// Members can be added and removed within the same proposal.\n//\n// Each list of members must be newline separated list of addresses.\n// Each line must contain an address and optionally be followed by one or more DAO member roles:\n// ```\n// g187982000zsc493znqt828s90cmp6hcp2erhu6m foo\n// g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5 bar foo\n// ```\nfunc SubmitDAOMembersModificationProposal(\n\tproposalTitle,\n\tproposalDescription,\n\tdaoPath,\n\tnewMembers,\n\tremoveMembers string,\n) uint64 {\n\tassertDAOIsNotLocked()\n\n\tdao := mustGetDAO(daoPath)\n\tassertDAOIsNotDismissed(dao)\n\n\tcaller := std.GetOrigCaller()\n\tassertCanCreateProposal(caller, dao)\n\n\tstrategy := newDAOMembersModificationStrategy(\n\t\tgnome.MustParseStringToMembers(newMembers),\n\t\tgnome.MustParseStringToMembers(removeMembers),\n\t)\n\tp, err := gnome.NewProposal(\n\t\tgenProposalID(),\n\t\tstrategy,\n\t\tcaller,\n\t\tdao,\n\t\tproposalTitle,\n\t\tgnome.WithDescription(proposalDescription),\n\t\tgnome.WithReviewDeadline(time.Now().Add(parameters.ReviewDeadline)),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tproposals.Index(p)\n\tAdvanceProposals()\n\n\treturn uint64(p.ID())\n}\n\n// SubmitBudgetProposal submits a new budget proposal.\n//\n// Only membes of the Council or Main DAO can vote on this type of proposals.\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - daoPath: Path of the DAO where the proposal should be created (required)\n// - budget: The proposal budget (required)\n//\n// Budget doesn't enforce any specific format right now but an example format that\n// could be used is amount plus symbol, for example 100UGNOT, 100000USD, etc.\nfunc SubmitBudgetProposal(\n\tproposalTitle,\n\tproposalDescription,\n\tdaoPath,\n\tbudget string,\n) uint64 {\n\tassertDAOIsNotLocked()\n\n\tdao := mustGetDAO(daoPath)\n\tassertDAOIsNotDismissed(dao)\n\n\tcaller := std.GetOrigCaller()\n\tassertCanCreateProposal(caller, dao)\n\n\tstrategy := newBudgetStrategy(gnomeDAO, budget)\n\tp, err := gnome.NewProposal(\n\t\tgenProposalID(),\n\t\tstrategy,\n\t\tcaller,\n\t\tdao,\n\t\tproposalTitle,\n\t\tgnome.WithDescription(proposalDescription),\n\t\tgnome.WithReviewDeadline(time.Now().Add(parameters.ReviewDeadline)),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tproposals.Index(p)\n\tAdvanceProposals()\n\n\treturn uint64(p.ID())\n}\n\n// SubmitDAOLockingProposal submits a new proposal to lock the DAO.\n//\n// Locking the DAO \"freezes the state\" by disallowing further modifications.\n// State must be locked to migrate the realm to a newer version.\n//\n// Proposal requires a 33% quorum, otherwise the outcome will be low participation.\n// This type of proposal can only be created by the Council or Main DAO members.\n// Tally is done by plurality.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - daoPath: Path of the DAO where the proposal should be created (required)\n// - reason: Text with the DAO locking reason\n//\n// The optional `reason` argument can contain HTML.\nfunc SubmitDAOLockingProposal(\n\tproposalTitle,\n\tproposalDescription,\n\tdaoPath,\n\treason string,\n) uint64 {\n\tassertDAOIsNotLocked()\n\n\tcaller := std.GetOrigCaller()\n\tassertIsCouncilOrMainDAOMember(caller)\n\n\tdao := mustGetDAO(daoPath)\n\tassertIsCouncilOrMainDAO(dao)\n\n\treason = strings.TrimSpace(reason)\n\tstrategy := newLockingStrategy(gnomeDAO, reason, func() error {\n\t\t// Advance all proposals before locking the DAO\n\t\tadvanceProposals()\n\t\treturn nil\n\t})\n\n\tp, err := gnome.NewProposal(\n\t\tgenProposalID(),\n\t\tstrategy,\n\t\tcaller,\n\t\tdao,\n\t\tproposalTitle,\n\t\tgnome.WithDescription(proposalDescription),\n\t\tgnome.WithReviewDeadline(time.Now().Add(parameters.ReviewDeadline)),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tproposals.Index(p)\n\tAdvanceProposals()\n\n\treturn uint64(p.ID())\n}\n\n// SubmitParamsUpdateProposal submits a new proposal to update one or more realm parameters.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - daoPath: Path of the DAO where the proposal should be created (required)\n// - proposalReviewDeadline: Number of seconds where proposals can be withdrawed\n// - votingPeriodSubDAOCreation: Voting period for sub DAO creation proposals\n// - votingPeriodSubDAODismissal: Voting period for sub DAO dismissal proposals\n// - votingPeriodDAOMembersModification: Voting period for DAO members modification proposals\n// - votingPeriodBudget: Voting period for budget proposals\n// - votingPeriodGeneral: Voting period for general proposals\n// - votingPeriodLocking: Voting period for locking proposals\n// - votingPeriodParamsUpdate: Voting period for parameters update proposals\n//\n// Voting period is the number of days that members can vote on a proposal\n// At least one parameter value is required for creating a proposal.\nfunc SubmitParamsUpdateProposal(\n\tproposalTitle,\n\tproposalDescription,\n\tdaoPath string,\n\tproposalReviewDeadline,\n\tvotingPeriodSubDAOCreation,\n\tvotingPeriodSubDAODismissal,\n\tvotingPeriodDAOMembersModification,\n\tvotingPeriodBudget,\n\tvotingPeriodGeneral,\n\tvotingPeriodLocking,\n\tvotingPeriodParamsUpdate int,\n) uint64 {\n\tassertDAOIsNotLocked()\n\n\tdao := mustGetDAO(daoPath)\n\tassertDAOIsNotDismissed(dao)\n\n\tcaller := std.GetOrigCaller()\n\tassertCanCreateProposal(caller, dao)\n\n\tstrategy := paramsUpdateStrategy{\n\t\treviewDeadline: time.Second * time.Duration(proposalReviewDeadline),\n\t}\n\n\tif votingPeriodSubDAOCreation \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodSubDAOCreation) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameBudget, period)\n\t}\n\n\tif votingPeriodSubDAODismissal \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodSubDAODismissal) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameBudget, period)\n\t}\n\n\tif votingPeriodDAOMembersModification \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodDAOMembersModification) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameBudget, period)\n\t}\n\n\tif votingPeriodBudget \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodBudget) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameBudget, period)\n\t}\n\n\tif votingPeriodGeneral \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodGeneral) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameGeneral, period)\n\t}\n\n\tif votingPeriodLocking \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodLocking) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameLocking, period)\n\t}\n\n\tif votingPeriodParamsUpdate \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodParamsUpdate) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameParamsUpdate, period)\n\t}\n\n\tif strategy.votingPeriods.Size() == 0 \u0026\u0026 strategy.reviewDeadline == 0 {\n\t\tpanic(\"at least one parameter value must be specified\")\n\t}\n\n\tp, err := gnome.NewProposal(\n\t\tgenProposalID(),\n\t\tstrategy,\n\t\tcaller,\n\t\tdao,\n\t\tproposalTitle,\n\t\tgnome.WithDescription(proposalDescription),\n\t\tgnome.WithReviewDeadline(time.Now().Add(parameters.ReviewDeadline)),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := p.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tproposals.Index(p)\n\tAdvanceProposals()\n\n\treturn uint64(p.ID())\n}\n\nfunc assertCanCreateProposal(proposer std.Address, dao *gnome.DAO) {\n\tif !dao.HasMember(proposer) {\n\t\tpanic(\"you must be a DAO member to create a proposal\")\n\t}\n}\n\nfunc assertDAOIsNotDismissed(dao *gnome.DAO) {\n\t// DAOs are locked when they are dismissed\n\tif dao.IsLocked() {\n\t\tpanic(\"DAO is dismissed: \" + dao.Path())\n\t}\n}\n\nfunc assertDAOIsNotLocked() {\n\tif gnomeDAO.IsLocked() {\n\t\tpanic(\"DAO is locked\")\n\t}\n}\n\nfunc assertIsCouncilOrMainDAO(dao *gnome.DAO) {\n\tif !dao.IsSuperCouncil() {\n\t\t// Main DAO parent must be the super council\n\t\tparentDAO := dao.Parent()\n\t\tif !parentDAO.IsSuperCouncil() {\n\t\t\tpanic(\"DAO is not the council or main DAO\")\n\t\t}\n\t}\n}\n\nfunc assertIsCouncilOrMainDAOMember(addr std.Address) {\n\tif !gnomeDAO.HasMember(addr) {\n\t\tmainDAO := gnomeDAO.SubDAOs()[0]\n\t\tif !mainDAO.HasMember(addr) {\n\t\t\tpanic(\"account is not a council or main DAO member\")\n\t\t}\n\t}\n}\n"},{"name":"public_proposals_0a_filetest.gno","body":"package main\n\nimport (\n\t\"std\"\n\n\tgnome \"gno.land/r/ecodevx/dao/pre1\"\n)\n\nconst member = std.Address(\"g1lyzcpa7duh69lk04nahxup484xrz4k6k2nqdun\")\n\nfunc init() {\n\tstd.TestSetOrigCaller(member)\n}\n\nfunc main() {\n\ttitle := \"Test proposal\"\n\tdesc := \"A test proposal\"\n\tdaoPath := \"council/main\"\n\tpID := gnome.SubmitGeneralProposal(title, desc, daoPath, 0)\n\tprintln(pID)\n\n\tmarkdown := gnome.Render(\"proposal/1\")\n\tprintln(markdown)\n}\n\n// Output:\n// 1\n// # #1 Test proposal\n// - Type: general\n// - Created: 2009-02-13 23:31 UTC\n// - Proposer: g1lyzcpa7duh69lk04nahxup484xrz4k6k2nqdun\n// - Status: **review**\n// - Review Deadline: 2009-02-14 00:31 UTC\n// ## Description\n// A test proposal\n// ## Votes\n// The proposal has no votes\n"},{"name":"public_proposals_0b_filetest.gno","body":"package main\n\nimport (\n\t\"std\"\n\n\tgnome \"gno.land/r/ecodevx/dao/pre1\"\n)\n\nconst nonMember = std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\nfunc init() {\n\tstd.TestSetOrigCaller(nonMember)\n}\n\nfunc main() {\n\ttitle := \"Test proposal\"\n\tdesc := \"A test proposal\"\n\tdaoPath := \"council/main\"\n\tgnome.SubmitGeneralProposal(title, desc, daoPath, 0)\n}\n\n// Error:\n// you must be a DAO member to create a proposal\n"},{"name":"public_proposals_0c_filetest.gno","body":"package main\n\nimport (\n\t\"std\"\n\n\tgnome \"gno.land/r/ecodevx/dao/pre1\"\n)\n\nconst member = std.Address(\"g1lyzcpa7duh69lk04nahxup484xrz4k6k2nqdun\")\n\nfunc init() {\n\tstd.TestSetOrigCaller(member)\n}\n\nfunc main() {\n\ttitle := \"Test proposal\"\n\tdesc := \"A test proposal\"\n\tdaoPath := \"council/main\"\n\tgnome.SubmitGeneralProposal(title, desc, daoPath, 1)\n}\n\n// Error:\n// voting period deadline must be between 2 and 10 days\n"},{"name":"public_proposals_0d_filetest.gno","body":"package main\n\nimport (\n\t\"std\"\n\n\tgnome \"gno.land/r/ecodevx/dao/pre1\"\n)\n\nconst member = std.Address(\"g1lyzcpa7duh69lk04nahxup484xrz4k6k2nqdun\")\n\nfunc init() {\n\tstd.TestSetOrigCaller(member)\n}\n\nfunc main() {\n\ttitle := \"Test proposal\"\n\tdesc := \"A test proposal\"\n\tdaoPath := \"invalid\"\n\tgnome.SubmitGeneralProposal(title, desc, daoPath, 0)\n}\n\n// Error:\n// DAO not found\n"},{"name":"public_proposals_0e_filetest.gno","body":"package main\n\nimport (\n\t\"std\"\n\n\tgnome \"gno.land/r/ecodevx/dao/pre1\"\n)\n\nconst member = std.Address(\"g1lyzcpa7duh69lk04nahxup484xrz4k6k2nqdun\")\n\nfunc init() {\n\tstd.TestSetOrigCaller(member)\n}\n\nfunc main() {\n\ttitle := \"Test proposal\"\n\tdaoPath := \"council/main\"\n\tgnome.SubmitGeneralProposal(title, \"\", daoPath, 0)\n}\n\n// Error:\n// proposal description is required\n"},{"name":"render.gno","body":"package gnome\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/ecodevx/alerts\"\n\tgnome \"gno.land/p/ecodevx/dao\"\n\trouter \"gno.land/p/ecodevx/router\"\n)\n\nconst (\n\tdateFmt             = \"2006-01-02 15:04 MST\"\n\tproposalTakeoverMsg = \"For the proposal outcome to change it has to be taken over by a parent DAO by voting on it\"\n)\n\nconst (\n\tcustomStyle = `\n\u003cstyle\u003e\n.custom ul { padding-left: 20px; }\n.custom li { list-style-type: disc; }\n.custom li.current { font-weight: 900; }\n.custom li \u003e p { margin: 0px; }\n\u003c/style\u003e\n`\n\tpaginatorStyle = `\u003cstyle\u003e\n.paginator { text-align: center; }\n.paginator a { text-decoration: none; }\n.paginator a:hover { text-decoration: underline; }\n.paginator .left { padding-right: 4px; }\n.paginator .right { padding-left: 4px; }\n\u003c/style\u003e`\n)\n\nfunc renderAlerts() string {\n\tif gnomeDAO.IsLocked() {\n\t\tmsg := \"Realm is locked\"\n\t\tif reason := gnomeDAO.LockReason(); reason != \"\" {\n\t\t\tmsg += \"\u003c/br\u003e\" + reason\n\t\t}\n\n\t\treturn alerts.NewError(msg)\n\t}\n\n\tif IsProposalsAdvanceNeeded() {\n\t\treturn alerts.NewWarning(\n\t\t\tnewGnoStudioConnectLink(\"AdvanceProposals\", \"Proposals advance needed\"),\n\t\t)\n\t}\n\treturn \"\"\n}\n\nfunc renderDAO(res router.ResponseWriter, req router.Request) {\n\tvar (\n\t\tdao     *gnome.DAO\n\t\tdaoPath = req.Route\n\t)\n\n\tif daoPath == \"\" {\n\t\tdao = gnomeDAO\n\t\tdaoPath = nameCouncilDAO\n\t} else {\n\t\tvar found bool\n\t\tdao, found = daos.GetByPath(daoPath)\n\t\tif !found {\n\t\t\tres.Write(\"DAO Not Found\")\n\t\t\treturn\n\t\t}\n\n\t\t// TODO: Add lock dismissal reason when available\n\t\tif dao.IsLocked() {\n\t\t\tres.Write(alerts.NewError(\"DAO is dismissed\"))\n\t\t}\n\t}\n\n\tres.Writef(\n\t\t\"# Gno.me DAO\\n\"+\n\t\t\t\"## %s\\n\"+\n\t\t\t\"%s\\n\\n\"+\n\t\t\t\"[View Proposals of %s](%s)\\n\",\n\t\tdao.Title(),\n\t\tdao.Manifest(),\n\t\tdao.Title(),\n\t\tmakeProposalsURI(daoPath, true),\n\t)\n\n\tres.Write(\"## \" + dao.Title() + \" Members\\n\")\n\tfor _, m := range dao.Members() {\n\t\tres.Write(\"- \" + m.String() + \"\\n\")\n\t}\n\n\tres.Write(\"\\n\" + customStyle + \"\\n\\n\")\n\n\tres.Write(\"## Organization\\n\\n\")\n\tres.Write(renderOrganizationTree(daoPath))\n\tres.Write(\"\\n\")\n}\n\nfunc renderProposals(res router.ResponseWriter, req router.Request) {\n\tdaoPath := req.Route\n\tdao, found := daos.GetByPath(daoPath)\n\tif !found {\n\t\tres.Write(\"DAO Not Found\")\n\t\treturn\n\t}\n\n\tdaoProposals := proposals.GetAllByDAO(dao.Path())\n\tcount := len(daoProposals)\n\tif count == 0 {\n\t\tres.Write(\"DAO has no proposals\")\n\t\treturn\n\t}\n\n\trealmPath := makeRealmPath(req.Path)\n\tpages := gnome.NewPaginator(realmPath, gnome.WithItemCount(count))\n\n\t// TODO: Add links to toggle display of dismissed proposals (when DAO dismissal is implemented)\n\n\tres.Writef(\"# %s: Proposals\\n\", dao.Title())\n\tpages.Iterate(func(i int) bool {\n\t\tif i \u003e= count {\n\t\t\treturn true\n\t\t}\n\n\t\tp := daoProposals[i]\n\t\t_ = advanceProposal(p) // TODO: Handle errors when render notice support is implemented\n\t\tpath := makeProposalURI(p.ID(), true)\n\t\tres.Writef(\"- [#%s %s](%s) (%s)\\n\", p.ID(), p.Title(), path, p.Status())\n\t\treturn false\n\t})\n\n\tif pages.IsEnabled() {\n\t\tres.Write(renderPaginator(pages))\n\t}\n}\n\n// TODO: Improve renderProposal code\nfunc renderProposal(res router.ResponseWriter, req router.Request) {\n\trawID := req.Route\n\tid, err := strconv.Atoi(rawID)\n\tif err != nil {\n\t\tres.Write(\"Invalid proposal ID: \" + gnome.EscapeHTML(rawID))\n\t\treturn\n\t}\n\n\tproposal, found := proposals.GetByID(gnome.ID(id))\n\tif !found {\n\t\tres.Write(\"Proposal Not Found\")\n\t\treturn\n\t}\n\n\tvar (\n\t\toutcome gnome.ProposalStatus\n\t\tstatus  = proposal.Status()\n\t)\n\n\t// When the status is not final advance the proposal to calculate the current outcome\n\tif !status.IsFinal() {\n\t\t_ = advanceProposal(proposal) // TODO: Implement generic alert support for render and use it to render errors\n\t\toutcome = proposal.Status()\n\n\t\t// Validate if proposal is valid for the current state\n\t\tif err := proposal.Validate(); err != nil {\n\t\t\tres.Write(alerts.NewError(err.Error()))\n\t\t}\n\n\t\t// Warn when the outcome could change if a member of a parent DAO votes on this proposal.\n\t\t// Proposal choice is only available when there is a majority, so there is voting concensus.\n\t\tif proposal.Choice() != gnome.ChoiceNone \u0026\u0026 !proposal.HasVotingDeadlinePassed() {\n\t\t\tres.Write(alerts.NewWarning(proposalTakeoverMsg))\n\t\t}\n\t} else if status == gnome.StatusDismissed {\n\t\t// Display an alert with the dismiss reason\n\t\tres.Write(alerts.NewWarning(proposal.StatusReason()))\n\t}\n\n\tdao := proposal.DAO()\n\tdaoPath := dao.Path()\n\tif proposal.HasBeenPromoted() {\n\t\turi := makeDAOURI(daoPath, true)\n\t\tlink := alerts.NewLink(uri, dao.Title())\n\t\tres.Write(alerts.NewWarning(\"Proposal has been promoted to \" + link + \" DAO\"))\n\t}\n\n\tres.Write(\"# #\" + proposal.ID().String() + \" \" + proposal.Title() + \"\\n\")\n\tres.Write(\"- Type: \" + proposal.Strategy().Name() + \"\\n\")\n\tres.Write(\"- Created: \" + proposal.CreatedAt().UTC().Format(dateFmt) + \"\\n\")\n\tres.Write(\"- Proposer: \" + proposal.Proposer().String() + \"\\n\")\n\tres.Write(\"- Status: \" + getProposalStatusMarkdown(status, proposal.Choice(), proposal.StatusReason()) + \"\\n\")\n\n\tif !status.IsFinal() {\n\t\tif outcome == gnome.StatusReview {\n\t\t\tres.Write(\"- Review Deadline: \" + proposal.ReviewDeadline().UTC().Format(dateFmt) + \"\\n\")\n\t\t} else {\n\t\t\tres.Write(\"- Voting Deadline: \" + proposal.VotingDeadline().UTC().Format(dateFmt) + \"\\n\")\n\t\t\tres.Write(\"- Expected Outcome: \" + getProposalStatusMarkdown(outcome, proposal.Choice(), proposal.StatusReason()) + \"\\n\")\n\n\t\t\t// Vote line should be render as long as voting deadline is not reached.\n\t\t\t// This is required for proposals that have to be advanced after deadline is reached.\n\t\t\tif !proposal.HasVotingDeadlinePassed() {\n\t\t\t\tres.Write(\"\\n\" + newGnoStudioConnectLink(\"Vote\", \"Vote on this proposal\") + \"\\n\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif s := proposal.Description(); s != \"\" {\n\t\tres.Write(\"## Description\\n\" + s + \"\\n\")\n\t}\n\n\tif r, ok := proposal.Strategy().(gnome.ParamsRenderer); ok {\n\t\t// TODO: Use custom HTML component to allow users to toggle params visibility\n\t\tif s := r.RenderParams(); s != \"\" {\n\t\t\tres.Write(\"## Parameters\\n\\n\" + s + \"\\n\")\n\t\t}\n\t}\n\n\tres.Write(\"## Votes\\n\")\n\trecord := proposal.VotingRecord()\n\tif record.VoteCount() == 0 {\n\t\tres.Write(\"The proposal has no votes\\n\")\n\t} else {\n\t\t// TODO: Render percentages for each voting choice and abstentions?\n\t\trecord.Iterate(func(c gnome.VoteChoice, count uint) bool {\n\t\t\tres.Writef(\"- %s: %d\\n\", string(c), count)\n\t\t\treturn false\n\t\t})\n\n\t\tres.Write(\"## Participation\\n\")\n\t\trenderProposalParticipation(res, record.Votes())\n\t}\n\n\t// If proposal has been promoted to a parent DAO render participation in child DAOs\n\tif proposal.HasBeenPromoted() {\n\t\tres.Write(\"## Sub DAOs Participation\\n\")\n\t\tdaos := proposal.Promotions()\n\t\trecords := proposal.VotingRecords()\n\t\tfor i := len(records) - 2; i \u003e= 0; i-- { // reverse iteration excluding record for current DAO\n\t\t\tr := records[i]\n\t\t\tdao := daos[i]\n\t\t\tres.Write(\"### [\" + dao.Title() + \"](\" + makeDAOURI(daoPath, true) + \"]\\n\")\n\t\t\trenderProposalParticipation(res, r.Votes())\n\t\t}\n\t}\n}\n\nfunc renderParams(res router.ResponseWriter, req router.Request) {\n\tres.Write(\"# Gno.me DAO: Parameters\\n\")\n\tres.Write(\"## Proposal\\n\")\n\tres.Write(\"**General**\\n\")\n\tres.Write(\"- Review Deadline: \" + gnome.HumanizeDuration(parameters.ReviewDeadline) + \"\\n\")\n\n\tres.Write(\"\\n**Voting Periods**\\n\")\n\tparameters.VotingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tres.Write(\"- `\" + name + \"`: \" + gnome.HumanizeDuration(period) + \"\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderProposalParticipation(res router.ResponseWriter, votes []gnome.Vote) {\n\tfor _, v := range votes {\n\t\tchoice := string(v.Choice)\n\t\tif v.Reason != \"\" {\n\t\t\t// TODO: Long reasons have to break lines to fit making web UI look bad\n\t\t\tchoice += ` \"` + gnome.EscapeHTML(v.Reason) + `\"`\n\t\t}\n\n\t\tres.Writef(\"- %s: voted %s\\n\", v.Address.String(), choice)\n\t}\n}\n\n// TODO: Use the UI package for HTML elements because rendered Markdown styles break the tree\nfunc renderOrganizationTree(currentPath string) string {\n\tvar item string\n\tif gnomeDAO.Name() == currentPath {\n\t\titem = `\u003cli class=\"current\"\u003e` + gnomeDAO.Title() + `\u003c/li\u003e`\n\t} else {\n\t\turi := makeDAOURI(gnomeDAO.Path(), true)\n\t\titem = `\u003cli\u003e` + alerts.NewLink(uri, gnomeDAO.Title()) + `\u003c/li\u003e`\n\t}\n\treturn `\u003cdiv class=\"custom\"\u003e\u003cul\u003e` + item + renderSubTree(gnomeDAO, currentPath) + `\u003c/ul\u003e\u003c/div\u003e`\n}\n\nfunc renderSubTree(parentDAO *gnome.DAO, currentPath string) string {\n\tvar (\n\t\tbuf  strings.Builder\n\t\titem string\n\t)\n\n\tfor _, dao := range parentDAO.SubDAOs() {\n\t\tif dao.IsLocked() {\n\t\t\t// Skip dismissed DAOs\n\t\t\t// TODO: Render filter option to toggle dismissed DAOs visibility\n\t\t\tcontinue\n\t\t}\n\n\t\tif dao.Path() == currentPath {\n\t\t\titem = `\u003cli class=\"current\"\u003e` + dao.Title() + `\u003c/li\u003e`\n\t\t} else {\n\t\t\turi := makeDAOURI(dao.Path(), true)\n\t\t\titem = `\u003cli\u003e` + alerts.NewLink(uri, dao.Title()) + `\u003c/li\u003e`\n\t\t}\n\n\t\tbuf.WriteString(item)\n\n\t\tif len(dao.SubDAOs()) \u003e 0 {\n\t\t\tbuf.WriteString(renderSubTree(dao, currentPath))\n\t\t}\n\t}\n\treturn `\u003cul\u003e` + buf.String() + `\u003c/ul\u003e`\n}\n\nfunc renderPaginator(p gnome.Paginator) string {\n\tvar out string\n\tif s := p.PrevPageURI(); s != \"\" {\n\t\tout = ufmt.Sprintf(`\u003ca href=\"%s\" class=\"left\"\u003e\u0026lt;-\u003c/a\u003e`, s)\n\t} else {\n\t\tout += `\u003cspan class=\"left\"\u003e--\u003c/span\u003e`\n\t}\n\n\t// TODO: Add display links to other page numbers?\n\tout += ufmt.Sprintf(\"page %d\", p.Page())\n\n\tif s := p.NextPageURI(); s != \"\" {\n\t\tout += ufmt.Sprintf(`\u003ca href=\"%s\" class=\"right\"\u003e-\u0026gt;\u003c/a\u003e`, s)\n\t} else {\n\t\tout += `\u003cspan class=\"right\"\u003e--\u003c/span\u003e`\n\t}\n\n\treturn \"\\n\" + paginatorStyle + `\u003cp class=\"paginator\"\u003e` + out + `\u003c/p\u003e`\n}\n\nfunc advanceProposal(p *gnome.Proposal) error {\n\tstatus := p.Status()\n\tif status == gnome.StatusReview \u0026\u0026 p.HasReviewDeadlinePassed() {\n\t\tif err := p.Activate(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tstatus = p.Status()\n\t}\n\n\tif status == gnome.StatusActive {\n\t\t// Tally active proposals to always have an up to date state with the current proposal outcome\n\t\tif err := p.Tally(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc getProposalStatusMarkdown(s gnome.ProposalStatus, c gnome.VoteChoice, reason string) string {\n\tswitch s {\n\tcase gnome.StatusPassed:\n\t\treturn ufmt.Sprintf(\"**%s** (%s)\", s, string(c))\n\tcase gnome.StatusRejected:\n\t\t// Rejected proposal might have a reason\n\t\tif reason == \"\" {\n\t\t\treturn ufmt.Sprintf(\"**%s**\", s)\n\t\t} else {\n\t\t\treturn ufmt.Sprintf(\"**%s** (%s)\", s, reason)\n\t\t}\n\tcase gnome.StatusDismissed, gnome.StatusFailed:\n\t\treturn ufmt.Sprintf(\"**%s** (%s)\", s, reason)\n\tdefault:\n\t\treturn ufmt.Sprintf(\"**%s**\", s)\n\t}\n}\n\nfunc newGnoStudioConnectLink(functionName, label string) string {\n\thref := makeGnoStudioConnectURL(functionName)\n\treturn alerts.NewLink(href, label)\n}\n"},{"name":"strategy_budget.gno","body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc newBudgetStrategy(council *gnome.DAO, budget string) budgetStrategy {\n\tif council == nil {\n\t\tpanic(\"council DAO is requried\")\n\t}\n\n\tif !council.IsSuperCouncil() {\n\t\tpanic(\"budget strategy expects DAO to be a super council\")\n\t}\n\n\tbudget = strings.TrimSpace(budget)\n\tif budget == \"\" {\n\t\tpanic(\"budget is required\")\n\t}\n\n\t// The council DAO must have at least one sub DAO which should the main DAO.\n\t// The first sub DAO is some times used to check if a vote is valid.\n\tif len(council.SubDAOs()) == 0 {\n\t\tpanic(\"budget strategy expects council DAO to have at least one sub DAO\")\n\t}\n\n\treturn budgetStrategy{\n\t\tchoices: []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo},\n\t\tcouncil: council,\n\t\tbudget:  budget, // TODO: Validate/split budget format? (ex. AMOUNTSYMBOL: 10USD)\n\t}\n}\n\ntype budgetStrategy struct {\n\tchoices []gnome.VoteChoice\n\tcouncil *gnome.DAO\n\tbudget  string\n}\n\n// Name returns the name of the strategy.\nfunc (budgetStrategy) Name() string {\n\treturn StrategyNameBudget\n}\n\n// Quorum returns the minimum required percentage of DAO member votes\n// required for a proposal to pass.\nfunc (budgetStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\n// VotingPeriod returns the period that a proposal should allow voting.\nfunc (budgetStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameBudget)\n\treturn period\n}\n\n// VoteChoices returns the valid voting choices for the strategy.\nfunc (s budgetStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn s.choices\n}\n\n// CheckVote checks that a vote is valid for the strategy.\nfunc (s budgetStrategy) CheckVote(addr std.Address, _ gnome.VoteChoice, _ string) error {\n\t// Check that voter address belongs to a council DAO member\n\tif s.council.HasMember(addr) {\n\t\treturn nil\n\t}\n\n\t// Make sure the main DAO was not dismissed and check that voter address belongs to a main DAO member\n\t// TODO: Check DAO status instead when DAO dismissal is implemented\n\tif sub := s.council.SubDAOs(); len(sub) \u003e 0 {\n\t\tmainDAO := sub[0]\n\t\tif !mainDAO.HasMember(addr) {\n\t\t\treturn errors.New(\"only members of the council DAO or main DAO can vote on budget proposals\")\n\t\t}\n\t} else {\n\t\treturn errors.New(\"main DAO not found\")\n\t}\n\treturn nil\n}\n\n// Tally counts the votes and returns the winner voting choice.\nfunc (budgetStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\t// Consider abstentions to make the majority absolute\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\n// RenderParams returns a markdown with the rendered strategy parameters.\nfunc (s budgetStrategy) RenderParams() string {\n\treturn \"Budget: \" + gnome.EscapeHTML(s.budget)\n}\n"},{"name":"strategy_budget_test.gno","body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/testutils\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc TestBudgetStrategy(t *testing.T) {\n\tcases := []struct {\n\t\tname    string\n\t\tcouncil *gnome.DAO\n\t\terr     string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\tcouncil: gnome.MustNew(\"council\", \"Council\",\n\t\t\t\tgnome.AssignAsSuperCouncil(),\n\t\t\t\tgnome.WithSubDAO(\n\t\t\t\t\tgnome.MustNew(\"main\", \"Main\"),\n\t\t\t\t),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"nil council\",\n\t\t\terr:  \"council DAO is requried\",\n\t\t},\n\t\t{\n\t\t\tname:    \"no super council\",\n\t\t\tcouncil: gnome.MustNew(\"council\", \"Council\"),\n\t\t\terr:     \"budget strategy expects DAO to be a super council\",\n\t\t},\n\t\t{\n\t\t\tname:    \"council without main DAO\",\n\t\t\tcouncil: gnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil()),\n\t\t\terr:     \"budget strategy expects council DAO to have at least one sub DAO\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tname := StrategyNameBudget\n\t\t\tquorum := 0.51\n\t\t\tvotingPeriod := time.Hour * 24 * 7\n\t\t\tchoices := fmt.Sprintf(\"%v\", []gnome.VoteChoice{\n\t\t\t\tgnome.ChoiceYes,\n\t\t\t\tgnome.ChoiceNo,\n\t\t\t})\n\n\t\t\t// Act\n\t\t\tvar s budgetStrategy\n\t\t\terr := handlePanic(t, func() {\n\t\t\t\ts = newBudgetStrategy(tc.council, \"1USD\")\n\t\t\t})\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif got := s.Name(); got != name {\n\t\t\t\tt.Fatalf(\"expected strategy name: '%s', got: '%s'\", name, got)\n\t\t\t}\n\n\t\t\tif got := s.Quorum(); got != quorum {\n\t\t\t\tt.Fatalf(\"expected strategy quorum: %.2f, got: %.2f\", quorum, got)\n\t\t\t}\n\n\t\t\tif got := s.VotingPeriod(); got != votingPeriod {\n\t\t\t\tt.Fatalf(\"expected strategy voting period: %d, got: %d\", votingPeriod, got)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", s.VoteChoices()); got != choices {\n\t\t\t\tt.Fatalf(\"expected strategy vote choices: %s, got: %s\", choices, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBudgetStrategyCheckVote(t *testing.T) {\n\tcouncilMember := newTestMember(t, \"council\")\n\tmainMember := newTestMember(t, \"main\")\n\tcouncil := gnome.MustNew(\n\t\t\"council\",\n\t\t\"Council\",\n\t\tgnome.AssignAsSuperCouncil(),\n\t\tgnome.WithMembers(councilMember),\n\t\tgnome.WithSubDAO(\n\t\t\tgnome.MustNew(\"main\", \"Main\", gnome.WithMembers(mainMember)),\n\t\t),\n\t)\n\n\tcases := []struct {\n\t\tname    string\n\t\taddress std.Address\n\t\tchoice  gnome.VoteChoice\n\t\tcouncil *gnome.DAO\n\t\terr     string\n\t}{\n\t\t{\n\t\t\tname:    \"council DAO vote\",\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\taddress: councilMember.Address,\n\t\t\tcouncil: council,\n\t\t},\n\t\t{\n\t\t\tname:    \"main DAO vote\",\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\taddress: mainMember.Address,\n\t\t\tcouncil: council,\n\t\t},\n\t\t{\n\t\t\tname:    \"non member vote\",\n\t\t\tchoice:  gnome.ChoiceNo,\n\t\t\taddress: testutils.TestAddress(\"foo\"),\n\t\t\tcouncil: council,\n\t\t\terr:     \"only members of the council DAO or main DAO can vote on budget proposals\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\ts := newBudgetStrategy(tc.council, \"1USD\")\n\n\t\t\t// Act\n\t\t\terr := s.CheckVote(tc.address, tc.choice, \"\")\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t} else {\n\t\t\t\tassertNoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBudgetStrategyTally(t *testing.T) {\n\tcouncil := gnome.MustNew(\n\t\t\"council\",\n\t\t\"Council\",\n\t\tgnome.AssignAsSuperCouncil(),\n\t\tgnome.WithMembers(\n\t\t\tnewTestMember(t, \"member1\"),\n\t\t\tnewTestMember(t, \"member2\"),\n\t\t\tnewTestMember(t, \"member3\"),\n\t\t\tnewTestMember(t, \"member4\"),\n\t\t),\n\t\tgnome.WithSubDAO(\n\t\t\tgnome.MustNew(\"main\", \"Main\"),\n\t\t),\n\t)\n\tcases := []struct {\n\t\tname   string\n\t\tvotes  []gnome.Vote\n\t\tchoice gnome.VoteChoice\n\t}{\n\t\t{\n\t\t\tname: \"majority\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname: \"majority with abstentions\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"no quorum\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t\t{\n\t\t\tname: \"no quorum with abstentions\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\trecord := gnome.NewVotingRecord()\n\t\t\tfor _, v := range tc.votes {\n\t\t\t\trecord.Add(v)\n\t\t\t}\n\n\t\t\ts := newBudgetStrategy(council, \"1USD\")\n\n\t\t\t// Act\n\t\t\tchoice := s.Tally(council, *record)\n\n\t\t\t// Assert\n\t\t\tif choice != tc.choice {\n\t\t\t\tt.Fatalf(\"expected tally result choice: '%v', got: '%v'\", tc.choice, choice)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc handlePanic(t *testing.T, fn func()) (reason error) {\n\tt.Helper()\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif err, _ := r.(error); err != nil {\n\t\t\t\treason = err\n\t\t\t} else {\n\t\t\t\treason = errors.New(fmt.Sprint(r))\n\t\t\t}\n\t\t}\n\t}()\n\n\tfn()\n\treturn\n}\n"},{"name":"strategy_dao.gno","body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// Minimum number of members per DAO.\n// This requirement is enforced because two members DAO can only use plurality to tally.\nconst minMembersCount = 3\n\nfunc newSubDAOCreationStrategy(daos daoIndex, name, title, manifest string, members []gnome.Member) subDAOCreationStrategy {\n\tif strings.TrimSpace(name) == \"\" {\n\t\tpanic(\"sub DAO name is required\")\n\t}\n\n\tif !gnome.IsSlug(name) {\n\t\tpanic(`invalid sub DAO name, only letters from \"a\" to \"z\", numbers, \"-\" and \"_\" are allowed`)\n\t}\n\n\tif strings.TrimSpace(title) == \"\" {\n\t\tpanic(\"sub DAO title is required\")\n\t}\n\n\tif strings.TrimSpace(manifest) == \"\" {\n\t\tpanic(\"sub DAO manifest is required\")\n\t}\n\n\tif len(members) \u003c minMembersCount {\n\t\tpanic(\"sub DAOs require at least \" + strconv.Itoa(minMembersCount) + \" members\")\n\t}\n\n\treturn subDAOCreationStrategy{\n\t\tchoices:  []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo},\n\t\tdaos:     daos,\n\t\tname:     name,\n\t\ttitle:    title,\n\t\tmanifest: manifest,\n\t\tmembers:  members,\n\t}\n}\n\ntype subDAOCreationStrategy struct {\n\tchoices               []gnome.VoteChoice\n\tdaos                  daoIndex\n\tname, title, manifest string\n\tmembers               []gnome.Member\n}\n\n// Name returns the name of the strategy.\nfunc (subDAOCreationStrategy) Name() string {\n\treturn StrategyNameSubDAOCreation\n}\n\n// Quorum returns the minimum required percentage of DAO member votes\n// required for a proposal to pass.\nfunc (subDAOCreationStrategy) Quorum() float64 {\n\treturn 1.0\n}\n\n// VotingPeriod returns the period that a proposal should allow voting.\nfunc (subDAOCreationStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameSubDAOCreation)\n\treturn period\n}\n\n// VoteChoices returns the valid voting choices for the strategy.\nfunc (s subDAOCreationStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn s.choices\n}\n\n// Tally counts the votes and returns the winner voting choice.\nfunc (subDAOCreationStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\t// Strategy need 100% participation to decide on the outcome.\n\t// Normally quorum should make sure all members voted before\n\t// tallying but otherwise tally should not return a valid outcome.\n\tif len(dao.Members()) != r.VoteCount() {\n\t\treturn gnome.ChoiceNone\n\t}\n\n\t// This type of proposals can pass only when 100% of members vote YES.\n\tfor _, v := range r.Votes() {\n\t\t// If there is at least one NO vote then proposal must be rejected\n\t\tif v.Choice == gnome.ChoiceNo {\n\t\t\treturn gnome.ChoiceNo\n\t\t}\n\t}\n\t// Proposal should pass when all votes are YES\n\treturn gnome.ChoiceYes\n}\n\n// Validate validates if a proposal is valid for the current state.\nfunc (s subDAOCreationStrategy) Validate(p *gnome.Proposal) error {\n\tdao := p.DAO()\n\tpath := dao.Path()\n\tif dao.IsLocked() {\n\t\treturn errors.New(\"parent DAO '\" + path + \"' is locked\")\n\t}\n\n\tsubDAOPath := path + gnome.PathSeparator + s.name\n\tif s.daos.HasPathKey(subDAOPath) {\n\t\treturn errors.New(\"sub DAO path has been taken by another DAO\")\n\t}\n\treturn nil\n}\n\n// RenderParams returns a markdown with the rendered strategy parameters.\nfunc (s subDAOCreationStrategy) RenderParams() string {\n\tvar (\n\t\tb        strings.Builder\n\t\tmembers  []string\n\t\tmanifest = gnome.EscapeHTML(s.manifest)\n\t)\n\n\tfor _, addr := range s.members {\n\t\tmembers = append(members, addr.String())\n\t}\n\n\t// TODO: Use a custom HTML table and add styling (vertical alignment, padding, ...)\n\t//       This would allow to remove the markdown \"hacks\" to improve the output layout\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\tb.WriteString(\"| Name: | \" + gnome.EscapeHTML(s.name) + \" |\\n\")\n\tb.WriteString(\"| Title: | \" + gnome.EscapeHTML(s.title) + \" |\\n\")\n\tb.WriteString(\"| Members: | \u003c/br\u003e\" + strings.Join(members, \"\u003c/br\u003e\") + \"\u003c/br\u003e\u003c/br\u003e |\\n\")\n\tb.WriteString(\"| Manifest:\u0026nbsp;\u0026nbsp; | \" + strings.ReplaceAll(manifest, \"\\n\", \"\u003c/br\u003e\") + \" |\\n\")\n\n\treturn b.String()\n}\n\n// Execute creates the new sub DAO.\nfunc (s subDAOCreationStrategy) Execute(dao *gnome.DAO) error {\n\tsubDAO, err := gnome.New(s.name, s.title, gnome.WithManifest(s.manifest), gnome.WithMembers(s.members...))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new sub DAO to its parent\n\tdao.AddSubDAO(subDAO)\n\n\t// Index the new sub DAO\n\ts.daos.IndexByPath(subDAO)\n\n\treturn nil\n}\n\nfunc newDAOMembersModificationStrategy(newMembers, removeMembers []gnome.Member) daoMembersModificationStrategy {\n\tif len(newMembers) == 0 \u0026\u0026 len(removeMembers) == 0 {\n\t\tpanic(\"members are required\")\n\t}\n\n\treturn daoMembersModificationStrategy{\n\t\tchoices:       []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo},\n\t\tnewMembers:    newMembers,\n\t\tremoveMembers: removeMembers,\n\t}\n}\n\ntype daoMembersModificationStrategy struct {\n\tchoices                   []gnome.VoteChoice\n\tnewMembers, removeMembers []gnome.Member\n}\n\n// Name returns the name of the strategy.\nfunc (daoMembersModificationStrategy) Name() string {\n\treturn StrategyNameDAOMembersModification\n}\n\n// Quorum returns the minimum required percentage of DAO member votes\n// required for a proposal to pass.\nfunc (daoMembersModificationStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\n// VotingPeriod returns the period that a proposal should allow voting.\nfunc (daoMembersModificationStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameDAOMembersModification)\n\treturn period\n}\n\n// VoteChoices returns the valid voting choices for the strategy.\nfunc (s daoMembersModificationStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn s.choices\n}\n\n// Tally counts the votes and returns the winner voting choice.\nfunc (daoMembersModificationStrategy) Tally(_ *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\t// Tally requires at least three votes to be able to tally by 2/3s super majority\n\tif r.VoteCount() \u003c 3 {\n\t\treturn gnome.ChoiceNone\n\t}\n\n\tif choice, ok := gnome.SelectChoiceBySuperMajority(r); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\n// Validate validates if a proposal is valid for the current DAO state.\nfunc (s daoMembersModificationStrategy) Validate(p *gnome.Proposal) error {\n\t// At least three members are required to enforce 2/3s majority on proposals\n\tdao := p.DAO()\n\tmemberCount := len(dao.Members()) + len(s.newMembers) - len(s.removeMembers)\n\tif memberCount \u003c minMembersCount {\n\t\treturn errors.New(\"DAO must always have a minimum of \" + strconv.Itoa(minMembersCount) + \" members\")\n\t}\n\n\t// TODO: Should we allow re-adding members to only change assigned roles?\n\tfor _, m := range s.newMembers {\n\t\tif dao.HasMember(m.Address) {\n\t\t\treturn errors.New(\"address is already a DAO member: \" + m.Address.String())\n\t\t}\n\t}\n\n\tfor _, m := range s.removeMembers {\n\t\tif !dao.HasMember(m.Address) {\n\t\t\treturn errors.New(\"address is not a DAO member: \" + m.Address.String())\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Execute modifies main DAO members.\nfunc (s daoMembersModificationStrategy) Execute(dao *gnome.DAO) error {\n\tfor _, m := range s.removeMembers {\n\t\tdao.RemoveMember(m.Address)\n\t}\n\n\tfor _, m := range s.newMembers {\n\t\tdao.AddMember(m)\n\t}\n\n\treturn nil\n}\n\n// RenderParams returns a markdown with the rendered strategy parameters.\nfunc (s daoMembersModificationStrategy) RenderParams() string {\n\tvar b strings.Builder\n\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\n\tif len(s.newMembers) \u003e 0 {\n\t\tvar members []string\n\t\tfor _, m := range s.newMembers {\n\t\t\tmembers = append(members, m.String())\n\t\t}\n\n\t\tb.WriteString(\"| New Members: | \" + strings.Join(members, \"\u003c/br\u003e\") + \"\u003c/br\u003e\u003c/br\u003e |\\n\")\n\t}\n\n\tif len(s.removeMembers) \u003e 0 {\n\t\tvar members []string\n\t\tfor _, m := range s.removeMembers {\n\t\t\tmembers = append(members, m.String())\n\t\t}\n\n\t\tb.WriteString(\"| Members to Remove: | \" + strings.Join(members, \"\u003c/br\u003e\") + \" |\\n\")\n\t}\n\n\treturn b.String()\n}\n\nfunc newSubDAODismissalStrategy(dao *gnome.DAO, x proposalIndex) subDAODismissalStrategy {\n\tif dao == nil {\n\t\tpanic(\"DAO is required\")\n\t}\n\n\treturn subDAODismissalStrategy{\n\t\tchoices:   []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo},\n\t\tdao:       dao,\n\t\tproposals: x,\n\t}\n}\n\ntype subDAODismissalStrategy struct {\n\tchoices   []gnome.VoteChoice\n\tdao       *gnome.DAO\n\tproposals proposalIndex\n}\n\n// Name returns the name of the strategy.\nfunc (subDAODismissalStrategy) Name() string {\n\treturn StrategyNameSubDAODismissal\n}\n\n// Quorum returns the minimum required percentage of DAO member votes\n// required for a proposal to pass.\nfunc (subDAODismissalStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\n// VotingPeriod returns the period that a proposal should allow voting.\nfunc (subDAODismissalStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameSubDAODismissal)\n\treturn period\n}\n\n// VoteChoices returns the valid voting choices for the strategy.\nfunc (s subDAODismissalStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn s.choices\n}\n\n// Tally counts the votes and returns the winner voting choice.\nfunc (subDAODismissalStrategy) Tally(_ *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tif choice, ok := gnome.SelectChoiceByPlurality(r); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\n// Validate validates if a proposal is valid for the current DAO state.\nfunc (s subDAODismissalStrategy) Validate(p *gnome.Proposal) error {\n\tparentDAO := s.dao.Parent()\n\tif parentDAO == nil {\n\t\treturn errors.New(\"the DAO to dismiss has no parent DAO\")\n\t}\n\n\tparentName := p.DAO().Name()\n\tif parentDAO.Name() != parentName {\n\t\treturn errors.New(`the DAO to dismiss must be a first level sub DAO of \"` + parentName + `\"`)\n\t}\n\treturn nil\n}\n\n// Execute modifies main DAO members.\nfunc (s subDAODismissalStrategy) Execute(*gnome.DAO) error {\n\t// Get the list of all sub DAOs and the root DAO to dismiss\n\tdaos := append(collectSubDAOs(s.dao), s.dao)\n\t// Proposal dismissal requires a reason\n\t// TODO: Send proposal to Execute and add dismissal proposal link?\n\treason := \"Dismissed because of DAO dismissal: \" + s.dao.Path()\n\n\tfor _, dao := range daos {\n\t\t// Dismiss all proposals for the current DAO\n\t\tfor _, p := range s.proposals.GetAllByDAO(dao.Path()) {\n\t\t\tif !p.Status().IsFinal() {\n\t\t\t\tp.Dismiss(reason)\n\t\t\t}\n\t\t}\n\n\t\t// Lock the DAO to dismiss it\n\t\tdao.Lock(\"\")\n\t}\n\treturn nil\n}\n\n// RenderParams returns a markdown with the rendered strategy parameters.\nfunc (s subDAODismissalStrategy) RenderParams() string {\n\treturn \"DAO: \" + s.dao.Path()\n}\n\nfunc collectSubDAOs(dao *gnome.DAO) []*gnome.DAO {\n\tdaos := dao.SubDAOs()\n\tfor _, sub := range daos[:] {\n\t\tdaos = append(daos, collectSubDAOs(sub)...)\n\t}\n\treturn daos\n}\n"},{"name":"strategy_dao_test.gno","body":"package gnome\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/testutils\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc TestSubDAOCreationStrategy(t *testing.T) {\n\tcases := []struct {\n\t\tname, daoName, title, manifest, err string\n\t\tmembers                             []gnome.Member\n\t}{\n\t\t{\n\t\t\tname:     \"ok\",\n\t\t\tdaoName:  \"test\",\n\t\t\ttitle:    \"Test\",\n\t\t\tmanifest: \"Test manifest\",\n\t\t\tmembers: []gnome.Member{\n\t\t\t\tnewTestMember(t, \"address1\"),\n\t\t\t\tnewTestMember(t, \"address2\"),\n\t\t\t\tnewTestMember(t, \"address3\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"without name\",\n\t\t\terr:  \"sub DAO name is required\",\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid name\",\n\t\t\tdaoName: \"invalid name\",\n\t\t\terr:     `invalid sub DAO name, only letters from \"a\" to \"z\", numbers, \"-\" and \"_\" are allowed`,\n\t\t},\n\t\t{\n\t\t\tname:    \"without title\",\n\t\t\tdaoName: \"test\",\n\t\t\terr:     \"sub DAO title is required\",\n\t\t},\n\t\t{\n\t\t\tname:    \"without manifest\",\n\t\t\tdaoName: \"test\",\n\t\t\ttitle:   \"Test\",\n\t\t\terr:     \"sub DAO manifest is required\",\n\t\t},\n\t\t{\n\t\t\tname:     \"less than two DAO members\",\n\t\t\tdaoName:  \"test\",\n\t\t\ttitle:    \"Test\",\n\t\t\tmanifest: \"Test manifest\",\n\t\t\terr:      \"sub DAOs require at least 3 members\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tname := StrategyNameSubDAOCreation\n\t\t\tquorum := 1.0\n\t\t\tvotingPeriod := time.Hour * 24 * 7\n\t\t\tchoices := fmt.Sprintf(\"%v\", []gnome.VoteChoice{\n\t\t\t\tgnome.ChoiceYes,\n\t\t\t\tgnome.ChoiceNo,\n\t\t\t})\n\n\t\t\t// Act\n\t\t\tvar s subDAOCreationStrategy\n\t\t\terr := handlePanic(t, func() {\n\t\t\t\ts = newSubDAOCreationStrategy(daoIndex{}, tc.daoName, tc.title, tc.manifest, tc.members)\n\t\t\t})\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif got := s.Name(); got != name {\n\t\t\t\tt.Fatalf(\"expected strategy name: '%s', got: '%s'\", name, got)\n\t\t\t}\n\n\t\t\tif got := s.Quorum(); got != quorum {\n\t\t\t\tt.Fatalf(\"expected strategy quorum: %.2f, got: %.2f\", quorum, got)\n\t\t\t}\n\n\t\t\tif got := s.VotingPeriod(); got != votingPeriod {\n\t\t\t\tt.Fatalf(\"expected strategy voting period: %d, got: %d\", votingPeriod, got)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", s.VoteChoices()); got != choices {\n\t\t\t\tt.Fatalf(\"expected strategy vote choices: %s, got: %s\", choices, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSubDAOCreationStrategyTally(t *testing.T) {\n\tdao := gnome.MustNew(\"main\", \"Main\", gnome.WithMembers(\n\t\tnewTestMember(t, \"member1\"),\n\t\tnewTestMember(t, \"member2\"),\n\t\tnewTestMember(t, \"member3\"),\n\t))\n\tcases := []struct {\n\t\tname   string\n\t\tvotes  []gnome.Vote\n\t\tchoice gnome.VoteChoice\n\t}{\n\t\t{\n\t\t\tname: \"quorum vote yes\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname: \"quorum vote no\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"quorum with different choices\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"no quorum\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\trecord := gnome.NewVotingRecord()\n\t\t\tfor _, v := range tc.votes {\n\t\t\t\trecord.Add(v)\n\t\t\t}\n\n\t\t\ts := newSubDAOCreationStrategy(daoIndex{}, \"name\", \"Name\", \"Manifest\", []gnome.Member{\n\t\t\t\tnewTestMember(t, \"member1\"),\n\t\t\t\tnewTestMember(t, \"member2\"),\n\t\t\t\tnewTestMember(t, \"member3\"),\n\t\t\t})\n\n\t\t\t// Act\n\t\t\tchoice := s.Tally(dao, *record)\n\n\t\t\t// Assert\n\t\t\tif choice != tc.choice {\n\t\t\t\tt.Fatalf(\"expected tally result choice: '%v', got: '%v'\", tc.choice, choice)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSubDAOCreationStrategyValidate(t *testing.T) {\n\tcases := []struct {\n\t\tname, daoName string\n\t\tsetup         func(*daoIndex) *gnome.DAO\n\t\terr           string\n\t}{\n\t\t{\n\t\t\tname:    \"ok\",\n\t\t\tdaoName: \"child\",\n\t\t\tsetup: func(*daoIndex) *gnome.DAO {\n\t\t\t\treturn gnome.MustNew(\"parent\", \"Parent\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"existing name\",\n\t\t\tdaoName: \"child\",\n\t\t\tsetup: func(x *daoIndex) *gnome.DAO {\n\t\t\t\tchild := gnome.MustNew(\"child\", \"Child\")\n\t\t\t\tdao := gnome.MustNew(\"parent\", \"Parent\", gnome.WithSubDAO(child))\n\t\t\t\tx.IndexByPath(child)\n\t\t\t\treturn dao\n\t\t\t},\n\t\t\terr: \"sub DAO path has been taken by another DAO\",\n\t\t},\n\t\t{\n\t\t\tname:    \"locked parent\",\n\t\t\tdaoName: \"child\",\n\t\t\tsetup: func(*daoIndex) *gnome.DAO {\n\t\t\t\tdao := gnome.MustNew(\"parent\", \"Parent\")\n\t\t\t\tdao.Lock(\"\")\n\t\t\t\treturn dao\n\t\t\t},\n\t\t\terr: \"parent DAO 'parent' is locked\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tx := daoIndex{}\n\t\t\tdao := tc.setup(\u0026x)\n\t\t\tmembers := []gnome.Member{\n\t\t\t\tnewTestMember(t, \"member1\"),\n\t\t\t\tnewTestMember(t, \"member2\"),\n\t\t\t\tnewTestMember(t, \"member3\"),\n\t\t\t}\n\t\t\ts := newSubDAOCreationStrategy(x, tc.daoName, \"Title\", \"Manifest\", members)\n\t\t\tp, _ := gnome.NewProposal(1, s, members[0].Address, dao, \"Title\")\n\n\t\t\t// Act\n\t\t\terr := s.Validate(p)\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t} else {\n\t\t\t\tassertNoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSubDAOCreationStrategyExecute(t *testing.T) {\n\t// Arrange\n\tdao := gnome.MustNew(\"name\", \"Name\")\n\tsubName := \"sub\"\n\ttitle := \"Sub DAO\"\n\tmanifest := \"Test manifest\"\n\n\ts := newSubDAOCreationStrategy(daoIndex{}, subName, title, manifest, []gnome.Member{\n\t\tnewTestMember(t, \"member1\"),\n\t\tnewTestMember(t, \"member2\"),\n\t\tnewTestMember(t, \"member3\"),\n\t})\n\tmembers := fmt.Sprintf(\"%v\", s.members)\n\n\t// Act\n\terr := s.Execute(dao)\n\n\t// Assert\n\tassertNoError(t, err)\n\n\tsubDAOs := dao.SubDAOs()\n\tif c := len(subDAOs); c != 1 {\n\t\tt.Fatalf(\"expected one sub DAO, got: %d\", c)\n\t}\n\n\tsubDAO := subDAOs[0]\n\tif got := subDAO.Name(); got != subName {\n\t\tt.Fatalf(\"expected sub DAO name: '%s', got: '%s'\", subName, got)\n\t}\n\n\tif got := subDAO.Title(); got != title {\n\t\tt.Fatalf(\"expected sub DAO title: '%s', got: '%s'\", title, got)\n\t}\n\n\tif got := subDAO.Manifest(); got != manifest {\n\t\tt.Fatalf(\"expected sub DAO manifest: '%s', got: '%d'\", manifest, got)\n\t}\n\n\tif got := fmt.Sprintf(\"%v\", subDAO.Members()); got != members {\n\t\tt.Fatalf(\"expected sub DAO members: '%s', got: '%s'\", members, got)\n\t}\n}\n\nfunc TestModifyDAOMembersStrategy(t *testing.T) {\n\tcases := []struct {\n\t\tname                      string\n\t\tnewMembers, removeMembers []gnome.Member\n\t\terr                       string\n\t}{\n\t\t{\n\t\t\tname: \"new and remove members\",\n\t\t\tnewMembers: []gnome.Member{\n\t\t\t\tnewTestMember(t, \"address1\"),\n\t\t\t},\n\t\t\tremoveMembers: []gnome.Member{\n\t\t\t\tnewTestMember(t, \"address2\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"new members only\",\n\t\t\tnewMembers: []gnome.Member{\n\t\t\t\tnewTestMember(t, \"address1\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"remove members only\",\n\t\t\tremoveMembers: []gnome.Member{\n\t\t\t\tnewTestMember(t, \"address1\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no members\",\n\t\t\terr:  \"members are required\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tname := StrategyNameDAOMembersModification\n\t\t\tquorum := 0.51\n\t\t\tvotingPeriod := time.Hour * 24 * 7\n\t\t\tchoices := fmt.Sprintf(\"%v\", []gnome.VoteChoice{\n\t\t\t\tgnome.ChoiceYes,\n\t\t\t\tgnome.ChoiceNo,\n\t\t\t})\n\n\t\t\t// Act\n\t\t\tvar s daoMembersModificationStrategy\n\t\t\terr := handlePanic(t, func() {\n\t\t\t\ts = newDAOMembersModificationStrategy(tc.newMembers, tc.removeMembers)\n\t\t\t})\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif got := s.Name(); got != name {\n\t\t\t\tt.Fatalf(\"expected strategy name: '%s', got: '%s'\", name, got)\n\t\t\t}\n\n\t\t\tif got := s.Quorum(); got != quorum {\n\t\t\t\tt.Fatalf(\"expected strategy quorum: %.2f, got: %.2f\", quorum, got)\n\t\t\t}\n\n\t\t\tif got := s.VotingPeriod(); got != votingPeriod {\n\t\t\t\tt.Fatalf(\"expected strategy voting period: %d, got: %d\", votingPeriod, got)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", s.VoteChoices()); got != choices {\n\t\t\t\tt.Fatalf(\"expected strategy vote choices: %s, got: %s\", choices, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestModifyDAOMembersStrategyTally(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\tvotes  []gnome.Vote\n\t\tchoice gnome.VoteChoice\n\t}{\n\t\t{\n\t\t\tname: \"super majority votes yes\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname: \"super majority votes no\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"no majority\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t\t{\n\t\t\tname: \"no quorum\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\trecord := gnome.NewVotingRecord()\n\t\t\tfor _, v := range tc.votes {\n\t\t\t\trecord.Add(v)\n\t\t\t}\n\n\t\t\ts := newDAOMembersModificationStrategy(\n\t\t\t\t[]gnome.Member{newTestMember(t, \"member5\")},\n\t\t\t\t[]gnome.Member{newTestMember(t, \"member2\")},\n\t\t\t)\n\n\t\t\t// Act\n\t\t\tchoice := s.Tally(nil, *record)\n\n\t\t\t// Assert\n\t\t\tif choice != tc.choice {\n\t\t\t\tt.Fatalf(\"expected tally result choice: '%v', got: '%v'\", tc.choice, choice)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestModifyDAOMembersStrategyValidate(t *testing.T) {\n\tmember5 := newTestMember(t, \"member5\")\n\tmembers := []gnome.Member{\n\t\tnewTestMember(t, \"member1\"),\n\t\tnewTestMember(t, \"member2\"),\n\t\tnewTestMember(t, \"member3\"),\n\t\tnewTestMember(t, \"member4\"),\n\t}\n\n\tcases := []struct {\n\t\tname                      string\n\t\tnewMembers, removeMembers []gnome.Member\n\t\tsetup                     func() *gnome.DAO\n\t\terr                       string\n\t}{\n\t\t{\n\t\t\tname:       \"ok\",\n\t\t\tnewMembers: []gnome.Member{member5},\n\t\t\tsetup: func() *gnome.DAO {\n\t\t\t\tdao := gnome.MustNew(\"main\", \"Main\", gnome.WithMembers(members...))\n\t\t\t\tgnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil(), gnome.WithSubDAO(dao))\n\t\t\t\treturn dao\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"less than three members\",\n\t\t\tnewMembers:    []gnome.Member{member5},\n\t\t\tremoveMembers: members[1:],\n\t\t\tsetup: func() *gnome.DAO {\n\t\t\t\tdao := gnome.MustNew(\"main\", \"Main\", gnome.WithMembers(members...))\n\t\t\t\tgnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil(), gnome.WithSubDAO(dao))\n\t\t\t\treturn dao\n\t\t\t},\n\t\t\terr: \"DAO must always have a minimum of 3 members\",\n\t\t},\n\t\t{\n\t\t\tname:       \"add existing member\",\n\t\t\tnewMembers: []gnome.Member{members[0]},\n\t\t\tsetup: func() *gnome.DAO {\n\t\t\t\tdao := gnome.MustNew(\"main\", \"Main\", gnome.WithMembers(members...))\n\t\t\t\tgnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil(), gnome.WithSubDAO(dao))\n\t\t\t\treturn dao\n\t\t\t},\n\t\t\terr: \"address is already a DAO member: \" + members[0].String(),\n\t\t},\n\t\t{\n\t\t\tname:          \"remove unexisting member\",\n\t\t\tremoveMembers: []gnome.Member{member5},\n\t\t\tsetup: func() *gnome.DAO {\n\t\t\t\tdao := gnome.MustNew(\"main\", \"Main\", gnome.WithMembers(members...))\n\t\t\t\tgnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil(), gnome.WithSubDAO(dao))\n\t\t\t\treturn dao\n\t\t\t},\n\t\t\terr: \"address is not a DAO member: \" + member5.String(),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tdao := tc.setup()\n\t\t\ts := newDAOMembersModificationStrategy(tc.newMembers, tc.removeMembers)\n\t\t\tp, _ := gnome.NewProposal(1, s, members[0].Address, dao, \"Title\")\n\n\t\t\t// Act\n\t\t\terr := s.Validate(p)\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t} else {\n\t\t\t\tassertNoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestModifyDAOMembersStrategyExecute(t *testing.T) {\n\t// Arrange\n\tdao := gnome.MustNew(\"main\", \"Main\", gnome.WithMembers(\n\t\tnewTestMember(t, \"member1\"),\n\t\tnewTestMember(t, \"member2\"),\n\t\tnewTestMember(t, \"member3\"),\n\t\tnewTestMember(t, \"member4\"),\n\t))\n\tnewMembers := []gnome.Member{\n\t\tnewTestMember(t, \"member5\"),\n\t\tnewTestMember(t, \"member6\"),\n\t}\n\tremoveMembers := dao.Members()[1:3]\n\ts := newDAOMembersModificationStrategy(newMembers, removeMembers)\n\n\t// Act\n\terr := s.Execute(dao)\n\n\t// Assert\n\tassertNoError(t, err)\n\n\tif c := len(dao.Members()); c != 4 {\n\t\tt.Fatalf(\"expected DAO to have 4 members, got: %d\", c)\n\t}\n\n\tfor _, m := range newMembers {\n\t\tif !dao.HasMember(m.Address) {\n\t\t\tt.Fatalf(\"expected member %s to be added to the DAO\", m.Address)\n\t\t}\n\t}\n\n\tfor _, m := range removeMembers {\n\t\tif dao.HasMember(m.Address) {\n\t\t\tt.Fatalf(\"expected member %s to be removed from the DAO\", m.Address)\n\t\t}\n\t}\n}\n\nfunc TestSubDAODismissalStrategy(t *testing.T) {\n\tcases := []struct {\n\t\tname string\n\t\tdao  *gnome.DAO\n\t\terr  string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\tdao:  gnome.MustNew(\"dao\", \"DAO\"),\n\t\t},\n\t\t{\n\t\t\tname: \"no DAO\",\n\t\t\terr:  \"DAO is required\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tname := StrategyNameSubDAODismissal\n\t\t\tquorum := 0.51\n\t\t\tvotingPeriod := time.Hour * 24 * 7\n\t\t\tchoices := fmt.Sprintf(\"%v\", []gnome.VoteChoice{\n\t\t\t\tgnome.ChoiceYes,\n\t\t\t\tgnome.ChoiceNo,\n\t\t\t})\n\n\t\t\t// Act\n\t\t\tvar s subDAODismissalStrategy\n\t\t\terr := handlePanic(t, func() {\n\t\t\t\ts = newSubDAODismissalStrategy(tc.dao, proposalIndex{})\n\t\t\t})\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif got := s.Name(); got != name {\n\t\t\t\tt.Fatalf(\"expected strategy name: '%s', got: '%s'\", name, got)\n\t\t\t}\n\n\t\t\tif got := s.Quorum(); got != quorum {\n\t\t\t\tt.Fatalf(\"expected strategy quorum: %.2f, got: %.2f\", quorum, got)\n\t\t\t}\n\n\t\t\tif got := s.VotingPeriod(); got != votingPeriod {\n\t\t\t\tt.Fatalf(\"expected strategy voting period: %d, got: %d\", votingPeriod, got)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", s.VoteChoices()); got != choices {\n\t\t\t\tt.Fatalf(\"expected strategy vote choices: %s, got: %s\", choices, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSubDAODismissalStrategyTally(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\tvotes  []gnome.Vote\n\t\tchoice gnome.VoteChoice\n\t}{\n\t\t{\n\t\t\tname: \"yes with one vote\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname: \"no with one vote\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"yes with multiple votes\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname: \"no with multiple votes\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"tie\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t\t{\n\t\t\tname: \"tie with multiple votes\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t\t{\n\t\t\tname:   \"no votes\",\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tsubDAO := gnome.MustNew(\"sub\", \"Sub DAO\")\n\t\t\trecord := gnome.NewVotingRecord()\n\t\t\tfor _, v := range tc.votes {\n\t\t\t\trecord.Add(v)\n\t\t\t}\n\n\t\t\ts := newSubDAODismissalStrategy(subDAO, proposalIndex{})\n\n\t\t\t// Act\n\t\t\tchoice := s.Tally(nil, *record)\n\n\t\t\t// Assert\n\t\t\tif choice != tc.choice {\n\t\t\t\tt.Fatalf(\"expected tally result choice: '%v', got: '%v'\", tc.choice, choice)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSubDAODismissalStrategyValidate(t *testing.T) {\n\tparentDAO := gnome.MustNew(\"parent\", \"Parent\")\n\tcases := []struct {\n\t\tname  string\n\t\tsetup func(parent *gnome.DAO) (child *gnome.DAO)\n\t\terr   string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\tsetup: func(dao *gnome.DAO) *gnome.DAO {\n\t\t\t\tchild := gnome.MustNew(\"child\", \"Child\")\n\t\t\t\tdao.AddSubDAO(child)\n\t\t\t\treturn child\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"dismiss non child DAO\",\n\t\t\tsetup: func(*gnome.DAO) *gnome.DAO {\n\t\t\t\tchild := gnome.MustNew(\"child\", \"Child\")\n\t\t\t\tgnome.MustNew(\"foo\", \"Foo\", gnome.WithSubDAO(child))\n\t\t\t\treturn child\n\t\t\t},\n\t\t\terr: `the DAO to dismiss must be a first level sub DAO of \"` + parentDAO.Name() + `\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"parent DAO not found\",\n\t\t\tsetup: func(*gnome.DAO) *gnome.DAO {\n\t\t\t\treturn gnome.MustNew(\"child\", \"Child\")\n\t\t\t},\n\t\t\terr: \"the DAO to dismiss has no parent DAO\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tchildDAO := tc.setup(parentDAO)\n\t\t\ts := newSubDAODismissalStrategy(childDAO, proposalIndex{})\n\t\t\tp, _ := gnome.NewProposal(1, s, testutils.TestAddress(\"member\"), parentDAO, \"Dismiss child DAO\")\n\n\t\t\t// Act\n\t\t\terr := s.Validate(p)\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t} else {\n\t\t\t\tassertNoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSubDAODismissalStrategyExecute(t *testing.T) {\n\t// Arrange\n\tvar (\n\t\tstrategy  testStrategy\n\t\tproposals proposalIndex\n\t)\n\n\tcaller := testutils.TestAddress(\"caller\")\n\n\tthreeDAO := gnome.MustNew(\"three\", \"Three\")\n\ttwoDAO := gnome.MustNew(\"two\", \"Two\")\n\toneDAO := gnome.MustNew(\"one\", \"One\", gnome.WithSubDAO(twoDAO), gnome.WithSubDAO(threeDAO))\n\trootDAO := gnome.MustNew(\"root\", \"Root\", gnome.WithSubDAO(oneDAO))\n\n\tp, _ := gnome.NewProposal(1, strategy, caller, rootDAO, \"Root\")\n\tproposals.Index(p)\n\n\tp, _ = gnome.NewProposal(2, strategy, caller, oneDAO, \"One\")\n\tproposals.Index(p)\n\n\tp, _ = gnome.NewProposal(3, strategy, caller, twoDAO, \"Two\")\n\tproposals.Index(p)\n\n\tp, _ = gnome.NewProposal(4, strategy, caller, threeDAO, \"Thee\")\n\tproposals.Index(p)\n\n\tdismissReason := \"Dismissed because of DAO dismissal: \" + rootDAO.Name()\n\tdaos := []*gnome.DAO{rootDAO, oneDAO, twoDAO, threeDAO}\n\ts := newSubDAODismissalStrategy(rootDAO, proposals)\n\n\t// Act\n\terr := s.Execute(nil)\n\n\t// Assert\n\tassertNoError(t, err)\n\n\tfor _, dao := range daos {\n\t\tif !dao.IsLocked() {\n\t\t\tt.Fatalf(\"expected DAO '%s' to be locked\", dao.Title())\n\t\t}\n\t}\n\n\tproposals.Iterate(func(p *gnome.Proposal) bool {\n\t\tif got := p.Status(); got != gnome.StatusDismissed {\n\t\t\tt.Fatalf(\"expected proposal '%s' status to be 'dismissed', got: '%s'\", p.Title(), got.String())\n\t\t}\n\n\t\tif got := p.StatusReason(); got != dismissReason {\n\t\t\tt.Fatalf(\"expected dismiss reason '%s', got: '%s'\", dismissReason, got)\n\t\t}\n\t\treturn false\n\t})\n}\n\ntype testStrategy struct{}\n\nfunc (testStrategy) Name() string                                            { return \"test\" }\nfunc (testStrategy) Quorum() float64                                         { return 0.51 }\nfunc (testStrategy) VotingPeriod() time.Duration                             { return time.Hour * 24 * 2 }\nfunc (testStrategy) VoteChoices() []gnome.VoteChoice                         { return []gnome.VoteChoice{gnome.ChoiceYes} }\nfunc (s testStrategy) Tally(*gnome.DAO, gnome.VotingRecord) gnome.VoteChoice { return gnome.ChoiceYes }\n\nfunc newTestMember(t *testing.T, name string) gnome.Member {\n\tt.Helper()\n\treturn gnome.NewMember(testutils.TestAddress(name))\n}\n"},{"name":"strategy_general.gno","body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// newGeneralStrategy creates a new general proposal strategy.\n// This type of proposal is not executable so it doesn't modify the DAO state when proposal passes.\nfunc newGeneralStrategy() generalStrategy {\n\treturn generalStrategy{\n\t\tchoices: []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo},\n\t}\n}\n\ntype generalStrategy struct {\n\tchoices []gnome.VoteChoice\n}\n\n// Name returns the name of the strategy.\nfunc (generalStrategy) Name() string {\n\treturn StrategyNameGeneral\n}\n\n// Quorum returns the minimum required percentage of DAO member votes\n// required for a proposal to pass.\nfunc (generalStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\n// VotingPeriod returns the period that a proposal should allow voting.\nfunc (generalStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameGeneral)\n\treturn period\n}\n\n// VoteChoices returns the valid voting choices for the strategy.\nfunc (s generalStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn s.choices\n}\n\n// CheckVote checks that a vote is valid for the strategy.\nfunc (s generalStrategy) CheckVote(_ std.Address, choice gnome.VoteChoice, reason string) error {\n\t// Reason is required when voting NO on standard proposals\n\tif choice == gnome.ChoiceNo \u0026\u0026 reason == \"\" {\n\t\treturn errors.New(\"reason is required when voting NO in standard proposals\")\n\t}\n\treturn nil\n}\n\n// Tally counts the votes and returns the winner voting choice.\nfunc (generalStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\t// Consider abstentions to make the majority absolute\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\n// Validate validates if a proposal is valid for the current DAO state.\nfunc (generalStrategy) Validate(p *gnome.Proposal) error {\n\tif strings.TrimSpace(p.Description()) == \"\" {\n\t\treturn errors.New(\"proposal description is required\")\n\t}\n\treturn nil\n}\n"},{"name":"strategy_general_test.gno","body":"package gnome\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc TestGeneralStrategy(t *testing.T) {\n\t// Arrange\n\tname := StrategyNameGeneral\n\tquorum := 0.51\n\tvotingPeriod := time.Hour * 24 * 2\n\tchoices := fmt.Sprintf(\"%v\", []gnome.VoteChoice{\n\t\tgnome.ChoiceYes,\n\t\tgnome.ChoiceNo,\n\t})\n\n\t// Act\n\ts := newGeneralStrategy()\n\n\t// Assert\n\tif got := s.Name(); got != name {\n\t\tt.Fatalf(\"expected strategy name: '%s', got: '%s'\", name, got)\n\t}\n\n\tif got := s.Quorum(); got != quorum {\n\t\tt.Fatalf(\"expected strategy quorum: %.2f, got: %.2f\", quorum, got)\n\t}\n\n\tif got := s.VotingPeriod(); got != votingPeriod {\n\t\tt.Fatalf(\"expected strategy voting period: %d, got: %d\", votingPeriod, got)\n\t}\n\n\tif got := fmt.Sprintf(\"%v\", s.VoteChoices()); got != choices {\n\t\tt.Fatalf(\"expected strategy vote choices: %s, got: %s\", choices, got)\n\t}\n}\n\nfunc TestGeneralStrategyCheckVote(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\tchoice      gnome.VoteChoice\n\t\treason, err string\n\t}{\n\t\t{\n\t\t\tname:   \"yes\",\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname:   \"yes with reason\",\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t\treason: \"foo bar\",\n\t\t},\n\t\t{\n\t\t\tname:   \"no with reason\",\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t\treason: \"foo bar\",\n\t\t},\n\t\t{\n\t\t\tname:   \"no with invalid reason\",\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t\terr:    \"reason is required when voting NO in standard proposals\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\ts := newGeneralStrategy()\n\n\t\t\t// Act\n\t\t\terr := s.CheckVote(\"\", tc.choice, tc.reason)\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t} else {\n\t\t\t\tassertNoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGeneralStrategyTally(t *testing.T) {\n\tdao := gnome.MustNew(\"test\", \"Test\", gnome.WithMembers(\n\t\tnewTestMember(t, \"member1\"),\n\t\tnewTestMember(t, \"member2\"),\n\t\tnewTestMember(t, \"member3\"),\n\t\tnewTestMember(t, \"member4\"),\n\t))\n\tcases := []struct {\n\t\tname   string\n\t\tvotes  []gnome.Vote\n\t\tchoice gnome.VoteChoice\n\t}{\n\t\t{\n\t\t\tname: \"majority\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname: \"majority with abstentions\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"no quorum\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t\t{\n\t\t\tname: \"no quorum with abstentions\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\trecord := gnome.NewVotingRecord()\n\t\t\tfor _, v := range tc.votes {\n\t\t\t\trecord.Add(v)\n\t\t\t}\n\n\t\t\ts := newGeneralStrategy()\n\n\t\t\t// Act\n\t\t\tchoice := s.Tally(dao, *record)\n\n\t\t\t// Assert\n\t\t\tif choice != tc.choice {\n\t\t\t\tt.Fatalf(\"expected tally result choice: '%v', got: '%v'\", tc.choice, choice)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc assertError(t *testing.T, expected interface{}, actual error) {\n\tt.Helper()\n\n\twant, ok := expected.(string)\n\tif !ok {\n\t\tif err, ok := expected.(error); ok {\n\t\t\twant = err.Error()\n\t\t}\n\t}\n\n\tif actual == nil {\n\t\tt.Fatalf(\"expected error: '%s', got no error\", want)\n\t}\n\n\tif want != actual.Error() {\n\t\tt.Fatalf(\"expected error: '%s', got: '%s'\", want, actual.Error())\n\t}\n}\n\nfunc assertNoError(t *testing.T, err interface{}) {\n\tt.Helper()\n\n\tif err == nil {\n\t\treturn\n\t}\n\n\tactual, ok := err.(string)\n\tif !ok {\n\t\tif e, ok := err.(error); ok {\n\t\t\tactual = e.Error()\n\t\t}\n\t}\n\n\tif actual != \"\" {\n\t\tt.Fatalf(\"expected no error, got: '%s'\", actual)\n\t}\n}\n"},{"name":"strategy_lock.gno","body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// newLockingStrategy creates a new DAO locking proposal strategy.\nfunc newLockingStrategy(council *gnome.DAO, reason string, preLockFn func() error) lockingStrategy {\n\t// Locking should only be done in the council DAO\n\tif !council.IsSuperCouncil() {\n\t\tpanic(\"DAO is not the council\")\n\t}\n\n\treturn lockingStrategy{\n\t\tchoices:   []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo},\n\t\tcouncil:   council,\n\t\treason:    reason,\n\t\tpreLockFn: preLockFn,\n\t}\n}\n\ntype lockingStrategy struct {\n\tchoices   []gnome.VoteChoice\n\tcouncil   *gnome.DAO\n\treason    string\n\tpreLockFn func() error\n}\n\n// Name returns the name of the strategy.\nfunc (lockingStrategy) Name() string {\n\treturn StrategyNameLocking\n}\n\n// Quorum returns the minimum required percentage of DAO member votes\n// required for a proposal to pass.\nfunc (lockingStrategy) Quorum() float64 {\n\treturn 0.33\n}\n\n// VotingPeriod returns the period that a proposal should allow voting.\nfunc (lockingStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameLocking)\n\treturn period\n}\n\n// VoteChoices returns the valid voting choices for the strategy.\nfunc (s lockingStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn s.choices\n}\n\n// Tally counts the votes and returns the winner voting choice.\nfunc (lockingStrategy) Tally(_ *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tif choice, ok := gnome.SelectChoiceByPlurality(r); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\n// Validate validates if a proposal is valid for the current state.\nfunc (s lockingStrategy) Validate(*gnome.Proposal) error {\n\tif s.council.IsLocked() {\n\t\treturn errors.New(\"council DAO is already locked\")\n\t}\n\treturn nil\n}\n\n// Execute locks the council DAO.\nfunc (s lockingStrategy) Execute(*gnome.DAO) (err error) {\n\tif s.preLockFn != nil {\n\t\tif err := s.preLockFn(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ts.council.Lock(s.reason)\n\treturn nil\n}\n\n// RenderParams returns a markdown with the rendered strategy parameters.\nfunc (s lockingStrategy) RenderParams() string {\n\tvar b strings.Builder\n\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\tb.WriteString(\"| Reason: | \" + gnome.EscapeHTML(s.reason) + \" |\\n\")\n\n\treturn b.String()\n}\n"},{"name":"strategy_lock_test.gno","body":"package gnome\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc TestLockingStrategy(t *testing.T) {\n\tcases := []struct {\n\t\tname, err string\n\t\tsetup     func() *gnome.DAO\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\tsetup: func() *gnome.DAO {\n\t\t\t\treturn gnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"dao is not council\",\n\t\t\tsetup: func() *gnome.DAO {\n\t\t\t\treturn gnome.MustNew(\"council\", \"Council\")\n\t\t\t},\n\t\t\terr: \"DAO is not the council\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tname := StrategyNameLocking\n\t\t\tquorum := 0.33\n\t\t\tvotingPeriod := time.Hour * 24 * 2\n\t\t\tchoices := fmt.Sprintf(\"%v\", []gnome.VoteChoice{\n\t\t\t\tgnome.ChoiceYes,\n\t\t\t\tgnome.ChoiceNo,\n\t\t\t})\n\t\t\tcouncilDAO := tc.setup()\n\n\t\t\t// Act\n\t\t\tvar s lockingStrategy\n\t\t\terr := handlePanic(t, func() {\n\t\t\t\ts = newLockingStrategy(councilDAO, \"\", nil)\n\t\t\t})\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif got := s.Name(); got != name {\n\t\t\t\tt.Fatalf(\"expected strategy name: '%s', got: '%s'\", name, got)\n\t\t\t}\n\n\t\t\tif got := s.Quorum(); got != quorum {\n\t\t\t\tt.Fatalf(\"expected strategy quorum: %.2f, got: %.2f\", quorum, got)\n\t\t\t}\n\n\t\t\tif got := s.VotingPeriod(); got != votingPeriod {\n\t\t\t\tt.Fatalf(\"expected strategy voting period: %d, got: %d\", votingPeriod, got)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", s.VoteChoices()); got != choices {\n\t\t\t\tt.Fatalf(\"expected strategy vote choices: %s, got: %s\", choices, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLockingStrategyTally(t *testing.T) {\n\tcouncilDAO := gnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil())\n\tcases := []struct {\n\t\tname   string\n\t\tvotes  []gnome.Vote\n\t\tchoice gnome.VoteChoice\n\t}{\n\t\t{\n\t\t\tname: \"yes with one vote\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname: \"no with one vote\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"yes with multiple votes\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceYes,\n\t\t},\n\t\t{\n\t\t\tname: \"no with multiple votes\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNo,\n\t\t},\n\t\t{\n\t\t\tname: \"tie\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t\t{\n\t\t\tname: \"tie with multiple votes\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t\t{Choice: gnome.ChoiceYes},\n\t\t\t\t{Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t\t{\n\t\t\tname:   \"no votes\",\n\t\t\tchoice: gnome.ChoiceNone,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\trecord := gnome.NewVotingRecord()\n\t\t\tfor _, v := range tc.votes {\n\t\t\t\trecord.Add(v)\n\t\t\t}\n\n\t\t\ts := newLockingStrategy(councilDAO, \"\", nil)\n\n\t\t\t// Act\n\t\t\tchoice := s.Tally(nil, *record)\n\n\t\t\t// Assert\n\t\t\tif choice != tc.choice {\n\t\t\t\tt.Fatalf(\"expected tally result choice: '%v', got: '%v'\", tc.choice, choice)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLockingStrategyValidate(t *testing.T) {\n\tcases := []struct {\n\t\tname  string\n\t\tsetup func(*gnome.DAO)\n\t\terr   string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t},\n\t\t{\n\t\t\tname: \"locked council DAO\",\n\t\t\tsetup: func(councilDAO *gnome.DAO) {\n\t\t\t\tcouncilDAO.Lock(\"\")\n\t\t\t},\n\t\t\terr: \"council DAO is already locked\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tcouncilDAO := gnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil())\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(councilDAO)\n\t\t\t}\n\n\t\t\ts := newLockingStrategy(councilDAO, \"\", nil)\n\n\t\t\t// Act\n\t\t\terr := s.Validate(nil)\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t} else {\n\t\t\t\tassertNoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLockingStrategyExecute(t *testing.T) {\n\tcases := []struct {\n\t\tname, reason, err string\n\t\tsetup             func(*gnome.DAO)\n\t\tpreLockErr        error\n\t}{\n\t\t{\n\t\t\tname:   \"ok\",\n\t\t\treason: \"Lock reason\",\n\t\t},\n\t\t{\n\t\t\tname:       \"pre lock function error\",\n\t\t\tpreLockErr: errors.New(\"test error\"),\n\t\t\terr:        \"test error\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tcouncilDAO := gnome.MustNew(\"council\", \"Council\", gnome.AssignAsSuperCouncil())\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(councilDAO)\n\t\t\t}\n\n\t\t\tvar (\n\t\t\t\tpreLockFnCalled bool\n\n\t\t\t\ts = newLockingStrategy(councilDAO, tc.reason, func() error {\n\t\t\t\t\tpreLockFnCalled = true\n\t\t\t\t\treturn tc.preLockErr\n\t\t\t\t})\n\t\t\t)\n\n\t\t\t// Act\n\t\t\terr := s.Execute(nil)\n\n\t\t\t// Assert\n\t\t\tif tc.err != \"\" {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif !preLockFnCalled {\n\t\t\t\tt.Fatal(\"expected pre-lock function to be called\")\n\t\t\t}\n\n\t\t\tif !councilDAO.IsLocked() {\n\t\t\t\tt.Fatal(\"expected DAO to be locked\")\n\t\t\t}\n\n\t\t\tif got := councilDAO.LockReason(); got != tc.reason {\n\t\t\t\tt.Fatalf(\"expected lock reason: '%s', got: '%s'\", tc.reason, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"strategy_params.gno","body":"package gnome\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\ntype paramsUpdateStrategy struct {\n\tvotingPeriods  gnome.DurationParams\n\treviewDeadline time.Duration\n}\n\nfunc (paramsUpdateStrategy) Name() string {\n\treturn StrategyNameParamsUpdate\n}\n\nfunc (paramsUpdateStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\nfunc (paramsUpdateStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameParamsUpdate)\n\treturn period\n}\n\nfunc (paramsUpdateStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (paramsUpdateStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s paramsUpdateStrategy) Execute(*gnome.DAO) error {\n\tif s.reviewDeadline \u003e 0 {\n\t\tparameters.ReviewDeadline = s.reviewDeadline\n\t}\n\n\ts.votingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tparameters.VotingPeriods.Set(name, period)\n\t\treturn false\n\t})\n\treturn nil\n}\n\nfunc (s paramsUpdateStrategy) RenderParams() string {\n\tvar b strings.Builder\n\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\tif s.reviewDeadline \u003e 0 {\n\t\tb.WriteString(\"| Proposal Review Deadline: | \" + gnome.HumanizeDuration(s.reviewDeadline) + \" |\\n\")\n\t}\n\n\ts.votingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tb.WriteString(\"| Voting Period for `\" + name + \"`: | \" + gnome.HumanizeDuration(period) + \" |\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n"},{"name":"uri.gno","body":"package gnome\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc makeRealmURL(renderPath string) string {\n\tvar (\n\t\tsub string\n\t\tid  = std.GetChainID()\n\t)\n\n\t// Sub domain prefix for testnets\n\tif strings.HasPrefix(id, \"test\") {\n\t\tsub = id + \".\"\n\t}\n\n\turl := \"https://\" + sub + std.CurrentRealm().PkgPath()\n\tif renderPath != \"\" {\n\t\turl += \":\" + renderPath\n\t}\n\treturn url\n}\n\nfunc makeRealmPath(renderPath string) string {\n\treturn strings.TrimPrefix(std.CurrentRealm().PkgPath(), \"gno.land\") + \":\" + renderPath\n}\n\nfunc makeGnoStudioConnectURL(functionName string) string {\n\treturn ufmt.Sprintf(\n\t\t\"https://gno.studio/connect/view/%s?network=%s\u0026tab=functions#%s\",\n\t\tstd.CurrentRealm().PkgPath(),\n\t\tstd.GetChainID(),\n\t\tfunctionName,\n\t)\n}\n\nfunc makeDAOURI(daoPath string, isRelative bool) string {\n\trenderPath := \"dao/\" + daoPath\n\tif isRelative {\n\t\treturn makeRealmPath(renderPath)\n\t}\n\treturn makeRealmURL(renderPath)\n}\n\nfunc makeProposalURI(proposalID gnome.ID, isRelative bool) string {\n\trenderPath := \"proposal/\" + proposalID.String()\n\tif isRelative {\n\t\treturn makeRealmPath(renderPath)\n\t}\n\treturn makeRealmURL(renderPath)\n}\n\nfunc makeProposalsURI(daoPath string, isRelative bool) string {\n\trenderPath := \"proposals/\" + daoPath + \":page=1\"\n\tif isRelative {\n\t\treturn makeRealmPath(renderPath)\n\t}\n\treturn makeRealmURL(renderPath)\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"26000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"AKbI0VBibM4JZr6ACU7cefBmT2KXuelt25z37CNwmR0w9kq9irlS6SEiv9iYA7PqDM49gtphn04RgFCFSooh8A=="}],"memo":""},"blockNum":"2145604"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","package":{"name":"space","path":"gno.land/r/ecodevx/space/pre1","files":[{"name":"datasource.gno","body":"package space\n\nimport (\n\t\"time\"\n)\n\ntype (\n\tRecord interface {\n\t\tGetSlug() string\n\t\tGetTitle() string\n\t\tGetImage() string\n\t\tGetDescription() string\n\t\tGetTags() []string\n\t\tGetCreationTime() time.Time\n\t}\n\n\tRecordIterFn = func(key string, _ Record) bool\n\n\tDatasource interface {\n\t\tIterate(start string, fn RecordIterFn) bool\n\t\tIterateByTag(tag, start string, fn RecordIterFn) bool\n\t\tGetContent(slug string, fn func(content string)) error\n\t}\n\n\tDataSection struct {\n\t\tSlug        string\n\t\tTitle       string\n\t\tRealm       string\n\t\tDatasource  Datasource\n\t\tBlockHeight int64\n\t\tDisabled    bool\n\t}\n)\n"},{"name":"genesis.gno","body":"package space\n\nfunc init() {\n\t// Platform Links\n\tindexes.Link.Index(SectionPlatform, \u0026Link{\n\t\tTitle: \"Tutorials\",\n\t\tURL:   \"section/tutorials\",\n\t})\n\tindexes.Link.Index(SectionPlatform, \u0026Link{\n\t\tTitle: \"News\",\n\t\tURL:   \"news\",\n\t})\n\n\t// Resources Links\n\tindexes.Link.Index(SectionResources, \u0026Link{\n\t\tTitle: \"gno.studio\",\n\t\tURL:   \"https://gno.studio/\",\n\t})\n\tindexes.Link.Index(SectionResources, \u0026Link{\n\t\tTitle: \"play.gno.land\",\n\t\tURL:   \"https://play.gno.land/\",\n\t})\n\tindexes.Link.Index(SectionResources, \u0026Link{\n\t\tTitle: \"gno.land\",\n\t\tURL:   \"https://gno.land/\",\n\t})\n\tindexes.Link.Index(SectionResources, \u0026Link{\n\t\tTitle: \"gno.docs\",\n\t\tURL:   \"https://docs.gno.land/\",\n\t})\n\n\t// Social Links\n\tindexes.Link.Index(SectionSocials, \u0026Link{\n\t\tTitle: \"YouTube\",\n\t\tURL:   \"\", // TODO: Assign YouTube link\n\t})\n\tindexes.Link.Index(SectionSocials, \u0026Link{\n\t\tTitle: \"Discord\",\n\t\tURL:   \"\", // TODO: Add Discord link\n\t})\n\n\t// Ecosystem Tool\n\t// TODO: Add IPFS links to tool icons\n\ttools = []*Tool{\n\t\t{\n\t\t\tName:        \"Gno.Studio\",\n\t\t\tURL:         \"https://gno.studio/\",\n\t\t\tDescription: \"A premier builder experience with a full-featured IDE and smart contract templates.\",\n\t\t},\n\t\t{\n\t\t\tName:        \"Adena Wallet\",\n\t\t\tURL:         \"https://www.adena.app/\",\n\t\t\tDescription: \"Adena is a friendly, open-source, non-custodial Gnoland wallet, built for Gnomes worldwide.\",\n\t\t},\n\t\t{\n\t\t\tName:        \"Gno Studio Connect\",\n\t\t\tURL:         \"https://gno.studio/connect\",\n\t\t\tDescription: \"Simplifies interaction with Gno smart contract functions.\",\n\t\t},\n\t\t{\n\t\t\tName:        \"Gno Playground\",\n\t\t\tURL:         \"https://play.gno.land/\",\n\t\t\tDescription: \"A minimalist IDE for creating, testing, deploying, and sharing Gno code\",\n\t\t},\n\t\t{\n\t\t\tName:        \"GnoDev\",\n\t\t\tURL:         \"https://docs.gno.land/gno-tooling/cli/gno-tooling-gnodev/\",\n\t\t\tDescription: \"Quick and efficient development of Gno code.\",\n\t\t},\n\t\t{\n\t\t\tName:        \"GnoScan\",\n\t\t\tURL:         \"https://gnoscan.io/\",\n\t\t\tDescription: \"Gnoscan is a Gnoland blockchain explorer, making on-chain data readable and intuitive.\",\n\t\t},\n\t}\n}\n"},{"name":"indexes.gno","body":"package space\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar indexes struct {\n\tNews        newsIndex\n\tLink        linkIndex\n\tDataSection dataSectionsIndex\n}\n\ntype newsIndex struct {\n\tindex avl.Tree // string(binary id) -\u003e *News\n\ttags  avl.Tree // string(tag) -\u003e []*News\n}\n\nfunc (x newsIndex) Size() int {\n\treturn x.index.Size()\n}\n\nfunc (x *newsIndex) Index(n *News) {\n\t// Index by ID\n\tkey := n.ID.Key()\n\tupdated := x.index.Set(key, n)\n\tif updated {\n\t\tpanic(\"news ID is already indexed: \" + key)\n\t}\n\n\t// Index by tags\n\tfor _, tag := range n.Tags {\n\t\tnews := x.GetByTag(tag)\n\t\tx.tags.Set(tag, append(news, n))\n\t}\n}\n\nfunc (x newsIndex) GetByID(id ID) (*News, bool) {\n\tif v, ok := x.index.Get(id.Key()); ok {\n\t\treturn v.(*News), true\n\t}\n\treturn nil, false\n}\n\nfunc (x newsIndex) GetByTag(tag string) []*News {\n\tif v, ok := x.tags.Get(tag); ok {\n\t\treturn v.([]*News)\n\t}\n\treturn nil\n}\n\nfunc (x newsIndex) GetTags() (tags []string) {\n\tx.tags.Iterate(\"\", \"\", func(tag string, _ interface{}) bool {\n\t\ttags = append(tags, tag)\n\t\treturn false\n\t})\n\treturn\n}\n\nfunc (x *newsIndex) Remove(id ID) bool {\n\tv, removed := x.index.Remove(id.Key())\n\tif !removed {\n\t\treturn false\n\t}\n\n\tcurrent := v.(*News)\n\tfor _, tag := range current.Tags {\n\t\tnews := x.GetByTag(tag)\n\t\tif len(news) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i, n := range news {\n\t\t\tif n.ID == current.ID {\n\t\t\t\tx.tags.Set(tag, append(news[:i], news[i+1:]...))\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// Iterate iterates news starting from the oldest one.\nfunc (x newsIndex) Iterate(fn func(*News) bool) bool {\n\treturn x.index.Iterate(\"\", \"\", func(_ string, v interface{}) bool {\n\t\treturn fn(v.(*News))\n\t})\n}\n\n// ReverseIterate iterates news starting from the latest one.\nfunc (x newsIndex) ReverseIterate(fn func(*News) bool) bool {\n\treturn x.index.ReverseIterate(\"\", \"\", func(_ string, v interface{}) bool {\n\t\treturn fn(v.(*News))\n\t})\n}\n\ntype linkIndex struct {\n\tindex avl.Tree // string(section) -\u003e []*Link\n}\n\nfunc (x *linkIndex) Index(s Section, l *Link) {\n\tlinks, _ := x.Get(s)\n\tlinks = append(links, l)\n\tx.index.Set(string(s), links)\n}\n\nfunc (x linkIndex) Get(s Section) ([]*Link, bool) {\n\tif v, ok := x.index.Get(string(s)); ok {\n\t\treturn v.([]*Link), true\n\t}\n\treturn nil, false\n}\n\nfunc (x linkIndex) Has(s Section) bool {\n\treturn x.index.Has(string(s))\n}\n\nfunc (x *linkIndex) Remove(s Section, url string) bool {\n\tlinks, found := x.Get(s)\n\tif !found {\n\t\treturn false\n\t}\n\n\tfor i, l := range links {\n\t\tif l.URL != url {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn x.index.Set(string(s), append(links[:i], links[i+1:]...))\n\t}\n\treturn false\n}\n\n// Iterate iterates links.\nfunc (x linkIndex) Iterate(fn func(Section, *Link) bool) bool {\n\treturn x.index.Iterate(\"\", \"\", func(s string, v interface{}) bool {\n\t\tsection := Section(s)\n\t\tfor _, l := range v.([]*Link) {\n\t\t\tif fn(section, l) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\ntype dataSectionsIndex struct {\n\tindex   avl.Tree // string(slug) -\u003e *DataSection\n\tordered []*DataSection\n}\n\nfunc (x dataSectionsIndex) Size() int {\n\treturn x.index.Size()\n}\n\nfunc (x *dataSectionsIndex) Index(s *DataSection) {\n\t// Index by slug\n\tx.index.Set(s.Slug, s)\n\n\t// Index by order\n\tx.ordered = append(x.ordered, s)\n}\n\nfunc (x dataSectionsIndex) GetBySlug(slug string) (*DataSection, bool) {\n\tif v, ok := x.index.Get(slug); ok {\n\t\treturn v.(*DataSection), true\n\t}\n\treturn nil, false\n}\n\nfunc (x *dataSectionsIndex) Remove(slug string) bool {\n\t_, removed := x.index.Remove(slug)\n\tif !removed {\n\t\treturn false\n\t}\n\n\tfor i, s := range x.ordered {\n\t\tif s.Slug == slug {\n\t\t\tx.ordered = append(x.ordered[:i], x.ordered[i+1:]...)\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (x *dataSectionsIndex) Reorder(currentOrder, newOrder int) bool {\n\tc := len(x.ordered)\n\tif currentOrder \u003e= c || newOrder \u003e= c {\n\t\treturn false\n\t}\n\n\ts := x.ordered[currentOrder]\n\tx.ordered = append(x.ordered[:currentOrder], x.ordered[currentOrder+1:]...)\n\tx.ordered = append(x.ordered[:newOrder], append([]*DataSection{s}, x.ordered[newOrder:]...)...)\n\treturn true\n}\n\n// Iterate iterates data sections.\nfunc (x dataSectionsIndex) Iterate(fn func(*DataSection) bool) bool {\n\tfor _, s := range x.ordered {\n\t\tif fn(s) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"},{"name":"invar.gno","body":"package space\n\n// TODO: Remove this file if Gno implements invar (inmutable) references\n\nimport \"time\"\n\nfunc newInvarTool(t *Tool) InvarTool {\n\treturn InvarTool{t}\n}\n\ntype InvarTool struct {\n\tref *Tool\n}\n\nfunc (t InvarTool) Name() string {\n\treturn t.ref.Name\n}\n\nfunc (t InvarTool) Description() string {\n\treturn t.ref.Description\n}\n\nfunc (t InvarTool) URL() string {\n\treturn t.ref.URL\n}\n\nfunc (t InvarTool) Icon() string {\n\treturn t.ref.Icon\n}\n\nfunc newInvarLink(l *Link) InvarLink {\n\treturn InvarLink{l}\n}\n\ntype InvarLink struct {\n\tref *Link\n}\n\nfunc (l InvarLink) URL() string {\n\treturn l.ref.URL\n}\n\nfunc (l InvarLink) Title() string {\n\treturn l.ref.Title\n}\n\nfunc newInvarNews(n *News) InvarNews {\n\treturn InvarNews{n}\n}\n\ntype InvarNews struct {\n\tref *News\n}\n\nfunc (n InvarNews) ID() ID {\n\treturn n.ref.ID\n}\n\nfunc (n InvarNews) Title() string {\n\treturn n.ref.Title\n}\n\nfunc (n InvarNews) URL() string {\n\treturn n.ref.URL\n}\n\nfunc (n InvarNews) ImageURL() string {\n\treturn n.ref.ImageURL\n}\n\nfunc (n InvarNews) Tags() []string {\n\treturn append([]string(nil), n.ref.Tags...)\n}\n\nfunc (n InvarNews) CreatedAt() time.Time {\n\treturn n.ref.CreatedAt\n}\n\nfunc newInvarDataSection(s *DataSection) InvarDataSection {\n\treturn InvarDataSection{s}\n}\n\ntype InvarDataSection struct {\n\tref *DataSection\n}\n\nfunc (l InvarDataSection) Slug() string {\n\treturn l.ref.Slug\n}\n\nfunc (l InvarDataSection) Title() string {\n\treturn l.ref.Title\n}\n\nfunc (l InvarDataSection) Realm() string {\n\treturn l.ref.Realm\n}\n\nfunc (l InvarDataSection) Datasource() Datasource {\n\treturn l.ref.Datasource\n}\n\nfunc (l InvarDataSection) Disabled() bool {\n\treturn l.ref.Disabled\n}\n"},{"name":"params.gno","body":"package space\n\nimport (\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// Day defines the duration of a day.\nconst Day = time.Hour * 24\n\n// Names for the different strategy types.\nconst (\n\tStrategyNameDataSection         = \"space-data-section\"\n\tStrategyNameEditorsModification = \"space-editors-modification\"\n\tStrategyNameLocking             = \"space-realm-locking\"\n\tStrategyNameParamsUpdate        = \"space-params-update\"\n)\n\nvar parameters struct {\n\tVotingPeriods gnome.DurationParams\n\tSpaceDAO      string\n}\n\nfunc init() {\n\t// Initial voting periods for each proposal type.\n\t// Periods can be changed by sumitting a params update proposal.\n\tparameters.VotingPeriods.Set(StrategyNameDataSection, Day*5)\n\tparameters.VotingPeriods.Set(StrategyNameEditorsModification, Day*2)\n\tparameters.VotingPeriods.Set(StrategyNameLocking, Day*3)\n\tparameters.VotingPeriods.Set(StrategyNameParamsUpdate, time.Minute*10)\n\n\t// Path to the Gnome space DAO\n\tparameters.SpaceDAO = \"council/main/space\"\n}\n"},{"name":"public.gno","body":"package space\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/mux\"\n\t\"gno.land/p/ecodevx/blog\"\n)\n\nconst minTitleLen = 6\n\nfunc Render(path string) string {\n\tr := mux.NewRouter()\n\tr.NotFoundHandler = func(res *mux.ResponseWriter, _ *mux.Request) {\n\t\tres.Write(\"Path not found\")\n\t}\n\n\tr.HandleFunc(\"\", renderHome)\n\tr.HandleFunc(\"news\", renderNews)\n\tr.HandleFunc(\"news/{tag}\", renderNewsByTag)\n\tr.HandleFunc(\"section/{slug}\", renderDataSection)\n\tr.HandleFunc(\"section/{slug}/{tag}\", renderDataSectionByTag)\n\tr.HandleFunc(\"content/{sectionSlug}/{contentSlug}\", renderContent)\n\tr.HandleFunc(\"datasources\", renderDatasources)\n\tr.HandleFunc(\"params\", renderParams)\n\n\tr.HandleFunc(\"terms-and-conditions\", func(res *mux.ResponseWriter, _ *mux.Request) {\n\t\tres.Write(termsAndConditions)\n\t})\n\tr.HandleFunc(\"privacy-policy\", func(res *mux.ResponseWriter, _ *mux.Request) {\n\t\tres.Write(privacyPolicy)\n\t})\n\n\treturn renderAlerts() + r.Render(path)\n}\n\n// IterateEditors iterates editor accounts.\nfunc IterateEditors(fn func(std.Address) bool) {\n\tfor _, e := range editors {\n\t\tif fn(e) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// IterateTools iterates invariant references of Gnome space tools.\nfunc IterateTools(fn func(InvarTool) bool) {\n\tfor _, t := range tools {\n\t\tif fn(newInvarTool(t)) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// IterateLinks iterates invariant references of Gnome space links.\nfunc IterateLinks(fn func(section string, _ InvarLink) bool) {\n\tindexes.Link.Iterate(func(s Section, l *Link) bool {\n\t\treturn fn(string(s), newInvarLink(l))\n\t})\n}\n\n// IterateNews iterates invariant references of Gnome space news.\nfunc IterateNews(fn func(InvarNews) bool) {\n\tindexes.News.Iterate(func(n *News) bool {\n\t\treturn fn(newInvarNews(n))\n\t})\n}\n\n// IterateDataSections iterates invariant references of Gnome space data sections.\nfunc IterateDataSections(fn func(InvarDataSection) bool) {\n\tindexes.DataSection.Iterate(func(s *DataSection) bool {\n\t\treturn fn(newInvarDataSection(s))\n\t})\n}\n\n// CreateNews creates a news entry.\n//\n// Only editors are allowed to create news.\n//\n// Parameters:\n// - title: A title for the news entry (required)\n// - url: URL with the link to the news content (required)\n// - tags: Comma separated list of tags for the news entry (required)\nfunc CreateNews(title, url, tags string) uint64 {\n\tassertRealmIsNotLocked()\n\tassertOrigCallerIsEditor()\n\n\ttitle = strings.TrimSpace(title)\n\tassertNewsTitleLength(title)\n\tassertValidURL(url)\n\n\tid := genNewsID()\n\tindexes.News.Index(\u0026News{\n\t\tID:        id,\n\t\tTitle:     title,\n\t\tURL:       url,\n\t\tTags:      mustParseStringToTags(tags),\n\t\tCreatedAt: time.Now(),\n\t})\n\treturn uint64(id)\n}\n\n// UpdateNews updates a news entry.\n//\n// Only editors are allowed to update news.\n//\n// Parameters:\n// - newsID: ID of the news entry to update (required)\n// - title: A title for the news entry\n// - url: URL with the link to the news content\n// - tags: Comma separated list of tags for the news entry\nfunc UpdateNews(newsID uint64, title, url, tags string) {\n\tassertRealmIsNotLocked()\n\tassertOrigCallerIsEditor()\n\n\tn, found := indexes.News.GetByID(ID(newsID))\n\tif !found {\n\t\tpanic(\"news not found\")\n\t}\n\n\ttitle = strings.TrimSpace(title)\n\tif title != \"\" {\n\t\tassertNewsTitleLength(title)\n\t\tn.Title = title\n\t}\n\n\turl = strings.TrimSpace(url)\n\tif url != \"\" {\n\t\tassertValidURL(url)\n\t\tn.URL = url\n\t}\n\n\ttags = strings.TrimSpace(tags)\n\tif tags != \"\" {\n\t\tn.Tags = mustParseStringToTags(tags)\n\t}\n}\n\n// DeleteNews deletes a news entry.\n//\n// Only editors are allowed to delete news.\n//\n// Parameters:\n// - newsID: ID of the news entry to delete (required)\nfunc DeleteNews(newsID uint64) {\n\tassertRealmIsNotLocked()\n\tassertOrigCallerIsEditor()\n\n\tif !indexes.News.Remove(ID(newsID)) {\n\t\tpanic(\"news not found\")\n\t}\n}\n\n// DisableDataSection disabled or enables a data section.\n// Data sections are sections where the data displayed in that section comes from another realm.\n//\n// Only editors are allowed to disable or enable data sections.\n//\n// Parameters:\n// - sectionSlug: Slug of the section.\n// - disable: Toggle disabled or enabled data sections.\nfunc DisableDataSection(sectionSlug string, disable bool) {\n\tassertRealmIsNotLocked()\n\tassertOrigCallerIsEditor()\n\n\tsection, found := indexes.DataSection.GetBySlug(sectionSlug)\n\tif !found {\n\t\tpanic(\"data section not found\")\n\t}\n\n\tsection.Disabled = disable\n}\n\nfunc mustParseStringToTags(s string) (tags []string) {\n\tfor _, v := range strings.Split(s, \",\") {\n\t\ttag := strings.TrimSpace(v)\n\t\tassertIsTag(tag)\n\t\ttags = append(tags, tag)\n\t}\n\treturn\n}\n\nfunc assertOrigCallerIsEditor() {\n\tcaller := std.GetOrigCaller()\n\tassertIsEditor(caller)\n}\n\nfunc assertIsTag(tag string) {\n\tif !blog.IsSlug(tag) {\n\t\tpanic(\"invalid tag: \" + tag)\n\t}\n}\n\nfunc assertValidURL(url string) {\n\tif !blog.IsURL(url, false) {\n\t\tpanic(\"URL is not valid\")\n\t}\n}\n\nfunc assertNewsTitleLength(title string) {\n\tif len(title) \u003c minTitleLen {\n\t\tpanic(\"title is too short\")\n\t}\n}\n"},{"name":"public_proposals.gno","body":"package space\n\nimport (\n\t\"regexp\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/ecodevx/blog\"\n\tgnomeDAO \"gno.land/r/ecodevx/dao/pre1\"\n)\n\nconst maxSectionTitleLen = 60 // TODO: Should it be a parameter?\n\nvar realmPathRe = regexp.MustCompile(`^gno\\.land\\/r(?:\\/_?[a-z]+[a-z0-9_]*)+$`)\n\n// SubmitEditorsModificationProposal submits a new proposal to modify Gnome space editors.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - newEditors: List of editor addresses\n// - removeEditors: List of editor addresses\n//\n// At least one editor to add or remove is required for the proposal to be valid.\n// The list of editors must be a newline separated list of addresses.\nfunc SubmitEditorsModificationProposal(\n\tproposalTitle,\n\tproposalDescription,\n\tnewEditors,\n\tremoveEditors string,\n) uint64 {\n\tassertRealmIsNotLocked()\n\n\tstrategy := editorsModificationStrategy{\n\t\tnewEditors:    blog.MustParseStringToAddresses(newEditors),\n\t\tremoveEditors: blog.MustParseStringToAddresses(removeEditors),\n\t}\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.SpaceDAO)\n\treturn uint64(id)\n}\n\n// SubmitDataSectionProposal submits a new proposal to add a datasource based Gnome space section.\n//\n// IMPORTANT, this function must be called using a MsgRun message, for example with `gnokey maketx run` command.\n// The code uploaded within this message must be verified to be sure realm path matches the datasource's one.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - realm: The realm path of the datasource (required)\n// - slug: Slug of the section (required)\n// - sectionTitle: A title for the section (required)\n// - ds: A datasource to retrieve section's data (required)\nfunc SubmitDataSectionProposal(\n\tproposalTitle,\n\tproposalDescription,\n\trealm,\n\tslug,\n\tsectionTitle string,\n\tsectionDS Datasource,\n) uint64 {\n\tassertRealmIsNotLocked()\n\n\tif sectionDS == nil {\n\t\tpanic(\"section datasource is required\")\n\t}\n\n\tif !std.PrevRealm().IsUser() {\n\t\t// TODO: Support realm calls when datasource package can be inferred\n\t\tpanic(\"realm calls are not allowed\")\n\t}\n\n\tsectionTitle = strings.TrimSpace(sectionTitle)\n\tassertValidSectionTitle(sectionTitle)\n\tassertIsSlug(slug)\n\tassertIsRealmPath(realm)\n\n\tstrategy := dataSectionStrategy{\n\t\tslug:        slug,\n\t\ttitle:       sectionTitle,\n\t\trealm:       realm,\n\t\tdatasource:  sectionDS,\n\t\tblockHeight: std.GetHeight(),\n\t}\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.SpaceDAO)\n\treturn uint64(id)\n}\n\n// SubmitLockingProposal submits a new proposal to lock the realm.\n//\n// Locking the realm \"freezes the state\" by disallowing further modifications.\n// State must be locked to migrate the realm to a newer version.\n//\n// Proposal requires a 34% quorum, otherwise the outcome will be low participation.\n// This type of proposal can only be created by members with `admin` role.\n// Tally is done by plurality.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - realmPath: Path of the realm that should be allowed to import state data\n//\n// The optional realm path authorizes a realm to import the state data once the realm is locked.\nfunc SubmitLockingProposal(proposalTitle, proposalDescription, realmPath string) uint64 {\n\tassertHasAdminRole(std.GetOrigCaller())\n\n\tif realmPath != \"\" \u0026\u0026 !strings.HasPrefix(realmPath, \"gno.land/r/\") {\n\t\tpanic(`realm path must start with \"gno.land/r/\"`)\n\t}\n\n\tstrategy := lockingStrategy{realmPath}\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.SpaceDAO)\n\treturn uint64(id)\n}\n\n// SubmitParamsUpdateProposal submits a new proposal to update one or more realm parameters.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - spaceDAO: Path to the space SubDAO\n// - votingPeriodEditorsModification: Voting period for editors modification proposals\n// - votingPeriodLocking: Voting period for realm locking proposals\n// - votingPeriodParamsUpdate: Voting period for parameters update proposals\n//\n// Voting period is the number of days that members can vote on a proposal\n// At least one parameter value is required for creating a proposal.\nfunc SubmitParamsUpdateProposal(\n\tproposalTitle,\n\tproposalDescription,\n\tspaceDAO string,\n\tvotingPeriodEditorsModification,\n\tvotingPeriodLocking,\n\tvotingPeriodParamsUpdate int,\n) uint64 {\n\tstrategy := paramsUpdateStrategy{}\n\tspaceDAO = strings.TrimSpace(spaceDAO)\n\tif spaceDAO != \"\" {\n\t\tif _, found := gnomeDAO.GetDAO(spaceDAO); !found {\n\t\t\tpanic(\"space DAO path doesn't exist: \" + spaceDAO)\n\t\t}\n\n\t\tstrategy.spaceDAO = spaceDAO\n\t}\n\n\tif votingPeriodEditorsModification \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodEditorsModification) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameEditorsModification, period)\n\t}\n\n\tif votingPeriodLocking \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodLocking) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameLocking, period)\n\t}\n\n\tif votingPeriodParamsUpdate \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodParamsUpdate) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameParamsUpdate, period)\n\t}\n\n\tif strategy.votingPeriods.Size() == 0 {\n\t\tpanic(\"at least one parameter value must be specified\")\n\t}\n\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.SpaceDAO)\n\treturn uint64(id)\n}\n\nfunc assertHasAdminRole(addr std.Address) {\n\terr := gnomeDAO.CheckMemberHasRole(parameters.SpaceDAO, addr, gnomeDAO.RoleAdmin)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc assertIsRealmPath(path string) {\n\tif !realmPathRe.MatchString(path) {\n\t\tpanic(\"invalid realm path\")\n\t}\n}\n\nfunc assertIsSlug(slug string) {\n\tif !blog.IsSlug(slug) {\n\t\tpanic(\"invalid slug: \" + slug)\n\t}\n}\n\nfunc assertValidSectionTitle(title string) {\n\tif title == \"\" {\n\t\tpanic(\"section title is required\")\n\t}\n\n\tif len(title) \u003e maxSectionTitleLen {\n\t\tpanic(\"maximum section title length is \" + strconv.Itoa(maxSectionTitleLen) + \" chars\")\n\t}\n}\n"},{"name":"render.gno","body":"package space\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/mux\"\n\t\"gno.land/p/demo/ufmt\"\n\n\t\"gno.land/p/ecodevx/alerts\"\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// TODO: Should it be a parameter?\nconst homeDescription = `Welcome to Gno.me,\nan educational and community platform for gnomes and newcomers to learn,\nshare and build together. Gno.me exists to encourage, challenge, and develop\nthe skills and standards of people interested in building a smart contract\necosystem of innovative, responsible and curious gnomes.\n`\n\nconst maxDataSectionItems = 4\n\nfunc renderHome(res *mux.ResponseWriter, _ *mux.Request) {\n\trenderHeader(res)\n\tres.Write(\"\\n\" + homeDescription + \"\\n\")\n\trenderHomeDataSections(res)\n\trenderHomeNews(res)\n\trenderHomeTools(res)\n\trenderHomeFooter(res)\n}\n\nfunc renderNews(res *mux.ResponseWriter, req *mux.Request) {\n\trenderHomeMenu(res)\n\n\tres.Write(\"## News\\n\")\n\n\t// TODO: Add pagination support\n\tindexes.News.ReverseIterate(func(n *News) bool {\n\t\tres.Write(n.String() + \"\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderNewsByTag(res *mux.ResponseWriter, req *mux.Request) {\n\trenderHomeMenu(res)\n\n\ttag := req.GetVar(\"tag\")\n\tres.Write(\"## News: \" + tag + \"\\n\")\n\n\t// TODO: Add pagination support\n\tfor _, n := range indexes.News.GetByTag(tag) {\n\t\tres.Write(n.String() + \"\\n\")\n\t}\n}\n\nfunc renderDataSection(res *mux.ResponseWriter, req *mux.Request) {\n\tsection, found := indexes.DataSection.GetBySlug(req.GetVar(\"slug\"))\n\tif !found || section.Disabled {\n\t\tres.Write(\"section not found\")\n\t\treturn\n\t}\n\n\trenderHomeMenu(res)\n\n\tres.Write(\"## gno.me: \" + section.Title + \"\\n\")\n\n\t// TODO: Add pagination support\n\tsection.Datasource.Iterate(\"\", func(_ string, r Record) bool {\n\t\tassertPrevRealmPath(section.Realm)\n\t\trenderDatasourceRecord(res, section, r)\n\t\treturn false\n\t})\n}\n\nfunc renderDataSectionByTag(res *mux.ResponseWriter, req *mux.Request) {\n\tsection, found := indexes.DataSection.GetBySlug(req.GetVar(\"slug\"))\n\tif !found || section.Disabled {\n\t\tres.Write(\"section not found\")\n\t\treturn\n\t}\n\n\trenderHomeMenu(res)\n\n\ttag := req.GetVar(\"tag\")\n\tres.Write(ufmt.Sprintf(\"## gno.me: %s (%s)\\n\", section.Title, tag))\n\n\t// TODO: Add pagination support\n\tsection.Datasource.IterateByTag(tag, \"\", func(_ string, r Record) bool {\n\t\tassertPrevRealmPath(section.Realm)\n\t\trenderDatasourceRecord(res, section, r)\n\t\treturn false\n\t})\n}\n\nfunc renderContent(res *mux.ResponseWriter, req *mux.Request) {\n\tsection, found := indexes.DataSection.GetBySlug(req.GetVar(\"sectionSlug\"))\n\tif !found || section.Disabled {\n\t\tres.Write(\"section not found\")\n\t\treturn\n\t}\n\n\tvar output string\n\terr := section.Datasource.GetContent(req.GetVar(\"contentSlug\"), func(content string) {\n\t\tassertPrevRealmPath(section.Realm)\n\t\toutput = content\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// TODO: Add a title for the section\n\trenderHomeMenu(res)\n\tres.Write(output)\n}\n\nfunc renderDatasources(res *mux.ResponseWriter, _ *mux.Request) {\n\trenderHomeMenu(res)\n\n\tres.Write(\"# Data Sections\\n\")\n\tindexes.DataSection.Iterate(func(s *DataSection) bool {\n\t\theight := strconv.FormatInt(s.BlockHeight, 10)\n\n\t\tres.Write(\"## \" + s.Title + \"\\n\")\n\t\tres.Write(\"- Slug: [\" + s.Slug + \"](https://gno.land\" + newSectionPath(s.Slug) + \")\\n\")\n\t\tres.Write(\"- Realm: [\" + s.Realm + \"](https://\" + s.Realm + \")\\n\")\n\t\tres.Write(\"- Block Height: [\" + height + \"](\" + newBlockURL(s.BlockHeight) + \")\\n\")\n\n\t\tif s.Disabled {\n\t\t\tres.Write(\"- Disabled: Yes\\n\\n\")\n\t\t} else {\n\t\t\tres.Write(\"- Disabled: No\\n\\n\")\n\t\t}\n\n\t\treturn false\n\t})\n}\n\nfunc renderParams(res *mux.ResponseWriter, _ *mux.Request) {\n\tres.Write(\"# Gnome Space: Parameters\\n\")\n\tres.Write(\"## Proposal\\n\")\n\tres.Write(\"**General**\\n\")\n\tres.Write(\"- Space DAO Path: \" + parameters.SpaceDAO + \"\\n\")\n\tres.Write(\"\\n**Voting Periods**\\n\")\n\tparameters.VotingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tres.Write(\"- `\" + name + \"`: \" + gnome.HumanizeDuration(period) + \"\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderHeader(res *mux.ResponseWriter) {\n\tres.Write(\"# gno.me\\n\")\n\trenderHomeMenu(res)\n}\n\nfunc renderHomeMenu(res *mux.ResponseWriter) {\n\titems, found := indexes.Link.Get(SectionPlatform)\n\tif !found {\n\t\treturn\n\t}\n\n\tvar menu []string\n\tfor _, link := range items {\n\t\tmenu = append(menu, ufmt.Sprintf(\"/[%s](%s)\", strings.ToLower(link.Title), newRealmURL(link.URL)))\n\t}\n\tres.Write(strings.Join(menu, \"\u0026nbsp;\u0026nbsp;\") + \"\\n\\n---\\n\\n\")\n}\n\nfunc renderHomeDataSections(res *mux.ResponseWriter) {\n\tindexes.DataSection.Iterate(func(s *DataSection) bool {\n\t\tif s.Disabled {\n\t\t\treturn false\n\t\t}\n\n\t\tvar (\n\t\t\ti   int\n\t\t\turl = newSectionPath(s.Slug)\n\t\t)\n\n\t\tres.Write(\"## \" + gnome.EscapeHTML(s.Title) + \"\\n\")\n\t\tres.Write(ufmt.Sprintf(\"_([view all](%s))_\\n\\n\", url))\n\n\t\ts.Datasource.Iterate(\"\", func(_ string, r Record) bool {\n\t\t\t// Make sure that records come from the data section realm\n\t\t\tcaller := std.PrevRealm().PkgPath()\n\t\t\tif caller != s.Realm {\n\t\t\t\tres.Write(\n\t\t\t\t\t\"\u003e \u0026nbsp;**Error:**  \\n\" +\n\t\t\t\t\t\t\" \u0026nbsp; \u0026nbsp;Expected section content from _\" + s.Realm + \"_.  \\n\" +\n\t\t\t\t\t\t\" \u0026nbsp; \u0026nbsp;Content from _\" + caller + \"_ is not allowed.\\n\",\n\t\t\t\t)\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\t// Don't render all records in the home, render a reduced number\n\t\t\ti++\n\t\t\trenderDatasourceRecord(res, s, r)\n\t\t\treturn (i == maxDataSectionItems)\n\t\t})\n\n\t\treturn false\n\t})\n}\n\nfunc renderHomeNews(res *mux.ResponseWriter) {\n\tif indexes.News.Size() == 0 {\n\t\treturn\n\t}\n\n\tres.Write(\"## News\\n\")\n\tres.Write(ufmt.Sprintf(\"_([view all](%s))_\\n\\n\", newRealmURL(\"news\")))\n\n\tindexes.News.ReverseIterate(func(n *News) bool {\n\t\tres.Write(n.String() + \"\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderHomeTools(res *mux.ResponseWriter) {\n\tif len(tools) == 0 {\n\t\treturn\n\t}\n\n\tres.Write(\"## Tools\\n\")\n\tres.Write(\"These resources are designed to enhance your Gno experience and streamline your workflow.\\n\\n\")\n\n\tfor _, tool := range tools {\n\t\tres.Write(tool.String() + \"\\n\")\n\t}\n}\n\nfunc renderHomeFooter(res *mux.ResponseWriter) {\n\tres.Write(\"---\\n\")\n\trenderHomeFooterLinks(res)\n\n\tfooter := []string{\n\t\t\"©2024 gno.me\",\n\t\tufmt.Sprintf(\"[Terms and Conditions](%s)\", newRealmURL(\"terms-and-conditions\")),\n\t\tufmt.Sprintf(\"[Privacy Policy](%s)\", newRealmURL(\"privacy-policy\")),\n\t}\n\tres.Write(\"---\\n\" + strings.Join(footer, strings.Repeat(\"\u0026nbsp;\", 4)))\n}\n\nfunc renderHomeFooterLinks(res *mux.ResponseWriter) {\n\tsections := []Section{SectionPlatform, SectionResources, SectionSocials}\n\tfor _, s := range sections {\n\t\titems, found := indexes.Link.Get(s)\n\t\tif !found {\n\t\t\tcontinue\n\t\t}\n\n\t\tres.Write(\"**\" + strings.Title(string(s)) + \"**\\n\")\n\t\tfor _, link := range items {\n\t\t\tres.Write(ufmt.Sprintf(\"- %s\\n\", link))\n\t\t}\n\t\tres.Write(\"\\n\")\n\t}\n}\n\nfunc renderAlerts() string {\n\tif locked {\n\t\tmsg := \"Realm is locked\"\n\t\tif nextVersionRealmPath != \"\" {\n\t\t\tlink := alerts.NewLink(\"https://\"+nextVersionRealmPath, nextVersionRealmPath)\n\t\t\tmsg += \"\u003c/br\u003eThis realm is deprecated in favor of a new version found at \" + link\n\t\t}\n\n\t\treturn alerts.NewError(msg)\n\t}\n\treturn \"\"\n}\n\nfunc renderDatasourceRecord(res *mux.ResponseWriter, s *DataSection, r Record) {\n\t// TODO: Validate required record values before rendering\n\tsectionURL := newSectionPath(s.Slug)\n\tcontentURL := newContentPath(s.Slug, r.GetSlug())\n\tif link := r.GetImage(); link != \"\" {\n\t\tres.Write(ufmt.Sprintf(\"[![](%s)](%s)\\n\", link, contentURL))\n\t}\n\n\tres.Write(ufmt.Sprintf(\"**[%s](%s)**\\n\\n\", r.GetTitle(), contentURL))\n\tres.Write(ufmt.Sprintf(\"%s\\n\\n\", r.GetDescription()))\n\tres.Write(r.GetCreationTime().UTC().Format(\"Jan 02, 2006 (MST)\"))\n\n\tvar tags []string\n\tfor _, tag := range r.GetTags() {\n\t\ttags = append(tags, ufmt.Sprintf(\"[%s](%s)\", tag, sectionURL+\"/\"+tag))\n\t}\n\n\tif len(tags) \u003e 0 {\n\t\tres.Write(\" - \" + strings.Join(tags, \", \"))\n\t}\n\tres.Write(\"\\n\\n\")\n}\n\nfunc newSectionPath(slug string) string {\n\treturn newRealmURL(\"section/\" + slug)\n}\n\nfunc newContentPath(sectionSlug, contentSlug string) string {\n\treturn newRealmURL(\"content/\" + sectionSlug + \"/\" + contentSlug)\n}\n\nfunc newBlockURL(height int64) string {\n\treturn \"https://gnoscan.io/blocks/\" + strconv.FormatInt(height, 10)\n}\n\nfunc assertPrevRealmPath(path string) {\n\tcaller := std.PrevRealm().PkgPath()\n\tif caller != path {\n\t\tpanic(\"expected datasource content from \" + path + \", \" + caller + \" is not allowed\")\n\t}\n}\n"},{"name":"render_static.gno","body":"package space\n\nconst termsAndConditions = `\n# Terms and Conditions\n\n## 1. Introduction\n\nWelcome to Gno.me. By accessing or using our platform, you agree to be bound by these Terms and Conditions. If you do not agree with any part of these terms, please do not use our platform.\n\n## 2. Eligibility\n\nTo use Gno.me, you must meet the minimum age required by local laws in your jurisdiction, typically at least 13 years old. By creating an account, you represent that you meet this age requirement. In some regions, this age may be higher; please refer to local regulations.\n\n## 3. User Accounts\n\nYou are responsible for maintaining the confidentiality of your account information and for all activities that occur under your account. Notify us immediately of any unauthorized use of your account. You agree to provide accurate and complete information when creating your account and to update your information as necessary.\n\n## 4. Content and Contributions\n\n- User-Generated Content: You retain ownership of any content you post. By posting content, you grant Gno.me a non-exclusive, royalty-free, worldwide license to use, display, and distribute your content. You warrant that you have the right to grant this license and that your content does not infringe on any third-party rights.\n- Content Guidelines: All content must comply with our community guidelines. We reserve the right to remove any content that violates these guidelines or is otherwise inappropriate.\n\n## 5. Community Guidelines\n\nUsers are expected to behave respectfully and not engage in harassment, discrimination, or any form of abusive behavior. Violations can result in suspension or termination of your account. Specific prohibited activities include, but are not limited to:\n\n- Posting offensive or harmful content.\n- Spamming or distributing unsolicited messages.\n- Impersonating another person or entity.\n- Engaging in illegal activities, such as distributing malware or conducting phishing attacks.\n\n## 6. Platform Usage\n\nYou agree not to use Gno.me for any illegal or unauthorized purpose. You must not, in the use of the platform, violate any laws in your jurisdiction. This includes, but is not limited to, intellectual property laws, privacy laws, and financial regulations.\n\n## 7. Privacy and Data Protection\n\nOur use of your personal information is governed by our Privacy Policy, which is incorporated into these terms by reference. By using Gno.me, you consent to the collection and use of your data as outlined in our Privacy Policy.\n\n## 8. Payments and Transactions\n\nIf you purchase any services or products from Gno.me, you agree to pay all applicable fees and charges. All payments are non-refundable unless otherwise specified. We use third-party payment processors and you must comply with their terms and conditions.\n\n## 9. Intellectual Property and Trademarks\n\nThis platform contains copyrighted material, trademarks, and other proprietary material belonging to Gno.me, its licensors, and others. You shall not use, copy, reproduce, distribute, modify, adapt, create derivative works of, display, publicly perform, transmit, broadcast, sell, license, or in any way exploit the Proprietary Material without advance written consent. This restriction does not apply to open-source content contributed by Gno.me under an open-source license.\n\nAll trademarks, service marks, trade names, and trade dress, whether registered or unregistered, used by Gno.me are proprietary to Gno.me or their respective owners. You shall not use, display, or reproduce the Marks without prior written consent.\n\n## 10. Restrictions on Use\n\nAny commercial or promotional distribution, publishing, or exploitation of the platform, or any content, code, data, or materials on the platform, is strictly prohibited unless you have received express prior written permission from authorized personnel. You may not alter, edit, delete, remove, or otherwise change the meaning or appearance of any content, including the alteration or removal of any trademarks, trade names, logos, or proprietary rights notices.\n\n## 11. Disclaimer of Warranties\n\nGno.me is provided \"as is\" with no warranty of any kind. To the maximum extent permitted by law, Gno.me disclaims all representations and warranties, express or implied, including but not limited to warranties of merchantability, fitness for a particular purpose, title, non-infringement, uninterrupted access, and freedom from errors or omissions.\n\n## 12. Limitation of Liability\n\nNeither Gno.me nor its officers, directors, employees, agents, suppliers, licensors, or representatives will be liable for any direct, indirect, special, punitive, incidental, exemplary, or consequential damages arising out of or in connection with the use or inability to use Gno.me, even if advised of the possibility of such damages.\n\n## 13. Indemnification\n\nYou agree to indemnify, defend, and hold harmless Gno.me and its officers, directors, employees, agents, suppliers, licensors, and representatives from and against all claims, losses, expenses, damages, and costs, including reasonable attorneys' fees, arising out of your use of the platform or your breach of these Terms and Conditions.\n\n## 14. Governing Law\n\nThese terms are governed by the laws of Delaware, without regard to its conflict of law principles. Any disputes arising out of or in connection with these terms will be resolved in the courts of Delaware.\n\n## 15. Changes to Terms\n\nWe may revise these terms at any time without notice. By using Gno.me, you agree to be bound by the current version of these Terms and Conditions. We will notify users of any significant changes through our platform or via email.\n\n## 16. Third-Party Links\n\nOur platform may contain links to third-party websites or services that are not owned or controlled by Gno.me. We are not responsible for the content, privacy policies, or practices of any third-party websites or services. You acknowledge and agree that Gno.me shall not be responsible or liable, directly or indirectly, for any damage or loss caused or alleged to be caused by or in connection with the use of or reliance on any such content, goods, or services available on or through any such websites or services.\n\n## 17. Other Agreements\n\nCertain software, other content, and services offered by Gno.me may be governed by separate written agreements with individuals or entities. Such agreements shall govern in all cases with respect to the subject matter of those agreements. Your license to use open-source software contributed by Gno.me will also be governed by the terms of the applicable open-source license.\n\n## 18. Severability\n\nIf any provision of these Terms and Conditions is found to be invalid or unenforceable by a court of competent jurisdiction, the remaining provisions shall continue in full force and effect. The invalid or unenforceable provision will be deemed modified so that it is valid and enforceable to the maximum extent permitted by law.\n\n## 19. Waiver\n\nNo waiver of any term or condition of these Terms and Conditions shall be deemed a further or continuing waiver of such term or condition or any other term or condition, and any failure to assert a right or provision under these Terms and Conditions shall not constitute a waiver of such right or provision.\n\n## 20. Termination\n\nEither you or Gno.me may terminate this agreement at any time. Upon termination, your right to use the platform will immediately cease. If you violate any provision of this agreement, it will automatically terminate, and you must cease further use of the platform.\n\n## 21. Entire Agreement\n\nThese Terms and Conditions, together with our Privacy Policy, constitute the entire agreement between you and Gno.me regarding the use of the platform and supersede any prior agreements between you and Gno.me relating to your use of the platform.\n\n## 22. Contact Information\n\nFor any questions about these Terms and Conditions, please contact us at support@gno.me.\n`\n\nconst privacyPolicy = `\n# Privacy Policy\n\n## 1. Introduction\n\nWe are committed to protecting the privacy of our users. This Privacy Policy explains how we collect, use, and share your personal information when you use our website or web applications (altogether the “Site”). By using our platform, you agree to the terms of this policy.\n\n## 2. Scope and Updates to this Privacy Policy\n\nThis Privacy Policy applies to personal information processed by us in connection with Gno.me. By accessing or using Gno.me, you signify that you have read, understood, and agree to the Terms and Conditions and this Privacy Policy. We may revise this Privacy Policy from time to time in our sole discretion. Material changes will be notified as required by applicable law. Continuing to use Gno.me after updates means you accept the new policy.\n\n## 3. Data Collection\n\n- **Personal Information:** Includes identifiers such as your name, email address, username, profile picture, phone number, or address when you register to use Gno.me.\n- **Geolocation:** Information about where you live or use Gno.me.\n- **Communications:** Any personal information you provide in communications with us.\n- **Automatically Collected Information:** Includes your IP address, user settings, cookie identifiers, mobile carrier, browser or device information, Internet service provider, pages visited, links clicked, content interacted with, and usage details.\n\n## 4. Use of Data\n\nWe use your data to:\n\n- Provide and improve our services.\n- Communicate with you about your account and our services.\n- Customize your experience on our platform.\n- Analyze, develop, improve, and optimize the use, function, and performance of our Site and services.\n- Manage the security and operation of our Site, networks, and systems.\n- Administer contests, promotions, surveys, or other site features.\n- Prevent and investigate fraudulent or illegal activities.\n- Comply with applicable laws, regulations, and legal processes.\n\nWe may also use your personal information for direct marketing, research and development, network and information security, fraud prevention, measuring interest and engagement, improving services, developing new products, debugging, enforcing agreements, and any other activities required to comply with legal obligations.\n\n## 5. Data Sharing\n\nWe do not sell your personal information. We may share your data with:\n\n- **Service Providers:** Third-party services that help us operate our platform. These providers are contractually obligated to protect your information and use it only for the purposes we specify.\n- **Business Partners:** Partners with whom we jointly offer products or services.\n- **Affiliates:** Our company affiliates for administrative purposes, IT management, or providing services to you.\n- **Advertising Partners:** Third-party advertising partners for personalized advertisements.\n\nWe may also disclose your personal information to comply with legal requests, protect rights and safety, enforce our policies, collect amounts owed, or assist with investigations.\n\nIn the event of a business transfer such as a merger, acquisition, or sale of assets, your information may be transferred as part of the transaction.\n\n## 6. Data Retention\n\nWe retain your personal data as long as necessary to provide services, fulfill the purpose for which it was collected, resolve disputes, establish legal defenses, conduct audits, pursue legitimate business purposes, enforce agreements, and comply with applicable laws.\n\n## 7. Data Security\n\nWe implement appropriate technical and organizational measures to protect your data against unauthorized access, alteration, disclosure, or destruction. These measures include encryption, secure servers, and access controls. However, no system is completely secure, and we cannot guarantee absolute security. We may communicate with you electronically regarding security, privacy, and administrative issues relating to your use of Gno.me.\n\n## 8. User Rights\n\nYou have the right to:\n\n- Access your data.\n- Correct any inaccuracies.\n- Request deletion of your data.\n- Object to or restrict our use of your data.\n- Withdraw consent where our processing is based on your consent.\n- Data portability.\n\nTo exercise these rights, contact us at privacy@gno.me.\n\n## 9. Cookies and Tracking\n\nWe use cookies and similar technologies to track your activity on our platform and hold certain information. Cookies help us provide a better user experience by remembering your preferences and visit history. You can control the use of cookies through your browser settings, but disabling cookies may affect the functionality of certain features on our platform.\n\n## 10. International Data Transfers\n\nYour information may be transferred to, and maintained on, computers located outside of your state, province, country, or other governmental jurisdiction where data protection laws may differ from those of your jurisdiction. We ensure that your data is protected through contractual obligations and other safeguards in accordance with applicable law.\n\n## 11. Children’s Privacy\n\nOur service does not address anyone under the age of 13. We do not knowingly collect personally identifiable information from children under 13. If we become aware that we have collected personal information from a child under 13 without verification of parental consent, we will take steps to remove that information from our servers.\n\n## 12. Third-Party Links\n\nOur platform may contain links to other websites. We are not responsible for the privacy practices or the content of those sites. We encourage you to review the privacy policies of any third-party sites you visit.\n\n## 13. Transparency and Control\n\nWe strive to provide transparency and control over your personal information. You can manage your privacy settings and communication preferences in your account settings. You can also contact us to review, update, or delete your personal information.\n\n## 14. Data Anonymization and Aggregation\n\nWe may anonymize and aggregate your personal information to generate statistical and analytical data. This data will not identify you personally and may be used for research, analysis, and improving our services.\n\n## 15. Third-Party Service Providers\n\nWe may work with third-party service providers to provide and improve our services. These providers may have access to your personal information only to perform specific tasks on our behalf and are obligated to protect your information.\n\n## 16. International Data Privacy Standards\n\nWe comply with international data privacy standards and frameworks, including the EU-U.S. Privacy Shield and the Swiss-U.S. Privacy Shield, to ensure adequate protection of your personal information when transferred internationally.\n\n## 17. California Residents\n\nCalifornia residents may request information concerning the categories of personal information we share with third parties or affiliates for their direct marketing purposes. Our websites do not respond to “Do Not Track” signals.\n\n## 18. EU Residents\n\nConsumers in the EU have specific rights under data protection laws, including access, correction, deletion, restriction, objection, and portability of personal information. If you believe our processing of your personal information violates applicable law, you have the right to lodge a complaint with the competent supervisory authority.\n\n## 19. Accountability\n\nWe are committed to accountability and transparency in our data protection practices. We conduct regular audits and assessments to ensure compliance with our privacy policy and applicable data protection laws.\n\n## 20. Changes to Privacy Policy\n\nWe may update our Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page and updating the effective date. You are advised to review this Privacy Policy periodically for any changes.\n\n## 21. Contact Information\n\nFor any questions about this Privacy Policy, please contact us at privacy@gno.me.\n`\n"},{"name":"space.gno","body":"package space\n\nimport (\n\t\"encoding/binary\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tSectionPlatform  Section = \"platform\"\n\tSectionResources Section = \"resources\"\n\tSectionSocials   Section = \"socials\"\n)\n\ntype (\n\t// Section defines a type for a Gnome space section.\n\t// Sections can be used for grouping, for example external links.\n\tSection string\n\n\t// ID defines a type for `uint64` IDs.\n\tID uint64\n\n\t// Link is a reference to an external link.\n\tLink struct {\n\t\tURL   string\n\t\tTitle string\n\t}\n\n\t// News is a reference to an external news publication.\n\tNews struct {\n\t\tID        ID\n\t\tTitle     string\n\t\tURL       string\n\t\tImageURL  string\n\t\tTags      []string\n\t\tCreatedAt time.Time\n\t}\n\n\t// Tool defines a Gno ecosystem tool.\n\tTool struct {\n\t\tName        string\n\t\tDescription string\n\t\tURL         string\n\t\tIcon        string\n\t}\n)\n\nvar (\n\tlocked               bool\n\tnextVersionRealmPath string\n\tlastNewsID           ID\n\n\t// Editor accounts.\n\t// These accounts are allowed to add and remove news, tools and links.\n\teditors []std.Address\n\n\t// Ecosystem tools.\n\ttools []*Tool\n)\n\n// String returns the value of the ID as a string.\nfunc (id ID) String() string {\n\treturn strconv.FormatUint(uint64(id), 10)\n}\n\n// Key returns the binary representation of the ID to be used as key for AVL trees.\nfunc (id ID) Key() string {\n\tbuf := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(buf, uint64(id))\n\treturn string(buf)\n}\n\n// String returns a Markdown link.\nfunc (l Link) String() string {\n\turl := l.URL\n\tif !strings.HasPrefix(url, \"https://\") {\n\t\turl = newRealmURL(url)\n\t}\n\treturn ufmt.Sprintf(\"[%s](%s)\", l.Title, url)\n}\n\n// String returns a Markdown with tool info.\nfunc (t Tool) String() string {\n\tvar buf strings.Builder\n\n\tif t.Icon != \"\" {\n\t\tbuf.WriteString(ufmt.Sprintf(\"[![](%s)](%s)\\n\", t.Icon, t.URL))\n\t}\n\n\tbuf.WriteString(ufmt.Sprintf(\"**[%s](%s)**: \", t.Name, t.URL))\n\tbuf.WriteString(t.Description + \"\\n\")\n\treturn buf.String()\n}\n\n// String returns a Markdown with news info.\nfunc (n News) String() string {\n\tvar (\n\t\tbuf  strings.Builder\n\t\ttags []string\n\t)\n\n\tif n.ImageURL != \"\" {\n\t\tbuf.WriteString(ufmt.Sprintf(\"[![](%s)](%s)\\n\", n.ImageURL, n.URL))\n\t}\n\n\tbuf.WriteString(ufmt.Sprintf(\"**[%s](%s)**\\n\\n\", n.Title, n.URL))\n\tbuf.WriteString(\"#\" + n.ID.String() + \" - \")\n\tbuf.WriteString(n.CreatedAt.UTC().Format(\"Jan 02, 2006 (MST)\"))\n\n\tfor _, tag := range n.Tags {\n\t\ttags = append(tags, ufmt.Sprintf(\"[%s](%s)\", tag, newRealmURL(\"news/\"+tag)))\n\t}\n\n\tbuf.WriteString(\" - \" + strings.Join(tags, \", \") + \"\\n\")\n\treturn buf.String()\n}\n\nfunc newRealmURL(renderPath string) string {\n\treturn strings.TrimPrefix(std.CurrentRealm().PkgPath(), \"gno.land\") + \":\" + renderPath\n}\n\nfunc genNewsID() ID {\n\tlastNewsID += 1\n\treturn lastNewsID\n}\n\nfunc assertIsEditor(addr std.Address) {\n\tfor _, editor := range editors {\n\t\tif editor == addr {\n\t\t\treturn\n\t\t}\n\t}\n\n\tpanic(\"forbidden\")\n}\n\nfunc assertRealmIsNotLocked() {\n\tif locked {\n\t\tpanic(\"realm is locked\")\n\t}\n}\n"},{"name":"strategy_editors.gno","body":"package space\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\ntype editorsModificationStrategy struct {\n\tnewEditors, removeEditors []std.Address\n}\n\nfunc (editorsModificationStrategy) Name() string {\n\treturn StrategyNameEditorsModification\n}\n\nfunc (editorsModificationStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\nfunc (editorsModificationStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameEditorsModification)\n\treturn period\n}\n\nfunc (editorsModificationStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (editorsModificationStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s editorsModificationStrategy) Validate(*gnome.Proposal) error {\n\tfor _, e := range s.newEditors {\n\t\tfor _, addr := range editors {\n\t\t\tif addr == e {\n\t\t\t\treturn errors.New(\"address is already an editor: \" + e.String())\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, e := range s.removeEditors {\n\t\tfor _, addr := range editors {\n\t\t\tif addr == e {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn errors.New(\"address is not an editor: \" + e.String())\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s editorsModificationStrategy) Execute(*gnome.DAO) error {\n\tfor _, e := range s.removeEditors {\n\t\tfor i, addr := range editors {\n\t\t\tif addr != e {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\teditors = append(editors[:i], editors[i+1:]...)\n\t\t}\n\t}\n\n\tfor _, e := range s.newEditors {\n\t\teditors = append(editors, e)\n\t}\n\treturn nil\n}\n\nfunc (s editorsModificationStrategy) RenderParams() string {\n\tvar b strings.Builder\n\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\n\tif len(s.newEditors) \u003e 0 {\n\t\tvar editors []string\n\t\tfor _, m := range s.newEditors {\n\t\t\teditors = append(editors, m.String())\n\t\t}\n\n\t\tb.WriteString(\"| New Editors: | \" + strings.Join(editors, \"\u003c/br\u003e\") + \"\u003c/br\u003e\u003c/br\u003e |\\n\")\n\t}\n\n\tif len(s.removeEditors) \u003e 0 {\n\t\tvar editors []string\n\t\tfor _, m := range s.removeEditors {\n\t\t\teditors = append(editors, m.String())\n\t\t}\n\n\t\tb.WriteString(\"| Editors to Remove: | \" + strings.Join(editors, \"\u003c/br\u003e\") + \" |\\n\")\n\t}\n\n\treturn b.String()\n}\n"},{"name":"strategy_lock.gno","body":"package space\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\ntype lockingStrategy struct {\n\trealmPath string\n}\n\nfunc (lockingStrategy) Name() string {\n\treturn StrategyNameLocking\n}\n\nfunc (lockingStrategy) Quorum() float64 {\n\treturn 0.33\n}\n\nfunc (lockingStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameLocking)\n\treturn period\n}\n\nfunc (lockingStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (s lockingStrategy) Validate(*gnome.Proposal) error {\n\t// Allow modification of the newxt version package path when realm is locked\n\tif locked \u0026\u0026 nextVersionRealmPath == \"\" \u0026\u0026 s.realmPath != \"\" {\n\t\treturn nil\n\t}\n\n\tif locked {\n\t\treturn errors.New(\"realm is already locked\")\n\t}\n\treturn nil\n}\n\nfunc (lockingStrategy) Tally(_ *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tif choice, ok := gnome.SelectChoiceByPlurality(r); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s lockingStrategy) Execute(*gnome.DAO) error {\n\tlocked = true\n\tif s.realmPath != \"\" {\n\t\tnextVersionRealmPath = s.realmPath\n\t}\n\treturn nil\n}\n\nfunc (s lockingStrategy) RenderParams() string {\n\tif s.realmPath != \"\" {\n\t\treturn \"Next Realm Path: [\" + s.realmPath + \"](https://\" + s.realmPath + \")\"\n\t}\n\treturn \"\"\n}\n"},{"name":"strategy_params.gno","body":"package space\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\ntype paramsUpdateStrategy struct {\n\tspaceDAO      string\n\tvotingPeriods gnome.DurationParams\n}\n\nfunc (paramsUpdateStrategy) Name() string {\n\treturn StrategyNameParamsUpdate\n}\n\nfunc (paramsUpdateStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\nfunc (paramsUpdateStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameParamsUpdate)\n\treturn period\n}\n\nfunc (paramsUpdateStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (paramsUpdateStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s paramsUpdateStrategy) Execute(*gnome.DAO) error {\n\tif s.spaceDAO != \"\" {\n\t\tparameters.SpaceDAO = s.spaceDAO\n\t}\n\n\ts.votingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tparameters.VotingPeriods.Set(name, period)\n\t\treturn false\n\t})\n\treturn nil\n}\n\nfunc (s paramsUpdateStrategy) RenderParams() string {\n\tvar b strings.Builder\n\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\n\tif s.spaceDAO != \"\" {\n\t\tb.WriteString(\"| Gnome Space DAO Path | \" + s.spaceDAO + \" |\\n\")\n\t}\n\n\ts.votingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tb.WriteString(\"| Voting Period for `\" + name + \"` | \" + gnome.HumanizeDuration(period) + \" |\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n"},{"name":"strategy_section.gno","body":"package space\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\ntype dataSectionStrategy struct {\n\tslug, title, realm string\n\tblockHeight        int64\n\tdatasource         Datasource\n}\n\nfunc (dataSectionStrategy) Name() string {\n\treturn StrategyNameDataSection\n}\n\nfunc (dataSectionStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\nfunc (dataSectionStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameDataSection)\n\treturn period\n}\n\nfunc (dataSectionStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (dataSectionStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s dataSectionStrategy) Validate(*gnome.Proposal) error {\n\tif _, exists := indexes.DataSection.GetBySlug(s.slug); exists {\n\t\treturn errors.New(\"data section slug is already taken: \" + s.slug)\n\t}\n\treturn nil\n}\n\nfunc (s dataSectionStrategy) Execute(*gnome.DAO) error {\n\tindexes.DataSection.Index(\u0026DataSection{\n\t\tSlug:        s.slug,\n\t\tTitle:       s.title,\n\t\tRealm:       s.realm,\n\t\tBlockHeight: s.blockHeight,\n\t\tDatasource:  s.datasource,\n\t})\n\treturn nil\n}\n\nfunc (s dataSectionStrategy) RenderParams() string {\n\tvar (\n\t\tb      strings.Builder\n\t\theight = strconv.FormatInt(s.blockHeight, 10)\n\t)\n\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\tb.WriteString(\"| Slug: | \" + s.slug + \" |\\n\")\n\tb.WriteString(\"| Title: | \" + gnome.EscapeHTML(s.title) + \" |\\n\")\n\tb.WriteString(\"| Realm: | \" + s.realm + \" |\\n\")\n\tb.WriteString(\"| Block Height: | [\" + height + \"](\" + newBlockURL(s.blockHeight) + \") |\\n\")\n\n\treturn b.String()\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"26000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"t0d0c3frvPBR2C0jDWgac8w23czCnlNGHo//wPUGIEMGFIpCONdfumH0CCwam1LGxNuUbOpDVJY0GJMFy3dPFA=="}],"memo":""},"blockNum":"2145649"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","package":{"name":"tutorials","path":"gno.land/r/ecodevx/tutorials/pre1","files":[{"name":"LICENSE","body":"Copyright (c) 2024. All rights reserved.\n\nProject Owner:\nNewTendermint, LLC\n\nProject Maintainer:\nİlker Göktuğ ÖZTÜRK. \u003cilker@ilgooz.com\u003e, \u003cilkergoktugozturk@gmail.com\u003e\n\nYour access to this Project and your contributions to this Project are subject\nto the following terms:\n\n* You hereby grant to the listed Owner and Maintainer of this Project the\nworldwide, irrevocable and royalty-free right to use, publish, relicense and\nsublicense your contributions under any non-exclusive license of their\nchoosing for commercial and non-commercial purposes.\n* You shall not attempt to bring any intellectual property infringement or\nmisappropriation claims against the Owner or Maintainer of this Project\nrelating to or arising from your contributions.\n* You represent that you are the sole owner of all rights in your\ncontributions and that no third party has any rights or interests therein.\n\nFOR THE SCOPE OF THIS LICENSE, A CONTRIBUTION IS DEFINED TO INCLUDE ANY WORKS,\nIDEAS, CODE, PROCESSES, OR APIS MADE AVAILABLE TO VIEW BY THE GENERAL PUBLIC\n(INCLUDING ANY PUBLICLY ACCESSIBLE INTERNET FORUMS AND CHAT SERVERS WHERE\nACCESS IS AVAILABLE FOR FREE WITH REGISTRATION) OR PRIVATELY TO THIS PROJECT'S\nOWNER AND MAINTAINERS; INCLUDING WORKS, IDEAS, CODE, PROCESSES, AND APIS THAT\nARE ABOUT THIS PROJECT AND ITS CONTRIBUTIONS, OR MENTIONED IN REFERENCE TO\nTHIS PROJECT, WHERE SUCH WORKS, IDEAS, CODE, PROCESSES, AND APIS ARE MATERIAL\nTO THE SUCCESS, IMPROVEMENT, OR COMPLETION OF THIS PROJECT, AS DETERMINED BY\nTHE OWNER OF THIS PROJECT.\n\nContributions may come in any form, and include (but are not limited to):\n\n* pull requests\n* diff patches\n* commentary\n* example code\n\nIf you do not want your contribution to become incorporated into this Project,\ndo not make contributions to this Project. The creation of contributions that\nmay in the future become known to this Project's Owner and Maintainer\nconstitutes a willing contribution to this Project in accordance with this\nlicense.\n\nTHIS PROJECT AND THE WORKS AVAILABLE THROUGH THIS PROJECT ARE PROVIDED “AS IS”\nAND WITHOUT WARRANTY OF ANY KIND. IN NO EVENT SHALL THE OWNER OR MAINTAINER OF\nTHIS PROJECT BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THIS PROJECT OR THE WORKS AVAILABLE THROUGH\nTHIS PROJECT. YOU AGREED TO INDEMNIFY, DEFEND AND HOLD THE OWNER AND\nMAINTAINER FROM AND AGAINST ANY CLAIMS, LOSSES OR DAMAGES ARISING FROM YOUR\nUSE OF THIS PROJECT OR THE WORKS AVAILABLE THROUGH THIS PROJECT.\n\nThis license is subject to change at any time by the Project Owner or\nMaintainer.\n\nYour continued access to or use of this Project or any works\navailable through this Project shall be subject to the then-current version\nof this license.\n\nThe Project Owner and Maintainer reserve the right to change this license\nwithout needing the consent of the contributors to this Project.\n"},{"name":"datasource.gno","body":"package tutorials\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"gno.land/p/ecodevx/blog\"\n\tspace \"gno.land/r/ecodevx/space/pre1\"\n)\n\nvar _ space.Datasource = (*datasource)(nil)\n\nfunc NewDatasource() space.Datasource {\n\treturn \u0026datasource{}\n}\n\ntype datasource struct{}\n\nfunc (ds datasource) Iterate(start string, fn space.RecordIterFn) bool {\n\treturn tutorials.ReverseIterate(start, \"\", func(key string, p *blog.Post) bool {\n\t\tif isTutorialPublished(p) {\n\t\t\treturn fn(key, \u0026postRecord{p})\n\t\t}\n\t\treturn false\n\t})\n}\n\nfunc (ds datasource) IterateByTag(tag, start string, fn space.RecordIterFn) bool {\n\treturn tags.ReverseIteratePosts(tag, start, func(key string, p *blog.Post) bool {\n\t\tif isTutorialPublished(p) {\n\t\t\treturn fn(key, \u0026postRecord{p})\n\t\t}\n\t\treturn false\n\t})\n}\n\nfunc (ds datasource) GetContent(slug string, fn func(content string)) error {\n\tp, found := tutorials.Get(slug)\n\tif !found {\n\t\treturn errors.New(\"tutorial not found\")\n\t}\n\n\tif !isTutorialPublished(p) {\n\t\treturn errors.New(\"tutorial is not published\")\n\t}\n\n\tfn(p.Content)\n\treturn nil\n}\n\nvar _ space.Record = (*postRecord)(nil)\n\ntype postRecord struct {\n\tpost *blog.Post\n}\n\nfunc (r postRecord) GetSlug() string            { return r.post.Slug }\nfunc (r postRecord) GetTitle() string           { return r.post.Title }\nfunc (r postRecord) GetImage() string           { return \"\" } // TODO: What image should be returned?\nfunc (r postRecord) GetDescription() string     { return r.post.Summary }\nfunc (r postRecord) GetTags() []string          { return r.post.Tags }\nfunc (r postRecord) GetCreationTime() time.Time { return r.post.CreatedAt }\n"},{"name":"indexes.gno","body":"package tutorials\n\nimport (\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/ecodevx/blog\"\n)\n\nconst keyDateFmt = \"2006-01-02T15:04:05\"\n\nvar (\n\ttags      tagIndex\n\ttutorials tutorialIndex\n)\n\ntype tagIndex struct {\n\tindex avl.Tree // string(tag) -\u003e *tutorialIndex\n}\n\nfunc (x *tagIndex) Index(p *blog.Post) (indexed bool) {\n\tif p == nil {\n\t\treturn\n\t}\n\n\tfor _, tag := range p.Tags {\n\t\t// Get the tutorials for the current tag\n\t\tvar (\n\t\t\tidx      *tutorialIndex\n\t\t\tv, found = x.index.Get(tag)\n\t\t)\n\n\t\tif found {\n\t\t\tidx = v.(*tutorialIndex)\n\t\t} else {\n\t\t\tidx = \u0026tutorialIndex{}\n\t\t}\n\n\t\t// Index the tutorial\n\t\tidx.Index(p)\n\n\t\t// Keep track of indexing success\n\t\tindexed = x.index.Set(tag, idx) || indexed\n\t}\n\treturn\n}\n\nfunc (x *tagIndex) Remove(p *blog.Post) (removed bool) {\n\tif p == nil {\n\t\treturn\n\t}\n\n\tfor _, tag := range p.Tags {\n\t\tv, found := x.index.Get(tag)\n\t\tif !found {\n\t\t\t// Ignore tags that are not indexed\n\t\t\tcontinue\n\t\t}\n\n\t\tidx := v.(*tutorialIndex)\n\t\tif idx.Remove(p) \u0026\u0026 !removed {\n\t\t\tremoved = true\n\t\t}\n\n\t\tif idx.Size() == 0 {\n\t\t\t// Remove the tag from the index when empty\n\t\t\tx.index.Remove(tag)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (x tagIndex) IterateTags(fn func(tag string) bool) bool {\n\treturn x.index.Iterate(\"\", \"\", func(tag string, _ interface{}) bool {\n\t\treturn fn(tag)\n\t})\n}\n\nfunc (x tagIndex) IteratePosts(tag, start string, fn func(key string, _ *blog.Post) bool) bool {\n\tv, found := x.index.Get(tag)\n\tif !found {\n\t\treturn false\n\t}\n\n\tidx := v.(*tutorialIndex)\n\treturn idx.Iterate(start, \"\", func(key string, p *blog.Post) bool {\n\t\treturn fn(key, p)\n\t})\n}\n\nfunc (x tagIndex) ReverseIteratePosts(tag, start string, fn func(key string, _ *blog.Post) bool) bool {\n\tv, found := x.index.Get(tag)\n\tif !found {\n\t\treturn false\n\t}\n\n\tidx := v.(*tutorialIndex)\n\treturn idx.ReverseIterate(start, \"\", func(key string, p *blog.Post) bool {\n\t\treturn fn(key, p)\n\t})\n}\n\ntype tutorialIndex struct {\n\tindex avl.Tree // string(post creation time + post slug) -\u003e *blog.Post\n\tslugs avl.Tree // string(slug) -\u003e *blog.Post\n}\n\nfunc (x tutorialIndex) Size() int {\n\treturn x.index.Size()\n}\n\nfunc (x *tutorialIndex) Index(p *blog.Post) bool {\n\tx.slugs.Set(p.Slug, p)\n\n\tk := newTutorialKey(p)\n\treturn x.index.Set(k, p)\n}\n\nfunc (x tutorialIndex) Get(slug string) (*blog.Post, bool) {\n\tif v, found := x.slugs.Get(slug); found {\n\t\treturn v.(*blog.Post), true\n\t}\n\treturn nil, false\n}\n\nfunc (x *tutorialIndex) Remove(p *blog.Post) bool {\n\tx.slugs.Remove(p.Slug)\n\n\tk := newTutorialKey(p)\n\t_, removed := x.index.Remove(k)\n\treturn removed\n}\n\nfunc (x tutorialIndex) Iterate(start, end string, fn func(string, *blog.Post) bool) bool {\n\treturn x.index.Iterate(start, end, func(key string, v interface{}) bool {\n\t\treturn fn(key, v.(*blog.Post))\n\t})\n}\n\nfunc (x tutorialIndex) ReverseIterate(start, end string, fn func(string, *blog.Post) bool) bool {\n\treturn x.index.ReverseIterate(start, end, func(key string, v interface{}) bool {\n\t\treturn fn(key, v.(*blog.Post))\n\t})\n}\n\nfunc newTutorialKey(p *blog.Post) string {\n\treturn p.CreatedAt.UTC().Format(keyDateFmt) + p.Slug\n}\n"},{"name":"params.gno","body":"package tutorials\n\nimport (\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\n// Day defines the duration of a day.\nconst Day = time.Hour * 24\n\n// Names for the different strategy types.\nconst (\n\tStrategyNameCreation     = \"tutorial-creation\"\n\tStrategyNameDeletion     = \"tutorial-deletion\"\n\tStrategyNameLocking      = \"tutorial-realm-locking\"\n\tStrategyNameModification = \"tutorial-modification\"\n\tStrategyNameParamsUpdate = \"tutorial-params-update\"\n)\n\nvar parameters struct {\n\tVotingPeriods gnome.DurationParams\n\tTutorialsDAO  string\n}\n\nfunc init() {\n\t// Initial voting periods for each proposal type.\n\t// Periods can be changed by sumitting a params update proposal.\n\tparameters.VotingPeriods.Set(StrategyNameCreation, Day*3)\n\tparameters.VotingPeriods.Set(StrategyNameDeletion, Day*3)\n\tparameters.VotingPeriods.Set(StrategyNameLocking, Day*3)\n\tparameters.VotingPeriods.Set(StrategyNameModification, Day*3)\n\tparameters.VotingPeriods.Set(StrategyNameParamsUpdate, time.Minute*10)\n\n\t// Path to the tutorials DAO\n\tparameters.TutorialsDAO = \"council/main/community/tutorials\"\n}\n"},{"name":"public.gno","body":"package tutorials\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/mux\"\n\t\"gno.land/p/ecodevx/blog\"\n)\n\nfunc Render(path string) string {\n\trouter := mux.NewRouter()\n\trouter.NotFoundHandler = func(res *mux.ResponseWriter, _ *mux.Request) {\n\t\tres.Write(\"Path not found\")\n\t}\n\n\trouter.HandleFunc(\"\", renderBlog)\n\trouter.HandleFunc(\"posts\", renderBlog)\n\trouter.HandleFunc(\"posts/{slug}\", renderPost)\n\trouter.HandleFunc(\"drafts\", renderDrafts)\n\trouter.HandleFunc(\"revisions\", renderRevisions)\n\trouter.HandleFunc(\"tags\", renderTags)\n\trouter.HandleFunc(\"tags/{name}\", renderPostsByTag)\n\trouter.HandleFunc(\"params\", renderParams)\n\n\treturn renderAlerts() + router.Render(path)\n}\n\n// GetTutorialsBlog returns an invariant reference to the tutorials blog.\nfunc GetTutorialsBlog() blog.InvarBlog {\n\treturn blog.NewInvarBlog(\u0026tutorialsBlog)\n}\n\n// TutorialExists checks if a tutorial with a specific slug exists.\nfunc TutorialExists(slug string) bool {\n\treturn tutorialsBlog.HasPost(slug)\n}\n\n// Publish publishes content for a tutorial.\n//\n// The submited content must be previously approved by a creation or modification proposal.\n//\n// Parameters:\n// - slug: Slug name of the tutorial (required)\n// - content: The tutorial content to publish (required)\nfunc Publish(slug, content string) {\n\tassertRealmIsNotLocked()\n\n\t// Check that content checksum matches the approved content for the tutorial post\n\tp := mustGetPost(slug)\n\tblog.AssertContentSha256Hash(content, p.ContentHash)\n\n\t// Remove content metadata if present\n\t// TODO: Use front matter JSON metadata to init optional post fields?\n\t_, content = extractFrontMatter(content)\n\n\t// Add caller to the list of publishers\n\tcaller := std.GetOrigCaller()\n\tif !p.Publishers.HasAddress(caller) {\n\t\tp.Publishers = append(p.Publishers, caller)\n\t}\n\n\tif p.Status == blog.StatusDraft {\n\t\tp.PublishAt = time.Now()\n\t}\n\n\tp.Status = blog.StatusPublished\n\tp.Content = content\n\tp.UpdatedAt = time.Now()\n}\n\nfunc extractFrontMatter(content string) (meta, body string) {\n\t// Front matter is defined at the start of the Markdown content, surrounded by \"---\"\n\ts, hasMeta := strings.CutPrefix(content, \"---\\n\")\n\tif !hasMeta {\n\t\treturn \"\", content\n\t}\n\n\t// Split front matter metadata and Markdown content\n\tmeta, body, _ = strings.Cut(s, \"---\\n\")\n\treturn strings.TrimSpace(meta), body\n}\n"},{"name":"public_proposals.gno","body":"package tutorials\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/ecodevx/blog\"\n\tgnomeDAO \"gno.land/r/ecodevx/dao/pre1\"\n)\n\n// SubmitCreationProposal submits a new proposal to create a new tutorial.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - tutorialSlug: Slug name of the tutorial (required)\n// - tutorialTitle: A title for the tutorial (required)\n// - tutorialContentHash: A SHA256 hash of the tutorial's content (required)\n// - tutorialContentURL: A URL where the tutorial's content is currently available (required)\n// - tutorialAuthors: List of author addresses (required)\n// - tutorialEditors:\tList of editor addresses\n// - tutorialTags: Space separated list of tutorial tags\n//\n// Tutorial slug name allows letters from \"a\" to \"z\", numbers and \"-\" as valid characters.\n// Unicode letters are also allowed.\n//\n// The list of authors and editors must be a newline separated list of addresses.\nfunc SubmitCreationProposal(\n\tproposalTitle,\n\tproposalDescription,\n\ttutorialSlug,\n\ttutorialTitle,\n\ttutorialContentHash,\n\ttutorialContentURL,\n\ttutorialAuthors,\n\ttutorialEditors,\n\ttutorialTags string,\n) uint64 {\n\tassertRealmIsNotLocked()\n\tassertSlugIsAvailable(tutorialSlug)\n\tblog.AssertTitleIsNotEmpty(tutorialTitle)\n\tblog.AssertIsSlug(tutorialSlug)\n\tblog.AssertIsSha256Hash(tutorialContentHash)\n\tblog.AssertIsContentURL(tutorialContentURL)\n\n\ttags := strings.Fields(tutorialTags)\n\tassertValidTags(tags)\n\n\tauthors := blog.MustParseStringToAddresses(tutorialAuthors)\n\tif len(authors) == 0 {\n\t\tpanic(\"tutorial authors must have at least one author's address\")\n\t}\n\n\tstrategy := creationStrategy{\n\t\tslug:        tutorialSlug,\n\t\ttitle:       strings.TrimSpace(tutorialTitle),\n\t\tcontentHash: tutorialContentHash,\n\t\tcontentURL:  tutorialContentURL,\n\t\tauthors:     authors,\n\t\teditors:     blog.MustParseStringToAddresses(tutorialEditors),\n\t\ttags:        tags,\n\t}\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.TutorialsDAO)\n\treturn uint64(id)\n}\n\n// SubmitModificationProposal submits a new proposal to modify a tutorial.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - tutorialSlug: Slug name of the tutorial (required)\n// - tutorialTitle: A title for the tutorial\n// - tutorialContentHash: A SHA256 hash of the new tutorial's content\n// - tutorialCurrentContentHash: A SHA256 hash of the current tutorial's content\n// - tutorialContentURL: A URL where the new tutorial's content is currently available\n// - tutorialNewAuthors: List of author addresses\n// - tutorialNewEditors:\tList of editor addresses\n// - tutorialTags: Space separated list of tutorial tags\n//\n// Tutorial slug name allows letters from \"a\" to \"z\", numbers and \"-\" as valid characters.\n// Unicode letters are also allowed.\n//\n// The list of new authors and editors must be a newline separated list of addresses.\n// If present, authors and editors are appended to the current list of authors and editors.\nfunc SubmitModificationProposal(\n\tproposalTitle,\n\tproposalDescription,\n\ttutorialSlug,\n\ttutorialTitle,\n\ttutorialContentHash,\n\ttutorialCurrentContentHash,\n\ttutorialContentURL,\n\ttutorialNewAuthors,\n\ttutorialNewEditors,\n\ttutorialTags string,\n) uint64 {\n\tassertRealmIsNotLocked()\n\n\ttutorialSlug = strings.TrimSpace(tutorialSlug)\n\tassertTutorialExists(tutorialSlug)\n\n\ttags := strings.Fields(tutorialTags)\n\tassertValidTags(tags)\n\n\ttutorialContentHash = strings.TrimSpace(tutorialContentHash)\n\tif tutorialContentHash != \"\" {\n\t\ttutorialCurrentContentHash = strings.TrimSpace(tutorialCurrentContentHash)\n\t\tif tutorialCurrentContentHash == \"\" {\n\t\t\tpanic(\"the current content hash of the tutorial to modify is required\")\n\t\t}\n\n\t\tblog.AssertIsSha256Hash(tutorialContentHash)\n\t\tblog.AssertIsSha256Hash(tutorialCurrentContentHash)\n\t\tblog.AssertIsContentURL(tutorialContentURL)\n\t}\n\n\tstrategy := modificationStrategy{\n\t\tslug:               tutorialSlug,\n\t\ttitle:              strings.TrimSpace(tutorialTitle),\n\t\tcontentHash:        tutorialContentHash,\n\t\tcurrentContentHash: tutorialCurrentContentHash,\n\t\tcontentURL:         tutorialContentURL,\n\t\tauthors:            blog.MustParseStringToAddresses(tutorialNewAuthors),\n\t\teditors:            blog.MustParseStringToAddresses(tutorialNewEditors),\n\t\ttags:               tags,\n\t}\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.TutorialsDAO)\n\treturn uint64(id)\n}\n\n// SubmitDeletionProposal submits a new proposal to delete a tutorial.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - tutorialSlug: Slug name of the tutorial (required)\nfunc SubmitDeletionProposal(proposalTitle, proposalDescription, tutorialSlug string) uint64 {\n\tassertRealmIsNotLocked()\n\n\ttutorialSlug = strings.TrimSpace(tutorialSlug)\n\tassertTutorialExists(tutorialSlug)\n\n\tstrategy := deletionStrategy{tutorialSlug}\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.TutorialsDAO)\n\treturn uint64(id)\n}\n\n// SubmitLockingProposal submits a new proposal to lock the realm.\n//\n// Locking the realm \"freezes the state\" by disallowing further modifications.\n// State must be locked to migrate the realm to a newer version.\n//\n// Proposal requires a 34% quorum, otherwise the outcome will be low participation.\n// This type of proposal can only be created by members with `admin` role.\n// Tally is done by plurality.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - realmPath: Path of the realm that should be allowed to import state data\n//\n// The optional realm path authorizes a realm to import the state data once the realm is locked.\nfunc SubmitLockingProposal(proposalTitle, proposalDescription, realmPath string) uint64 {\n\tassertHasAdminRole(std.GetOrigCaller())\n\n\tif realmPath != \"\" \u0026\u0026 !strings.HasPrefix(realmPath, \"gno.land/r/\") {\n\t\tpanic(`realm path must start with \"gno.land/r/\"`)\n\t}\n\n\tstrategy := lockingStrategy{realmPath}\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.TutorialsDAO)\n\treturn uint64(id)\n}\n\n// SubmitParamsUpdateProposal submits a new proposal to update one or more realm parameters.\n//\n// Proposal requires a 51% quorum, otherwise the outcome will be low participation.\n// Tally is done by absolute majority, so all abstentions are considered.\n//\n// Parameters:\n// - proposalTitle: A title for the proposal (required)\n// - proposalDescription: A description of the proposal\n// - tutorialsDAO: Path to the tutorials SubDAO\n// - votingPeriodCreation: Voting period for tutorial creation proposals\n// - votingPeriodModification: Voting period for tutorial modification proposals\n// - votingPeriodDeletion: Voting period for tutorial deletion proposals\n// - votingPeriodLocking: Voting period for realm locking proposals\n// - votingPeriodParamsUpdate: Voting period for parameters update proposals\n//\n// Voting period is the number of days that members can vote on a proposal\n// At least one parameter value is required for creating a proposal.\nfunc SubmitParamsUpdateProposal(\n\tproposalTitle,\n\tproposalDescription,\n\ttutorialsDAO string,\n\tvotingPeriodCreation,\n\tvotingPeriodModification,\n\tvotingPeriodDeletion,\n\tvotingPeriodLocking,\n\tvotingPeriodParamsUpdate int,\n) uint64 {\n\tstrategy := paramsUpdateStrategy{}\n\ttutorialsDAO = strings.TrimSpace(tutorialsDAO)\n\tif tutorialsDAO != \"\" {\n\t\tif _, found := gnomeDAO.GetDAO(tutorialsDAO); !found {\n\t\t\tpanic(\"tutorials DAO path doesn't exist: \" + tutorialsDAO)\n\t\t}\n\n\t\tstrategy.tutorialsDAO = tutorialsDAO\n\t}\n\n\tif votingPeriodCreation \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodCreation) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameCreation, period)\n\t}\n\n\tif votingPeriodModification \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodModification) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameModification, period)\n\t}\n\n\tif votingPeriodDeletion \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodDeletion) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameDeletion, period)\n\t}\n\n\tif votingPeriodLocking \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodLocking) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameLocking, period)\n\t}\n\n\tif votingPeriodParamsUpdate \u003e 0 {\n\t\tperiod := time.Duration(votingPeriodParamsUpdate) * Day\n\t\tstrategy.votingPeriods.Set(StrategyNameParamsUpdate, period)\n\t}\n\n\tif strategy.votingPeriods.Size() == 0 {\n\t\tpanic(\"at least one parameter value must be specified\")\n\t}\n\n\tid := gnomeDAO.SubmitCustomProposal(proposalTitle, proposalDescription, strategy, parameters.TutorialsDAO)\n\treturn uint64(id)\n}\n\nfunc assertSlugIsAvailable(slug string) {\n\tif tutorialsBlog.HasPost(slug) {\n\t\tpanic(\"tutorial URL slug already exists\")\n\t}\n}\n\nfunc assertTutorialExists(slug string) {\n\tif !tutorialsBlog.HasPost(slug) {\n\t\tpanic(\"tutorial not found\")\n\t}\n}\n\nfunc assertValidTags(tags []string) {\n\tfor _, t := range tags {\n\t\tif !blog.IsSlug(t) {\n\t\t\tpanic(\"invalid tag: \" + t)\n\t\t}\n\t}\n}\n\nfunc assertHasAdminRole(addr std.Address) {\n\terr := gnomeDAO.CheckMemberHasRole(parameters.TutorialsDAO, addr, gnomeDAO.RoleAdmin)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"},{"name":"render.gno","body":"package tutorials\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/mux\"\n\t\"gno.land/p/ecodevx/alerts\"\n\t\"gno.land/p/ecodevx/blog\"\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nconst (\n\tdateFormat      = \"2006-01-02 15:04 MST\"\n\tshortDateFormat = \"Jan 2, 2006\"\n)\n\nfunc renderBlog(res *mux.ResponseWriter, _ *mux.Request) {\n\t// Write header\n\tres.Write(\"# \" + tutorialsBlog.Title + \"\\n\")\n\tif tutorialsBlog.Description != \"\" {\n\t\tres.Write(tutorialsBlog.Description + \"\\n\\n\")\n\t}\n\n\t// Write tutorials menu\n\tres.Write(renderMenu() + \"\\n\\n---\\n\")\n\n\t// Write list of published tutorials\n\ttutorials.Iterate(\"\", \"\", func(_ string, p *blog.Post) bool { // TODO: Add post pagination support\n\t\tif !isTutorialPublished(p) {\n\t\t\treturn false\n\t\t}\n\n\t\turl := newRealmURL(\"posts/\" + p.Slug)\n\t\tdate := p.PublishAt.UTC().Format(shortDateFormat)\n\t\tres.Write(\"**[\" + p.Title + \"](\" + url + \")**\u003c/br\u003e\")\n\t\tres.Write(\"_Published: \" + date + \"_\\n\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderPost(res *mux.ResponseWriter, req *mux.Request) {\n\tslug := req.GetVar(\"slug\")\n\tp, found := tutorialsBlog.GetPost(slug)\n\tif !found {\n\t\tres.Write(\"Post not found\")\n\t\treturn\n\t}\n\n\tif p.Status == blog.StatusRevised {\n\t\tres.Write(alerts.NewWarning(\"Tutorial content is being revised\"))\n\t}\n\n\t// TODO: Add post tags with links\n\tres.Write(\"# \" + p.Title + \"\\n\")\n\tres.Write(\"- Author(s): \" + p.Authors.String() + \"\\n\")\n\n\tif len(p.Editors) \u003e 0 {\n\t\tres.Write(\"- Editors(s): \" + p.Editors.String() + \"\\n\")\n\t}\n\n\tres.Write(\"- Publisher(s): \" + p.Publishers.String() + \"\\n\")\n\tres.Write(\"- Status: \" + p.Status.String() + \"\\n\")\n\tres.Write(\"- Content Hash: \" + p.ContentHash + \"\\n\")\n\tres.Write(\"- Created: \" + p.CreatedAt.UTC().Format(dateFormat) + \"\\n\")\n\tif !p.UpdatedAt.IsZero() {\n\t\tres.Write(\"- Updated: \" + p.UpdatedAt.UTC().Format(dateFormat) + \"\\n\")\n\t}\n\n\tif len(p.Tags) \u003e 0 {\n\t\tres.Write(\"- Tag(s): \" + renderTagLinks(p.Tags) + \"\\n\")\n\t}\n\n\tif p.Content != \"\" {\n\t\tres.Write(\"\\n\" + p.Content)\n\t}\n}\n\nfunc renderDrafts(res *mux.ResponseWriter, _ *mux.Request) {\n\tres.Write(\"# \" + tutorialsBlog.Title + \": Drafts\\n\")\n\ttutorials.Iterate(\"\", \"\", func(_ string, p *blog.Post) bool { // TODO: Add pagination support\n\t\tif p.Status != blog.StatusDraft {\n\t\t\treturn false\n\t\t}\n\n\t\turl := newRealmURL(\"posts/\" + p.Slug)\n\t\tdate := p.CreatedAt.UTC().Format(shortDateFormat)\n\t\tres.Write(\"**[\" + p.Title + \"](\" + url + \")**\u003c/br\u003e\")\n\t\tres.Write(\"_Created: \" + date + \"_\\n\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderRevisions(res *mux.ResponseWriter, _ *mux.Request) {\n\tres.Write(\"# \" + tutorialsBlog.Title + \": Revisions\\n\")\n\ttutorials.Iterate(\"\", \"\", func(_ string, p *blog.Post) bool { // TODO: Add pagination support\n\t\tif p.Status != blog.StatusRevised {\n\t\t\treturn false\n\t\t}\n\n\t\turl := newRealmURL(\"posts/\" + p.Slug)\n\t\tdate := p.PublishAt.UTC().Format(shortDateFormat)\n\t\tres.Write(\"**[\" + p.Title + \"](\" + url + \")**\u003c/br\u003e\")\n\t\tres.Write(\"_Published: \" + date + \"_\\n\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderTags(res *mux.ResponseWriter, req *mux.Request) {\n\tres.Write(\"# \" + tutorialsBlog.Title + \": Tags\\n\")\n\ttags.IterateTags(func(tag string) bool {\n\t\tres.Write(\"- [\" + tag + \"](\" + newRealmURL(\"tags/\"+tag) + \")\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderPostsByTag(res *mux.ResponseWriter, req *mux.Request) {\n\ttag := req.GetVar(\"name\")\n\tres.Write(\"# \" + tutorialsBlog.Title + \": Tag `\" + tag + \"`\\n\")\n\n\tif tag == \"\" {\n\t\treturn\n\t}\n\n\ttags.IteratePosts(tag, \"\", func(_ string, p *blog.Post) bool {\n\t\tif p.Status != blog.StatusPublished \u0026\u0026 p.Status != blog.StatusRevised {\n\t\t\treturn false\n\t\t}\n\n\t\turl := newRealmURL(\"posts/\" + p.Slug)\n\t\tdate := p.PublishAt.UTC().Format(shortDateFormat)\n\t\tres.Write(\"**[\" + p.Title + \"](\" + url + \")**\u003c/br\u003e\")\n\t\tres.Write(\"_Published: \" + date + \"_\\n\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderParams(res *mux.ResponseWriter, _ *mux.Request) {\n\tres.Write(\"# \" + tutorialsBlog.Title + \": Parameters\\n\")\n\tres.Write(\"## Proposal\\n\")\n\tres.Write(\"**General**\\n\")\n\tres.Write(\"- Tutorials DAO Path: \" + parameters.TutorialsDAO + \"\\n\")\n\tres.Write(\"\\n**Voting Periods**\\n\")\n\tparameters.VotingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tres.Write(\"- `\" + name + \"`: \" + gnome.HumanizeDuration(period) + \"\\n\")\n\t\treturn false\n\t})\n}\n\nfunc renderAlerts() string {\n\tif locked {\n\t\tmsg := \"Realm is locked\"\n\t\tif nextVersionRealmPath != \"\" {\n\t\t\tlink := alerts.NewLink(\"https://\"+nextVersionRealmPath, nextVersionRealmPath)\n\t\t\tmsg += \"\u003c/br\u003eThis realm is deprecated in favor of a new version found at \" + link\n\t\t}\n\n\t\treturn alerts.NewError(msg)\n\t}\n\treturn \"\"\n}\n\nfunc renderMenu() string {\n\titems := []string{\n\t\t\"**[drafts](\" + newRealmURL(\"drafts\") + \")**\",\n\t\t\"**[revisions](\" + newRealmURL(\"revisions\") + \")**\",\n\t}\n\n\t// Add taxonomy entries\n\ttags.IterateTags(func(tag string) bool {\n\t\titems = append(items, \"**[\"+tag+\"](\"+newRealmURL(\"tags/\"+tag)+\")**\")\n\t\treturn false\n\t})\n\n\treturn strings.Join(items, \" \")\n}\n\nfunc renderTagLinks(tags []string) string {\n\tvar links []string\n\tfor _, t := range tags {\n\t\tlinks = append(links, \"[\"+t+\"](\"+newRealmURL(\"tags/\"+t)+\")\")\n\t}\n\treturn strings.Join(links, \", \")\n}\n\nfunc newRealmURL(renderPath string) string {\n\treturn strings.TrimPrefix(std.CurrentRealm().PkgPath(), \"gno.land\") + \":\" + renderPath\n}\n\nfunc isTutorialPublished(p *blog.Post) bool {\n\t// Skip posts that should be published at a future date\n\tif p.PublishAt.IsZero() || p.PublishAt.After(time.Now()) {\n\t\treturn false\n\t}\n\n\t// Skip posts that are not published or being revised\n\tif p.Status != blog.StatusPublished \u0026\u0026 p.Status != blog.StatusRevised {\n\t\treturn false\n\t}\n\treturn true\n}\n"},{"name":"strategy_lock.gno","body":"package tutorials\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\ntype lockingStrategy struct {\n\trealmPath string\n}\n\nfunc (lockingStrategy) Name() string {\n\treturn StrategyNameLocking\n}\n\nfunc (lockingStrategy) Quorum() float64 {\n\treturn 0.33\n}\n\nfunc (lockingStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameLocking)\n\treturn period\n}\n\nfunc (lockingStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (s lockingStrategy) Validate(*gnome.Proposal) error {\n\t// Allow modification of the newxt version package path when realm is locked\n\tif locked \u0026\u0026 nextVersionRealmPath == \"\" \u0026\u0026 s.realmPath != \"\" {\n\t\treturn nil\n\t}\n\n\tif locked {\n\t\treturn errors.New(\"realm is already locked\")\n\t}\n\treturn nil\n}\n\nfunc (lockingStrategy) Tally(_ *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tif choice, ok := gnome.SelectChoiceByPlurality(r); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s lockingStrategy) Execute(*gnome.DAO) error {\n\tlocked = true\n\tif s.realmPath != \"\" {\n\t\tnextVersionRealmPath = s.realmPath\n\t}\n\treturn nil\n}\n\nfunc (s lockingStrategy) RenderParams() string {\n\tif s.realmPath != \"\" {\n\t\treturn \"Next Realm Path: [\" + s.realmPath + \"](https://\" + s.realmPath + \")\"\n\t}\n\treturn \"\"\n}\n"},{"name":"strategy_params.gno","body":"package tutorials\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\ntype paramsUpdateStrategy struct {\n\ttutorialsDAO  string\n\tvotingPeriods gnome.DurationParams\n}\n\nfunc (paramsUpdateStrategy) Name() string {\n\treturn StrategyNameParamsUpdate\n}\n\nfunc (paramsUpdateStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\nfunc (paramsUpdateStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameParamsUpdate)\n\treturn period\n}\n\nfunc (paramsUpdateStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (paramsUpdateStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s paramsUpdateStrategy) Execute(*gnome.DAO) error {\n\tif s.tutorialsDAO != \"\" {\n\t\tparameters.TutorialsDAO = s.tutorialsDAO\n\t}\n\n\ts.votingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tparameters.VotingPeriods.Set(name, period)\n\t\treturn false\n\t})\n\treturn nil\n}\n\nfunc (s paramsUpdateStrategy) RenderParams() string {\n\tvar b strings.Builder\n\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\n\tif s.tutorialsDAO != \"\" {\n\t\tb.WriteString(\"| Tutorials DAO Path | \" + s.tutorialsDAO + \" |\\n\")\n\t}\n\n\ts.votingPeriods.Iterate(func(name string, period time.Duration) bool {\n\t\tb.WriteString(\"| Voting Period for `\" + name + \"` | \" + gnome.HumanizeDuration(period) + \" |\\n\")\n\t\treturn false\n\t})\n\n\treturn b.String()\n}\n"},{"name":"strategy_tutorials.gno","body":"package tutorials\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/ecodevx/blog\"\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\ntype creationStrategy struct {\n\tslug, title, contentHash, contentURL string\n\tauthors, editors                     blog.AddressList\n\ttags                                 []string\n}\n\nfunc (creationStrategy) Name() string {\n\treturn StrategyNameCreation\n}\n\nfunc (creationStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\nfunc (creationStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameCreation)\n\treturn period\n}\n\nfunc (creationStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (s creationStrategy) Validate(*gnome.Proposal) error {\n\tif tutorialsBlog.HasPost(s.slug) {\n\t\treturn errors.New(\"tutorial URL slug already exists\")\n\t}\n\treturn nil\n}\n\nfunc (creationStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s creationStrategy) Execute(*gnome.DAO) error {\n\tp := \u0026blog.Post{\n\t\tSlug:        s.slug,\n\t\tTitle:       s.title,\n\t\tContentHash: s.contentHash,\n\t\tAuthors:     s.authors,\n\t\tEditors:     s.editors,\n\t\tStatus:      blog.StatusDraft,\n\t\tTags:        s.tags,\n\t\tCreatedAt:   time.Now(),\n\t}\n\ttutorialsBlog.AddPost(p)\n\n\t// Update realm indexes\n\ttutorials.Index(p)\n\tif len(p.Tags) \u003e 0 {\n\t\ttags.Index(p)\n\t}\n\n\treturn nil\n}\n\nfunc (s creationStrategy) RenderParams() string {\n\tvar (\n\t\tb       strings.Builder\n\t\tauthors = strings.ReplaceAll(s.authors.String(), \", \", \"\u003c/br\u003e\")\n\t)\n\n\t// TODO: Implement using gno.land/p/demo/ui\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\tb.WriteString(\"| Slug: | \" + s.slug + \" |\\n\")\n\tb.WriteString(\"| Title: | \" + gnome.EscapeHTML(s.title) + \" |\\n\")\n\tb.WriteString(\"| Content URL: | \" + gnome.NewLinkURI(s.contentURL) + \" |\\n\")\n\tb.WriteString(\"| Content Hash: | \" + s.contentHash + \" |\\n\")\n\n\tif len(s.tags) \u003e 0 {\n\t\tb.WriteString(\"| Tag(s): | \" + renderTagLinks(s.tags) + \" |\\n\")\n\t}\n\n\tb.WriteString(\"| Author(s): | \u003c/br\u003e\" + authors + \"\u003c/br\u003e\u003c/br\u003e |\\n\")\n\n\tif len(s.editors) \u003e 0 {\n\t\teditors := strings.ReplaceAll(s.editors.String(), \", \", \"\u003c/br\u003e\")\n\t\tb.WriteString(\"| Editor(s): | \u003c/br\u003e\" + editors + \"\u003c/br\u003e\u003c/br\u003e |\\n\")\n\t}\n\n\treturn b.String()\n}\n\ntype modificationStrategy struct {\n\tslug, title, currentContentHash, contentHash, contentURL string\n\tauthors, editors                                         blog.AddressList\n\ttags                                                     []string\n}\n\nfunc (modificationStrategy) Name() string {\n\treturn StrategyNameModification\n}\n\nfunc (modificationStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\nfunc (modificationStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameModification)\n\treturn period\n}\n\nfunc (modificationStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (s modificationStrategy) Validate(*gnome.Proposal) error {\n\tp, found := tutorialsBlog.GetPost(s.slug)\n\tif !found {\n\t\treturn errors.New(\"tutorial doesn't exists\")\n\t}\n\n\tif s.currentContentHash != \"\" \u0026\u0026 s.currentContentHash != p.ContentHash {\n\t\treturn errors.New(\"tutorial's content has been previously modified\")\n\t}\n\n\tfor _, addr := range s.authors {\n\t\tif p.Authors.HasAddress(addr) {\n\t\t\treturn errors.New(\"author already exists: \" + addr.String())\n\t\t}\n\t}\n\n\tfor _, addr := range s.editors {\n\t\tif p.Authors.HasAddress(addr) {\n\t\t\treturn errors.New(\"editor already exists: \" + addr.String())\n\t\t}\n\t}\n\n\tif len(s.tags) \u003e 0 {\n\t\tvar seenTags avl.Tree\n\t\tfor _, t := range s.tags {\n\t\t\tif seenTags.Has(t) {\n\t\t\t\treturn errors.New(\"duplicated tag: \" + t)\n\t\t\t}\n\n\t\t\tseenTags.Set(t, struct{}{})\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (modificationStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s modificationStrategy) Execute(*gnome.DAO) error {\n\tp, _ := tutorialsBlog.GetPost(s.slug)\n\n\tif s.title != \"\" {\n\t\tp.Title = s.title\n\t}\n\n\tif len(s.authors) \u003e 0 {\n\t\tp.Authors = append(p.Authors, s.authors...)\n\t}\n\n\tif len(s.editors) \u003e 0 {\n\t\tp.Editors = append(p.Editors, s.editors...)\n\t}\n\n\t// Update tag index\n\tif len(s.tags) \u003e 0 {\n\t\ttags.Remove(p)\n\t\tp.Tags = s.tags\n\t\ttags.Index(p)\n\t}\n\n\t// Changing content hash converts post to a revised until new content is setted\n\tif s.contentHash != \"\" {\n\t\tp.Status = blog.StatusRevised\n\t\tp.ContentHash = s.contentHash\n\t}\n\n\tp.UpdatedAt = time.Now()\n\treturn nil\n}\n\nfunc (s modificationStrategy) RenderParams() string {\n\tvar b strings.Builder\n\n\t// TODO: Implement using gno.land/p/demo/ui\n\tb.WriteString(\"|||\\n|---|---|\\n\")\n\tb.WriteString(\"| Slug: | [\" + s.slug + \"](\" + newRealmURL(\"posts/\"+s.slug) + \") |\\n\")\n\n\tif s.title != \"\" {\n\t\tb.WriteString(\"| Title: | \" + gnome.EscapeHTML(s.title) + \" |\\n\")\n\t}\n\n\tif s.contentHash != \"\" {\n\t\tb.WriteString(\"| Content URL: | \" + gnome.NewLinkURI(s.contentURL) + \" |\\n\")\n\t\tb.WriteString(\"| Content Hash: | \" + s.contentHash + \" |\\n\")\n\t\tb.WriteString(\"| Modifies Content Hash: | \" + s.currentContentHash + \" |\\n\")\n\t}\n\n\tif len(s.tags) \u003e 0 {\n\t\tb.WriteString(\"| Tag(s): | \" + renderTagLinks(s.tags) + \" |\\n\")\n\t}\n\n\tif len(s.authors) \u003e 0 {\n\t\tauthors := strings.ReplaceAll(s.authors.String(), \", \", \"\u003c/br\u003e\")\n\t\tb.WriteString(\"| Author(s): | \u003c/br\u003e\" + authors + \"\u003c/br\u003e\u003c/br\u003e |\\n\")\n\t}\n\n\tif len(s.editors) \u003e 0 {\n\t\teditors := strings.ReplaceAll(s.editors.String(), \", \", \"\u003c/br\u003e\")\n\t\tb.WriteString(\"| Editor(s): | \u003c/br\u003e\" + editors + \"\u003c/br\u003e\u003c/br\u003e |\\n\")\n\t}\n\n\treturn b.String()\n}\n\ntype deletionStrategy struct {\n\tslug string\n}\n\nfunc (deletionStrategy) Name() string {\n\treturn StrategyNameDeletion\n}\n\nfunc (deletionStrategy) Quorum() float64 {\n\treturn 0.51\n}\n\nfunc (deletionStrategy) VotingPeriod() time.Duration {\n\tperiod, _ := parameters.VotingPeriods.Get(StrategyNameDeletion)\n\treturn period\n}\n\nfunc (deletionStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n\nfunc (deletionStrategy) Tally(dao *gnome.DAO, r gnome.VotingRecord) gnome.VoteChoice {\n\tabstentions := len(dao.Members()) - r.VoteCount()\n\tif choice, ok := gnome.SelectChoiceByMajority(r, abstentions); ok {\n\t\treturn choice\n\t}\n\treturn gnome.ChoiceNone\n}\n\nfunc (s deletionStrategy) Validate(*gnome.Proposal) error {\n\tif !tutorialsBlog.HasPost(s.slug) {\n\t\treturn errors.New(\"tutorial doesn't exists\")\n\t}\n\treturn nil\n}\n\nfunc (s deletionStrategy) Execute(*gnome.DAO) error {\n\tp, found := tutorialsBlog.RemovePost(s.slug)\n\tif !found {\n\t\treturn errors.New(\"tutorial not found\")\n\t}\n\n\t// Update realm indexes\n\ttutorials.Remove(p)\n\tif len(p.Tags) \u003e 0 {\n\t\ttags.Remove(p)\n\t}\n\n\treturn nil\n}\n\nfunc (s deletionStrategy) RenderParams() string {\n\treturn \"Slug: [\" + s.slug + \"](\" + newRealmURL(\"posts/\"+s.slug) + \")\"\n}\n"},{"name":"tutorials.gno","body":"package tutorials\n\nimport (\n\t\"gno.land/p/ecodevx/blog\"\n)\n\nvar (\n\tlocked               bool\n\tnextVersionRealmPath string\n\n\ttutorialsBlog = blog.Blog{Title: \"Gno.me Tutorials\"} // TODO: Define a realm description\n)\n\nfunc mustGetPost(slug string) *blog.Post {\n\tp, found := tutorialsBlog.GetPost(slug)\n\tif !found {\n\t\tpanic(\"tutorial not found\")\n\t}\n\treturn p\n}\n\nfunc assertRealmIsNotLocked() {\n\tif locked {\n\t\tpanic(\"realm is locked\")\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"21000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"SLrugiPpinroJuoCbv0+XkWY5McL0EzBeqE1BhmFpO8lSEUqhkZUDM8Xtt6Z/7qqMkyM7jSIQ/xBYBxCof7zPQ=="}],"memo":""},"blockNum":"2145663"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1hrfvdh7jdvnlxpk2y20tp3scj9jqal3zzu7wjz","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"u5+jsSOrU6+GMQHRTiamp3AZUbgXEB44b0ivDaeSAfIs1lE0TFsaBn/OWicAetqtSv2wCa2ai3xKP0U80aVFGQ=="}],"memo":""},"blockNum":"2149162"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"15000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","15000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","15009447"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5AUjFIdvgvvYPCszkBSj4LyyQVI/uczvuxzbg5IRDB3"},"signature":"ZQTRpqZrQuRXH7hi0sNX0VdbnXn9JbMYlStVS3ozHA9fpK6Yuiu5PL8Os+KiVDsOwIrzxZZNOtlgyLJkSytg3w=="}],"memo":""},"blockNum":"2154429"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1ujtg2d36ftvmyps44wfatn69g2mutns8hcgzxk","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"DpglO8KcKGhXQ8WlOdh+Mp6rgpsoFu/bHkEvt00H8oRbljEHdqZyyV0sietHy+UwX3aiEx0C93xfoILWaecurA=="}],"memo":""},"blockNum":"2154728"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1hyggwhlgg24yf8lpc5wcp9x9rtwx8hxq2tmmdq","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"/HDVLP3dLnFHNO2loYCJbNxvePp6Kxtb0WBV3bJFmJBp/yyd0+PVeYgopMqrweYj6P4nehJhCSwbE8rRnnUjYQ=="}],"memo":""},"blockNum":"2154925"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["abc.gno","5b11618c2e44027877d0cd0921ed166b9f176f50587fc91e7534dd2946db77d6"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"Nw7jqUsEfaro5KmkgVOC3VyjDXckfNmV8TF4d4AcDxgwM4Gv0OgB5uWizg3UJFCBeUAnqKgUu5Hl8wTIOTeyHg=="}],"memo":""},"blockNum":"2155588"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["1","secret","abc.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"f9au8xYU2QMKNYEdDZ3V1523tb6/XW8rirUZe+lnboMTaABBKMIdOxwBVy4fQNrRtQ/QcCRzVUV/D8Vs8HmlQw=="}],"memo":""},"blockNum":"2155611"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v406/domain/registrar","func":"GetJoinedBid","args":["g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"r0x/SOWbvJ0yjrMjlQLQyVp4V+gk7NEnyQx1+plDMzF8wNsIFyUffPuzF1XKtPebMHfJg4r9p+XWEDi89GBtiQ=="}],"memo":""},"blockNum":"2155637"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"","pkg_path":"gno.land/r/varmeta/demo/v406/domain/registrar","func":"GetJoinedBid","args":["g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9"]}],"fee":{"gas_wanted":"80000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"frgSp3p6poyLYkUNYMD+XduzApUyx/MK3QkbjNwsFJcSrOExAdEtbjBZZLRPVZcIqL9YblHkTmamY8gKbxIj2g=="}],"memo":""},"blockNum":"2155648"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["abcd.gno","1b4f0e9851971998e732078544c96b36c3d01cedf7caa332359d6f1d83567014"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"kl5INwWvOwL7GCoj9s1jwmE7prVxNNVWDyYaW5dDnsorBioNaoC0hUWsbFjVMHqCAClxsaFqagDU5cKKJWhfOw=="}],"memo":""},"blockNum":"2155687"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g162jgpk4740r6a7g53cgz9ahxqtyuekgqchw6w9","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["1","test","abcd.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AqD4AqUY/VAPgrwGhq7e9Px4Pj81GRDZYwRvm+A69599"},"signature":"ycBKUtnkBVLby/JH5fs08QrJCKiReQ0t6J0q9XOjLFBbxVQJyk+K3q7L6pPXSn2eL0dD7DP4Kecw3iRcnHWEuQ=="}],"memo":""},"blockNum":"2155718"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"Gau+ExSagGowybNNMoBVSOESk9eWYFTYz72yjDia8ug0WQ4rOYDeRA33j5QnUo82JYbAfJ73tFYZweMdNFKwsQ=="}],"memo":""},"blockNum":"2155733"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["test111.gno","1c9829230647c7cdd03a4d27971a1a9c2df276e5e2b207f11eb37d7d0b0bb198"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"GG8JcEOPomRlucbuJIaii6dyh6doPAalYOrj3Ftvp+8/EVizbPCG8HaqGOZkMCH7jjBB2PSx4nJ8OvIJEI5j3Q=="}],"memo":""},"blockNum":"2155745"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"20000000ugnot","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","zx_xmamamia",""]},{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["DisplayName","zxxxxxma"]},{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Avatar","ipfs://undefined"]},{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Banner","ipfs://undefined"]},{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Bio","zôÖzôÖ!"]}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AyDlf14q7C2aBqar/Qryh6dVR9VACxVZV6fOaM3X5YEA"},"signature":"1AWNOnviJo2dDrIMB1tcPzWuXyeCsjrhZ3ijXQ6G5rAH5UFslaIlzJ7cYqNP2n9JiFiTbA1OB6sAoo3Mdw1sQA=="}],"memo":""},"blockNum":"2155754"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["100","test","test111.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"4TFoSNX+62/2hNa9ah5ph4Y+/S5DmqQs2xUW19PSBBYukkhU/ZE6pGG7gonWUy7a0xhzWFKvkSLMAfXU5S4iUQ=="}],"memo":""},"blockNum":"2155764"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"200ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"Claim","args":["test111.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"xehj64xaDsU+qVaqZ7/ID/z7LLUx4QvOrqvrJgPov1ogXYherQdCLvKDt9XUipdRrReW96wSylxum7NhzpBJyA=="}],"memo":""},"blockNum":"2155775"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["test11111.gno","ec2738feb2bbb0bc783eb4667903391416372ba6ed8b8dddbebbdb37e5102473"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"ndUvQNZGrjBAXPNLI04PwZLPlVutzN3x6t0yUUNu14Zy2nuhEBf0tyVLoBD9grMyzCY7/uMQIzmNYBrPCUmywg=="}],"memo":""},"blockNum":"2155824"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["10","test","test11111.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"iSzAroZMh/Vr0VAXzMSLuGdFAC3pJyK3Ytqv9UjzwcUsM9nuGVnM4lbhvDoru4V5cA7afCP9v89MxDH2AUjtLw=="}],"memo":""},"blockNum":"2155841"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"110ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"Claim","args":["test11111.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"jXYSPGi8Hw7QveeLYlE8W9cXc0J3cACHG7c3gjI/ZLY/FijDW3GEkwe7nnJC7yGkdQ6svbyqbm5c9NTT9924TA=="}],"memo":""},"blockNum":"2155850"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Bio","Some gnome that codes"]}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArDpFd2owLPsaNRQ2xWL/ELLJVVwo7OoPqIi0OtZJV7/"},"signature":"Bpc2gP2TPCHTvVwZqdGAk55lCGzUN8BDeVGi5XZvjvNMR6WrWzQuq4qGBOaho+XHdQtxndmZxYCNfxKc1XvUNA=="}],"memo":""},"blockNum":"2155856"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"20000000ugnot","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","zoooooooooo",""]},{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["DisplayName","zx_xma"]},{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Bio","testing!"]}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AyDlf14q7C2aBqar/Qryh6dVR9VACxVZV6fOaM3X5YEA"},"signature":"wVYT4uT5/6N7am3X0Y8aq88G1qafswITqm25BOLcagIkdfMc5q44C4+LpLO4xRhvON0XyrkS12u+q0ihe9GzlA=="}],"memo":""},"blockNum":"2155873"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Avatar","ipfs://bafybeigdvkxl5yfg5aihjilphd27sszguy2dibht33nvy43v6lx4fqykuq"]},{"@type":"/vm.m_call","caller":"g108cszmcvs4r3k67k7h5zuhm4el3qhlrxzhshtv","send":"","pkg_path":"gno.land/r/teritori/profile","func":"SetStringField","args":["Bio","Some gnome"]}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArDpFd2owLPsaNRQ2xWL/ELLJVVwo7OoPqIi0OtZJV7/"},"signature":"Y8eOVvj6O+aWY14Lg4CUecItM+YXzfVzi64KdAOMa/wDYZqL5ydRfNz/9Cp0uGWJ8rfYcGI41wVIy0Okj/Jx4Q=="}],"memo":""},"blockNum":"2155879"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["gnotest.gno","1c9829230647c7cdd03a4d27971a1a9c2df276e5e2b207f11eb37d7d0b0bb198"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"zpRMxBjQ8Gt5TDU3FfSGRBSdZhM32aXkUPSJPfu8g0t3fjrFbrPawjyj/gf2tJAVXbs1oOqfpDsJk8gllMSanQ=="}],"memo":""},"blockNum":"2156269"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["100","test","gnotest.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"OKuzaBAK/3/Jmt8IEVKaENiJZnz1Z7txwz/y00wjl9VwEzy2wigLhn5QrUggtWC5ht4Vk/uJitHDXyH2uSx+BQ=="}],"memo":""},"blockNum":"2156294"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitHash","args":["testtest.gno","1c9829230647c7cdd03a4d27971a1a9c2df276e5e2b207f11eb37d7d0b0bb198"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"fZssAutENPUzjjy71RbYL69DK1mKQmm9lPewWR0eLsMWCPBcjGk7X8RyJwkNcajabx6cc+cLxdrCzs3u3qp/Qg=="}],"memo":""},"blockNum":"2156344"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"100ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"CommitPrice","args":["100","test","testtest.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"t2wLb3DPmqfSMU5AYMqbXSfTHRMEtrTu+oX0EwOJ0lNREGby8GFsxBz4SLm49XhPq/KyacvCw5xLO/JUu4afhQ=="}],"memo":""},"blockNum":"2156359"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1np0y3gpghzd3yavdsfefhj8agj48uk2h2qk2pp","send":"200ugnot","pkg_path":"gno.land/r/varmeta/demo/v405/domain/registrar","func":"Claim","args":["testtest.gno"]}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A24uyt5WsEoZjEU+fYdxR9gAVeaKdg10pdiwhZivhoFV"},"signature":"FUC4lO5SeAgWQk0/m4lBh7ZI9TC4qYzDfLfMnUoMVPs+8oSVzHx2hZaZ39FI8DSYEMrEJSC3EG2d3X8+hZbENw=="}],"memo":""},"blockNum":"2156371"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["86"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["86","true"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["87"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["87","true"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["90"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["90","true"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["91"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["91","true"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/onbloc/foo","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g14fclvfqynndp0l6kpyxkpgn4sljw9rr96hz46l","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/position","func":"CollectFee","args":["92"]},{"@type":"/vm.m_call","caller":"g10y2y4l4g7cx23tkl9jy5u638lw5aykvx7upqaz","send":"","pkg_path":"gno.land/r/gnoswap/v2/staker","func":"CollectReward","args":["92","true"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A1t+ghsl+0iSQZ51MozHZ1U04/dlLmgN1yDqvcynDdxF"},"signature":"FZBI9QL6THmaSbG2g3aFamLAAJxQGY//0D7YWZ5igMUg8fnbdl/j7ASD7VisoYlDb3GRzvZiOjQCeLmyCUhAWg=="}],"memo":""},"blockNum":"2161253"}
