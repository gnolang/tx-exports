{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","to_address":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","amount":"20000000000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"hjXllVnylTAOFm+86Nr4H0Y0oQjMR1H765l6VpKHS4Iz9lju+mK86KiYHOy2RqmoTycZDJ+WbMgT3XQbxij9Qg=="}],"memo":""},"blockNum":"2123139"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","send":"20000000ugnot","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","ecodevx","Ecodev DevX"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"us0hECjYK3xBCV3VNWOHlJcflQTuvi929MHIggZouFNnkvxakbgqZJhLd3L5zD0CFUjwiTFAdMeQSOHzgS06WA=="}],"memo":""},"blockNum":"2123667"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"20000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","20000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","20012642"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5AUjFIdvgvvYPCszkBSj4LyyQVI/uczvuxzbg5IRDB3"},"signature":"ctMRz8PBI0vzHC8Gh/ek1C5Z3mRFsWZ2vhqqBqrLD/dtpDfa2o7Eyf/Q9J54fOt5eiaZE02wVUw0P7ofuAYsFA=="}],"memo":""},"blockNum":"2125091"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g126swhfaq2vyvvjywevhgw7lv9hg8qan93dasu8","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/demo/wugnot","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"","pkg_path":"gno.land/r/gnoswap/v2/gns","func":"Approve","args":["g1cnz5gm2l09pm2k6rknjjar9a2w53fdhk4yjzy5","18446744073709551615"]},{"@type":"/vm.m_call","caller":"g14ks20xj4csuyn0jucwdt96rgr6cenht30avkyr","send":"20000000ugnot","pkg_path":"gno.land/r/gnoswap/v2/router","func":"SwapRoute","args":["gnot","gno.land/r/gnoswap/v2/gns","20000000","EXACT_IN","gno.land/r/demo/wugnot:gno.land/r/gnoswap/v2/gns:3000","100","20012642"]}],"fee":{"gas_wanted":"100000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5AUjFIdvgvvYPCszkBSj4LyyQVI/uczvuxzbg5IRDB3"},"signature":"RAPLzRjnLZq0tlT+p5zJLnWMSWFS6QsSL3n6NBx2cRVAp137bmotHDSr/B6x5akRSfgUEo77L74ZGwDYPoc42A=="}],"memo":""},"blockNum":"2125098"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g12jny55gjzpzdwrm93n4wj4fsgpglgc6a7at7v4","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"9B1seqfG+NWW5oMqIcojSznABy68qblwDbEw/q4armMzTiP7UElBq7iAKIkEKGHUqE0nUfSo2X9npKvYEdi72g=="}],"memo":""},"blockNum":"2125119"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g12jny55gjzpzdwrm93n4wj4fsgpglgc6a7at7v4","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","2","{\"message\":\"L=wANQgBMAQBf8RAVRQAE80FC8EAPQgUGshBK4xBMUAVAxRAR4BVUMgGDYBEM8UGaEAVBsgHCYhFE80EasAGccgUbxhFEMQBM8EGY8UBf8kHNAwEZYgHY8kGa80BIYgUB4BBOFUGBoRFOpRGc8EACYBGVZAEOlhBF0gFL4hUGQQANgBCVdwAORAGd4RHOFEGWAAEHsBASwwGa80HE8UHCgBCVRAHH8EBc8hDU80GDgBVGgBCVJQHO1wGdgAVFAAHVhhHOhgBNcgHboAFV1wHBEgUPoQHOFACF8RBEkgAVpRAOZBCAQQPOFUGc8kGeghHX8kDe8UTV5gAXQwGAoBVHMgUQgBVBoAEU80EEohBdIUEX8ECQYAVaYgGTcBVf8UFWgwBHkRBVlB=\\nHere it start\",\"files\":[],\"gifs\":[],\"hashtags\":[],\"mentions\":[],\"title\":\"\",\"location\":[48.8566,2.3522],\"createdAt\":\"2024-10-01T15:50:50.466Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6gRtl8VFTdkwPKJtbaq4fF0SPfsvc9LxCpPOH1Hhbf+"},"signature":"rTQUXMrlcNBEcGrYt5+f7wziLyBbwvpG04rYygqu8C05FACocevEX4on6y2nPhLVMfFgyg40xWLrUian5OIVug=="}],"memo":""},"blockNum":"2125238"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","to_address":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","amount":"20000000000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"q2DECOqN8/MnBWZ/MojNv3FUMSMSOMuum0i43wQxVuhyIjZHn7z/hQfs25QyKxTlrdacpdrb2NtAAGFHXy3mZw=="}],"memo":""},"blockNum":"2128150"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","to_address":"g1ym6zxff3xq7wfldcs3uyu7x7z40gstggcx8zdj","amount":"20000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"s/AhNicwDSF1W2vM0D1reAd1FvGhHXhx9NLV1tn4lrM1EkA8Fktb8Ca3TzmEVbefl7fkCOQ0alKpM1wEw0tscA=="}],"memo":""},"blockNum":"2128347"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","to_address":"g1ym6zxff3xq7wfldcs3uyu7x7z40gstggcx8zdj","amount":"1000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"w3Y9aPeZobeyUfVb62enNHq0QzSvzA89cBlck+Fy+PAT+3dd2jHTvyeL1Sk+iPISwCrkHULTY60svr2hzwUpGQ=="}],"memo":""},"blockNum":"2128403"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1ym6zxff3xq7wfldcs3uyu7x7z40gstggcx8zdj","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"20000000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A1aMNE1kph6Iz3F5TClsg/B3t455EOjTfF855cv1FWn5"},"signature":"IHN0wyprX+loZ2oh3q/52mGUjs4VIUSQZ+8nuEd23cZzoe+ijGpcOTYSFMc6DXqnWjbQ/DMMtb2iOlNKlsxuFg=="}],"memo":""},"blockNum":"2128468"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1ym6zxff3xq7wfldcs3uyu7x7z40gstggcx8zdj","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"900000ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A1aMNE1kph6Iz3F5TClsg/B3t455EOjTfF855cv1FWn5"},"signature":"e+rxj23X3hH0tSoeRZBhxUFkSmUbyiKINo77YK9LiWJsRHJs5vZNZ74Gi5ap0ROhIJEp6+X7uAvFzNSUrQRX7g=="}],"memo":""},"blockNum":"2128499"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","package":{"name":"alerts","path":"gno.land/p/ecodevx/alerts","files":[{"name":"LICENSE","body":"Copyright (c) 2024. All rights reserved.\n\nProject Owner:\nNewTendermint, LLC\n\nProject Maintainer:\nİlker Göktuğ ÖZTÜRK. \u003cilker@ilgooz.com\u003e, \u003cilkergoktugozturk@gmail.com\u003e\n\nYour access to this Project and your contributions to this Project are subject\nto the following terms:\n\n* You hereby grant to the listed Owner and Maintainer of this Project the\nworldwide, irrevocable and royalty-free right to use, publish, relicense and\nsublicense your contributions under any non-exclusive license of their\nchoosing for commercial and non-commercial purposes.\n* You shall not attempt to bring any intellectual property infringement or\nmisappropriation claims against the Owner or Maintainer of this Project\nrelating to or arising from your contributions.\n* You represent that you are the sole owner of all rights in your\ncontributions and that no third party has any rights or interests therein.\n\nFOR THE SCOPE OF THIS LICENSE, A CONTRIBUTION IS DEFINED TO INCLUDE ANY WORKS,\nIDEAS, CODE, PROCESSES, OR APIS MADE AVAILABLE TO VIEW BY THE GENERAL PUBLIC\n(INCLUDING ANY PUBLICLY ACCESSIBLE INTERNET FORUMS AND CHAT SERVERS WHERE\nACCESS IS AVAILABLE FOR FREE WITH REGISTRATION) OR PRIVATELY TO THIS PROJECT'S\nOWNER AND MAINTAINERS; INCLUDING WORKS, IDEAS, CODE, PROCESSES, AND APIS THAT\nARE ABOUT THIS PROJECT AND ITS CONTRIBUTIONS, OR MENTIONED IN REFERENCE TO\nTHIS PROJECT, WHERE SUCH WORKS, IDEAS, CODE, PROCESSES, AND APIS ARE MATERIAL\nTO THE SUCCESS, IMPROVEMENT, OR COMPLETION OF THIS PROJECT, AS DETERMINED BY\nTHE OWNER OF THIS PROJECT.\n\nContributions may come in any form, and include (but are not limited to):\n\n* pull requests\n* diff patches\n* commentary\n* example code\n\nIf you do not want your contribution to become incorporated into this Project,\ndo not make contributions to this Project. The creation of contributions that\nmay in the future become known to this Project's Owner and Maintainer\nconstitutes a willing contribution to this Project in accordance with this\nlicense.\n\nTHIS PROJECT AND THE WORKS AVAILABLE THROUGH THIS PROJECT ARE PROVIDED “AS IS”\nAND WITHOUT WARRANTY OF ANY KIND. IN NO EVENT SHALL THE OWNER OR MAINTAINER OF\nTHIS PROJECT BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THIS PROJECT OR THE WORKS AVAILABLE THROUGH\nTHIS PROJECT. YOU AGREED TO INDEMNIFY, DEFEND AND HOLD THE OWNER AND\nMAINTAINER FROM AND AGAINST ANY CLAIMS, LOSSES OR DAMAGES ARISING FROM YOUR\nUSE OF THIS PROJECT OR THE WORKS AVAILABLE THROUGH THIS PROJECT.\n\nThis license is subject to change at any time by the Project Owner or\nMaintainer.\n\nYour continued access to or use of this Project or any works\navailable through this Project shall be subject to the then-current version\nof this license.\n\nThe Project Owner and Maintainer reserve the right to change this license\nwithout needing the consent of the contributors to this Project.\n"},{"name":"alerts.gno","body":"package alerts\n\nimport (\n\t\"gno.land/p/demo/ufmt\"\n)\n\nconst (\n\tTypeError   Type = \"alerts-error\"\n\tTypeWarning Type = \"alerts-warning\"\n)\n\nconst (\n\tStyleError = `\n.alerts-error {\n\tpadding: .75rem 1.25rem;\n\tborder: 1px solid #f5c6cb;\n\tbackground-color: #f8d7da;\n\tcolor: #721c24;\n\tborder-radius: .25rem;\n}\n`\n\tStyleWarning = `\n.alerts-warning {\n\tpadding: .75rem 1.25rem;\n\tborder: 1px solid #ffeeba;\n\tbackground-color: #fff3cd;\n\tcolor: #856404;\n\tborder-radius: .25rem;\n}\n`\n)\n\n// Type defines the type of alerts.\ntype Type string\n\n// NewAlert returns HTML for an alert.\nfunc NewAlert(t Type, content string) string {\n\tvar css string\n\tswitch t {\n\tcase TypeWarning:\n\t\tcss = StyleWarning\n\tcase TypeError:\n\t\tcss = StyleError\n\tdefault:\n\t\tpanic(\"unknown alert type\")\n\t}\n\n\treturn \"\\n\\n\" + ufmt.Sprintf(`\u003cp class=\"%s\"\u003e%s\u003c/p\u003e\u003cstyle\u003e%s\u003c/style\u003e`, string(t), content, css) + \"\\n\\n\"\n}\n\n// NewWarning returns HTML for a warning alert.\nfunc NewWarning(content string) string {\n\treturn NewAlert(TypeWarning, content)\n}\n\n// NewError returns HTML for an error alert.\nfunc NewError(content string) string {\n\treturn NewAlert(TypeError, content)\n}\n\n// NewLink returns an HTML link.\nfunc NewLink(href, label string) string {\n\treturn ufmt.Sprintf(`\u003ca href=\"%s\"\u003e%s\u003c/a\u003e`, href, label)\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"2K5A+um+U7s8otIj8yL86C5sr60OxWjC48Res52q9RY8FrUB1lUjSfkieXIktHgvx2ZkYnoEAMPoMft4ggfaTg=="}],"memo":""},"blockNum":"2128548"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","package":{"name":"router","path":"gno.land/p/ecodevx/router","files":[{"name":"LICENSE","body":"Copyright (c) 2024. All rights reserved.\n\nProject Owner:\nNewTendermint, LLC\n\nProject Maintainer:\nİlker Göktuğ ÖZTÜRK. \u003cilker@ilgooz.com\u003e, \u003cilkergoktugozturk@gmail.com\u003e\n\nYour access to this Project and your contributions to this Project are subject\nto the following terms:\n\n* You hereby grant to the listed Owner and Maintainer of this Project the\nworldwide, irrevocable and royalty-free right to use, publish, relicense and\nsublicense your contributions under any non-exclusive license of their\nchoosing for commercial and non-commercial purposes.\n* You shall not attempt to bring any intellectual property infringement or\nmisappropriation claims against the Owner or Maintainer of this Project\nrelating to or arising from your contributions.\n* You represent that you are the sole owner of all rights in your\ncontributions and that no third party has any rights or interests therein.\n\nFOR THE SCOPE OF THIS LICENSE, A CONTRIBUTION IS DEFINED TO INCLUDE ANY WORKS,\nIDEAS, CODE, PROCESSES, OR APIS MADE AVAILABLE TO VIEW BY THE GENERAL PUBLIC\n(INCLUDING ANY PUBLICLY ACCESSIBLE INTERNET FORUMS AND CHAT SERVERS WHERE\nACCESS IS AVAILABLE FOR FREE WITH REGISTRATION) OR PRIVATELY TO THIS PROJECT'S\nOWNER AND MAINTAINERS; INCLUDING WORKS, IDEAS, CODE, PROCESSES, AND APIS THAT\nARE ABOUT THIS PROJECT AND ITS CONTRIBUTIONS, OR MENTIONED IN REFERENCE TO\nTHIS PROJECT, WHERE SUCH WORKS, IDEAS, CODE, PROCESSES, AND APIS ARE MATERIAL\nTO THE SUCCESS, IMPROVEMENT, OR COMPLETION OF THIS PROJECT, AS DETERMINED BY\nTHE OWNER OF THIS PROJECT.\n\nContributions may come in any form, and include (but are not limited to):\n\n* pull requests\n* diff patches\n* commentary\n* example code\n\nIf you do not want your contribution to become incorporated into this Project,\ndo not make contributions to this Project. The creation of contributions that\nmay in the future become known to this Project's Owner and Maintainer\nconstitutes a willing contribution to this Project in accordance with this\nlicense.\n\nTHIS PROJECT AND THE WORKS AVAILABLE THROUGH THIS PROJECT ARE PROVIDED “AS IS”\nAND WITHOUT WARRANTY OF ANY KIND. IN NO EVENT SHALL THE OWNER OR MAINTAINER OF\nTHIS PROJECT BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THIS PROJECT OR THE WORKS AVAILABLE THROUGH\nTHIS PROJECT. YOU AGREED TO INDEMNIFY, DEFEND AND HOLD THE OWNER AND\nMAINTAINER FROM AND AGAINST ANY CLAIMS, LOSSES OR DAMAGES ARISING FROM YOUR\nUSE OF THIS PROJECT OR THE WORKS AVAILABLE THROUGH THIS PROJECT.\n\nThis license is subject to change at any time by the Project Owner or\nMaintainer.\n\nYour continued access to or use of this Project or any works\navailable through this Project shall be subject to the then-current version\nof this license.\n\nThe Project Owner and Maintainer reserve the right to change this license\nwithout needing the consent of the contributors to this Project.\n"},{"name":"router.gno","body":"package router\n\nimport (\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype (\n\t// ResponseWriter defines the interface to write response output content.\n\tResponseWriter interface {\n\t\t// Write writes a string to the response output.\n\t\tWrite(s string)\n\n\t\t// Writef writes a formatted string to the response output.\n\t\tWritef(format string, values ...interface{})\n\t}\n\n\t// Request contains incoming request info.\n\tRequest struct {\n\t\t// Path contains the full render path.\n\t\tPath string\n\n\t\t// Prefix contains the render path prefix that handled the request.\n\t\t// For example for \"/prefix/custom/route\" the prefix path is \"/prefix\".\n\t\tPrefix string\n\n\t\t// Route contains the render path after the prefix.\n\t\t// This path doesn't include arguments.\n\t\t// For example for \"/prefix/custom/route:arg1=value1\" the route is \"/custom/route\".\n\t\tRoute string\n\n\t\t// Args contains the list of arguments found in the render path.\n\t\t// Any number of arguments can be defined as render path suffix by using\n\t\t// a colon as separator, for example:\n\t\t//\n\t\t//  /prefix/custom/route:arg1=value1:arg2=value2\n\t\t//\n\t\t// In the example the argument are \"arg1=value1\" and \"arg2=value2\".\n\t\t// The arguments can have any format as long as they are separated by a colon.\n\t\tArgs []string\n\t}\n\n\t// HandlerFunc defines the type for request handlers.\n\tHandlerFunc func(ResponseWriter, Request)\n\n\thandler struct {\n\t\tPrefix string\n\t\tFn     HandlerFunc\n\t}\n)\n\n// New creates a new prefix router.\nfunc New() Router {\n\treturn Router{}\n}\n\n// Router allows routing requests by render path prefix.\ntype Router struct {\n\thandlers []handler\n}\n\n// HandlerFunc registers a request handler for a request path prefix.\nfunc (r *Router) HandleFunc(prefix string, fn HandlerFunc) {\n\tr.handlers = append(r.handlers, handler{\n\t\tPrefix: prefix,\n\t\tFn:     fn,\n\t})\n}\n\n// Render returns the response content for a render path.\nfunc (r Router) Render(path string) string {\n\tprefix, route, args := SplitRenderPath(path)\n\n\tfor _, h := range r.handlers {\n\t\tif h.Prefix == prefix {\n\t\t\tvar (\n\t\t\t\tw   responseWriter\n\t\t\t\treq = Request{\n\t\t\t\t\tPath:   path,\n\t\t\t\t\tPrefix: prefix,\n\t\t\t\t\tRoute:  route,\n\t\t\t\t\tArgs:   args,\n\t\t\t\t}\n\t\t\t)\n\n\t\t\th.Fn(\u0026w, req)\n\n\t\t\treturn w.Output()\n\t\t}\n\t}\n\n\treturn \"Path not found\"\n}\n\ntype responseWriter struct {\n\toutput strings.Builder\n}\n\nfunc (w *responseWriter) Write(s string) {\n\tw.output.WriteString(s)\n}\n\nfunc (w *responseWriter) Writef(format string, values ...interface{}) {\n\tw.output.WriteString(ufmt.Sprintf(format, values...))\n}\n\nfunc (w responseWriter) Output() string {\n\treturn w.output.String()\n}\n\n// SplitRenderPath splits render path into a prefix, route and arguments.\nfunc SplitRenderPath(path string) (prefix, route string, args []string) {\n\tpath = strings.TrimSpace(path)\n\tpath = strings.TrimLeft(path, \"/\")\n\n\t// Handle the case where the path is the prefix with no route\n\tif !strings.ContainsAny(path, \"/\") {\n\t\t// Split prefix and arguments\n\t\tparts := strings.Split(path, \":\")\n\t\tprefix = parts[0]\n\t\tif len(parts) \u003e 1 {\n\t\t\targs = parts[1:]\n\t\t}\n\n\t\treturn prefix, route, args\n\t}\n\n\t// Split route prefix and route\n\tparts := strings.SplitN(path, \"/\", 2)\n\tprefix = parts[0]\n\n\t// Split route and arguments\n\tparts = strings.Split(parts[1], \":\")\n\troute = parts[0]\n\tif len(parts) \u003e 1 {\n\t\targs = parts[1:]\n\t}\n\n\treturn prefix, route, args\n}\n"},{"name":"router_test.gno","body":"package router\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\trouter \"gno.land/p/ecodevx/router\"\n)\n\nfunc TestSplitRenderPath(t *testing.T) {\n\tcases := []struct {\n\t\tname, renderPath, prefix, route, args string\n\t}{\n\t\t{\n\t\t\tname:       \"prefix path\",\n\t\t\trenderPath: \"/foo\",\n\t\t\tprefix:     \"foo\",\n\t\t\targs:       \"[]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"path with short route\",\n\t\t\trenderPath: \"/foo/bar\",\n\t\t\tprefix:     \"foo\",\n\t\t\troute:      \"bar\",\n\t\t\targs:       \"[]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"path with long route\",\n\t\t\trenderPath: \"/foo/bar/baz\",\n\t\t\tprefix:     \"foo\",\n\t\t\troute:      \"bar/baz\",\n\t\t\targs:       \"[]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"full path with one arg\",\n\t\t\trenderPath: \"/foo/bar/baz:arg=value\",\n\t\t\tprefix:     \"foo\",\n\t\t\troute:      \"bar/baz\",\n\t\t\targs:       \"[arg=value]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"full path with multiple args\",\n\t\t\trenderPath: \"/foo/bar/baz:arg1=value1:arg2=value2\",\n\t\t\tprefix:     \"foo\",\n\t\t\troute:      \"bar/baz\",\n\t\t\targs:       \"[arg1=value1 arg2=value2]\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty path\",\n\t\t\targs: \"[]\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tprefix, route, args := router.SplitRenderPath(tc.renderPath)\n\n\t\t\t// Assert\n\t\t\tif prefix != tc.prefix {\n\t\t\t\tt.Fatalf(\"expected prefix: '%s', got: '%s'\", tc.prefix, prefix)\n\t\t\t}\n\n\t\t\tif route != tc.route {\n\t\t\t\tt.Fatalf(\"expected route: '%s', got: '%s'\", tc.route, route)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", args); got != tc.args {\n\t\t\t\tt.Fatalf(\"expected arguments: %s, got: %s\", tc.args, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRouterRender(t *testing.T) {\n\tcases := []struct {\n\t\tname, renderPath, prefix, route, args string\n\t\tnotFound                              bool\n\t}{\n\t\t{\n\t\t\tname:       \"prefix path\",\n\t\t\trenderPath: \"/foo\",\n\t\t\tprefix:     \"foo\",\n\t\t\targs:       \"[]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"path with short route\",\n\t\t\trenderPath: \"/foo/bar\",\n\t\t\tprefix:     \"foo\",\n\t\t\troute:      \"bar\",\n\t\t\targs:       \"[]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"path with long route\",\n\t\t\trenderPath: \"/foo/bar/baz\",\n\t\t\tprefix:     \"foo\",\n\t\t\troute:      \"bar/baz\",\n\t\t\targs:       \"[]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"full path with multiple args\",\n\t\t\trenderPath: \"/foo/bar/baz:arg1=value1:arg2=value2\",\n\t\t\tprefix:     \"foo\",\n\t\t\troute:      \"bar/baz\",\n\t\t\targs:       \"[arg1=value1 arg2=value2]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"missing path\",\n\t\t\trenderPath: \"/test\",\n\t\t\tnotFound:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty path\",\n\t\t\tnotFound: true,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tvar (\n\t\t\t\trequest       router.Request\n\t\t\t\tsuccessOutput = \"OK\"\n\t\t\t\tr             = router.New()\n\t\t\t)\n\n\t\t\tr.HandleFunc(\"foo\", func(res router.ResponseWriter, req router.Request) {\n\t\t\t\trequest = req\n\t\t\t\tres.Write(successOutput)\n\t\t\t})\n\n\t\t\t// Act\n\t\t\toutput := r.Render(tc.renderPath)\n\n\t\t\t// Assert\n\t\t\tif tc.notFound {\n\t\t\t\tif output == successOutput {\n\t\t\t\t\tt.Fatal(\"expected request to fail\")\n\t\t\t\t}\n\n\t\t\t\t// Run the next test\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif output != successOutput {\n\t\t\t\tt.Fatalf(\"expected output: '%s', got: '%s'\", successOutput, output)\n\t\t\t}\n\n\t\t\tif request.Path != tc.renderPath {\n\t\t\t\tt.Fatalf(\"expected request path: '%s', got: '%s'\", tc.renderPath, request.Path)\n\t\t\t}\n\n\t\t\tif request.Prefix != tc.prefix {\n\t\t\t\tt.Fatalf(\"expected request prefix: '%s', got: '%s'\", tc.prefix, request.Prefix)\n\t\t\t}\n\n\t\t\tif request.Route != tc.route {\n\t\t\t\tt.Fatalf(\"expected request route: '%s', got: '%s'\", tc.route, request.Route)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", request.Args); got != tc.args {\n\t\t\t\tt.Fatalf(\"expected request arguments: %s, got: %s\", tc.args, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"10000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"fixrGHiiNt1sNAEepWpSaiG7SAOAL9evDpiiFHrP/OlZNnsPRfQCxyPkdEkTa+Go8szqyozqcsatcvJWeVR9/g=="}],"memo":""},"blockNum":"2128563"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","package":{"name":"blog","path":"gno.land/p/ecodevx/blog","files":[{"name":"LICENSE","body":"Copyright (c) 2024. All rights reserved.\n\nProject Owner:\nNewTendermint, LLC\n\nProject Maintainer:\nİlker Göktuğ ÖZTÜRK. \u003cilker@ilgooz.com\u003e, \u003cilkergoktugozturk@gmail.com\u003e\n\nYour access to this Project and your contributions to this Project are subject\nto the following terms:\n\n* You hereby grant to the listed Owner and Maintainer of this Project the\nworldwide, irrevocable and royalty-free right to use, publish, relicense and\nsublicense your contributions under any non-exclusive license of their\nchoosing for commercial and non-commercial purposes.\n* You shall not attempt to bring any intellectual property infringement or\nmisappropriation claims against the Owner or Maintainer of this Project\nrelating to or arising from your contributions.\n* You represent that you are the sole owner of all rights in your\ncontributions and that no third party has any rights or interests therein.\n\nFOR THE SCOPE OF THIS LICENSE, A CONTRIBUTION IS DEFINED TO INCLUDE ANY WORKS,\nIDEAS, CODE, PROCESSES, OR APIS MADE AVAILABLE TO VIEW BY THE GENERAL PUBLIC\n(INCLUDING ANY PUBLICLY ACCESSIBLE INTERNET FORUMS AND CHAT SERVERS WHERE\nACCESS IS AVAILABLE FOR FREE WITH REGISTRATION) OR PRIVATELY TO THIS PROJECT'S\nOWNER AND MAINTAINERS; INCLUDING WORKS, IDEAS, CODE, PROCESSES, AND APIS THAT\nARE ABOUT THIS PROJECT AND ITS CONTRIBUTIONS, OR MENTIONED IN REFERENCE TO\nTHIS PROJECT, WHERE SUCH WORKS, IDEAS, CODE, PROCESSES, AND APIS ARE MATERIAL\nTO THE SUCCESS, IMPROVEMENT, OR COMPLETION OF THIS PROJECT, AS DETERMINED BY\nTHE OWNER OF THIS PROJECT.\n\nContributions may come in any form, and include (but are not limited to):\n\n* pull requests\n* diff patches\n* commentary\n* example code\n\nIf you do not want your contribution to become incorporated into this Project,\ndo not make contributions to this Project. The creation of contributions that\nmay in the future become known to this Project's Owner and Maintainer\nconstitutes a willing contribution to this Project in accordance with this\nlicense.\n\nTHIS PROJECT AND THE WORKS AVAILABLE THROUGH THIS PROJECT ARE PROVIDED “AS IS”\nAND WITHOUT WARRANTY OF ANY KIND. IN NO EVENT SHALL THE OWNER OR MAINTAINER OF\nTHIS PROJECT BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THIS PROJECT OR THE WORKS AVAILABLE THROUGH\nTHIS PROJECT. YOU AGREED TO INDEMNIFY, DEFEND AND HOLD THE OWNER AND\nMAINTAINER FROM AND AGAINST ANY CLAIMS, LOSSES OR DAMAGES ARISING FROM YOUR\nUSE OF THIS PROJECT OR THE WORKS AVAILABLE THROUGH THIS PROJECT.\n\nThis license is subject to change at any time by the Project Owner or\nMaintainer.\n\nYour continued access to or use of this Project or any works\navailable through this Project shall be subject to the then-current version\nof this license.\n\nThe Project Owner and Maintainer reserve the right to change this license\nwithout needing the consent of the contributors to this Project.\n"},{"name":"asserts.gno","body":"package blog\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\thostnameRe = regexp.MustCompile(`^(?i)[a-z0-9-]+(\\.[a-z0-9-]+)+\\.?$`)\n\tsha256Re   = regexp.MustCompile(`^[a-f0-9]{64}$`)\n\tslugRe     = regexp.MustCompile(`^[a-z0-9\\p{L}]+(?:-[a-z0-9\\p{L}]+)*$`)\n)\n\n// AssertIsSlug asserts that a URL slug is valid.\nfunc AssertIsSlug(slug string) {\n\tif !IsSlug(slug) {\n\t\tpanic(\"URL slug is not valid\")\n\t}\n}\n\n// AssertContentSha256Hash asserts that a hex hash is a valid SHA256 hash.\nfunc AssertIsSha256Hash(hexHash string) {\n\tif !IsSha256Hash(hexHash) {\n\t\tpanic(\"invalid sha256 hash\")\n\t}\n}\n\n// AssertIsContentURL asserts that a URL is a valid link to a content.\n// URL must have a path to ve valid. Website URLs will fail.\nfunc AssertIsContentURL(url string) {\n\tif !IsURL(url, true) {\n\t\tpanic(\"content URL is not valid, make sure path to content is specified\")\n\t}\n}\n\n// AssertTitleIsNotEmpty asserts that a title is not an empty string.\nfunc AssertTitleIsNotEmpty(title string) {\n\tif strings.TrimSpace(title) == \"\" {\n\t\tpanic(\"title is empty\")\n\t}\n}\n\n// AssertContentSha256Hash asserts that the SHA256 hash of a content matches a hash.\nfunc AssertContentSha256Hash(content, hash string) {\n\tif hash != GetHexSha256Hash(content) {\n\t\tpanic(\"content sha256 checksum is not valid\")\n\t}\n}\n\n// IsSlug checks if a string is a valid URL slug.\nfunc IsSlug(slug string) bool {\n\treturn slugRe.MatchString(slug)\n}\n\n// IsSha256Hash checks is a hex hash is a valid SHA256 hash.\nfunc IsSha256Hash(hexHash string) bool {\n\treturn sha256Re.MatchString(strings.ToLower(hexHash))\n}\n\n// IsURL checks if a URL is valid.\n// URL path availability can optionally be enforced.\nfunc IsURL(rawURL string, requirePath bool) bool {\n\tu, err := url.ParseRequestURI(rawURL)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif requirePath \u0026\u0026 u.Path == \"\" || u.Path == \"/\" {\n\t\treturn false\n\t}\n\n\tif u.Scheme != \"https\" \u0026\u0026 u.Scheme != \"http\" {\n\t\treturn false\n\t}\n\n\thostname := u.Hostname()\n\treturn hostname != \"\" \u0026\u0026 hostnameRe.MatchString(hostname)\n}\n\n// GetHexSha256Hash returns the hexadecimal encoding of the string's SHA256 hash.\n// An empty string is returned when the argument is an empty string.\nfunc GetHexSha256Hash(s string) string {\n\tsum := sha256.Sum256([]byte(s))\n\treturn hex.EncodeToString(sum[:])\n}\n"},{"name":"asserts_test.gno","body":"package blog\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/ecodevx/blog\"\n)\n\nfunc TestIsSlug(t *testing.T) {\n\tcases := []struct {\n\t\tname, slug string\n\t\twant       bool\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"one letter\",\n\t\t\tslug: \"a\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one unicode letter\",\n\t\t\tslug: \"á\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one word\",\n\t\t\tslug: \"foo\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one unicode word\",\n\t\t\tslug: \"fóo\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"many words\",\n\t\t\tslug: \"foo-bar-baz\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"many unicode words\",\n\t\t\tslug: \"fóo-bár-báz\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"with spaces\",\n\t\t\tslug: \"foo bar\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"with invalid chars\",\n\t\t\tslug: \"foo/bar\",\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tgot := blog.IsSlug(tc.slug)\n\n\t\t\t// Assert\n\t\t\tif got != tc.want {\n\t\t\t\tt.Fatalf(\"expected slug check to return: %v\", tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIsSha256Hash(t *testing.T) {\n\tcases := []struct {\n\t\tname, hash string\n\t\twant       bool\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\thash: \"1a66cf828aea323fc58c653b0bc0d64061bb5c198e500a541a2c97f4f45b668d\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid size\",\n\t\t\thash: \"1a66cf828aea323\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid characters\",\n\t\t\thash: \"1a66#?\",\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tgot := blog.IsSha256Hash(tc.hash)\n\n\t\t\t// Assert\n\t\t\tif got != tc.want {\n\t\t\t\tt.Fatalf(\"expected sha256 check check to return: %v\", tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIsURL(t *testing.T) {\n\tcases := []struct {\n\t\turl  string\n\t\twant bool\n\t}{\n\t\t{url: \"https\", want: false},\n\t\t{url: \"https/a\", want: false},\n\t\t{url: \"https/a/b\", want: false},\n\t\t{url: \"https/a/b/\", want: false},\n\t\t{url: \"https:\", want: false},\n\t\t{url: \"https:www.test.com\", want: false},\n\t\t{url: \"https:www.test.com/\", want: false},\n\t\t{url: \"https:www.test.com/a\", want: false},\n\t\t{url: \"https:www.test.com/a/b\", want: false},\n\t\t{url: \"https:www.test.com/a/b/\", want: false},\n\t\t{url: \"https:www.test.com:42/a/b/\", want: false},\n\t\t{url: \"https:/\", want: false},\n\t\t{url: \"https:/a\", want: false},\n\t\t{url: \"https:/a/b\", want: false},\n\t\t{url: \"https:/a/b/\", want: false},\n\t\t{url: \"https:/www.test.com/a/b\", want: false},\n\t\t{url: \"https://\", want: false},\n\t\t{url: \"https://a\", want: false},\n\t\t{url: \"https://a/b\", want: false},\n\t\t{url: \"https://a/b/\", want: false},\n\t\t{url: \"https://www.test.com\", want: false},\n\t\t{url: \"https://www.test.com/\", want: false},\n\t\t{url: \"https://www.test.com/a\", want: true},\n\t\t{url: \"https://www.test.com/a/b\", want: true},\n\t\t{url: \"https://www.test.com/a/b/\", want: true},\n\t\t{url: \"https://www.test.com:42/a/b/\", want: true},\n\t\t{url: \"https://foo.bar.test.com\", want: false},\n\t\t{url: \"https://foo.bar.test.com/\", want: false},\n\t\t{url: \"https://foo.bar.test.com/a\", want: true},\n\t\t{url: \"https://foo.bar.test.com/a/b\", want: true},\n\t\t{url: \"https://foo.bar.test.com/a/b/\", want: true},\n\t\t{url: \"https://foo.bar.test.com/a/b\", want: true},\n\t\t{url: \"https://foo.bar.test.com:42/a/b\", want: true},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.url, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tgot := blog.IsURL(tc.url, true)\n\n\t\t\t// Assert\n\t\t\tif got != tc.want {\n\t\t\t\tt.Fatalf(\"expected URL check to return: %v\", tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetHexSha256Hash(t *testing.T) {\n\tcases := []struct {\n\t\tname, content, want string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\twant: \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n\t\t},\n\t\t{\n\t\t\tname:    \"ok\",\n\t\t\tcontent: \"foo\",\n\t\t\twant:    \"2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tgot := blog.GetHexSha256Hash(tc.content)\n\n\t\t\t// Assert\n\t\t\tif got != tc.want {\n\t\t\t\tt.Fatalf(\"expected hash: '%s', got: '%s'\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"blog.gno","body":"package blog\n\nimport (\n\t\"strings\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype (\n\t// Blog defines a blog.\n\tBlog struct {\n\t\tposts avl.Tree // string(slug) -\u003e *Post\n\n\t\t// Title is blog's title.\n\t\tTitle string\n\n\t\t// Description is the blog's description.\n\t\tDescription string\n\t}\n\n\t// PostIterFn defines the a callback to iterate blog posts.\n\tPostIterFn func(*Post) bool\n)\n\n// HasPost checks if a post with a URL slug exists.\nfunc (b Blog) HasPost(slug string) bool {\n\treturn b.posts.Has(slug)\n}\n\n// GetPost returns a blog's post.\nfunc (b Blog) GetPost(slug string) (_ *Post, found bool) {\n\tif v, found := b.posts.Get(slug); found {\n\t\treturn v.(*Post), true\n\t}\n\treturn nil, false\n}\n\n// AddPost adds a new post to the blog.\nfunc (b *Blog) AddPost(p *Post) bool {\n\tslug := strings.TrimSpace(p.Slug)\n\tif slug == \"\" {\n\t\tpanic(\"post has an empty slug\")\n\t}\n\n\treturn b.posts.Set(slug, p)\n}\n\n// RemovePost removes a post from the blog.\n// The removed post is returned after being removed if it exists.\nfunc (b *Blog) RemovePost(slug string) (_ *Post, removed bool) {\n\tif v, removed := b.posts.Remove(slug); removed {\n\t\treturn v.(*Post), true\n\t}\n\treturn nil, false\n}\n\n// IteratePosts iterates all posts by slug.\nfunc (b Blog) IteratePosts(fn PostIterFn) bool {\n\t// TODO: Improve blog post iteration\n\treturn b.posts.Iterate(\"\", \"\", func(_ string, value interface{}) bool {\n\t\treturn fn(value.(*Post))\n\t})\n}\n"},{"name":"invar.gno","body":"package blog\n\n// TODO: Remove this file if Gno implements invar (inmutable) references\n\nimport \"time\"\n\nfunc NewInvarBlog(b *Blog) InvarBlog {\n\treturn InvarBlog{b}\n}\n\ntype InvarBlog struct {\n\tref *Blog\n}\n\nfunc (b InvarBlog) Title() string {\n\treturn b.ref.Title\n}\n\nfunc (b InvarBlog) Description() string {\n\treturn b.ref.Description\n}\n\nfunc (b InvarBlog) IteratePosts(fn func(InvarPost) bool) bool {\n\treturn b.ref.IteratePosts(func(p *Post) bool {\n\t\treturn fn(NewInvarPost(p))\n\t})\n}\n\nfunc NewInvarPost(p *Post) InvarPost {\n\treturn InvarPost{p}\n}\n\ntype InvarPost struct {\n\tref *Post\n}\n\nfunc (p InvarPost) Slug() string {\n\treturn p.ref.Slug\n}\n\nfunc (p InvarPost) Title() string {\n\treturn p.ref.Title\n}\n\nfunc (p InvarPost) Summary() string {\n\treturn p.ref.Summary\n}\n\nfunc (p InvarPost) Status() PostStatus {\n\treturn p.ref.Status\n}\n\nfunc (p InvarPost) Content() string {\n\treturn p.ref.Content\n}\n\nfunc (p InvarPost) ContentHash() string {\n\treturn p.ref.ContentHash\n}\n\nfunc (p InvarPost) Authors() AddressList {\n\treturn p.ref.Authors\n}\n\nfunc (p InvarPost) Editors() AddressList {\n\treturn p.ref.Editors\n}\n\nfunc (p InvarPost) Contributors() AddressList {\n\treturn p.ref.Contributors\n}\n\nfunc (p InvarPost) Publishers() AddressList {\n\treturn p.ref.Publishers\n}\n\nfunc (p InvarPost) Tags() []string {\n\treturn p.ref.Tags\n}\n\nfunc (p InvarPost) CreatedAt() time.Time {\n\treturn p.ref.CreatedAt\n}\n\nfunc (p InvarPost) UpdatedAt() time.Time {\n\treturn p.ref.UpdatedAt\n}\n\nfunc (p InvarPost) PublishAt() time.Time {\n\treturn p.ref.PublishAt\n}\n\nfunc (p InvarPost) ExpireAt() time.Time {\n\treturn p.ref.ExpireAt\n}\n"},{"name":"post.gno","body":"package blog\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\tStatusDraft PostStatus = iota\n\tStatusApproved\n\tStatusPublished\n\tStatusRevised\n\tStatusArchived\n)\n\ntype (\n\t// AddressList defines a list of addresses.\n\tAddressList []std.Address\n\n\t// PostStatus defines a type for blog post states.\n\tPostStatus uint8\n\n\t// Post defines a blog post.\n\tPost struct {\n\t\t// Slug contains the URL path slug for the post.\n\t\tSlug string\n\n\t\t// Title is the post's title.\n\t\tTitle string\n\n\t\t// Summary is the post's summary.\n\t\tSummary string\n\n\t\t// Status is the current post's state.\n\t\tStatus PostStatus\n\n\t\t// Content contains the post's content.\n\t\tContent string\n\n\t\t// ContentHash contains the hash of the post's content.\n\t\tContentHash string\n\n\t\t// Authors contains the list of post authors.\n\t\tAuthors AddressList\n\n\t\t// Editors contains the list of post editors.\n\t\t// Each account belongs to an editor that significantly improved the content.\n\t\tEditors AddressList\n\n\t\t// Contributors contains the list of post contributors.\n\t\t// Each account belongs to a contributor that submitted small content changes.\n\t\tContributors AddressList\n\n\t\t// Publishers contains the accounts that published the content.\n\t\tPublishers AddressList\n\n\t\t// Tags contains a list of tags for the post.\n\t\t// These tags can be used to build the blog content taxonomy.\n\t\tTags []string\n\n\t\t// CreatedAt is the block time when the post has been created.\n\t\tCreatedAt time.Time\n\n\t\t// UpdatedAt is the block time when the post has been updated for the last time.\n\t\tUpdatedAt time.Time\n\n\t\t// PublishAt is the block time when the post should be published.\n\t\tPublishAt time.Time\n\n\t\t// ExpireAt is the block time when the post should be archived.\n\t\tExpireAt time.Time\n\t}\n)\n\n// String returns a comma separated string with the list of addresses.\nfunc (x AddressList) String() string {\n\tvar s []string\n\tfor _, item := range x {\n\t\ts = append(s, item.String())\n\t}\n\treturn strings.Join(s, \", \")\n}\n\n// HasAddress checks if an address is part of the address list.\nfunc (x AddressList) HasAddress(addr std.Address) bool {\n\tfor _, item := range x {\n\t\tif item == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// String returns the post status name.\nfunc (s PostStatus) String() string {\n\tswitch s {\n\tcase StatusDraft:\n\t\treturn \"draft\"\n\tcase StatusApproved:\n\t\treturn \"approved\"\n\tcase StatusPublished:\n\t\treturn \"published\"\n\tcase StatusRevised:\n\t\treturn \"revised\"\n\tcase StatusArchived:\n\t\treturn \"archived\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\n// IsExpired checks if the expiration date was reached.\nfunc (p Post) IsExpired() bool {\n\treturn !p.ExpireAt.IsZero() \u0026\u0026 p.ExpireAt.Before(time.Now())\n}\n\n// ParseStringToAddresses parses a string addresses.\n// String should have one or more lines where each line should contain an address.\n// Addresses are validated after being parsed.\nfunc ParseStringToAddresses(s string) (AddressList, error) {\n\tvar addresses AddressList\n\tfor _, line := range strings.Split(s, \"\\n\") {\n\t\tline = strings.TrimSpace(line)\n\t\tif line == \"\" {\n\t\t\t// Skip empty lines\n\t\t\tcontinue\n\t\t}\n\n\t\taddr := std.Address(strings.TrimSpace(line))\n\t\tif !addr.IsValid() {\n\t\t\treturn nil, errors.New(\"invalid address: \" + EscapeHTML(addr.String()))\n\t\t}\n\n\t\taddresses = append(addresses, addr)\n\t}\n\treturn addresses, nil\n}\n\n// MustParseStringToAddresses parses a string addresses.\n// String should have one or more lines where each line should contain an address.\n// Addresses are validated after being parsed.\nfunc MustParseStringToAddresses(s string) AddressList {\n\taddresses, err := ParseStringToAddresses(s)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn addresses\n}\n\n// EscapeHTML escapes special characters like \"\u003c\" to become \"\u0026lt;\".\n// It escapes only five such characters: \u003c, \u003e, \u0026, ' and \".\nfunc EscapeHTML(s string) string {\n\ts = strings.ReplaceAll(s, `\u0026`, \"\u0026amp;\")\n\ts = strings.ReplaceAll(s, `\"`, \"\u0026#34;\")\n\ts = strings.ReplaceAll(s, `'`, \"\u0026#39;\")\n\ts = strings.ReplaceAll(s, `\u003c`, \"\u0026lt;\")\n\treturn strings.ReplaceAll(s, `\u003e`, \"\u0026gt;\")\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"40000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"wHoaU3mh8fMI5iSloZ79vYGpkbgxO9qLdOOhpOrHFu0peF1zoS+CyZOvEsPskPLgqBFoMwoWQcXleidlffm8Pg=="}],"memo":""},"blockNum":"2128791"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g147ah9520z0r6jh9mjr6c75rv6l8aypzvcd3f7d","package":{"name":"dao","path":"gno.land/p/ecodevx/dao","files":[{"name":"LICENSE","body":"Copyright (c) 2024. All rights reserved.\n\nProject Owner:\nNewTendermint, LLC\n\nProject Maintainer:\nİlker Göktuğ ÖZTÜRK. \u003cilker@ilgooz.com\u003e, \u003cilkergoktugozturk@gmail.com\u003e\n\nYour access to this Project and your contributions to this Project are subject\nto the following terms:\n\n* You hereby grant to the listed Owner and Maintainer of this Project the\nworldwide, irrevocable and royalty-free right to use, publish, relicense and\nsublicense your contributions under any non-exclusive license of their\nchoosing for commercial and non-commercial purposes.\n* You shall not attempt to bring any intellectual property infringement or\nmisappropriation claims against the Owner or Maintainer of this Project\nrelating to or arising from your contributions.\n* You represent that you are the sole owner of all rights in your\ncontributions and that no third party has any rights or interests therein.\n\nFOR THE SCOPE OF THIS LICENSE, A CONTRIBUTION IS DEFINED TO INCLUDE ANY WORKS,\nIDEAS, CODE, PROCESSES, OR APIS MADE AVAILABLE TO VIEW BY THE GENERAL PUBLIC\n(INCLUDING ANY PUBLICLY ACCESSIBLE INTERNET FORUMS AND CHAT SERVERS WHERE\nACCESS IS AVAILABLE FOR FREE WITH REGISTRATION) OR PRIVATELY TO THIS PROJECT'S\nOWNER AND MAINTAINERS; INCLUDING WORKS, IDEAS, CODE, PROCESSES, AND APIS THAT\nARE ABOUT THIS PROJECT AND ITS CONTRIBUTIONS, OR MENTIONED IN REFERENCE TO\nTHIS PROJECT, WHERE SUCH WORKS, IDEAS, CODE, PROCESSES, AND APIS ARE MATERIAL\nTO THE SUCCESS, IMPROVEMENT, OR COMPLETION OF THIS PROJECT, AS DETERMINED BY\nTHE OWNER OF THIS PROJECT.\n\nContributions may come in any form, and include (but are not limited to):\n\n* pull requests\n* diff patches\n* commentary\n* example code\n\nIf you do not want your contribution to become incorporated into this Project,\ndo not make contributions to this Project. The creation of contributions that\nmay in the future become known to this Project's Owner and Maintainer\nconstitutes a willing contribution to this Project in accordance with this\nlicense.\n\nTHIS PROJECT AND THE WORKS AVAILABLE THROUGH THIS PROJECT ARE PROVIDED “AS IS”\nAND WITHOUT WARRANTY OF ANY KIND. IN NO EVENT SHALL THE OWNER OR MAINTAINER OF\nTHIS PROJECT BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THIS PROJECT OR THE WORKS AVAILABLE THROUGH\nTHIS PROJECT. YOU AGREED TO INDEMNIFY, DEFEND AND HOLD THE OWNER AND\nMAINTAINER FROM AND AGAINST ANY CLAIMS, LOSSES OR DAMAGES ARISING FROM YOUR\nUSE OF THIS PROJECT OR THE WORKS AVAILABLE THROUGH THIS PROJECT.\n\nThis license is subject to change at any time by the Project Owner or\nMaintainer.\n\nYour continued access to or use of this Project or any works\navailable through this Project shall be subject to the then-current version\nof this license.\n\nThe Project Owner and Maintainer reserve the right to change this license\nwithout needing the consent of the contributors to this Project.\n"},{"name":"dao.gno","body":"package dao\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n)\n\n// PathSeparator defines the DAO path separator.\nconst PathSeparator = \"/\"\n\ntype (\n\t// Role defines the type for DAO roles.\n\tRole string\n\n\t// Roles defines the type for a list of DAO roles.\n\tRoles []Role\n)\n\n// String returns the role as a string.\nfunc (r Role) String() string {\n\treturn string(r)\n}\n\n// NewMember creates a new DAO member.\nfunc NewMember(addr std.Address, roles ...Role) Member {\n\treturn Member{\n\t\tAddress: addr,\n\t\tRoles:   roles,\n\t}\n}\n\n// Member defines a DAO member.\ntype Member struct {\n\t// Address is the member account address.\n\tAddress std.Address\n\n\t// Roles contains the optional list of roles that the member belongs to.\n\tRoles Roles\n}\n\n// String returns a string representation of the member.\nfunc (m Member) String() string {\n\tif len(m.Roles) == 0 {\n\t\treturn m.Address.String()\n\t}\n\n\tvar roles []string\n\tfor _, r := range m.Roles {\n\t\troles = append(roles, string(r))\n\t}\n\treturn m.Address.String() + \" \" + strings.Join(roles, \", \")\n}\n\n// HasRole checks if the member belongs to a specific role.\nfunc (m Member) HasRole(r Role) bool {\n\tfor _, role := range m.Roles {\n\t\tif role == r {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Option configures DAO.\ntype Option func(*DAO)\n\n// AssignAsSuperCouncil makes the DAO a super council.\nfunc AssignAsSuperCouncil() Option {\n\treturn func(dao *DAO) {\n\t\tdao.isSuperCouncil = true\n\t}\n}\n\n// WithSubDAO assigns sub DAO to a DAO.\nfunc WithSubDAO(sub *DAO) Option {\n\treturn func(dao *DAO) {\n\t\tsub.parent = dao\n\t\tdao.children = append(dao.children, sub)\n\t}\n}\n\n// WithMembers assigns members to a DAO.\nfunc WithMembers(members ...Member) Option {\n\treturn func(dao *DAO) {\n\t\tdao.members = members\n\t}\n}\n\n// WithManifest assigns a manifest to a DAO.\n// Manifest should describe the purpose of the DAO.\nfunc WithManifest(manifest string) Option {\n\treturn func(dao *DAO) {\n\t\tdao.manifest = manifest\n\t}\n}\n\n// New creates a new DAO.\nfunc New(name, title string, options ...Option) (*DAO, error) {\n\tname = strings.TrimSpace(name)\n\tif name == \"\" {\n\t\treturn nil, errors.New(\"DAO name is required\")\n\t}\n\n\tif !IsSlug(name) {\n\t\treturn nil, errors.New(`DAO name is not valid, only letters from \"a\" to \"z\", numbers, \"-\" and \"_\" are allowed`)\n\t}\n\n\ttitle = strings.TrimSpace(title)\n\tif title == \"\" {\n\t\treturn nil, errors.New(\"DAO title is required\")\n\t}\n\n\tdao := \u0026DAO{\n\t\tname:      name,\n\t\ttitle:     title,\n\t\tcreatedAt: time.Now(),\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(dao)\n\t}\n\n\treturn dao, nil\n}\n\n// MustNew creates a new DAO.\n// The function panics if any of the arguments is not valid.\nfunc MustNew(name, title string, options ...Option) *DAO {\n\tdao, err := New(name, title, options...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn dao\n}\n\n// DAO is a decentralized autonomous organization.\ntype DAO struct {\n\tname           string\n\ttitle          string\n\tmanifest       string\n\tisSuperCouncil bool\n\tisLocked       bool\n\tlockReason     string\n\tparent         *DAO\n\tchildren       []*DAO\n\tmembers        []Member\n\tcreatedAt      time.Time\n}\n\n// Name returns the name of the DAO.\nfunc (dao DAO) Name() string {\n\treturn dao.name\n}\n\n// Title returns the title of the DAO.\nfunc (dao DAO) Title() string {\n\treturn dao.title\n}\n\n// Manifest returns the manifest of the DAO.\nfunc (dao DAO) Manifest() string {\n\treturn dao.manifest\n}\n\n// SetManifest sets the manifest of the DAO.\nfunc (dao *DAO) SetManifest(s string) {\n\tdao.manifest = s\n}\n\n// CreatedAt returns the creation time of the DAO.\nfunc (dao DAO) CreatedAt() time.Time {\n\treturn dao.createdAt\n}\n\n// Parent returns the parent DAO of the sub DAO.\n// The result is nil for the DAO at the root of the DAO tree.\nfunc (dao DAO) Parent() *DAO {\n\treturn dao.parent\n}\n\n// Path returns the path of the DAO.\nfunc (dao DAO) Path() string {\n\tif dao.parent == nil {\n\t\treturn dao.name\n\t}\n\treturn dao.parent.Path() + PathSeparator + dao.name\n}\n\n// SubDAOs returns the first level sub DAOs.\nfunc (dao DAO) SubDAOs() []*DAO {\n\treturn dao.children\n}\n\n// Members returns the members of the DAOs.\nfunc (dao DAO) Members() []Member {\n\treturn dao.members\n}\n\n// LockReason returns a string with the reason the DAO is locked.\nfunc (dao DAO) LockReason() string {\n\treturn dao.lockReason\n}\n\n// IsSuperCouncil checks if the DAO is a super council.\nfunc (dao DAO) IsSuperCouncil() bool {\n\treturn dao.isSuperCouncil\n}\n\n// IsLocked checks if the DAO is locked.\nfunc (dao DAO) IsLocked() bool {\n\treturn dao.isLocked\n}\n\n// Lock locks the DAO.\nfunc (dao *DAO) Lock(reason string) {\n\tdao.lockReason = reason\n\tdao.isLocked = true\n}\n\n// HasParent checks if a DAO is a parent of this DAO.\nfunc (dao DAO) HasParent(parent *DAO) bool {\n\tif parent == nil {\n\t\treturn false\n\t}\n\treturn strings.HasPrefix(dao.Path(), parent.Path())\n}\n\n// HasMember checks if a member is part of the DAO.\nfunc (dao DAO) HasMember(addr std.Address) bool {\n\tfor _, m := range dao.members {\n\t\tif m.Address == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AddMember adds a member to the DAO.\n// Caller must check the member before adding to avoid duplications.\nfunc (dao *DAO) AddMember(m Member) {\n\tdao.members = append(dao.members, m)\n}\n\n// GetMember gets a member of the DAO.\nfunc (dao DAO) GetMember(addr std.Address) (Member, bool) {\n\tfor _, m := range dao.members {\n\t\tif m.Address == addr {\n\t\t\treturn m, true\n\t\t}\n\t}\n\treturn Member{}, false\n}\n\n// RemoveMember removes a member of the DAO.\nfunc (dao *DAO) RemoveMember(addr std.Address) bool {\n\tfor i, m := range dao.members {\n\t\tif m.Address == addr {\n\t\t\tdao.members = append(dao.members[:i], dao.members[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AddSubDAO adds a sub DAO to the DAO.\nfunc (dao *DAO) AddSubDAO(sub *DAO) bool {\n\tif sub == nil {\n\t\treturn false\n\t}\n\n\tfor _, n := range dao.children {\n\t\tif n.name == sub.name {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tsub.parent = dao\n\tdao.children = append(dao.children, sub)\n\treturn true\n}\n\n// GetDAO get a DAO by path.\nfunc (dao *DAO) GetDAO(path string) (_ *DAO, found bool) {\n\tif path == \"\" {\n\t\treturn nil, false\n\t}\n\n\tif path == dao.name {\n\t\treturn dao, true\n\t}\n\n\t// Make sure that current node is not present at the beginning of the path\n\tpath = strings.TrimPrefix(path, dao.name+PathSeparator)\n\n\t// Split DAO path in child name and relative sub path\n\tparts := strings.SplitN(path, PathSeparator, 2)\n\tchildName := parts[0]\n\n\tfor _, sub := range dao.children {\n\t\tif sub.name != childName {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(parts) \u003e 1 {\n\t\t\t// Traverse node children when a sub node path is available\n\t\t\treturn sub.GetDAO(parts[1])\n\t\t}\n\t\treturn sub, true\n\t}\n\n\treturn nil, false\n}\n\n// RemoveSubDAO removes a sub DAO.\n// The sub DAO must be a first level children of the DAO.\nfunc (dao *DAO) RemoveSubDAO(name string) bool {\n\tfor i, sub := range dao.children {\n\t\tif sub.name == name {\n\t\t\tdao.children = append(dao.children[:i], dao.children[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsRoot checks if the DAO is the main DAO.\n// The main DAO is the root of the DAO tree.\nfunc (dao DAO) IsRoot() bool {\n\treturn dao.parent == nil\n}\n\n// ParseStringToMembers parses a string of member addresses and roles.\n// String should have one or more lines where each line should contain an\n// address optionally followed by one or more roles.\n// Example multi line string:\n//\n//\tg1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun roleA\n//\tg1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl\n//\tg1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5 roleB roleA\n//\n// Addresses are validated after being parsed.\n// Roles must be validated by the caller to make sure the names are valid.\nfunc ParseStringToMembers(s string) ([]Member, error) {\n\tvar members []Member\n\tfor _, line := range strings.Split(s, \"\\n\") {\n\t\tline = strings.TrimSpace(line)\n\t\tif line == \"\" {\n\t\t\t// Skip empty lines\n\t\t\tcontinue\n\t\t}\n\n\t\tvar (\n\t\t\troles  []Role\n\t\t\tfields = strings.Fields(line)\n\t\t\taddr   = std.Address(strings.TrimSpace(fields[0]))\n\t\t)\n\n\t\tif !addr.IsValid() {\n\t\t\treturn nil, errors.New(\"invalid member address: \" + EscapeHTML(addr.String()))\n\t\t}\n\n\t\tfor _, v := range fields[1:] {\n\t\t\troles = appendRole(roles, strings.TrimSpace(v))\n\t\t}\n\n\t\tmembers = append(members, NewMember(addr, roles...))\n\t}\n\treturn members, nil\n}\n\n// MustParseStringToMembers parses a string of member addresses and roles.\n// String should have one or more lines where each line should contain an\n// address optionally followed by one or more roles.\n// Example multi line string:\n//\n//\tg1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun roleA\n//\tg1e5hud66rs7ye4zgeqmqvwfhurs2mnf408hdqcl\n//\tg1vh7krmmzfua5xjmkatvmx09z37w34lsvd2mxa5 roleB roleA\n//\n// Addresses are validated after being parsed.\n// Roles must be validated by the caller to make sure the names are valid.\nfunc MustParseStringToMembers(s string) []Member {\n\tmembers, err := ParseStringToMembers(s)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn members\n}\n\n// appendRole append a role if it doesn't exists within the list of roles.\nfunc appendRole(roles []Role, name string) []Role {\n\tfor _, r := range roles {\n\t\tif string(r) == name {\n\t\t\treturn roles\n\t\t}\n\t}\n\treturn append(roles, Role(name))\n}\n"},{"name":"dao_test.gno","body":"package dao\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc TestMember(t *testing.T) {\n\tcases := []struct {\n\t\tname    string\n\t\taddress std.Address\n\t\troles   []gnome.Role\n\t\toutput  string\n\t}{\n\t\t{\n\t\t\tname:    \"without roles\",\n\t\t\taddress: std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"),\n\t\t\toutput:  \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\",\n\t\t},\n\t\t{\n\t\t\tname:    \"with one role\",\n\t\t\taddress: std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"),\n\t\t\troles:   []gnome.Role{\"foo\"},\n\t\t\toutput:  \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5 foo\",\n\t\t},\n\t\t{\n\t\t\tname:    \"with two roles\",\n\t\t\taddress: std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"),\n\t\t\troles:   []gnome.Role{\"foo\", \"bar\"},\n\t\t\toutput:  \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5 foo, bar\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tm := gnome.NewMember(tc.address, tc.roles...)\n\n\t\t\t// Assert\n\t\t\tif got := m.Address; got != tc.address {\n\t\t\t\tt.Fatalf(\"expected address %s, got: %s\", tc.address, got)\n\t\t\t}\n\n\t\t\tfor i, r := range m.Roles {\n\t\t\t\tif r != tc.roles[i] {\n\t\t\t\t\tt.Fatalf(\"expected role %s, got: %s\", tc.roles[i], r)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif got := m.String(); got != tc.output {\n\t\t\t\tt.Fatalf(\"expected member string output '%s', got: '%s'\", tc.output, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TODO: Add test cases to check different DAO options\nfunc TestDAO(t *testing.T) {\n\t// Arrange\n\tname := \"test\"\n\ttitle := \"Test DAO\"\n\tmanifest := \"This is a test\"\n\taddresses := []std.Address{\n\t\ttestutils.TestAddress(\"member1\"),\n\t\ttestutils.TestAddress(\"member2\"),\n\t}\n\n\t// Act\n\tdao := gnome.MustNew(name, title, gnome.WithManifest(manifest), gnome.WithMembers(\n\t\tgnome.NewMember(addresses[0]),\n\t\tgnome.NewMember(addresses[1]),\n\t))\n\n\t// Assert\n\tif got := dao.Name(); got != name {\n\t\tt.Fatalf(\"expected name: %d, got: %d\", name, got)\n\t}\n\n\tif got := dao.CreatedAt(); got.IsZero() {\n\t\tt.Fatalf(\"expected a valid creation time, got: '%s'\", got.String())\n\t}\n\n\tif got := dao.Title(); got != title {\n\t\tt.Fatalf(\"expected title: '%s', got: '%s'\", title, got)\n\t}\n\n\tif got := dao.Manifest(); got != manifest {\n\t\tt.Fatalf(\"expected manifest: '%s', got: '%s'\", manifest, got)\n\t}\n\n\tif got := dao.Parent(); got != nil {\n\t\tt.Fatalf(\"expected no parent DAO, got: '%s'\", got.Name())\n\t}\n\n\tif c := len(dao.SubDAOs()); c != 0 {\n\t\tt.Fatalf(\"expected no sub DAO nodes, got %d node(s)\", c)\n\t}\n\n\tif dao.IsSuperCouncil() {\n\t\tt.Fatal(\"expected DAO not to be a super council\")\n\t}\n\n\tif c := len(dao.Members()); c != len(addresses) {\n\t\tt.Fatalf(\"expected %d DAO members, got %d\", len(addresses), c)\n\t}\n\n\tfor _, addr := range addresses {\n\t\tif !dao.HasMember(addr) {\n\t\t\tt.Fatalf(\"expected member %s to be a member of DAO\", addr)\n\t\t}\n\n\t\tm, found := dao.GetMember(addr)\n\t\tif !found {\n\t\t\tt.Fatalf(\"expected member %s to be found\", addr)\n\t\t}\n\n\t\tif m.Address != addr {\n\t\t\tt.Fatalf(\"expected member to have address %s, got: %s\", addr, m.Address)\n\t\t}\n\t}\n}\n\nfunc TestDAOAddMember(t *testing.T) {\n\tcases := []struct {\n\t\tname         string\n\t\tmember       gnome.Member\n\t\tmembersCount int\n\t\tshouldExist  bool\n\t\tsetup        func(*gnome.DAO)\n\t}{\n\t\t{\n\t\t\tname:         \"ok\",\n\t\t\tmember:       newTestMember(t, \"member\"),\n\t\t\tmembersCount: 1,\n\t\t\tshouldExist:  true,\n\t\t},\n\t\t{\n\t\t\tname:         \"existing\",\n\t\t\tmember:       newTestMember(t, \"member\"),\n\t\t\tmembersCount: 2,\n\t\t\tshouldExist:  true,\n\t\t\tsetup: func(dao *gnome.DAO) {\n\t\t\t\tdao.AddMember(newTestMember(t, \"member2\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:         \"duplicate\",\n\t\t\tmember:       newTestMember(t, \"member\"),\n\t\t\tmembersCount: 2,\n\t\t\tshouldExist:  true,\n\t\t\tsetup: func(dao *gnome.DAO) {\n\t\t\t\tdao.AddMember(newTestMember(t, \"member\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tdao := gnome.MustNew(\"test\", \"Test\")\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(dao)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\tdao.AddMember(tc.member)\n\n\t\t\t// Assert\n\t\t\tif got := dao.HasMember(tc.member.Address); got != tc.shouldExist {\n\t\t\t\tt.Fatalf(\"expected has member call to return %v, got: %v\", tc.shouldExist, got)\n\t\t\t}\n\n\t\t\tm, found := dao.GetMember(tc.member.Address)\n\t\t\tif found != tc.shouldExist {\n\t\t\t\tt.Fatalf(\"expected member getter to return %v, got: %v\", tc.shouldExist, found)\n\t\t\t}\n\n\t\t\tif tc.shouldExist \u0026\u0026 m.Address != tc.member.Address {\n\t\t\t\tt.Fatalf(\"expected added member to have adderss %s, got: %s\", tc.member, m)\n\t\t\t}\n\n\t\t\tmembers := dao.Members()\n\t\t\tif c := len(members); c != tc.membersCount {\n\t\t\t\tt.Fatalf(\"expected %d member(s), got: %d\", tc.membersCount, c)\n\t\t\t}\n\n\t\t\tif len(members) \u003e 0 {\n\t\t\t\tm = members[len(members)-1]\n\t\t\t\tif m.Address != tc.member.Address {\n\t\t\t\t\tt.Fatalf(\"expected last added member address: %s, got: %s\", tc.member.Address, m.Address)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDAORemoveMember(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\tmember gnome.Member\n\t\tsetup  func(*gnome.DAO)\n\t\tresult bool\n\t}{\n\t\t{\n\t\t\tname:   \"ok\",\n\t\t\tmember: newTestMember(t, \"member\"),\n\t\t\tresult: true,\n\t\t\tsetup: func(dao *gnome.DAO) {\n\t\t\t\tdao.AddMember(newTestMember(t, \"member\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"missing\",\n\t\t\tmember: newTestMember(t, \"member\"),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tdao := gnome.MustNew(\"test\", \"Test\")\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(dao)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\tresult := dao.RemoveMember(tc.member.Address)\n\n\t\t\t// Assert\n\t\t\tif result != tc.result {\n\t\t\t\tt.Fatalf(\"expected result to be %v, got: %v\", tc.result, result)\n\t\t\t}\n\n\t\t\tif dao.HasMember(tc.member.Address) {\n\t\t\t\tt.Fatal(\"member shouldn't exist\")\n\t\t\t}\n\n\t\t\tif _, found := dao.GetMember(tc.member.Address); found {\n\t\t\t\tt.Fatal(\"expected member getter to return false\")\n\t\t\t}\n\n\t\t\tif c := len(dao.Members()); c != 0 {\n\t\t\t\tt.Fatalf(\"expected no DAO members, got: %d\", c)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDAOAddSubDAO(t *testing.T) {\n\tcases := []struct {\n\t\tname, path  string\n\t\tchildren    int\n\t\tdao, subDAO *gnome.DAO\n\t\tresult      bool\n\t\tsetup       func(*gnome.DAO)\n\t}{\n\t\t{\n\t\t\tname:     \"ok\",\n\t\t\tdao:      gnome.MustNew(\"main\", \"Main\"),\n\t\t\tsubDAO:   gnome.MustNew(\"foo\", \"Foo\"),\n\t\t\tchildren: 1,\n\t\t\tpath:     \"main/foo\",\n\t\t\tresult:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"with children\",\n\t\t\tdao: gnome.MustNew(\n\t\t\t\t\"main\",\n\t\t\t\t\"Main\",\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"bar\", \"Bar\")),\n\t\t\t),\n\t\t\tsubDAO:   gnome.MustNew(\"foo\", \"Foo\"),\n\t\t\tchildren: 2,\n\t\t\tpath:     \"main/foo\",\n\t\t\tresult:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate\",\n\t\t\tdao: gnome.MustNew(\n\t\t\t\t\"main\",\n\t\t\t\t\"Main\",\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"foo\", \"Foo\")),\n\t\t\t),\n\t\t\tsubDAO: gnome.MustNew(\"foo\", \"Foo\"),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tresult := tc.dao.AddSubDAO(tc.subDAO)\n\n\t\t\t// Assert\n\t\t\tif result != tc.result {\n\t\t\t\tt.Fatalf(\"expected result to be %v, got: %v\", tc.result, result)\n\t\t\t}\n\n\t\t\tif result {\n\t\t\t\tif got := tc.subDAO.Path(); got != tc.path {\n\t\t\t\t\tt.Fatalf(\"expected path to be '%s', got: '%s'\", tc.path, got)\n\t\t\t\t}\n\n\t\t\t\tif c := len(tc.dao.SubDAOs()); c != tc.children {\n\t\t\t\t\tt.Fatalf(\"expected %d sub DAO node(s), got %d node(s)\", tc.children, c)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDAORemoveSubDAO(t *testing.T) {\n\tcases := []struct {\n\t\tname, subName string\n\t\tchildren      int\n\t\tsubDAO        *gnome.DAO\n\t\tresult        bool\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\tsubDAO: gnome.MustNew(\n\t\t\t\t\"main\",\n\t\t\t\t\"Main\",\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"foo\", \"Foo\")),\n\t\t\t),\n\t\t\tsubName: \"foo\",\n\t\t\tresult:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"with children\",\n\t\t\tsubDAO: gnome.MustNew(\n\t\t\t\t\"main\",\n\t\t\t\t\"Main\",\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"foo\", \"Foo\")),\n\t\t\t\tgnome.WithSubDAO(gnome.MustNew(\"bar\", \"Bar\")),\n\t\t\t),\n\t\t\tsubName:  \"foo\",\n\t\t\tchildren: 1,\n\t\t\tresult:   true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing\",\n\t\t\tsubName: \"foo\",\n\t\t\tsubDAO:  gnome.MustNew(\"main\", \"Main\"),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tresult := tc.subDAO.RemoveSubDAO(tc.subName)\n\n\t\t\t// Assert\n\t\t\tif result != tc.result {\n\t\t\t\tt.Fatalf(\"expected result to be %v, got: %v\", tc.result, result)\n\t\t\t}\n\n\t\t\tif result {\n\t\t\t\tif c := len(tc.subDAO.SubDAOs()); c != tc.children {\n\t\t\t\t\tt.Fatalf(\"expected %d sub DAO node(s), got %d node(s)\", tc.children, c)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDAOTree(t *testing.T) {\n\tdaoA1 := gnome.MustNew(\"a1\", \"A1\")\n\tdaoA2 := gnome.MustNew(\"a2\", \"A2\")\n\tdaoA := gnome.MustNew(\"a\", \"A\", gnome.WithSubDAO(daoA1), gnome.WithSubDAO(daoA2))\n\tdaoB1 := gnome.MustNew(\"b1\", \"B1\")\n\tdaoB := gnome.MustNew(\"b\", \"B\", gnome.WithSubDAO(daoB1))\n\tdao := gnome.MustNew(\"main\", \"Main\", gnome.WithSubDAO(daoA), gnome.WithSubDAO(daoB))\n\n\tcases := []struct {\n\t\tname, path string\n\t\tdao        *gnome.DAO\n\t}{\n\t\t{\n\t\t\tname: \"root\",\n\t\t\tpath: \"main\",\n\t\t\tdao:  dao,\n\t\t},\n\t\t{\n\t\t\tname: \"path a\",\n\t\t\tpath: \"main/a\",\n\t\t\tdao:  daoA,\n\t\t},\n\t\t{\n\t\t\tname: \"path a1\",\n\t\t\tpath: \"main/a/a1\",\n\t\t\tdao:  daoA1,\n\t\t},\n\t\t{\n\t\t\tname: \"path a2\",\n\t\t\tpath: \"main/a/a2\",\n\t\t\tdao:  daoA2,\n\t\t},\n\t\t{\n\t\t\tname: \"path b\",\n\t\t\tpath: \"main/b\",\n\t\t\tdao:  daoB,\n\t\t},\n\t\t{\n\t\t\tname: \"path b1\",\n\t\t\tpath: \"main/b/b1\",\n\t\t\tdao:  daoB1,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid\",\n\t\t\tpath: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid sub path\",\n\t\t\tpath: \"foo/bar\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\tsubDAO, found := dao.GetDAO(tc.path)\n\n\t\t\t// Assert\n\t\t\tif subDAO != tc.dao {\n\t\t\t\tif !found {\n\t\t\t\t\tt.Fatalf(\"DAO for path '%s' not found\", tc.path)\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"unexpected DAO for path '%s': '%s'\", tc.path, subDAO.Name())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif found \u0026\u0026 subDAO.Path() != tc.path {\n\t\t\t\tt.Fatalf(\"expected DAO to return path '%s': got '%s'\", tc.path, subDAO.Path())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc newTestMember(t *testing.T, name string) gnome.Member {\n\tt.Helper()\n\treturn gnome.NewMember(testutils.TestAddress(name))\n}\n"},{"name":"id.gno","body":"package dao\n\nimport (\n\t\"encoding/binary\"\n\t\"strconv\"\n)\n\n// ID defines a generic ID type.\ntype ID uint64\n\n// String returns the value of the ID as a string.\nfunc (id ID) String() string {\n\treturn strconv.FormatUint(uint64(id), 10)\n}\n\n// Key returns the binary representation of the ID to be used as key for AVL trees.\nfunc (id ID) Key() string {\n\tbuf := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(buf, uint64(id))\n\treturn string(buf)\n}\n\n// ConvertKeyToID converts a key to an ID.\n// Key is a binary representation of an ID.\nfunc ConvertKeyToID(key string) (ID, bool) {\n\tif len(key) != 8 {\n\t\treturn 0, false\n\t}\n\treturn ID(binary.BigEndian.Uint64([]byte(key))), true\n}\n"},{"name":"invar.gno","body":"package dao\n\n// TODO: Remove this file if Gno implements invar (inmutable) references\n\nimport (\n\t\"std\"\n\t\"time\"\n)\n\nfunc NewInvarProposalStrategy(s ProposalStrategy) InvarProposalStrategy {\n\treturn InvarProposalStrategy{s}\n}\n\ntype InvarProposalStrategy struct {\n\tref ProposalStrategy\n}\n\nfunc (s InvarProposalStrategy) Name() string {\n\treturn s.ref.Name()\n}\n\nfunc (s InvarProposalStrategy) Quorum() float64 {\n\treturn s.ref.Quorum()\n}\n\nfunc (s InvarProposalStrategy) VotingPeriod() time.Duration {\n\treturn s.ref.VotingPeriod()\n}\n\nfunc (s InvarProposalStrategy) VoteChoices() []VoteChoice {\n\treturn s.ref.VoteChoices()\n}\n\nfunc (s InvarProposalStrategy) RenderParams() string {\n\tif r, ok := s.ref.(ParamsRenderer); ok {\n\t\treturn r.RenderParams()\n\t}\n\treturn \"\"\n}\n\nfunc NewInvarVote(v Vote) InvarVote {\n\treturn InvarVote{\n\t\tAddress:   v.Address,\n\t\tChoice:    v.Choice,\n\t\tReason:    v.Reason,\n\t\tDAO:       NewInvarDAO(v.DAO),\n\t\tCreatedAt: v.CreatedAt,\n\t}\n}\n\ntype InvarVote struct {\n\tAddress   std.Address\n\tChoice    VoteChoice\n\tReason    string\n\tDAO       InvarDAO\n\tCreatedAt time.Time\n}\n\nfunc NewInvarDAO(dao *DAO) InvarDAO {\n\treturn InvarDAO{dao}\n}\n\ntype InvarDAO struct {\n\tref *DAO\n}\n\nfunc (dao InvarDAO) Name() string {\n\treturn dao.ref.Name()\n}\n\nfunc (dao InvarDAO) Title() string {\n\treturn dao.ref.Title()\n}\n\nfunc (dao InvarDAO) Manifest() string {\n\treturn dao.ref.Manifest()\n}\n\nfunc (dao InvarDAO) CreatedAt() time.Time {\n\treturn dao.ref.CreatedAt()\n}\n\nfunc (dao InvarDAO) Parent() (_ InvarDAO, exists bool) {\n\tif p := dao.ref.Parent(); p != nil {\n\t\treturn NewInvarDAO(p), true\n\t}\n\treturn InvarDAO{}, false\n}\n\nfunc (dao InvarDAO) Path() string {\n\treturn dao.ref.Path()\n}\n\nfunc (dao InvarDAO) SubDAOs() (daos []InvarDAO) {\n\tfor _, sub := range dao.ref.SubDAOs() {\n\t\tdaos = append(daos, NewInvarDAO(sub))\n\t}\n\treturn\n}\n\nfunc (dao InvarDAO) Members() []Member {\n\treturn dao.ref.Members()\n}\n\nfunc (dao InvarDAO) LockReason() string {\n\treturn dao.ref.LockReason()\n}\n\nfunc (dao InvarDAO) IsSuperCouncil() bool {\n\treturn dao.ref.IsSuperCouncil()\n}\n\nfunc (dao InvarDAO) IsLocked() bool {\n\treturn dao.ref.IsLocked()\n}\n\nfunc (dao InvarDAO) IsRoot() bool {\n\treturn dao.ref.IsRoot()\n}\n\nfunc NewInvarProposal(p *Proposal) InvarProposal {\n\treturn InvarProposal{p}\n}\n\ntype InvarProposal struct {\n\tref *Proposal\n}\n\nfunc (p InvarProposal) ID() ID {\n\treturn p.ref.ID()\n}\n\nfunc (p InvarProposal) DAO() InvarDAO {\n\treturn NewInvarDAO(p.ref.DAO())\n}\n\nfunc (p InvarProposal) InitialDAO() InvarDAO {\n\treturn NewInvarDAO(p.ref.InitialDAO())\n}\n\nfunc (p InvarProposal) Strategy() InvarProposalStrategy {\n\treturn NewInvarProposalStrategy(p.ref.Strategy())\n}\n\nfunc (p InvarProposal) Title() string {\n\treturn p.ref.Title()\n}\n\nfunc (p InvarProposal) Description() string {\n\treturn p.ref.Description()\n}\n\nfunc (p InvarProposal) StatusReason() string {\n\treturn p.ref.StatusReason()\n}\n\nfunc (p InvarProposal) Proposer() std.Address {\n\treturn p.ref.Proposer()\n}\n\nfunc (p InvarProposal) Choice() VoteChoice {\n\treturn p.ref.Choice()\n}\n\nfunc (p InvarProposal) CreatedAt() time.Time {\n\treturn p.ref.CreatedAt()\n}\n\nfunc (p InvarProposal) Promotions() (daos []InvarDAO) {\n\tfor _, dao := range p.ref.Promotions() {\n\t\tdaos = append(daos, NewInvarDAO(dao))\n\t}\n\treturn\n}\n\nfunc (p InvarProposal) VotingDeadline() time.Time {\n\treturn p.ref.VotingDeadline()\n}\n\nfunc (p InvarProposal) ReviewDeadline() time.Time {\n\treturn p.ref.ReviewDeadline()\n}\n\nfunc (p InvarProposal) VoteChangeDuration() time.Duration {\n\treturn p.ref.VoteChangeDuration()\n}\n\nfunc (p InvarProposal) Status() ProposalStatus {\n\treturn p.ref.Status()\n}\n\nfunc (p InvarProposal) Votes() (votes []InvarVote) {\n\tfor _, v := range p.ref.Votes() {\n\t\tvotes = append(votes, NewInvarVote(v))\n\t}\n\treturn\n}\n\nfunc (p InvarProposal) VotingRecord() InvarVotingRecord {\n\treturn NewInvarVotingRecord(p.ref.VotingRecord())\n}\n\nfunc (p InvarProposal) VotingRecords() (records []InvarVotingRecord) {\n\tfor _, r := range p.ref.VotingRecords() {\n\t\trecords = append(records, NewInvarVotingRecord(r))\n\t}\n\treturn\n}\n\nfunc NewInvarVotingRecord(r *VotingRecord) InvarVotingRecord {\n\treturn InvarVotingRecord{r}\n}\n\ntype InvarVotingRecord struct {\n\tref *VotingRecord\n}\n\nfunc (r InvarVotingRecord) Votes() (votes []InvarVote) {\n\tfor _, v := range r.ref.Votes() {\n\t\tvotes = append(votes, NewInvarVote(v))\n\t}\n\treturn\n}\n\nfunc (r InvarVotingRecord) VoteCount() int {\n\treturn r.ref.VoteCount()\n}\n\nfunc (r InvarVotingRecord) Get(c VoteChoice) uint {\n\treturn r.ref.Get(c)\n}\n\nfunc (r InvarVotingRecord) Iterate(fn VotingRecordIterFn) bool {\n\treturn r.ref.Iterate(fn)\n}\n"},{"name":"paginator.gno","body":"package dao\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar (\n\tdefaultPageSize = 50\n\tminPageSize     = 1\n\tpagePrefix      = \"page=\"\n)\n\ntype (\n\t// PaginatorIterFn defines a callback to iterate page items.\n\tPaginatorIterFn func(index int) (stop bool)\n\n\t// PaginatorOption configures the paginator.\n\tPaginatorOption func(*Paginator)\n)\n\n// WithPageSize assigns a page size to a paginator.\n// The minimum page size is 5.\nfunc WithPageSize(size int) PaginatorOption {\n\treturn func(p *Paginator) {\n\t\tif size \u003c minPageSize {\n\t\t\tp.pageSize = minPageSize\n\t\t} else {\n\t\t\tp.pageSize = size\n\t\t}\n\t}\n}\n\n// WithItemCount assigns the total number of items that can be paginated.\n// Assigning the total item count allows the paginator to determine the last page number.\nfunc WithItemCount(count int) PaginatorOption {\n\treturn func(p *Paginator) {\n\t\tp.itemCount = count\n\t}\n}\n\n// NewPaginator creates a new paginator.\n// URI path must contain the page number for the paginator to iterate items.\n// Page number is specified in the URI path using \"page=N\" where N is the page\n// number which must start from 1. For example: gno.land/p/gnome:a/b:page=2.\n// Paginator is disabled when the URI path doesn't have a page specified or\n// when the specified page is not valid.\nfunc NewPaginator(uri string, options ...PaginatorOption) Paginator {\n\trealmURI, renderPath := SplitRealmURI(uri)\n\tp := Paginator{\n\t\trealmPath: strings.TrimPrefix(realmURI, \"gno.land\"),\n\t\tpageSize:  defaultPageSize,\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(\u0026p)\n\t}\n\n\tp.lastPage = int(math.Ceil(float64(p.itemCount) / float64(p.pageSize)))\n\n\t// Iterate path items until paginator arguments are found.\n\t// Path prefix and suffix are kept to be able to generate\n\t// page URLs keeping the render path format.\n\titems := strings.Split(renderPath, \":\")\n\tfor i, item := range items {\n\t\tif strings.HasPrefix(item, pagePrefix) {\n\t\t\tp.pathSuffix = items[i+1:]\n\t\t\tp.page, _ = strconv.Atoi(item[len(pagePrefix):])\n\t\t\tbreak\n\t\t}\n\n\t\tp.pathPrefix = append(p.pathPrefix, item)\n\t}\n\treturn p\n}\n\n// Paginator allows paging items.\ntype Paginator struct {\n\trealmPath                           string\n\tpathPrefix, pathSuffix              []string\n\tpageSize, page, lastPage, itemCount int\n}\n\n// Offset returns the index for the first page item.\nfunc (p Paginator) Offset() int {\n\tif !p.IsEnabled() {\n\t\treturn 0\n\t}\n\treturn (p.page - 1) * p.pageSize\n}\n\n// PageSize returns the size of each page.\nfunc (p Paginator) PageSize() int {\n\treturn p.pageSize\n}\n\n// Page returns the current page number.\n// Zero is returned when the paginator is disabled.\nfunc (p Paginator) Page() int {\n\treturn p.page\n}\n\n// LastPage returns the number of the last page.\n// Zero is returned when paginator is initialized without the total item count.\nfunc (p Paginator) LastPage() int {\n\treturn p.lastPage\n}\n\n// IsEnabled checks if paginator is enabled.\nfunc (p Paginator) IsEnabled() bool {\n\treturn p.page \u003e 0\n}\n\n// IsLastPage checks if the current page is the last one.\nfunc (p Paginator) IsLastPage() bool {\n\treturn p.page == p.lastPage\n}\n\n// GetPageURI returns the URI for a page.\n// An empty string is returned when page is \u003c 1.\nfunc (p Paginator) GetPageURI(page int) string {\n\tif !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\n\trenderPath := append(p.pathPrefix, pagePrefix+strconv.Itoa(page))\n\trenderPath = append(renderPath, p.pathSuffix...)\n\treturn p.realmPath + \":\" + strings.Join(renderPath, \":\")\n}\n\n// PrevPageURI returns the URI path to the previous page.\n// An empty string is returned when current page is the first page.\nfunc (p Paginator) PrevPageURI() string {\n\tif p.page == 1 || !p.IsEnabled() {\n\t\treturn \"\"\n\t}\n\treturn p.GetPageURI(p.page - 1)\n}\n\n// NextPageURI returns the URI path to the next page.\nfunc (p Paginator) NextPageURI() string {\n\tif p.IsLastPage() {\n\t\treturn \"\"\n\t}\n\treturn p.GetPageURI(p.page + 1)\n}\n\n// Iterate allows iterating page items.\nfunc (p Paginator) Iterate(fn PaginatorIterFn) bool {\n\tif !p.IsEnabled() {\n\t\treturn true\n\t}\n\n\tstart := p.Offset()\n\tfor i := start; i \u003c start+p.PageSize(); i++ {\n\t\tif fn(i) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"},{"name":"paginator_test.gno","body":"package dao\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestPaginator(t *testing.T) {\n\titems := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tcases := []struct {\n\t\tname, uri, prevPath, nextPath    string\n\t\toffset, pageSize, page, lastPage int\n\t\tpageItems                        string\n\t\tstopped, enabled, isLastPage     bool\n\t}{\n\t\t{\n\t\t\tname:      \"page 1\",\n\t\t\turi:       \"gno.land/r/gnome:foo/bar:page=1:foo=bar\",\n\t\t\tenabled:   true,\n\t\t\tnextPath:  \"/r/gnome:foo/bar:page=2:foo=bar\",\n\t\t\toffset:    0,\n\t\t\tpageSize:  5,\n\t\t\tpage:      1,\n\t\t\tlastPage:  2,\n\t\t\tpageItems: \"[1 2 3 4 5]\",\n\t\t},\n\t\t{\n\t\t\tname:       \"page 2\",\n\t\t\turi:        \"gno.land/r/gnome:foo/bar:page=2:foo=bar\",\n\t\t\tenabled:    true,\n\t\t\tprevPath:   \"/r/gnome:foo/bar:page=1:foo=bar\",\n\t\t\tnextPath:   \"\",\n\t\t\toffset:     5,\n\t\t\tpageSize:   5,\n\t\t\tpage:       2,\n\t\t\tlastPage:   2,\n\t\t\tpageItems:  \"[6 7 8 9 10]\",\n\t\t\tisLastPage: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"missing page\",\n\t\t\turi:       \"gno.land/r/gnome:foo/bar:page=3:foo=bar\",\n\t\t\tenabled:   true,\n\t\t\tprevPath:  \"/r/gnome:foo/bar:page=2:foo=bar\",\n\t\t\tnextPath:  \"/r/gnome:foo/bar:page=4:foo=bar\",\n\t\t\toffset:    10,\n\t\t\tpageSize:  5,\n\t\t\tpage:      3,\n\t\t\tlastPage:  2,\n\t\t\tpageItems: \"[]\",\n\t\t\tstopped:   true,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid page number\",\n\t\t\turi:       \"gno.land/r/gnome:foo/bar:page=0:foo=bar\",\n\t\t\tenabled:   false,\n\t\t\tprevPath:  \"\",\n\t\t\tnextPath:  \"\",\n\t\t\toffset:    0,\n\t\t\tpageSize:  4,\n\t\t\tpage:      0,\n\t\t\tlastPage:  3,\n\t\t\tpageItems: \"[]\",\n\t\t\tstopped:   true,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid page value\",\n\t\t\turi:       \"gno.land/r/gnome:foo/bar:page=foo:foo=bar\",\n\t\t\tenabled:   false,\n\t\t\tprevPath:  \"\",\n\t\t\tnextPath:  \"\",\n\t\t\toffset:    0,\n\t\t\tpageSize:  2,\n\t\t\tpage:      0,\n\t\t\tlastPage:  5,\n\t\t\tpageItems: \"[]\",\n\t\t\tstopped:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tvar pageItems []int\n\n\t\t\t// Act\n\t\t\tp := NewPaginator(tc.uri, WithPageSize(tc.pageSize), WithItemCount(len(items)))\n\n\t\t\t// Assert\n\t\t\tif got := p.Page(); got != tc.page {\n\t\t\t\tt.Fatalf(\"expected page: %d, got: %d\", tc.page, got)\n\t\t\t}\n\n\t\t\tif got := p.LastPage(); got != tc.lastPage {\n\t\t\t\tt.Fatalf(\"expected last page: %d, got: %d\", tc.lastPage, got)\n\t\t\t}\n\n\t\t\tif got := p.PrevPageURI(); got != tc.prevPath {\n\t\t\t\tt.Fatalf(\"expected prev page path: '%s', got: '%s'\", tc.prevPath, got)\n\t\t\t}\n\n\t\t\tif got := p.NextPageURI(); got != tc.nextPath {\n\t\t\t\tt.Fatalf(\"expected next page path: '%s', got: '%s'\", tc.nextPath, got)\n\t\t\t}\n\n\t\t\tif got := p.Offset(); got != tc.offset {\n\t\t\t\tt.Fatalf(\"expected offset: %d, got: %d\", tc.offset, got)\n\t\t\t}\n\n\t\t\tif got := p.PageSize(); got != tc.pageSize {\n\t\t\t\tt.Fatalf(\"expected page size: %d, got: %d\", tc.pageSize, got)\n\t\t\t}\n\n\t\t\tif got := p.IsEnabled(); got != tc.enabled {\n\t\t\t\tt.Fatalf(\"expected enabled: %v, got: %v\", tc.enabled, got)\n\t\t\t}\n\n\t\t\tif got := p.IsLastPage(); got != tc.isLastPage {\n\t\t\t\tt.Fatalf(\"expected is last page to be: %v, got: %v\", tc.isLastPage, got)\n\t\t\t}\n\n\t\t\tstopped := p.Iterate(func(i int) bool {\n\t\t\t\tif i \u003e= len(items) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\n\t\t\t\tpageItems = append(pageItems, items[i])\n\t\t\t\treturn false\n\t\t\t})\n\t\t\tif stopped != tc.stopped {\n\t\t\t\tt.Fatalf(\"expected iteration result: %v, got: %v\", tc.stopped, stopped)\n\t\t\t}\n\n\t\t\tif got := fmt.Sprintf(\"%v\", pageItems); got != tc.pageItems {\n\t\t\t\tt.Fatalf(\"expected page items: %s, got: %s\", tc.pageItems, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"name":"params.gno","body":"package dao\n\nimport (\n\t\"math\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype (\n\t// DurationIterFn defines the a callback to iterate duration values.\n\tDurationIterFn func(name string, _ time.Duration) bool\n\n\t// DurationParams contains duration values for different parameters.\n\tDurationParams struct {\n\t\tparams avl.Tree // string(parameter name) -\u003e time.Duration\n\t}\n)\n\n// Set sets or updates a parameter value.\nfunc (p *DurationParams) Set(name string, v time.Duration) bool {\n\treturn p.params.Set(name, v)\n}\n\n// Get gets a parameter value.\nfunc (p DurationParams) Get(name string) (_ time.Duration, found bool) {\n\tif v, found := p.params.Get(name); found {\n\t\treturn v.(time.Duration), true\n\t}\n\treturn 0, false\n}\n\n// Size returns the number of duration parameters.\nfunc (p DurationParams) Size() int {\n\treturn p.params.Size()\n}\n\n// Iterate iterates duration parameter values.\nfunc (p DurationParams) Iterate(fn DurationIterFn) bool {\n\treturn p.params.Iterate(\"\", \"\", func(name string, v interface{}) bool {\n\t\treturn fn(name, v.(time.Duration))\n\t})\n}\n\n// HumanizeDuration returns a friendlier text representation of a duration.\nfunc HumanizeDuration(d time.Duration) string { // TODO: Change to use singular/plurals\n\tif d == 0 {\n\t\treturn \"\"\n\t}\n\n\tif sec := d.Seconds(); sec \u003c 60 {\n\t\treturn ufmt.Sprintf(\"%d seconds\", int(sec))\n\t}\n\n\tif m := d.Minutes(); m \u003c 60 {\n\t\tsec := math.Mod(d.Seconds(), 60)\n\t\tif sec \u003c 1 {\n\t\t\treturn ufmt.Sprintf(\"%d minutes\", int(m))\n\t\t}\n\t\treturn ufmt.Sprintf(\"%d minutes %d seconds\", int(m), int(sec))\n\t}\n\n\tif hs := d.Hours(); hs \u003c 24 {\n\t\tm := math.Mod(d.Minutes(), 60)\n\t\tif m \u003c 1 {\n\t\t\treturn ufmt.Sprintf(\"%d hours\", int(hs))\n\t\t}\n\n\t\tsec := math.Mod(d.Seconds(), 60)\n\t\tif sec \u003c 1 {\n\t\t\treturn ufmt.Sprintf(\"%d hours %d minutes\", int(hs), int(m))\n\t\t}\n\t\treturn ufmt.Sprintf(\"%d hours %d minutes %d seconds\", int(hs), int(m), int(sec))\n\t}\n\n\tdays := d.Hours() / 24\n\ths := math.Mod(d.Hours(), 24)\n\tif hs \u003c 1 {\n\t\treturn ufmt.Sprintf(\"%d days\", int(days))\n\t}\n\n\tm := math.Mod(d.Minutes(), 60)\n\tif m \u003c 0 {\n\t\treturn ufmt.Sprintf(\"%d days %d hours\", int(days), int(hs))\n\t}\n\n\tsec := math.Mod(d.Seconds(), 60)\n\tif sec \u003c 1 {\n\t\treturn ufmt.Sprintf(\"%d days %d hours %d minutes\", int(days), int(hs), int(m))\n\t}\n\treturn ufmt.Sprintf(\"%d days %d hours %d minutes %d seconds\", int(days), int(hs), int(m), int(sec))\n}\n"},{"name":"proposal.gno","body":"package dao\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\tStatusReview ProposalStatus = iota\n\tStatusActive\n\tStatusPassed\n\tStatusRejected\n\tStatusWithdrawed\n\tStatusDismissed\n\tStatusFailed\n)\n\nconst (\n\t// TODO: Add more choices which also should be configurable (use a different type?)\n\tChoiceNone VoteChoice = \"\"\n\tChoiceYes  VoteChoice = \"yes\"\n\tChoiceNo   VoteChoice = \"no\"\n)\n\nconst (\n\tdefaultVoteChangeDuration = time.Hour\n\texecutionErrorMsg         = \"proposal execution error\"\n)\n\nvar (\n\tErrAlreadyVoted              = errors.New(\"member already voted on this proposal\")\n\tErrInvalidReason             = errors.New(\"reason must have at least 5 characters\")\n\tErrInvalidVoteChoice         = errors.New(\"invalid vote choice\")\n\tErrMemberVoteNotAllowed      = errors.New(\"you must be a DAO or parent DAO member to vote\")\n\tErrProposalPromote           = errors.New(\"proposals can only be promoted to a parent DAO\")\n\tErrProposalVotingDeadlineMet = errors.New(\"proposal voting deadline already met\")\n\tErrProposalNotActive         = errors.New(\"proposal is not active\")\n\tErrProposalNotPassed         = errors.New(`proposal status must be \"passed\"`)\n\tErrReasonRequired            = errors.New(\"reason is required\")\n\tErrReviewStatusRequired      = errors.New(`proposal status must be \"review\"`)\n)\n\ntype (\n\t// ExecutionError indicates that proposal execution failed.\n\tExecutionError struct {\n\t\t// Reason contains the error or error message with the reason of the error.\n\t\tReason interface{}\n\t}\n\n\t// ProposalIterFn defines the a callback to iterate proposals.\n\tProposalIterFn func(*Proposal) bool\n\n\t// ProposalOption configures proposals.\n\tProposalOption func(*Proposal)\n\n\t// ProposalStatus defines the type for proposal states.\n\tProposalStatus uint8\n\n\t// VoteChoice defines the type for proposal vote choices.\n\tVoteChoice string\n\n\t// Vote contains the information for a member vote.\n\tVote struct {\n\t\t// Address is the DAO member address.\n\t\tAddress std.Address\n\n\t\t// Choice is the proposal choice being voted.\n\t\tChoice VoteChoice\n\n\t\t// Reason contains the reason for the vote.\n\t\tReason string\n\n\t\t// DAO contains the DAO that the proposal being voted belongs to.\n\t\tDAO *DAO\n\n\t\t// CreatedAt contains the time when the vote was submitted.\n\t\tCreatedAt time.Time\n\t}\n)\n\n// Error returns the execution error message.\nfunc (e ExecutionError) Error() string {\n\tswitch v := e.Reason.(type) {\n\tcase string:\n\t\treturn executionErrorMsg + \": \" + v\n\tcase error:\n\t\treturn executionErrorMsg + \": \" + v.Error()\n\tdefault:\n\t\treturn executionErrorMsg\n\t}\n}\n\n// String returns the proposal status name.\nfunc (s ProposalStatus) String() string {\n\tswitch s {\n\tcase StatusReview:\n\t\treturn \"review\"\n\tcase StatusActive:\n\t\treturn \"active\"\n\tcase StatusPassed:\n\t\treturn \"passed\"\n\tcase StatusRejected:\n\t\treturn \"rejected\"\n\tcase StatusWithdrawed:\n\t\treturn \"withdrawed\"\n\tcase StatusDismissed:\n\t\treturn \"dismissed\"\n\tcase StatusFailed:\n\t\treturn \"failed\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\n// IsFinal checks if the status is a final status.\n// When a status is final it can't be changed to a different status.\n// Being final means that status signals the final outcome of a proposal.\nfunc (s ProposalStatus) IsFinal() bool {\n\tswitch s {\n\tcase StatusReview, StatusActive:\n\t\treturn false\n\tdefault:\n\t\treturn true\n\t}\n}\n\n// IsExecutionError checks if an error is an ExecutionError.\nfunc IsExecutionError(err error) bool {\n\tswitch err.(type) {\n\tcase ExecutionError:\n\t\treturn true\n\tcase *ExecutionError:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// WithDescription assigns a description to the proposal.\nfunc WithDescription(s string) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.description = s\n\t}\n}\n\n// WithVotingDeadline assigns a voting deadline to the proposal.\nfunc WithVotingDeadline(t time.Time) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.votingDeadline = t\n\t}\n}\n\n// WithReviewDeadline assigns a review deadline to the proposal.\n// Review status allows proposal withdraw within a time frame after the proposal is created.\n// Proposals must be activated when a review deadline is assigned.\nfunc WithReviewDeadline(t time.Time) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.reviewDeadline = t\n\t}\n}\n\n// WithVoteChangeDuration change the default grace period to change a submitted vote choice.\nfunc WithVoteChangeDuration(d time.Duration) ProposalOption {\n\treturn func(p *Proposal) {\n\t\tp.voteChangeDuration = d\n\t}\n}\n\n// NewProposal creates a new proposal.\n// By default proposals use the standard strategy with a deadline of seven days.\nfunc NewProposal(\n\tid ID,\n\tstrategy ProposalStrategy,\n\tproposer std.Address,\n\tdao *DAO,\n\ttitle string,\n\toptions ...ProposalOption,\n) (*Proposal, error) {\n\tif dao == nil {\n\t\treturn nil, errors.New(\"proposal DAO is required\")\n\t}\n\n\tif strings.TrimSpace(title) == \"\" {\n\t\treturn nil, errors.New(\"proposal title is required\")\n\t}\n\n\tnow := time.Now()\n\tp := \u0026Proposal{\n\t\tid:                 id,\n\t\tproposer:           proposer,\n\t\ttitle:              title,\n\t\tvotingDeadline:     now.Add(strategy.VotingPeriod()),\n\t\tvoteChangeDuration: defaultVoteChangeDuration,\n\t\tstrategy:           strategy,\n\t\tdaos:               []*DAO{dao},\n\t\tvotingRecords:      []*VotingRecord{NewVotingRecord()},\n\t\tcreatedAt:          now,\n\t}\n\n\tfor _, apply := range options {\n\t\tapply(p)\n\t}\n\n\t// Create the proposal as active when a review deadline is not assigned\n\tif p.reviewDeadline.IsZero() {\n\t\tp.status = StatusActive\n\t}\n\n\treturn p, nil\n}\n\n// Proposal defines a DAO proposal.\ntype Proposal struct {\n\tid                 ID\n\ttitle              string\n\tdescription        string\n\tproposer           std.Address\n\tcreatedAt          time.Time\n\tvotingDeadline     time.Time\n\treviewDeadline     time.Time\n\tvoteChangeDuration time.Duration\n\tstatus             ProposalStatus\n\tstrategy           ProposalStrategy\n\tdaos               []*DAO\n\tvotingRecords      []*VotingRecord\n\tchoice             VoteChoice\n\tstatusReason       string\n}\n\n// ID returns the proposal ID.\nfunc (p Proposal) ID() ID {\n\treturn p.id\n}\n\n// DAO returns the DAO that the proposal is assigned to.\n// If proposal has been promoted the returned DAO is the one where proposal has been promoted to.\nfunc (p Proposal) DAO() *DAO {\n\tcount := len(p.daos)\n\tif count == 0 {\n\t\tpanic(\"proposal is not assigned to a DAO\")\n\t}\n\treturn p.daos[count-1]\n}\n\n// InitialDAO returns the the DAO that was assigned during proposal creation.\nfunc (p Proposal) InitialDAO() *DAO {\n\tif len(p.daos) \u003e 0 {\n\t\treturn p.daos[0]\n\t}\n\treturn nil\n}\n\n// Strategy returns the strategy of the proposal.\nfunc (p Proposal) Strategy() ProposalStrategy {\n\treturn p.strategy\n}\n\n// Title returns the title of the proposal.\nfunc (p Proposal) Title() string {\n\treturn p.title\n}\n\n// Description returns the description of the proposal.\nfunc (p Proposal) Description() string {\n\treturn p.description\n}\n\n// StatusReason returns the reason that triggered the current proposal status.\n// Reason is relevant for some statuses like dismissed or failed.\nfunc (p Proposal) StatusReason() string {\n\treturn p.statusReason\n}\n\n// Proposer returns the address of the member that created the proposal.\nfunc (p Proposal) Proposer() std.Address {\n\treturn p.proposer\n}\n\n// Choice returns the winner choice.\nfunc (p Proposal) Choice() VoteChoice {\n\treturn p.choice\n}\n\n// CreatedAt returns the creation time of the proposal.\nfunc (p Proposal) CreatedAt() time.Time {\n\treturn p.createdAt\n}\n\n// Promotions returns the list of DAOs where the proposal has been promoted.\n// The result is nil when the proposal has never been promoted to another DAO.\nfunc (p Proposal) Promotions() []*DAO {\n\tif p.HasBeenPromoted() {\n\t\treturn p.daos\n\t}\n\treturn nil\n}\n\n// VotingDeadline returns the voting deadline for the proposal.\n// No more votes are allowed after this deadline.\nfunc (p Proposal) VotingDeadline() time.Time {\n\treturn p.votingDeadline\n}\n\n// ReviewDeadline returns the deadline for proposal review.\nfunc (p Proposal) ReviewDeadline() time.Time {\n\treturn p.reviewDeadline\n}\n\n// VoteChangeDuration returns the duration after voting where users can change the voted choice.\nfunc (p Proposal) VoteChangeDuration() time.Duration {\n\treturn p.voteChangeDuration\n}\n\n// Status returns the status of the proposal.\nfunc (p Proposal) Status() ProposalStatus {\n\treturn p.status\n}\n\n// Votes returns the proposal votes.\nfunc (p Proposal) Votes() []Vote {\n\treturn p.VotingRecord().Votes()\n}\n\n// VotingRecord returns the voting record of the proposal for the current DAO.\n// The record contains the number of votes for each voting choice.\nfunc (p Proposal) VotingRecord() *VotingRecord {\n\tcount := len(p.votingRecords)\n\tif count == 0 {\n\t\tpanic(\"proposal has not voting records\")\n\t}\n\treturn p.votingRecords[count-1]\n}\n\n// VotingRecords returns all voting records of the proposal.\n// Each record contains the number of votes for each DAO that the proposal was promoted to.\nfunc (p Proposal) VotingRecords() []*VotingRecord {\n\treturn p.votingRecords\n}\n\n// IsExecutable checks if the proposal is executable.\nfunc (p Proposal) IsExecutable() bool {\n\t_, ok := p.strategy.(Executer)\n\treturn ok\n}\n\n// IsChoiceAllowed checks if a vote choice is valid for the proposal.\nfunc (p Proposal) IsChoiceAllowed(choice VoteChoice) bool {\n\tfor _, c := range p.strategy.VoteChoices() {\n\t\tif c == choice {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// HasVotingDeadlinePassed checks if the voting deadline for the proposal has passed.\nfunc (p Proposal) HasVotingDeadlinePassed() bool {\n\treturn time.Now().After(p.votingDeadline)\n}\n\n// HasReviewDeadlinePassed checks if the deadline for proposal review has passed.\nfunc (p Proposal) HasReviewDeadlinePassed() bool {\n\treturn time.Now().After(p.reviewDeadline)\n}\n\n// HasBeenPromoted checks if the proposal has been promoted to another DAO.\nfunc (p Proposal) HasBeenPromoted() bool {\n\treturn len(p.daos) \u003e 1\n}\n\n// HasPromotion checks if proposal has been promoted to a DAO.\nfunc (p Proposal) HasPromotion(daoPath string) bool {\n\tfor _, dao := range p.Promotions() {\n\t\tif dao.Path() == daoPath {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// GetVotingRecord returns the voting record of a DAO.\n// Proposals can have more than one voting record if they are promoted to parent DAOs.\nfunc (p Proposal) GetVotingRecord(daoPath string) (_ *VotingRecord, found bool) {\n\tfor i, dao := range p.daos {\n\t\tif dao.Path() == daoPath {\n\t\t\t// Voting record index must match the DAO promotions index\n\t\t\treturn p.votingRecords[i], true\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// Withdraw changes the status of the proposal to withdrawed.\n// Proposal must have status \"review\" to be withdrawed.\nfunc (p *Proposal) Withdraw() error {\n\tif p.status != StatusReview {\n\t\treturn ErrReviewStatusRequired\n\t}\n\n\tp.status = StatusWithdrawed\n\treturn nil\n}\n\n// Dismiss dismisses a proposal.\nfunc (p *Proposal) Dismiss(reason string) error {\n\treason = strings.TrimSpace(reason)\n\tif reason == \"\" {\n\t\treturn ErrReasonRequired\n\t}\n\n\tp.statusReason = reason\n\tp.status = StatusDismissed\n\treturn nil\n}\n\n// Fail changes the proposal status to failed.\nfunc (p *Proposal) Fail(reason string) error {\n\treason = strings.TrimSpace(reason)\n\tif reason == \"\" {\n\t\treturn ErrReasonRequired\n\t}\n\n\tp.statusReason = reason\n\tp.status = StatusFailed\n\treturn nil\n}\n\n// Activate changes the status of the proposal to active.\n// Proposal must have status \"review\" to be activated.\nfunc (p *Proposal) Activate() error {\n\tif p.status != StatusReview {\n\t\treturn ErrReviewStatusRequired\n\t}\n\n\tp.status = StatusActive\n\treturn nil\n}\n\n// Promote promotes the proposal to a parent DAO.\n// Promoting extends the voting deadline by the voting period defined for the proposal\n// strategy and also creates a new voting record for the parent DAO members.\nfunc (p *Proposal) Promote(dao *DAO) error {\n\tif !p.DAO().HasParent(dao) {\n\t\treturn ErrProposalPromote\n\t}\n\n\tp.daos = append(p.daos, dao)\n\tp.votingRecords = append(p.votingRecords, NewVotingRecord())\n\tp.votingDeadline = time.Now().Add(p.strategy.VotingPeriod())\n\treturn nil\n}\n\n// Vote submits a vote for the proposal.\nfunc (p *Proposal) Vote(addr std.Address, choice VoteChoice, reason string) error {\n\tif p.status != StatusActive {\n\t\treturn ErrProposalNotActive\n\t}\n\n\tnow := time.Now()\n\tif p.votingDeadline.Before(now) {\n\t\treturn ErrProposalVotingDeadlineMet\n\t}\n\n\tif !p.IsChoiceAllowed(choice) {\n\t\treturn ErrInvalidVoteChoice\n\t}\n\n\tif reason != \"\" {\n\t\treason = strings.TrimSpace(reason)\n\t\tif len(reason) \u003c 5 {\n\t\t\treturn ErrInvalidReason\n\t\t}\n\t}\n\n\t// When there is a vote for the account check if it's voting within the\n\t// grace period that allows changing the voted choice. This allows to\n\t// correct mistakes made when seding the vote TX within a small time frame.\n\t// TODO: Add a unit test case to check vote change\n\trecord := p.VotingRecord()\n\tfor _, v := range record.Votes() {\n\t\tif v.Address == addr {\n\t\t\tif v.CreatedAt.Add(p.voteChangeDuration).Before(now) {\n\t\t\t\treturn ErrAlreadyVoted\n\t\t\t}\n\n\t\t\trecord.Remove(addr)\n\t\t}\n\t}\n\n\t// Check the vote being submitted if vote check is required\n\tif c, ok := p.strategy.(VoteChecker); ok {\n\t\tif err := c.CheckVote(addr, choice, reason); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Account must be a member of the proposal's DAO or any of its parents to be allowed to vote\n\tvar dao *DAO\n\tif p.DAO().HasMember(addr) {\n\t\t// When the account is member of the proposal's DAO its vote is accounted\n\t\t// as a vote from this DAO even if its also member of a parent DAO.\n\t\tdao = p.DAO()\n\t} else {\n\t\t// Try to find the higher order DAO that the account is member of\n\t\tdao = findBelongingDAO(addr, p.DAO().Parent())\n\t}\n\n\tif dao == nil {\n\t\treturn ErrMemberVoteNotAllowed\n\t}\n\n\trecord.Add(Vote{\n\t\tAddress:   addr,\n\t\tChoice:    choice,\n\t\tReason:    reason,\n\t\tDAO:       dao,\n\t\tCreatedAt: time.Now(),\n\t})\n\n\treturn nil\n}\n\n// Tally counts the number of votes and updates the proposal status accordingly.\n// The outcome of counting the votes depends on the proposal strategy.\n// This function does NOT check the voting deadline, it's responsibility of the caller to do so.\nfunc (p *Proposal) Tally() error {\n\tif p.status != StatusActive {\n\t\treturn ErrProposalNotActive\n\t}\n\n\t// Check if the required quorum is met\n\trecord := p.VotingRecord()\n\tpercentage := float64(record.VoteCount()) / float64(len(p.DAO().Members()))\n\tif percentage \u003c p.strategy.Quorum() {\n\t\tp.status = StatusRejected\n\t\tp.statusReason = \"low participation\"\n\t\treturn nil\n\t}\n\n\t// Tally votes and update proposal with the outcome\n\tchoice := p.strategy.Tally(p.DAO(), *record)\n\n\tswitch choice {\n\tcase ChoiceYes:\n\t\tp.choice = ChoiceYes\n\t\tp.status = StatusPassed\n\tcase ChoiceNo:\n\t\tp.choice = ChoiceNo\n\t\tp.status = StatusRejected\n\tdefault:\n\t\tp.status = StatusRejected\n\t}\n\treturn nil\n}\n\nfunc (p *Proposal) Validate() error {\n\tif v, ok := p.strategy.(Validator); ok {\n\t\tif err := v.Validate(p); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Execute executes the proposal.\nfunc (p *Proposal) Execute() error { // TODO: Write test for proposal execute\n\tif p.status != StatusPassed {\n\t\treturn ErrProposalNotPassed\n\t}\n\n\tif e, ok := p.strategy.(Executer); ok {\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn ExecutionError{err}\n\t\t}\n\n\t\tif err := e.Execute(p.InitialDAO()); err != nil {\n\t\t\treturn ExecutionError{err}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc findBelongingDAO(addr std.Address, node *DAO) *DAO {\n\tif node == nil {\n\t\treturn nil\n\t}\n\n\t// Before checking the current DAO try to find\n\t// if address is a member of a higher order DAO\n\tdao := findBelongingDAO(addr, node.parent)\n\tif dao == nil \u0026\u0026 node.HasMember(addr) {\n\t\treturn node\n\t}\n\treturn nil\n}\n"},{"name":"proposal_test.gno","body":"package dao\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/testutils\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nvar (\n\tfutureTime = time.Now().Add(time.Hour)\n\tzeroTime   = time.Time{}\n)\n\n// TODO: Improve proposal unit test using test cases and adding missing methods\nfunc TestProposal(t *testing.T) {\n\tcases := []struct {\n\t\tname, title, description string\n\t\tdao                      *gnome.DAO\n\t\terr                      error\n\t}{\n\t\t{\n\t\t\tname:        \"ok\",\n\t\t\tdao:         gnome.MustNew(\"test\", \"Test\"),\n\t\t\ttitle:       \"Proposal\",\n\t\t\tdescription: \"Test proposal\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty DAO\",\n\t\t\terr:  errors.New(\"proposal DAO is required\"),\n\t\t},\n\t\t{\n\t\t\tname: \"empty title\",\n\t\t\tdao:  gnome.MustNew(\"test\", \"Test\"),\n\t\t\terr:  errors.New(\"proposal title is required\"),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tid := gnome.ID(1)\n\t\t\tproposer := testutils.TestAddress(\"proposer\")\n\t\t\tstrategy := testStrategy{}\n\t\t\tstatus := gnome.StatusActive\n\t\t\topts := []gnome.ProposalOption{\n\t\t\t\tgnome.WithDescription(tc.description),\n\t\t\t}\n\n\t\t\t// Act\n\t\t\tproposal, err := gnome.NewProposal(id, strategy, proposer, tc.dao, tc.title, opts...)\n\n\t\t\t// Assert\n\t\t\tif tc.err != nil {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif got := proposal.ID(); got != id {\n\t\t\t\tt.Fatalf(\"expected ID: %d, got: %d\", id, got)\n\t\t\t}\n\n\t\t\tif got := proposal.DAO(); got.Name() != tc.dao.Name() {\n\t\t\t\tt.Fatalf(\"expected DAO: '%s', got: '%s'\", tc.dao.Name(), got.Name())\n\t\t\t}\n\n\t\t\tif got := proposal.Title(); got != tc.title {\n\t\t\t\tt.Fatalf(\"expected title: '%s', got: '%s'\", tc.title, got)\n\t\t\t}\n\n\t\t\tif got := proposal.Description(); got != tc.description {\n\t\t\t\tt.Fatalf(\"expected description: '%s', got: '%s'\", tc.description, got)\n\t\t\t}\n\n\t\t\tif got := proposal.StatusReason(); got != \"\" {\n\t\t\t\tt.Fatalf(\"expected empty dismiss reason, got: '%s'\", got)\n\t\t\t}\n\n\t\t\tif got := proposal.Proposer(); got != proposer {\n\t\t\t\tt.Fatalf(\"expected proposer: '%s', got: '%s'\", proposer, got)\n\t\t\t}\n\n\t\t\tif got := proposal.CreatedAt(); got.IsZero() {\n\t\t\t\tt.Fatalf(\"expected a valid creation time, got: '%s'\", got.String())\n\t\t\t}\n\n\t\t\tif c := len(proposal.Promotions()); c != 0 {\n\t\t\t\tt.Fatalf(\"expected an empty list of promotions, got: %d DAOs\", c)\n\t\t\t}\n\n\t\t\tif got := proposal.VotingDeadline(); got.IsZero() {\n\t\t\t\tt.Fatalf(\"expected a valid deadline time, got: '%s'\", got.String())\n\t\t\t}\n\n\t\t\tnow := time.Now()\n\t\t\tif got := proposal.VotingDeadline(); got.Before(now) { // TODO: Using after makes assertion fail (?)\n\t\t\t\tt.Fatalf(\"expected deadline to happen after: '%s', got: '%s'\", now.String(), got.String())\n\t\t\t}\n\n\t\t\tif got := proposal.Status(); got != status {\n\t\t\t\tt.Fatalf(\"expected status: %d, got: %d\", status, got)\n\t\t\t}\n\n\t\t\tif got := proposal.Strategy().Name(); got != strategy.Name() {\n\t\t\t\tt.Fatalf(\"expected strategy: '%s', got: '%s'\", strategy.Name(), got)\n\t\t\t}\n\n\t\t\tif got := proposal.Strategy().Name(); got != strategy.Name() {\n\t\t\t\tt.Fatalf(\"expected strategy: '%s', got: '%s'\", strategy.Name(), got)\n\t\t\t}\n\n\t\t\tif c := len(proposal.Votes()); c != 0 {\n\t\t\t\tt.Fatalf(\"expected no votes, got: %d votes\", c)\n\t\t\t}\n\n\t\t\tif c := proposal.VotingRecord().VoteCount(); c != 0 {\n\t\t\t\tt.Fatalf(\"expected an empty votes record, got: %d records\", c)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProposalWithdraw(t *testing.T) {\n\t// TODO: Test success cases where proposal status is review\n\twantErr := gnome.ErrReviewStatusRequired\n\twantStatus := gnome.StatusWithdrawed\n\tproposal := mustCreateProposal(t, testStrategy{}, gnome.WithReviewDeadline(futureTime))\n\n\tif err := proposal.Withdraw(); err != nil {\n\t\tt.Fatalf(\"expected no error, got: '%s'\", err.Error())\n\t}\n\n\tif err := proposal.Withdraw(); err != wantErr {\n\t\tt.Fatalf(\"expected error: '%s', got: '%s'\", wantErr.Error(), err.Error())\n\t}\n\n\tif got := proposal.Status(); got != wantStatus {\n\t\tt.Fatalf(\"expected status: %d, got: %d\", wantStatus, got)\n\t}\n}\n\nfunc TestProposalDismiss(t *testing.T) {\n\tcases := []struct {\n\t\tname, reason string\n\t\tstatus       gnome.ProposalStatus\n\t\terr          error\n\t}{\n\t\t{\n\t\t\tname:   \"ok\",\n\t\t\treason: \"Foo\",\n\t\t\tstatus: gnome.StatusDismissed,\n\t\t},\n\t\t{\n\t\t\tname: \"empty reason\",\n\t\t\terr:  gnome.ErrReasonRequired,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tproposal := mustCreateProposal(t, testStrategy{})\n\n\t\t\t// Act\n\t\t\terr := proposal.Dismiss(tc.reason)\n\n\t\t\t// Assert\n\t\t\tif tc.err != nil {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif got := proposal.Status(); got != tc.status {\n\t\t\t\tt.Fatalf(\"expected status: %s, got: %s\", tc.status.String(), got.String())\n\t\t\t}\n\n\t\t\tif got := proposal.StatusReason(); got != tc.reason {\n\t\t\t\tt.Fatalf(\"expected dismiss reason: '%s', got: '%s'\", tc.reason, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProposalActivate(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\tstatus gnome.ProposalStatus\n\t\tsetup  func(*gnome.Proposal)\n\t\terr    error\n\t}{\n\t\t{\n\t\t\tname:   \"ok\",\n\t\t\tstatus: gnome.StatusActive,\n\t\t},\n\t\t{\n\t\t\tname: \"review status required\",\n\t\t\tsetup: func(p *gnome.Proposal) {\n\t\t\t\tp.Activate()\n\t\t\t},\n\t\t\terr: gnome.ErrReviewStatusRequired,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tproposal := mustCreateProposal(t, testStrategy{}, gnome.WithReviewDeadline(futureTime))\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(proposal)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\terr := proposal.Activate()\n\n\t\t\t// Assert\n\t\t\tif tc.err != nil {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif got := proposal.Status(); got != tc.status {\n\t\t\t\tt.Fatalf(\"expected status: %s, got: %s\", tc.status.String(), got.String())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProposalPromote(t *testing.T) {\n\tstrategy := testStrategy{}\n\taddr := testutils.TestAddress(\"proposer\")\n\tcases := []struct {\n\t\tname     string\n\t\tdaoNames []string\n\t\tsetup    func() (*gnome.Proposal, *gnome.DAO)\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"promote to parent\",\n\t\t\tdaoNames: []string{\"child\", \"parent\"},\n\t\t\tsetup: func() (*gnome.Proposal, *gnome.DAO) {\n\t\t\t\tchild := gnome.MustNew(\"child\", \"Child\")\n\t\t\t\tparent := gnome.MustNew(\"parent\", \"Parent\", gnome.WithSubDAO(child))\n\t\t\t\tp, _ := gnome.NewProposal(1, strategy, addr, child, \"Title\")\n\t\t\t\treturn p, parent\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"promote to root\",\n\t\t\tdaoNames: []string{\"child\", \"root\"},\n\t\t\tsetup: func() (*gnome.Proposal, *gnome.DAO) {\n\t\t\t\tchild := gnome.MustNew(\"child\", \"Child\")\n\t\t\t\troot := gnome.MustNew(\"root\", \"Root\", gnome.WithSubDAO(\n\t\t\t\t\tgnome.MustNew(\"parent\", \"Parent\", gnome.WithSubDAO(child)),\n\t\t\t\t))\n\t\t\t\tp, _ := gnome.NewProposal(1, strategy, addr, child, \"Title\")\n\t\t\t\treturn p, root\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"promote to non parent\",\n\t\t\tsetup: func() (*gnome.Proposal, *gnome.DAO) {\n\t\t\t\tchild := gnome.MustNew(\"child\", \"Child\")\n\t\t\t\tgnome.MustNew(\"parent\", \"Parent\", gnome.WithSubDAO(child))\n\t\t\t\tp, _ := gnome.NewProposal(1, strategy, addr, child, \"Title\")\n\t\t\t\treturn p, gnome.MustNew(\"foo\", \"Foo\")\n\t\t\t},\n\t\t\terr: gnome.ErrProposalPromote,\n\t\t},\n\t\t{\n\t\t\tname:     \"promote with one promotion\",\n\t\t\tdaoNames: []string{\"child\", \"parent\", \"root\"},\n\t\t\tsetup: func() (*gnome.Proposal, *gnome.DAO) {\n\t\t\t\tchild := gnome.MustNew(\"child\", \"Child\")\n\t\t\t\tparent := gnome.MustNew(\"parent\", \"Parent\", gnome.WithSubDAO(child))\n\t\t\t\troot := gnome.MustNew(\"root\", \"Root\", gnome.WithSubDAO(parent))\n\t\t\t\tp, _ := gnome.NewProposal(1, strategy, addr, child, \"Title\")\n\t\t\t\tp.Promote(parent)\n\t\t\t\treturn p, root\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tp, dao := tc.setup()\n\n\t\t\tdeadline := time.Now().Add(-time.Hour * 24)\n\t\t\tp.votingDeadline = deadline // Change deadline to check that its resetted on promote\n\n\t\t\tp.VotingRecord().Add(gnome.Vote{}) // Add a single dummy vote for the current DAO\n\n\t\t\t// Act\n\t\t\terr := p.Promote(dao)\n\n\t\t\t// Assert\n\t\t\tif tc.err != nil {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassertNoError(t, err)\n\n\t\t\tif !p.HasBeenPromoted() {\n\t\t\t\tt.Fatal(\"expected proposal to be promotedt\")\n\t\t\t}\n\n\t\t\tif !p.HasPromotion(dao.Path()) {\n\t\t\t\tt.Fatal(\"expected proposal promotions to include the DAO\")\n\t\t\t}\n\n\t\t\tif got := p.VotingDeadline(); !got.After(deadline) {\n\t\t\t\tt.Fatalf(\"expected voting deadline to be greater than original deadline: %d, got: %d\", deadline.Unix(), got.Unix())\n\t\t\t}\n\n\t\t\tif p.VotingRecord().VoteCount() != 0 {\n\t\t\t\tt.Fatal(\"expected the voting record to be empty\")\n\t\t\t}\n\n\t\t\tpromotions := p.Promotions()\n\t\t\tif c := len(promotions); c != len(tc.daoNames) {\n\t\t\t\tt.Fatalf(\"expected promotions count: %d, got: %d DAOs\", len(tc.daoNames), c)\n\t\t\t}\n\n\t\t\tfor i, dao := range promotions {\n\t\t\t\tif got := dao.Name(); tc.daoNames[i] != got {\n\t\t\t\t\tt.Fatalf(\"expected DAO name: '%s', got: '%s'\", tc.daoNames[i], got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProposalVote(t *testing.T) {\n\tmemberAddr := testutils.TestAddress(\"member\")\n\tsetupDAOMember := func(p *gnome.Proposal) {\n\t\tp.DAO().AddMember(gnome.NewMember(memberAddr))\n\t}\n\n\tcases := []struct {\n\t\tname, reason string\n\t\taddress      std.Address\n\t\tchoice       gnome.VoteChoice\n\t\tvoteCount    int\n\t\toptions      []gnome.ProposalOption\n\t\tsetup        func(*gnome.Proposal)\n\t\terr          error\n\t}{\n\t\t{\n\t\t\tname:      \"ok\",\n\t\t\taddress:   memberAddr,\n\t\t\tchoice:    gnome.ChoiceYes,\n\t\t\tvoteCount: 1,\n\t\t\tsetup:     setupDAOMember,\n\t\t},\n\t\t{\n\t\t\tname:    \"proposal not active\",\n\t\t\taddress: memberAddr,\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\toptions: []gnome.ProposalOption{\n\t\t\t\tgnome.WithReviewDeadline(futureTime),\n\t\t\t},\n\t\t\terr: gnome.ErrProposalNotActive,\n\t\t\tsetup: func(p *gnome.Proposal) {\n\t\t\t\tsetupDAOMember(p)\n\t\t\t\tp.Withdraw()\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"vote with invalid reason\",\n\t\t\taddress: memberAddr,\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\treason:  \"1234\",\n\t\t\terr:     gnome.ErrInvalidReason,\n\t\t\tsetup:   setupDAOMember,\n\t\t},\n\t\t{\n\t\t\tname:      \"already voted\",\n\t\t\taddress:   memberAddr,\n\t\t\tchoice:    gnome.ChoiceYes,\n\t\t\tvoteCount: 1,\n\t\t\toptions: []gnome.ProposalOption{\n\t\t\t\tgnome.WithVoteChangeDuration(-1),\n\t\t\t},\n\t\t\terr: gnome.ErrAlreadyVoted,\n\t\t\tsetup: func(p *gnome.Proposal) {\n\t\t\t\tsetupDAOMember(p)\n\t\t\t\tp.Vote(memberAddr, gnome.ChoiceYes, \"\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"vote after proposal deadline\",\n\t\t\taddress: memberAddr,\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\toptions: []gnome.ProposalOption{\n\t\t\t\tgnome.WithVotingDeadline(zeroTime),\n\t\t\t},\n\t\t\terr:   gnome.ErrProposalVotingDeadlineMet,\n\t\t\tsetup: setupDAOMember,\n\t\t},\n\t\t{\n\t\t\tname:    \"non member vote not allowed\",\n\t\t\taddress: memberAddr,\n\t\t\tchoice:  gnome.ChoiceYes,\n\t\t\terr:     gnome.ErrMemberVoteNotAllowed,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tproposal := mustCreateProposal(t, testStrategy{}, tc.options...)\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(proposal)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\terr := proposal.Vote(tc.address, tc.choice, tc.reason)\n\n\t\t\t// Assert\n\t\t\tif tc.err != nil {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t} else {\n\t\t\t\tassertNoError(t, err)\n\t\t\t}\n\n\t\t\tvotes := proposal.Votes()\n\t\t\tvoteCount := len(votes)\n\t\t\tif voteCount != tc.voteCount {\n\t\t\t\tt.Fatalf(\"expected %d vote(s), got: %d\", tc.voteCount, voteCount)\n\t\t\t}\n\n\t\t\tif voteCount \u003e 0 {\n\t\t\t\tif got := votes[0].Address; got != tc.address {\n\t\t\t\t\tt.Fatalf(\"expected vote address: '%s', got: '%s'\", tc.address, got)\n\t\t\t\t}\n\n\t\t\t\tif got := votes[0].Choice; got != tc.choice {\n\t\t\t\t\tt.Fatalf(\"expected vote choice: '%s', got: '%s'\", tc.choice, got)\n\t\t\t\t}\n\n\t\t\t\tif got := votes[0].Reason; got != tc.reason {\n\t\t\t\t\tt.Fatalf(\"expected vote reason: '%s', got: '%s'\", tc.reason, got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProposalTally(t *testing.T) {\n\taddresses := [3]std.Address{\n\t\ttestutils.TestAddress(\"member1\"),\n\t\ttestutils.TestAddress(\"member2\"),\n\t\ttestutils.TestAddress(\"member3\"),\n\t}\n\tsetupDAOMembers := func(p *gnome.Proposal) {\n\t\tdao := p.DAO()\n\t\tfor _, addr := range addresses {\n\t\t\tdao.AddMember(gnome.NewMember(addr))\n\t\t}\n\t}\n\n\tcases := []struct {\n\t\tname                 string\n\t\tvotes                []gnome.Vote\n\t\tchoice               gnome.VoteChoice\n\t\tstrategy             gnome.ProposalStrategy\n\t\tstatus               gnome.ProposalStatus\n\t\tstatusReason         string\n\t\tvotingDeadlinePassed bool\n\t\toptions              []gnome.ProposalOption\n\t\tsetup                func(*gnome.Proposal)\n\t\terr                  error\n\t}{\n\t\t{\n\t\t\tname: \"proposal pass\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Address: addresses[0], Choice: gnome.ChoiceYes},\n\t\t\t\t{Address: addresses[1], Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tchoice:   gnome.ChoiceYes,\n\t\t\tstrategy: testStrategy{gnome.ChoiceYes},\n\t\t\tstatus:   gnome.StatusPassed,\n\t\t\toptions:  []gnome.ProposalOption{gnome.WithVotingDeadline(zeroTime)},\n\t\t\tsetup:    setupDAOMembers,\n\t\t},\n\t\t{\n\t\t\tname: \"proposal rejected\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Address: addresses[0], Choice: gnome.ChoiceYes},\n\t\t\t\t{Address: addresses[1], Choice: gnome.ChoiceNo},\n\t\t\t\t{Address: addresses[2], Choice: gnome.ChoiceNo},\n\t\t\t},\n\t\t\tchoice:   gnome.ChoiceNo,\n\t\t\tstrategy: testStrategy{gnome.ChoiceNo},\n\t\t\tstatus:   gnome.StatusRejected,\n\t\t\toptions:  []gnome.ProposalOption{gnome.WithVotingDeadline(zeroTime)},\n\t\t\tsetup:    setupDAOMembers,\n\t\t},\n\t\t{\n\t\t\tname: \"no quorum\",\n\t\t\tvotes: []gnome.Vote{\n\t\t\t\t{Address: addresses[0], Choice: gnome.ChoiceYes},\n\t\t\t},\n\t\t\tstrategy:     testStrategy{},\n\t\t\tstatus:       gnome.StatusRejected,\n\t\t\tstatusReason: \"low participation\",\n\t\t\toptions:      []gnome.ProposalOption{gnome.WithVotingDeadline(zeroTime)},\n\t\t\tsetup:        setupDAOMembers,\n\t\t},\n\t\t{\n\t\t\tname:     \"proposal not active\",\n\t\t\tstatus:   gnome.StatusWithdrawed,\n\t\t\toptions:  []gnome.ProposalOption{gnome.WithReviewDeadline(futureTime)},\n\t\t\tstrategy: testStrategy{},\n\t\t\tsetup: func(p *gnome.Proposal) {\n\t\t\t\tp.Withdraw()\n\t\t\t},\n\t\t\terr: gnome.ErrProposalNotActive,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Arrange\n\t\t\tproposal := mustCreateProposal(t, tc.strategy, tc.options...)\n\n\t\t\tfor _, v := range tc.votes {\n\t\t\t\t// Add votes directly to the record because deadline might be expired for some test cases\n\t\t\t\tproposal.VotingRecord().Add(v)\n\t\t\t}\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(proposal)\n\t\t\t}\n\n\t\t\t// Act\n\t\t\terr := proposal.Tally()\n\n\t\t\t// Assert\n\t\t\tif tc.err != nil {\n\t\t\t\tassertError(t, tc.err, err)\n\t\t\t} else {\n\t\t\t\tassertNoError(t, err)\n\t\t\t}\n\n\t\t\tif got := proposal.Status(); got != tc.status {\n\t\t\t\tt.Fatalf(\"expected status: %d, got: %d\", tc.status, got)\n\t\t\t}\n\n\t\t\tif got := proposal.StatusReason(); got != tc.statusReason {\n\t\t\t\tt.Fatalf(\"expected status reason: '%s', got: '%s'\", tc.statusReason, got)\n\t\t\t}\n\n\t\t\tif got := proposal.Choice(); got != tc.choice {\n\t\t\t\tt.Fatalf(\"expected winner choice: '%s', got: '%s'\", tc.choice, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc mustCreateProposal(t *testing.T, s gnome.ProposalStrategy, options ...gnome.ProposalOption) *gnome.Proposal {\n\tt.Helper()\n\n\tdao := gnome.MustNew(\"test\", \"Test\")\n\taddr := testutils.TestAddress(\"proposer\")\n\tproposal, err := gnome.NewProposal(1, s, addr, dao, \"Title\", options...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn proposal\n}\n\nfunc assertError(t *testing.T, expected interface{}, actual error) {\n\tt.Helper()\n\n\twant, ok := expected.(string)\n\tif !ok {\n\t\tif err, ok := expected.(error); ok {\n\t\t\twant = err.Error()\n\t\t}\n\t}\n\n\tif actual == nil {\n\t\tt.Fatalf(\"expected error: '%s', got no error\", want)\n\t}\n\n\tif want != actual.Error() {\n\t\tt.Fatalf(\"expected error: '%s', got: '%s'\", want, actual.Error())\n\t}\n}\n\nfunc assertNoError(t *testing.T, err interface{}) {\n\tt.Helper()\n\n\tif err == nil {\n\t\treturn\n\t}\n\n\tactual, ok := err.(string)\n\tif !ok {\n\t\tif e, ok := err.(error); ok {\n\t\t\tactual = e.Error()\n\t\t}\n\t}\n\n\tif actual != \"\" {\n\t\tt.Fatalf(\"expected no error, got: '%s'\", actual)\n\t}\n}\n\ntype testStrategy struct {\n\tChoice gnome.VoteChoice\n}\n\nfunc (testStrategy) Name() string                                            { return \"test\" }\nfunc (testStrategy) Quorum() float64                                         { return 0.51 }\nfunc (testStrategy) VotingPeriod() time.Duration                             { return time.Hour * 24 * 2 }\nfunc (s testStrategy) Tally(*gnome.DAO, gnome.VotingRecord) gnome.VoteChoice { return s.Choice }\n\nfunc (testStrategy) VoteChoices() []gnome.VoteChoice {\n\treturn []gnome.VoteChoice{gnome.ChoiceYes, gnome.ChoiceNo}\n}\n"},{"name":"record.gno","body":"package dao\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// VotingRecordIterFn defines the a callback to iterate voting choices.\ntype VotingRecordIterFn func(_ VoteChoice, voteCount uint) bool\n\n// NewVotingRecord creates a new voting record.\nfunc NewVotingRecord() *VotingRecord {\n\treturn \u0026VotingRecord{}\n}\n\n// VotingRecord mamages votes and vote count.\ntype VotingRecord struct {\n\tvotes   []Vote\n\tcounter avl.Tree // VoteChoice -\u003e count (uint)\n}\n\n// Votes return the list of votes.\nfunc (r VotingRecord) Votes() []Vote {\n\treturn r.votes\n}\n\n// VoteCount returns the number of votes.\nfunc (r VotingRecord) VoteCount() int {\n\treturn len(r.votes)\n}\n\n// Get returns the number of votes for vote choice.\nfunc (r VotingRecord) Get(c VoteChoice) uint {\n\tkey := string(c)\n\tif v, ok := r.counter.Get(key); ok {\n\t\treturn v.(uint)\n\t}\n\treturn 0\n}\n\n// Add adds a vote to the record.\nfunc (r *VotingRecord) Add(v Vote) {\n\tr.votes = append(r.votes, v)\n\tkey := string(v.Choice)\n\tr.counter.Set(key, r.Get(v.Choice)+1)\n}\n\n// Remove removes a vote from the record.\nfunc (r *VotingRecord) Remove(addr std.Address) bool {\n\tfor i, v := range r.votes {\n\t\tif v.Address == addr {\n\t\t\tr.votes = append(r.votes[:i], r.votes[i+1:]...)\n\t\t\tkey := string(v.Choice)\n\t\t\tr.counter.Set(key, r.Get(v.Choice)-1)\n\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Iterate iterates all vote choices.\nfunc (r VotingRecord) Iterate(fn VotingRecordIterFn) bool {\n\treturn r.counter.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tchoice := VoteChoice(key)\n\t\treturn fn(choice, value.(uint))\n\t})\n}\n\n// SelectChoiceByMajority select the vote choice by majority.\n// Vote choice is a majority when chosen by more than half of the votes.\n// Majority type is defined by the caller depending on the vote records and abstentions, it would be\n// absolute majority if abstentions are considered, otherwise it would be considered simple majority.\nfunc SelectChoiceByMajority(r VotingRecord, abstentions int) (VoteChoice, bool) {\n\tvotesCount := r.VoteCount() + abstentions\n\tchoice := getMajorityChoice(r)\n\tisMajority := r.Get(choice) \u003e uint(votesCount/2)\n\treturn choice, isMajority\n}\n\n// SelectChoiceBySuperMajority select the vote choice by super majority using a 2/3s threshold.\n// Abstentions are not considered when calculating the super majority choice.\nfunc SelectChoiceBySuperMajority(r VotingRecord) (VoteChoice, bool) {\n\tchoice := getMajorityChoice(r)\n\tisMajority := r.Get(choice) \u003e uint((2*r.VoteCount())/3) // TODO: Allow threshold customization\n\treturn choice, isMajority\n}\n\n// SelectChoiceByPlurality selects the vote choice by plurality.\n// The choice will be considered a majority if it has votes and if there is no other\n// choice with the same number of votes. A tie won't be considered majority.\nfunc SelectChoiceByPlurality(r VotingRecord) (VoteChoice, bool) {\n\tvar (\n\t\tchoice       VoteChoice\n\t\tcurrentCount uint\n\t\tisMajority   bool\n\t)\n\n\tr.Iterate(func(c VoteChoice, count uint) bool {\n\t\tif currentCount \u003c count {\n\t\t\tchoice = c\n\t\t\tcurrentCount = count\n\t\t\tisMajority = true\n\t\t} else if currentCount == count {\n\t\t\tisMajority = false\n\t\t}\n\t\treturn false\n\t})\n\treturn choice, isMajority\n}\n\n// getMajorityChoice returns the choice voted by the majority.\n// The result is only valid when there is a majority.\n// Caller must validate that the returned choice represents a majority.\nfunc getMajorityChoice(r VotingRecord) VoteChoice {\n\tvar (\n\t\tchoice       VoteChoice\n\t\tcurrentCount uint\n\t)\n\n\tr.Iterate(func(c VoteChoice, count uint) bool {\n\t\tif currentCount \u003c count {\n\t\t\tchoice = c\n\t\t\tcurrentCount = count\n\t\t}\n\t\treturn false\n\t})\n\n\treturn choice\n}\n"},{"name":"record_test.gno","body":"package dao\n\nimport (\n\t\"testing\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc TestVotingRecord(t *testing.T) {\n\t// Act\n\trecord := NewVotingRecord()\n\n\t// Assert\n\tif got := record.Votes(); got != nil {\n\t\tt.Fatalf(\"expected no votes, got: %d\", len(got))\n\t}\n\n\tif got := record.VoteCount(); got != 0 {\n\t\tt.Fatalf(\"expected no vote count: 0, got: %d\", got)\n\t}\n}\n\nfunc TestVotingRecordAdd(t *testing.T) {\n\t// Arrange\n\trecord := NewVotingRecord()\n\tvote := gnome.Vote{Choice: gnome.ChoiceYes}\n\n\t// Act\n\trecord.Add(vote)\n\n\t// Assert\n\tvotes := record.Votes()\n\tif c := len(votes); c != 1 {\n\t\tt.Fatalf(\"expected one votes, got: %d\", c)\n\t}\n\n\tif got := votes[0]; got != vote {\n\t\tt.Fatalf(\"expected vote: %v, got: %v\", vote, got)\n\t}\n\n\tif got := record.VoteCount(); got != 1 {\n\t\tt.Fatalf(\"expected vote count: %d, got: %d\", 1, got)\n\t}\n\n\tif got := record.Get(vote.Choice); got != 1 {\n\t\tt.Fatalf(\"expected record to get one '%v' count, got: %d\", gnome.ChoiceYes, got)\n\t}\n\n\trecord.Iterate(func(v gnome.VoteChoice, count uint) bool {\n\t\tif v != gnome.ChoiceYes {\n\t\t\tt.Fatalf(\"expected iterate choice: %v, got: %v\", gnome.ChoiceYes, v)\n\t\t}\n\n\t\tif count != 1 {\n\t\t\tt.Fatalf(\"expected iterate vote count: %d, got: %d\", 1, count)\n\t\t}\n\n\t\treturn false\n\t})\n}\n\nfunc TestVotingRecordRemove(t *testing.T) {\n\tt.Skip(\"TODO: Write unit test for VotingRecord.Remove()\")\n}\n\nfunc TestSelectChoiceByMajority(t *testing.T) {\n\tt.Skip(\"TODO: Write unit test for SelectChoiceByMajority\")\n}\n\nfunc TestSelectChoiceBySuperMajority(t *testing.T) {\n\tt.Skip(\"TODO: Write unit test for SelectChoiceBySuperMajority\")\n}\n\nfunc TestSelectChoiceByPlurality(t *testing.T) {\n\tt.Skip(\"TODO: Write unit test for SelectChoiceByPlurality\")\n}\n"},{"name":"render.gno","body":"package dao\n\nimport (\n\t\"strings\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// EscapeHTML escapes special characters like \"\u003c\" to become \"\u0026lt;\".\n// It escapes only five such characters: \u003c, \u003e, \u0026, ' and \".\nfunc EscapeHTML(s string) string {\n\ts = strings.ReplaceAll(s, `\u0026`, \"\u0026amp;\")\n\ts = strings.ReplaceAll(s, `\"`, \"\u0026#34;\")\n\ts = strings.ReplaceAll(s, `'`, \"\u0026#39;\")\n\ts = strings.ReplaceAll(s, `\u003c`, \"\u0026lt;\")\n\treturn strings.ReplaceAll(s, `\u003e`, \"\u0026gt;\")\n}\n\n// NewLink creates a new Markdown link.\nfunc NewLink(text, uri string) string {\n\treturn ufmt.Sprintf(\"[%s](%s)\", text, uri)\n}\n\n// NewLinkURI creates a new Markdown link where text and URI are the same.\nfunc NewLinkURI(uri string) string {\n\treturn ufmt.Sprintf(\"[%s](%s)\", uri, uri)\n}\n"},{"name":"strategy.gno","body":"package dao\n\nimport (\n\t\"std\"\n\t\"time\"\n)\n\ntype (\n\t// VoteChoiceRecord contains the number of counted votes for a single voting choice.\n\tVoteChoiceRecord struct {\n\t\tChoice VoteChoice\n\t\tCount  uint\n\t}\n\n\t// ProposalStrategy defines the interface for the different proposal types.\n\tProposalStrategy interface {\n\t\t// Name returns the name of the strategy.\n\t\tName() string\n\n\t\t// Quorum returns the minimum required percentage of DAO member votes\n\t\t// required for a proposal to pass.\n\t\tQuorum() float64\n\n\t\t// VotingPeriod returns the period that a proposal should allow voting.\n\t\tVotingPeriod() time.Duration\n\n\t\t// VoteChoices returns the valid voting choices for the strategy.\n\t\tVoteChoices() []VoteChoice\n\n\t\t// Tally counts the votes and returns the winner voting choice.\n\t\t// The DAO argument is the DAO that the proposal is currently assigned to,\n\t\t// by default the one where the proposal was created.\n\t\t// Proposals can be promoted to parent DAOs in which case the DAO argument\n\t\t// is the DAO where the proposal was promoted the last time.\n\t\tTally(*DAO, VotingRecord) VoteChoice\n\t}\n)\n\n// VoteChecker defines an interface for proposal vote validation.\n// Proposal strategies that require checking votes when they are submitted should implement it.\ntype VoteChecker interface {\n\t// CheckVote checks that a vote is valid for the strategy.\n\tCheckVote(member std.Address, choice VoteChoice, reason string) error\n}\n\n// Executer defines an interface for executable proposals.\n// Proposals strategies that implement the interface can modify the DAO state when proposal passes.\ntype Executer interface {\n\t// Execute executes the proposal.\n\t// The DAO argument is the DAO where the proposal was created, even if the proposal has been promoted\n\t// to a parent DAO.\n\t// TODO: Execute should return some feedback on success\n\tExecute(*DAO) error\n}\n\n// Validator defines an interface for proposal validation.\n// Proposal strategies that implement the interface can validate that a proposal is valid for the current state.\ntype Validator interface {\n\t// Validate validates if a proposal is valid for the current state.\n\tValidate(*Proposal) error\n}\n\n// ParamsRenderer defines an interface to allow strategies to render its input parameters.\ntype ParamsRenderer interface {\n\t// RenderParams returns a markdown with the rendered strategy parameters.\n\tRenderParams() string\n}\n"},{"name":"uri.gno","body":"package dao\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar reSlug = regexp.MustCompile(\"^[a-zA-Z]+[a-zA-Z0-9-_]*$\")\n\n// IsSlug checks if a string is a valid slug.\nfunc IsSlug(s string) bool {\n\treturn reSlug.MatchString(s)\n}\n\n// SplitRealmURI splits a Gnoland URI into Realm URI and render path.\nfunc SplitRealmURI(uri string) (realmURI, renderPath string) {\n\tif uri == \"\" {\n\t\treturn\n\t}\n\n\tparts := strings.SplitN(uri, \":\", 2)\n\trealmURI = parts[0]\n\tif len(parts) \u003e 1 {\n\t\trenderPath = parts[1]\n\t}\n\treturn\n}\n"},{"name":"uri_test.gno","body":"package dao\n\nimport (\n\t\"testing\"\n\n\tgnome \"gno.land/p/ecodevx/dao\"\n)\n\nfunc TestSplitRealmURI(t *testing.T) {\n\tcases := []struct {\n\t\tname, uri, realmURI, renderPath string\n\t}{\n\t\t{\n\t\t\tname:     \"realm URI\",\n\t\t\turi:      \"gno.land/r/gnome\",\n\t\t\trealmURI: \"gno.land/r/gnome\",\n\t\t},\n\t\t{\n\t\t\tname:       \"realm URI with render path\",\n\t\t\turi:        \"gno.land/r/gnome:foo/bar\",\n\t\t\trealmURI:   \"gno.land/r/gnome\",\n\t\t\trenderPath: \"foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname:       \"realm URI with render path\",\n\t\t\turi:        \"gno.land/r/gnome:foo/bar\",\n\t\t\trealmURI:   \"gno.land/r/gnome\",\n\t\t\trenderPath: \"foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty URI\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Act\n\t\t\trealmURI, renderPath := gnome.SplitRealmURI(tc.uri)\n\n\t\t\t// Assert\n\t\t\tif realmURI != tc.realmURI {\n\t\t\t\tt.Fatalf(\"expected realm URI: '%s', got: '%s'\", tc.realmURI, realmURI)\n\t\t\t}\n\n\t\t\tif renderPath != tc.renderPath {\n\t\t\t\tt.Fatalf(\"expected render path: '%s', got: '%s'\", tc.renderPath, renderPath)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"19000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgT3cOUK7x6Ivse+Ariq29QhVsmMuVVG1uY4cWpE0u4s"},"signature":"8zyTQdQdyob3bdmarIkIIIbX89vvT7m8K5DzUedQndNvJh9clxUHFRzDtiy3dJzspi+pT7yYmesBaOUJYr3mng=="}],"memo":""},"blockNum":"2128805"}
