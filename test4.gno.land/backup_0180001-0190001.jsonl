{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","package":{"name":"utf16","path":"gno.land/p/teritori/utf16","files":[{"name":"utf16.gno","body":"// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package utf16 implements encoding and decoding of UTF-16 sequences.\npackage utf16\n\n// The conditions replacementChar==unicode.ReplacementChar and\n// maxRune==unicode.MaxRune are verified in the tests.\n// Defining them locally avoids this package depending on package unicode.\n\nconst (\n\treplacementChar = '\\uFFFD'     // Unicode replacement character\n\tmaxRune         = '\\U0010FFFF' // Maximum valid Unicode code point.\n)\n\nconst (\n\t// 0xd800-0xdc00 encodes the high 10 bits of a pair.\n\t// 0xdc00-0xe000 encodes the low 10 bits of a pair.\n\t// the value is those 20 bits plus 0x10000.\n\tsurr1 = 0xd800\n\tsurr2 = 0xdc00\n\tsurr3 = 0xe000\n\n\tsurrSelf = 0x10000\n)\n\n// IsSurrogate reports whether the specified Unicode code point\n// can appear in a surrogate pair.\nfunc IsSurrogate(r rune) bool {\n\treturn surr1 \u003c= r \u0026\u0026 r \u003c surr3\n}\n\n// DecodeRune returns the UTF-16 decoding of a surrogate pair.\n// If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\n// the Unicode replacement code point U+FFFD.\nfunc DecodeRune(r1, r2 rune) rune {\n\tif surr1 \u003c= r1 \u0026\u0026 r1 \u003c surr2 \u0026\u0026 surr2 \u003c= r2 \u0026\u0026 r2 \u003c surr3 {\n\t\treturn (r1-surr1)\u003c\u003c10 | (r2 - surr2) + surrSelf\n\t}\n\treturn replacementChar\n}\n\n// EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\n// If the rune is not a valid Unicode code point or does not need encoding,\n// EncodeRune returns U+FFFD, U+FFFD.\nfunc EncodeRune(r rune) (r1, r2 rune) {\n\tif r \u003c surrSelf || r \u003e maxRune {\n\t\treturn replacementChar, replacementChar\n\t}\n\tr -= surrSelf\n\treturn surr1 + (r\u003e\u003e10)\u00260x3ff, surr2 + r\u00260x3ff\n}\n\n// Encode returns the UTF-16 encoding of the Unicode code point sequence s.\nfunc Encode(s []rune) []uint16 {\n\tn := len(s)\n\tfor _, v := range s {\n\t\tif v \u003e= surrSelf {\n\t\t\tn++\n\t\t}\n\t}\n\n\ta := make([]uint16, n)\n\tn = 0\n\tfor _, v := range s {\n\t\tswitch {\n\t\tcase 0 \u003c= v \u0026\u0026 v \u003c surr1, surr3 \u003c= v \u0026\u0026 v \u003c surrSelf:\n\t\t\t// normal rune\n\t\t\ta[n] = uint16(v)\n\t\t\tn++\n\t\tcase surrSelf \u003c= v \u0026\u0026 v \u003c= maxRune:\n\t\t\t// needs surrogate sequence\n\t\t\tr1, r2 := EncodeRune(v)\n\t\t\ta[n] = uint16(r1)\n\t\t\ta[n+1] = uint16(r2)\n\t\t\tn += 2\n\t\tdefault:\n\t\t\ta[n] = uint16(replacementChar)\n\t\t\tn++\n\t\t}\n\t}\n\treturn a[:n]\n}\n\n// Decode returns the Unicode code point sequence represented\n// by the UTF-16 encoding s.\nfunc Decode(s []uint16) []rune {\n\ta := make([]rune, len(s))\n\tn := 0\n\tfor i := 0; i \u003c len(s); i++ {\n\t\tswitch r := s[i]; {\n\t\tcase r \u003c surr1, surr3 \u003c= r:\n\t\t\t// normal rune\n\t\t\ta[n] = rune(r)\n\t\tcase surr1 \u003c= r \u0026\u0026 r \u003c surr2 \u0026\u0026 i+1 \u003c len(s) \u0026\u0026\n\t\t\tsurr2 \u003c= s[i+1] \u0026\u0026 s[i+1] \u003c surr3:\n\t\t\t// valid surrogate sequence\n\t\t\ta[n] = DecodeRune(rune(r), rune(s[i+1]))\n\t\t\ti++\n\t\tdefault:\n\t\t\t// invalid surrogate sequence\n\t\t\ta[n] = replacementChar\n\t\t}\n\t\tn++\n\t}\n\treturn a[:n]\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"50000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"vx1pYR8z9tlDZvGn+43nTf7lbAkzEJsngrSeodlKS1xf+yNLQNcS4TjBZ+2kKP+NUc5wpx8by7mTknTfTXfczA=="}],"memo":""},"blockNum":"181046"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","package":{"name":"ujson","path":"gno.land/p/teritori/ujson","files":[{"name":"format.gno","body":"package ujson\n\n// This package strives to have the same behavior as json.Marshal but does not support all types and returns strings\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/users\"\n)\n\ntype JSONAble interface {\n\tToJSON() string\n}\n\ntype FormatKV struct {\n\tKey   string\n\tValue interface{}\n\tRaw   bool\n}\n\n// does not work for slices, use FormatSlice instead\nfunc FormatAny(p interface{}) string {\n\tswitch p.(type) {\n\tcase std.Address:\n\t\treturn FormatString(string(p.(std.Address)))\n\tcase *avl.Tree:\n\t\treturn FormatAVLTree(p.(*avl.Tree))\n\tcase avl.Tree:\n\t\tt := p.(avl.Tree)\n\t\treturn FormatAVLTree(\u0026t)\n\tcase JSONAble:\n\t\treturn p.(JSONAble).ToJSON()\n\tcase string:\n\t\treturn FormatString(p.(string))\n\tcase uint64:\n\t\treturn FormatUint64(p.(uint64))\n\tcase uint32:\n\t\treturn FormatUint64(uint64(p.(uint32)))\n\tcase uint:\n\t\treturn FormatUint64(uint64(p.(uint)))\n\tcase int64:\n\t\treturn FormatInt64(p.(int64))\n\tcase int32:\n\t\treturn FormatInt64(int64(p.(int32)))\n\tcase int:\n\t\treturn FormatInt64(int64(p.(int)))\n\tcase float32:\n\t\tpanic(\"float32 not implemented\")\n\tcase float64:\n\t\tpanic(\"float64 not implemented\")\n\tcase bool:\n\t\treturn FormatBool(p.(bool))\n\tcase time.Time:\n\t\treturn FormatTime(p.(time.Time))\n\tcase time.Duration:\n\t\treturn FormatInt64(int64(p.(time.Duration)))\n\tcase users.AddressOrName:\n\t\treturn FormatString(string(p.(users.AddressOrName)))\n\tdefault:\n\t\treturn \"null\"\n\t}\n}\n\n// loosely ported from https://cs.opensource.google/go/go/+/master:src/time/time.go;l=1357?q=appendStrictRFC3339\u0026ss=go%2Fgo\nfunc FormatTime(t time.Time) string {\n\ts := t.Format(time.RFC3339Nano)\n\tb := []byte(s)\n\n\t// Not all valid Go timestamps can be serialized as valid RFC 3339.\n\t// Explicitly check for these edge cases.\n\t// See https://go.dev/issue/4556 and https://go.dev/issue/54580.\n\tn0 := 0\n\tnum2 := func(b []byte) byte { return 10*(b[0]-'0') + (b[1] - '0') }\n\tswitch {\n\tcase b[n0+len(\"9999\")] != '-': // year must be exactly 4 digits wide\n\t\tpanic(errors.New(\"year outside of range [0,9999]\"))\n\tcase b[len(b)-1] != 'Z':\n\t\tc := b[len(b)-len(\"Z07:00\")]\n\t\tif ('0' \u003c= c \u0026\u0026 c \u003c= '9') || num2(b[len(b)-len(\"07:00\"):]) \u003e= 24 {\n\t\t\tpanic(errors.New(\"timezone hour outside of range [0,23]\"))\n\t\t}\n\t}\n\treturn FormatString(string(b))\n}\n\nfunc FormatUint64(i uint64) string {\n\treturn strconv.FormatUint(i, 10)\n}\n\nfunc FormatInt64(i int64) string {\n\treturn strconv.FormatInt(i, 10)\n}\n\nfunc FormatSlice(s []interface{}) string {\n\telems := make([]string, len(s))\n\tfor i, elem := range s {\n\t\telems[i] = FormatAny(elem)\n\t}\n\treturn \"[\" + strings.Join(elems, \",\") + \"]\"\n}\n\nfunc FormatObject(kv []FormatKV) string {\n\telems := make([]string, len(kv))\n\ti := 0\n\tfor _, elem := range kv {\n\t\tvar val string\n\t\tif elem.Raw {\n\t\t\tval = elem.Value.(string)\n\t\t} else {\n\t\t\tval = FormatAny(elem.Value)\n\t\t}\n\t\telems[i] = FormatString(elem.Key) + \":\" + val\n\t\ti++\n\t}\n\treturn \"{\" + strings.Join(elems, \",\") + \"}\"\n}\n\nfunc FormatBool(b bool) string {\n\tif b {\n\t\treturn \"true\"\n\t}\n\treturn \"false\"\n}\n\nfunc FormatAVLTree(t *avl.Tree) string {\n\tif t == nil {\n\t\treturn \"{}\"\n\t}\n\tkv := make([]FormatKV, 0, t.Size())\n\tt.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tkv = append(kv, FormatKV{key, value, false})\n\t\treturn false\n\t})\n\treturn FormatObject(kv)\n}\n\nfunc FormatUnionMember(name string, val interface{}, raw bool) string {\n\treturn FormatObject([]FormatKV{\n\t\t{Key: name, Value: val, Raw: raw},\n\t})\n}\n"},{"name":"parse.gno","body":"package ujson\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/users\"\n)\n\n// https://stackoverflow.com/a/4150626\nconst whitespaces = \" \\t\\n\\r\"\n\ntype FromJSONAble interface {\n\tFromJSON(ast *JSONASTNode)\n}\n\n// does not work for slices, use ast exploration instead\nfunc (ast *JSONASTNode) ParseAny(ptr interface{}) {\n\tswitch ptr.(type) {\n\tcase *std.Address:\n\t\t*ptr.(*std.Address) = std.Address(ParseString(ast.Value))\n\tcase **avl.Tree:\n\t\tpanic(\"*avl.Tree not implemented, there is no way to know the type of the tree values, use a custom parser instead\")\n\tcase *avl.Tree:\n\t\tpanic(\"avl.Tree not implemented, there is no way to know the type of the tree values, use a custom parser instead\")\n\tcase *string:\n\t\tif ast.Kind != JSONKindValue {\n\t\t\tpanic(\"not a value\")\n\t\t}\n\t\tif ast.ValueKind != JSONTokenKindString {\n\t\t\tpanic(\"not a string\")\n\t\t}\n\t\t*ptr.(*string) = ParseString(ast.Value)\n\tcase *uint64:\n\t\tif ast.Kind != JSONKindValue {\n\t\t\tpanic(\"not a value\")\n\t\t}\n\t\tif ast.ValueKind != JSONTokenKindNumber {\n\t\t\tpanic(\"not a number\")\n\t\t}\n\t\t*ptr.(*uint64) = ParseUint64(ast.Value)\n\tcase *uint32:\n\t\tif ast.Kind != JSONKindValue {\n\t\t\tpanic(\"not a value\")\n\t\t}\n\t\tif ast.ValueKind != JSONTokenKindNumber {\n\t\t\tpanic(\"not a number\")\n\t\t}\n\t\t*ptr.(*uint32) = uint32(ParseUint64(ast.Value))\n\tcase *uint:\n\t\tif ast.Kind != JSONKindValue {\n\t\t\tpanic(\"not a value\")\n\t\t}\n\t\tif ast.ValueKind != JSONTokenKindNumber {\n\t\t\tpanic(\"not a number\")\n\t\t}\n\t\t*ptr.(*uint) = uint(ParseUint64(ast.Value))\n\tcase *int64:\n\t\tif ast.Kind != JSONKindValue {\n\t\t\tpanic(\"not a value\")\n\t\t}\n\t\tif ast.ValueKind != JSONTokenKindNumber {\n\t\t\tpanic(\"not a number\")\n\t\t}\n\t\t*ptr.(*int64) = ParseInt64(ast.Value)\n\tcase *int32:\n\t\tif ast.Kind != JSONKindValue {\n\t\t\tpanic(\"not a value\")\n\t\t}\n\t\tif ast.ValueKind != JSONTokenKindNumber {\n\t\t\tpanic(\"not a number\")\n\t\t}\n\t\t*ptr.(*int32) = int32(ParseInt64(ast.Value))\n\tcase *int:\n\t\tif ast.Kind != JSONKindValue {\n\t\t\tpanic(\"not a value\")\n\t\t}\n\t\tif ast.ValueKind != JSONTokenKindNumber {\n\t\t\tpanic(\"not a number\")\n\t\t}\n\t\t*ptr.(*int) = int(ParseInt64(ast.Value))\n\tcase *float64:\n\t\tpanic(\"float64 not implemented\")\n\tcase *float32:\n\t\tpanic(\"float32 not implemented\")\n\tcase *bool:\n\t\tif ast.Kind != JSONKindValue {\n\t\t\tpanic(\"not a value\")\n\t\t}\n\t\tif ast.ValueKind != JSONTokenKindTrue \u0026\u0026 ast.ValueKind != JSONTokenKindFalse {\n\t\t\tpanic(\"not a bool\")\n\t\t}\n\t\t*ptr.(*bool) = ast.ValueKind == JSONTokenKindTrue\n\tcase *FromJSONAble:\n\t\t(*(ptr.(*FromJSONAble))).FromJSON(ast)\n\tcase FromJSONAble:\n\t\tptr.(FromJSONAble).FromJSON(ast)\n\tcase **JSONASTNode:\n\t\t*ptr.(**JSONASTNode) = ast\n\tcase *time.Time:\n\t\tast.ParseTime(ptr.(*time.Time))\n\tcase *time.Duration:\n\t\t*ptr.(*time.Duration) = time.Duration(ParseInt64(ast.Value))\n\tcase *users.AddressOrName:\n\t\ts := ParseString(ast.Value)\n\t\t*ptr.(*users.AddressOrName) = users.AddressOrName(s)\n\tdefault:\n\t\tif ast.Kind == JSONKindValue \u0026\u0026 ast.ValueKind == JSONTokenKindNull {\n\t\t\t// *ptr.(*interface{}) = nil // TODO: handle nil\n\t\t\treturn\n\t\t}\n\t\tpanic(\"type not defined for `\" + ast.String() + \"`\")\n\t}\n}\n\n// loosely ported from https://cs.opensource.google/go/go/+/master:src/time/time.go;l=1370?q=appendStrictRFC3339\u0026ss=go%2Fgo\n// it's not a full port since it would require copying lot of utils\nfunc (ast *JSONASTNode) ParseTime(t *time.Time) {\n\tif ast.Kind != JSONKindValue \u0026\u0026 ast.ValueKind != JSONTokenKindString {\n\t\tpanic(\"time is not a string\")\n\t}\n\ts := ParseString(ast.Value)\n\tvar err error\n\t*t, err = time.Parse(time.RFC3339Nano, s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ParseUint64(s string) uint64 {\n\tval, err := strconv.Atoi(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn uint64(val)\n}\n\nfunc ParseInt64(s string) int64 {\n\tval, err := strconv.Atoi(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int64(val)\n}\n\ntype ParseKV struct {\n\tKey          string\n\tValue        interface{}\n\tArrayParser  func(children []*JSONASTNode)\n\tObjectParser func(children []*JSONASTKV)\n\tCustomParser func(node *JSONASTNode)\n}\n\nfunc ParseAny(s string, val interface{}) {\n\ttokens := tokenize(s)\n\tif len(tokens) == 0 {\n\t\tpanic(\"empty json\")\n\t}\n\tremainingTokens, ast := parseAST(tokens)\n\tif len(remainingTokens) \u003e 0 {\n\t\tpanic(\"invalid json\")\n\t}\n\tast.ParseAny(val)\n}\n\nfunc (ast *JSONASTNode) ParseObject(kv []*ParseKV) {\n\tif ast.Kind != JSONKindObject {\n\t\tpanic(\"not an object\")\n\t}\n\tfor _, elem := range kv {\n\t\tfor i, child := range ast.ObjectChildren {\n\t\t\tif child.Key == elem.Key {\n\t\t\t\tif elem.ArrayParser != nil {\n\t\t\t\t\tif child.Value.Kind != JSONKindArray {\n\t\t\t\t\t\tpanic(\"not an array\")\n\t\t\t\t\t}\n\t\t\t\t\telem.ArrayParser(child.Value.ArrayChildren)\n\t\t\t\t} else if elem.ObjectParser != nil {\n\t\t\t\t\tif child.Value.Kind != JSONKindObject {\n\t\t\t\t\t\tpanic(\"not an object\")\n\t\t\t\t\t}\n\t\t\t\t\telem.ObjectParser(child.Value.ObjectChildren)\n\t\t\t\t} else if elem.CustomParser != nil {\n\t\t\t\t\telem.CustomParser(child.Value)\n\t\t\t\t} else {\n\t\t\t\t\tchild.Value.ParseAny(elem.Value)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif i == (len(ast.ObjectChildren) - 1) {\n\t\t\t\tpanic(\"invalid key `\" + elem.Key + \"` in object `\" + ast.String() + \"`\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (ast *JSONASTNode) ParseUnion(kv []*ParseKV) interface{} {\n\tif ast.Kind != JSONKindObject {\n\t\tpanic(\"union is not an object\")\n\t}\n\tif len(ast.ObjectChildren) != 1 {\n\t\tpanic(\"union object does not have exactly one field\")\n\t}\n\tk, node := ast.ObjectChildren[0].Key, ast.ObjectChildren[0].Value\n\tfor _, kv := range kv {\n\t\tif kv.Key == k {\n\t\t\tnode.ParseAny(kv.Value)\n\t\t\treturn kv.Value\n\t\t}\n\t}\n\tpanic(\"unknown union type\") // TODO: expected one of ...\n}\n\nfunc ParseSlice(s string) []*JSONASTNode {\n\tast := TokenizeAndParse(s)\n\treturn ast.ParseSlice()\n}\n\nfunc (ast *JSONASTNode) ParseSlice() []*JSONASTNode {\n\tif ast.Kind != JSONKindArray {\n\t\tpanic(\"not an array\")\n\t}\n\treturn ast.ArrayChildren\n}\n\nfunc countWhitespaces(s string) int {\n\ti := 0\n\tfor i \u003c len(s) {\n\t\tif strings.ContainsRune(whitespaces, int32(s[i])) {\n\t\t\ti++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn i\n}\n\nfunc JSONTokensString(tokens []*JSONToken) string {\n\ts := \"\"\n\tfor _, token := range tokens {\n\t\ts += token.Raw\n\t}\n\treturn s\n}\n\nfunc (node *JSONASTNode) String() string {\n\tif node == nil {\n\t\treturn \"nil\"\n\t}\n\tswitch node.Kind {\n\tcase JSONKindValue:\n\t\treturn node.Value\n\tcase JSONKindArray:\n\t\ts := \"[\"\n\t\tfor i, child := range node.ArrayChildren {\n\t\t\tif i \u003e 0 {\n\t\t\t\ts += \",\"\n\t\t\t}\n\t\t\ts += child.String()\n\t\t}\n\t\ts += \"]\"\n\t\treturn s\n\tcase JSONKindObject:\n\t\ts := \"{\"\n\t\tfor i, child := range node.ObjectChildren {\n\t\t\tif i \u003e 0 {\n\t\t\t\ts += \",\"\n\t\t\t}\n\t\t\ts += `\"` + child.Key + `\":` + child.Value.String()\n\t\t}\n\t\ts += \"}\"\n\t\treturn s\n\tdefault:\n\t\tpanic(\"invalid json\")\n\t}\n}\n\nfunc TokenizeAndParse(s string) *JSONASTNode {\n\ttokens := tokenize(s)\n\tif len(tokens) == 0 {\n\t\tpanic(\"empty json\")\n\t}\n\tremainingTokens, ast := parseAST(tokens)\n\tif len(remainingTokens) \u003e 0 {\n\t\tpanic(\"invalid json\")\n\t}\n\treturn ast\n}\n\nfunc parseAST(tokens []*JSONToken) (tkn []*JSONToken, tree *JSONASTNode) {\n\tif len(tokens) == 0 {\n\t\tpanic(\"empty json\")\n\t}\n\n\tswitch tokens[0].Kind {\n\n\tcase JSONTokenKindString:\n\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindValue, ValueKind: tokens[0].Kind, Value: tokens[0].Raw}\n\tcase JSONTokenKindNumber:\n\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindValue, ValueKind: tokens[0].Kind, Value: tokens[0].Raw}\n\tcase JSONTokenKindTrue:\n\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindValue, ValueKind: tokens[0].Kind, Value: tokens[0].Raw}\n\tcase JSONTokenKindFalse:\n\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindValue, ValueKind: tokens[0].Kind, Value: tokens[0].Raw}\n\tcase JSONTokenKindNull:\n\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindValue, ValueKind: tokens[0].Kind, Value: tokens[0].Raw}\n\n\tcase JSONTokenKindOpenArray:\n\t\tarrayChildren := []*JSONASTNode{}\n\t\ttokens = tokens[1:]\n\t\tfor len(tokens) \u003e 0 {\n\t\t\tif tokens[0].Kind == JSONTokenKindCloseArray {\n\t\t\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindArray, ArrayChildren: arrayChildren}\n\t\t\t}\n\t\t\tvar child *JSONASTNode\n\t\t\ttokens, child = parseAST(tokens)\n\t\t\tarrayChildren = append(arrayChildren, child)\n\t\t\tif len(tokens) == 0 {\n\t\t\t\tpanic(\"exepected more tokens in array\")\n\t\t\t}\n\t\t\tif tokens[0].Kind == JSONTokenKindComma {\n\t\t\t\ttokens = tokens[1:]\n\t\t\t} else if tokens[0].Kind == JSONTokenKindCloseArray {\n\t\t\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindArray, ArrayChildren: arrayChildren}\n\t\t\t} else {\n\t\t\t\tpanic(\"unexpected token in array after value `\" + tokens[0].Raw + \"`\")\n\t\t\t}\n\t\t}\n\n\tcase JSONTokenKindOpenObject:\n\t\tobjectChildren := []*JSONASTKV{}\n\t\tif len(tokens) \u003c 2 {\n\t\t\tpanic(\"objects must have at least 2 tokens\")\n\t\t}\n\t\ttokens = tokens[1:]\n\t\tfor len(tokens) \u003e 0 {\n\t\t\tif tokens[0].Kind == JSONTokenKindCloseObject {\n\t\t\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindObject, ObjectChildren: objectChildren}\n\t\t\t}\n\t\t\tif tokens[0].Kind != JSONTokenKindString {\n\t\t\t\tpanic(\"invalid json\")\n\t\t\t}\n\t\t\tkey := tokens[0].Raw\n\t\t\ttokens = tokens[1:]\n\t\t\tif len(tokens) == 0 {\n\t\t\t\tpanic(\"exepected more tokens in object\")\n\t\t\t}\n\t\t\tif tokens[0].Kind != JSONTokenKindColon {\n\t\t\t\tpanic(\"expected :\")\n\t\t\t}\n\t\t\ttokens = tokens[1:]\n\t\t\tif len(tokens) == 0 {\n\t\t\t\tpanic(\"exepected more tokens in object after :\")\n\t\t\t}\n\t\t\tvar value *JSONASTNode\n\t\t\ttokens, value = parseAST(tokens)\n\t\t\tobjectChildren = append(objectChildren, \u0026JSONASTKV{Key: ParseString(key), Value: value})\n\t\t\tif len(tokens) == 0 {\n\t\t\t\tpanic(\"exepected more tokens in object after value\")\n\t\t\t}\n\t\t\tif tokens[0].Kind == JSONTokenKindComma {\n\t\t\t\ttokens = tokens[1:]\n\t\t\t} else if tokens[0].Kind == JSONTokenKindCloseObject {\n\t\t\t\treturn tokens[1:], \u0026JSONASTNode{Kind: JSONKindObject, ObjectChildren: objectChildren}\n\t\t\t} else {\n\t\t\t\tpanic(\"unexpected token in object after value `\" + tokens[0].Raw + \"`\")\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\tpanic(\"unexpected token `\" + tokens[0].Raw + \"`\")\n\t}\n\n\treturn\n}\n\nfunc tokenize(s string) []*JSONToken {\n\ttokens := []*JSONToken{}\n\tfor len(s) \u003e 0 {\n\t\tvar token *JSONToken\n\t\ts, token = tokenizeOne(s)\n\t\tif token.Kind != JSONTokenKindSpaces {\n\t\t\ttokens = append(tokens, token)\n\t\t}\n\t}\n\treturn tokens\n}\n\nfunc tokenizeOne(s string) (string, *JSONToken) {\n\tif len(s) == 0 {\n\t\tpanic(\"invalid token\")\n\t}\n\tspacesCount := countWhitespaces(s)\n\tif spacesCount \u003e 0 {\n\t\tspaces := s[:spacesCount]\n\t\treturn s[spacesCount:], \u0026JSONToken{Kind: JSONTokenKindSpaces, Raw: spaces}\n\t}\n\tswitch s[0] {\n\tcase '\"':\n\t\treturn parseStringToken(s)\n\tcase 't':\n\t\treturn parseKeyword(s, \"true\", JSONTokenKindTrue)\n\tcase 'f':\n\t\treturn parseKeyword(s, \"false\", JSONTokenKindFalse)\n\tcase 'n':\n\t\treturn parseKeyword(s, \"null\", JSONTokenKindNull)\n\tcase '{':\n\t\treturn s[1:], \u0026JSONToken{Kind: JSONTokenKindOpenObject, Raw: \"{\"}\n\tcase '[':\n\t\treturn s[1:], \u0026JSONToken{Kind: JSONTokenKindOpenArray, Raw: \"[\"}\n\tcase ':':\n\t\treturn s[1:], \u0026JSONToken{Kind: JSONTokenKindColon, Raw: \":\"}\n\tcase ',':\n\t\treturn s[1:], \u0026JSONToken{Kind: JSONTokenKindComma, Raw: \",\"}\n\tcase ']':\n\t\treturn s[1:], \u0026JSONToken{Kind: JSONTokenKindCloseArray, Raw: \"]\"}\n\tcase '}':\n\t\treturn s[1:], \u0026JSONToken{Kind: JSONTokenKindCloseObject, Raw: \"}\"}\n\tdefault:\n\t\treturn parseNumber(s)\n\t}\n}\n\nfunc parseKeyword(s string, keyword string, kind JSONTokenKind) (string, *JSONToken) {\n\tif len(s) \u003c len(keyword) {\n\t\tpanic(\"invalid keyword\")\n\t}\n\tif s[:len(keyword)] != keyword {\n\t\tpanic(\"invalid keyword\")\n\t}\n\treturn s[len(keyword):], \u0026JSONToken{Kind: kind, Raw: keyword}\n}\n\nfunc parseStringToken(s string) (string, *JSONToken) {\n\tif (len(s) \u003c 2) || (s[0] != '\"') {\n\t\tpanic(\"invalid string\")\n\t}\n\tquote := false\n\tfor i := 1; i \u003c len(s); i++ {\n\t\tif !quote \u0026\u0026 s[i] == '\\\\' {\n\t\t\tquote = true\n\t\t\tcontinue\n\t\t}\n\t\tif !quote \u0026\u0026 s[i] == '\"' {\n\t\t\treturn s[i+1:], \u0026JSONToken{Kind: JSONTokenKindString, Raw: s[:i+1]}\n\t\t}\n\t\tquote = false\n\t}\n\tpanic(\"invalid string\")\n}\n\n// copiloted\nfunc parseNumber(s string) (string, *JSONToken) {\n\tif len(s) == 0 {\n\t\tpanic(\"invalid number\")\n\t}\n\ti := 0\n\tif s[i] == '-' {\n\t\ti++\n\t}\n\tif i == len(s) {\n\t\tpanic(\"invalid number\")\n\t}\n\tif s[i] == '0' {\n\t\ti++\n\t} else if ('1' \u003c= s[i]) \u0026\u0026 (s[i] \u003c= '9') {\n\t\ti++\n\t\tfor (i \u003c len(s)) \u0026\u0026 ('0' \u003c= s[i]) \u0026\u0026 (s[i] \u003c= '9') {\n\t\t\ti++\n\t\t}\n\t} else {\n\t\tpanic(\"invalid number\")\n\t}\n\tif i == len(s) {\n\t\treturn s[i:], \u0026JSONToken{Kind: JSONTokenKindNumber, Raw: s}\n\t}\n\tif s[i] == '.' {\n\t\ti++\n\t\tif i == len(s) {\n\t\t\tpanic(\"invalid number\")\n\t\t}\n\t\tif ('0' \u003c= s[i]) \u0026\u0026 (s[i] \u003c= '9') {\n\t\t\ti++\n\t\t\tfor (i \u003c len(s)) \u0026\u0026 ('0' \u003c= s[i]) \u0026\u0026 (s[i] \u003c= '9') {\n\t\t\t\ti++\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(\"invalid number\")\n\t\t}\n\t}\n\tif i == len(s) {\n\t\treturn s[i:], \u0026JSONToken{Kind: JSONTokenKindNumber, Raw: s}\n\t}\n\tif (s[i] == 'e') || (s[i] == 'E') {\n\t\ti++\n\t\tif i == len(s) {\n\t\t\tpanic(\"invalid number\")\n\t\t}\n\t\tif (s[i] == '+') || (s[i] == '-') {\n\t\t\ti++\n\t\t}\n\t\tif i == len(s) {\n\t\t\tpanic(\"invalid number\")\n\t\t}\n\t\tif ('0' \u003c= s[i]) \u0026\u0026 (s[i] \u003c= '9') {\n\t\t\ti++\n\t\t\tfor (i \u003c len(s)) \u0026\u0026 ('0' \u003c= s[i]) \u0026\u0026 (s[i] \u003c= '9') {\n\t\t\t\ti++\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(\"invalid number\")\n\t\t}\n\t}\n\treturn s[i:], \u0026JSONToken{Kind: JSONTokenKindNumber, Raw: s[:i]}\n}\n\ntype JSONTokenKind int\n\ntype JSONKind int\n\nconst (\n\tJSONKindUnknown JSONKind = iota\n\tJSONKindValue\n\tJSONKindObject\n\tJSONKindArray\n)\n\ntype JSONASTNode struct {\n\tKind           JSONKind\n\tArrayChildren  []*JSONASTNode\n\tObjectChildren []*JSONASTKV\n\tValueKind      JSONTokenKind\n\tValue          string\n}\n\ntype JSONASTKV struct {\n\tKey   string\n\tValue *JSONASTNode\n}\n\nconst (\n\tJSONTokenKindUnknown JSONTokenKind = iota\n\tJSONTokenKindString\n\tJSONTokenKindNumber\n\tJSONTokenKindTrue\n\tJSONTokenKindFalse\n\tJSONTokenKindSpaces\n\tJSONTokenKindComma\n\tJSONTokenKindColon\n\tJSONTokenKindOpenArray\n\tJSONTokenKindCloseArray\n\tJSONTokenKindOpenObject\n\tJSONTokenKindCloseObject\n\tJSONTokenKindNull\n)\n\nfunc (k JSONTokenKind) String() string {\n\tswitch k {\n\tcase JSONTokenKindString:\n\t\treturn \"string\"\n\tcase JSONTokenKindNumber:\n\t\treturn \"number\"\n\tcase JSONTokenKindTrue:\n\t\treturn \"true\"\n\tcase JSONTokenKindFalse:\n\t\treturn \"false\"\n\tcase JSONTokenKindSpaces:\n\t\treturn \"spaces\"\n\tcase JSONTokenKindComma:\n\t\treturn \"comma\"\n\tcase JSONTokenKindColon:\n\t\treturn \"colon\"\n\tcase JSONTokenKindOpenArray:\n\t\treturn \"open-array\"\n\tcase JSONTokenKindCloseArray:\n\t\treturn \"close-array\"\n\tcase JSONTokenKindOpenObject:\n\t\treturn \"open-object\"\n\tcase JSONTokenKindCloseObject:\n\t\treturn \"close-object\"\n\tcase JSONTokenKindNull:\n\t\treturn \"null\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\ntype JSONToken struct {\n\tKind JSONTokenKind\n\tRaw  string\n}\n"},{"name":"strings.gno","body":"package ujson\n\nimport (\n\t\"unicode/utf8\"\n\n\t\"gno.land/p/teritori/utf16\"\n)\n\nconst (\n\tReplacementChar = '\\uFFFD' // Represents invalid code points.\n)\n\n// Ported from https://cs.opensource.google/go/go/+/refs/tags/go1.20.6:src/encoding/json/encode.go\nfunc FormatString(s string) string {\n\tconst escapeHTML = true\n\te := `\"` // e.WriteByte('\"')\n\tstart := 0\n\tfor i := 0; i \u003c len(s); {\n\t\tif b := s[i]; b \u003c utf8.RuneSelf {\n\t\t\tif htmlSafeSet[b] || (!escapeHTML \u0026\u0026 safeSet[b]) {\n\t\t\t\ti++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif start \u003c i {\n\t\t\t\te += s[start:i] // e.WriteString(s[start:i])\n\t\t\t}\n\t\t\te += \"\\\\\" // e.WriteByte('\\\\')\n\t\t\tswitch b {\n\t\t\tcase '\\\\', '\"':\n\t\t\t\te += string(b) // e.WriteByte(b)\n\t\t\tcase '\\n':\n\t\t\t\te += \"n\" // e.WriteByte('n')\n\t\t\tcase '\\r':\n\t\t\t\te += \"r\" // e.WriteByte('r')\n\t\t\tcase '\\t':\n\t\t\t\te += \"t\" // e.WriteByte('t')\n\t\t\tdefault:\n\t\t\t\t// This encodes bytes \u003c 0x20 except for \\t, \\n and \\r.\n\t\t\t\t// If escapeHTML is set, it also escapes \u003c, \u003e, and \u0026\n\t\t\t\t// because they can lead to security holes when\n\t\t\t\t// user-controlled strings are rendered into JSON\n\t\t\t\t// and served to some browsers.\n\t\t\t\te += `u00`              // e.WriteString(`u00`)\n\t\t\t\te += string(hex[b\u003e\u003e4])  // e.WriteByte(hex[b\u003e\u003e4])\n\t\t\t\te += string(hex[b\u00260xF]) // e.WriteByte(hex[b\u00260xF])\n\t\t\t}\n\t\t\ti++\n\t\t\tstart = i\n\t\t\tcontinue\n\t\t}\n\t\tc, size := utf8.DecodeRuneInString(s[i:])\n\t\tif c == utf8.RuneError \u0026\u0026 size == 1 {\n\t\t\tif start \u003c i {\n\t\t\t\te += s[start:i] // e.WriteString(s[start:i])\n\t\t\t}\n\t\t\te += `\\ufffd` // e.WriteString(`\\ufffd`)\n\t\t\ti += size\n\t\t\tstart = i\n\t\t\tcontinue\n\t\t}\n\t\t// U+2028 is LINE SEPARATOR.\n\t\t// U+2029 is PARAGRAPH SEPARATOR.\n\t\t// They are both technically valid characters in JSON strings,\n\t\t// but don't work in JSONP, which has to be evaluated as JavaScript,\n\t\t// and can lead to security holes there. It is valid JSON to\n\t\t// escape them, so we do so unconditionally.\n\t\t// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.\n\t\tif c == '\\u2028' || c == '\\u2029' {\n\t\t\tif start \u003c i {\n\t\t\t\te += s[start:i] // e.WriteString(s[start:i])\n\t\t\t}\n\t\t\te += `\\u202`            // e.WriteString(`\\u202`)\n\t\t\te += string(hex[c\u00260xF]) // e.WriteByte(hex[c\u00260xF])\n\t\t\ti += size\n\t\t\tstart = i\n\t\t\tcontinue\n\t\t}\n\t\ti += size\n\t}\n\tif start \u003c len(s) {\n\t\te += s[start:] // e.WriteString(s[start:])\n\t}\n\te += `\"` // e.WriteByte('\"')\n\treturn e\n}\n\n// Ported from https://cs.opensource.google/go/go/+/refs/tags/go1.20.6:src/encoding/json/decode.go\n// unquote converts a quoted JSON string literal s into an actual string t.\n// The rules are different than for Go, so cannot use strconv.Unquote.\nfunc ParseString(s string) string {\n\to, ok := unquoteBytes([]byte(s))\n\tif !ok {\n\t\tpanic(\"invalid string\")\n\t}\n\treturn string(o)\n}\n\nfunc unquoteBytes(s []byte) (t []byte, ok bool) {\n\tif len(s) \u003c 2 || s[0] != '\"' || s[len(s)-1] != '\"' {\n\t\treturn\n\t}\n\ts = s[1 : len(s)-1]\n\n\t// Check for unusual characters. If there are none,\n\t// then no unquoting is needed, so return a slice of the\n\t// original bytes.\n\tr := 0\n\tfor r \u003c len(s) {\n\t\tc := s[r]\n\t\tif c == '\\\\' || c == '\"' || c \u003c ' ' {\n\t\t\tbreak\n\t\t}\n\t\tif c \u003c utf8.RuneSelf {\n\t\t\tr++\n\t\t\tcontinue\n\t\t}\n\t\trr, size := utf8.DecodeRune(s[r:])\n\t\tif rr == utf8.RuneError \u0026\u0026 size == 1 {\n\t\t\tbreak\n\t\t}\n\t\tr += size\n\t}\n\tif r == len(s) {\n\t\treturn s, true\n\t}\n\n\tb := make([]byte, len(s)+2*utf8.UTFMax)\n\tw := copy(b, s[0:r])\n\tfor r \u003c len(s) {\n\t\t// Out of room? Can only happen if s is full of\n\t\t// malformed UTF-8 and we're replacing each\n\t\t// byte with RuneError.\n\t\tif w \u003e= len(b)-2*utf8.UTFMax {\n\t\t\tnb := make([]byte, (len(b)+utf8.UTFMax)*2)\n\t\t\tcopy(nb, b[0:w])\n\t\t\tb = nb\n\t\t}\n\t\tswitch c := s[r]; {\n\t\tcase c == '\\\\':\n\t\t\tr++\n\t\t\tif r \u003e= len(s) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tswitch s[r] {\n\t\t\tdefault:\n\t\t\t\treturn\n\t\t\tcase '\"', '\\\\', '/', '\\'':\n\t\t\t\tb[w] = s[r]\n\t\t\t\tr++\n\t\t\t\tw++\n\t\t\tcase 'b':\n\t\t\t\tb[w] = '\\b'\n\t\t\t\tr++\n\t\t\t\tw++\n\t\t\tcase 'f':\n\t\t\t\tb[w] = '\\f'\n\t\t\t\tr++\n\t\t\t\tw++\n\t\t\tcase 'n':\n\t\t\t\tb[w] = '\\n'\n\t\t\t\tr++\n\t\t\t\tw++\n\t\t\tcase 'r':\n\t\t\t\tb[w] = '\\r'\n\t\t\t\tr++\n\t\t\t\tw++\n\t\t\tcase 't':\n\t\t\t\tb[w] = '\\t'\n\t\t\t\tr++\n\t\t\t\tw++\n\t\t\tcase 'u':\n\t\t\t\tr--\n\t\t\t\trr := getu4(s[r:])\n\t\t\t\tif rr \u003c 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tr += 6\n\t\t\t\tif utf16.IsSurrogate(rr) {\n\t\t\t\t\trr1 := getu4(s[r:])\n\t\t\t\t\tif dec := utf16.DecodeRune(rr, rr1); dec != ReplacementChar {\n\t\t\t\t\t\t// A valid pair; consume.\n\t\t\t\t\t\tr += 6\n\t\t\t\t\t\tw += utf8.EncodeRune(b[w:], dec)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\t// Invalid surrogate; fall back to replacement rune.\n\t\t\t\t\trr = ReplacementChar\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t// Quote, control characters are invalid.\n\t\tcase c == '\"', c \u003c ' ':\n\t\t\treturn\n\n\t\t// ASCII\n\t\tcase c \u003c utf8.RuneSelf:\n\t\t\tb[w] = c\n\t\t\tr++\n\t\t\tw++\n\n\t\t// Coerce to well-formed UTF-8.\n\t\tdefault:\n\t\t\trr, size := utf8.DecodeRune(s[r:])\n\t\t\tr += size\n\t\t\tw += utf8.EncodeRune(b[w:], rr)\n\t\t}\n\t}\n\treturn b[0:w], true\n}\n\n// getu4 decodes \\uXXXX from the beginning of s, returning the hex value,\n// or it returns -1.\nfunc getu4(s []byte) rune {\n\tif len(s) \u003c 6 || s[0] != '\\\\' || s[1] != 'u' {\n\t\treturn -1\n\t}\n\tvar r rune\n\tfor _, c := range s[2:6] {\n\t\tswitch {\n\t\tcase '0' \u003c= c \u0026\u0026 c \u003c= '9':\n\t\t\tc = c - '0'\n\t\tcase 'a' \u003c= c \u0026\u0026 c \u003c= 'f':\n\t\t\tc = c - 'a' + 10\n\t\tcase 'A' \u003c= c \u0026\u0026 c \u003c= 'F':\n\t\t\tc = c - 'A' + 10\n\t\tdefault:\n\t\t\treturn -1\n\t\t}\n\t\tr = r*16 + rune(c)\n\t}\n\treturn r\n}\n"},{"name":"tables.gno","body":"package ujson\n\nimport \"unicode/utf8\"\n\nvar hex = \"0123456789abcdef\"\n\n// safeSet holds the value true if the ASCII character with the given array\n// position can be represented inside a JSON string without any further\n// escaping.\n//\n// All values are true except for the ASCII control characters (0-31), the\n// double quote (\"), and the backslash character (\"\\\").\nvar safeSet = [utf8.RuneSelf]bool{\n\t' ':      true,\n\t'!':      true,\n\t'\"':      false,\n\t'#':      true,\n\t'$':      true,\n\t'%':      true,\n\t'\u0026':      true,\n\t'\\'':     true,\n\t'(':      true,\n\t')':      true,\n\t'*':      true,\n\t'+':      true,\n\t',':      true,\n\t'-':      true,\n\t'.':      true,\n\t'/':      true,\n\t'0':      true,\n\t'1':      true,\n\t'2':      true,\n\t'3':      true,\n\t'4':      true,\n\t'5':      true,\n\t'6':      true,\n\t'7':      true,\n\t'8':      true,\n\t'9':      true,\n\t':':      true,\n\t';':      true,\n\t'\u003c':      true,\n\t'=':      true,\n\t'\u003e':      true,\n\t'?':      true,\n\t'@':      true,\n\t'A':      true,\n\t'B':      true,\n\t'C':      true,\n\t'D':      true,\n\t'E':      true,\n\t'F':      true,\n\t'G':      true,\n\t'H':      true,\n\t'I':      true,\n\t'J':      true,\n\t'K':      true,\n\t'L':      true,\n\t'M':      true,\n\t'N':      true,\n\t'O':      true,\n\t'P':      true,\n\t'Q':      true,\n\t'R':      true,\n\t'S':      true,\n\t'T':      true,\n\t'U':      true,\n\t'V':      true,\n\t'W':      true,\n\t'X':      true,\n\t'Y':      true,\n\t'Z':      true,\n\t'[':      true,\n\t'\\\\':     false,\n\t']':      true,\n\t'^':      true,\n\t'_':      true,\n\t'`':      true,\n\t'a':      true,\n\t'b':      true,\n\t'c':      true,\n\t'd':      true,\n\t'e':      true,\n\t'f':      true,\n\t'g':      true,\n\t'h':      true,\n\t'i':      true,\n\t'j':      true,\n\t'k':      true,\n\t'l':      true,\n\t'm':      true,\n\t'n':      true,\n\t'o':      true,\n\t'p':      true,\n\t'q':      true,\n\t'r':      true,\n\t's':      true,\n\t't':      true,\n\t'u':      true,\n\t'v':      true,\n\t'w':      true,\n\t'x':      true,\n\t'y':      true,\n\t'z':      true,\n\t'{':      true,\n\t'|':      true,\n\t'}':      true,\n\t'~':      true,\n\t'\\u007f': true,\n}\n\n// htmlSafeSet holds the value true if the ASCII character with the given\n// array position can be safely represented inside a JSON string, embedded\n// inside of HTML \u003cscript\u003e tags, without any additional escaping.\n//\n// All values are true except for the ASCII control characters (0-31), the\n// double quote (\"), the backslash character (\"\\\"), HTML opening and closing\n// tags (\"\u003c\" and \"\u003e\"), and the ampersand (\"\u0026\").\nvar htmlSafeSet = [utf8.RuneSelf]bool{\n\t' ':      true,\n\t'!':      true,\n\t'\"':      false,\n\t'#':      true,\n\t'$':      true,\n\t'%':      true,\n\t'\u0026':      false,\n\t'\\'':     true,\n\t'(':      true,\n\t')':      true,\n\t'*':      true,\n\t'+':      true,\n\t',':      true,\n\t'-':      true,\n\t'.':      true,\n\t'/':      true,\n\t'0':      true,\n\t'1':      true,\n\t'2':      true,\n\t'3':      true,\n\t'4':      true,\n\t'5':      true,\n\t'6':      true,\n\t'7':      true,\n\t'8':      true,\n\t'9':      true,\n\t':':      true,\n\t';':      true,\n\t'\u003c':      false,\n\t'=':      true,\n\t'\u003e':      false,\n\t'?':      true,\n\t'@':      true,\n\t'A':      true,\n\t'B':      true,\n\t'C':      true,\n\t'D':      true,\n\t'E':      true,\n\t'F':      true,\n\t'G':      true,\n\t'H':      true,\n\t'I':      true,\n\t'J':      true,\n\t'K':      true,\n\t'L':      true,\n\t'M':      true,\n\t'N':      true,\n\t'O':      true,\n\t'P':      true,\n\t'Q':      true,\n\t'R':      true,\n\t'S':      true,\n\t'T':      true,\n\t'U':      true,\n\t'V':      true,\n\t'W':      true,\n\t'X':      true,\n\t'Y':      true,\n\t'Z':      true,\n\t'[':      true,\n\t'\\\\':     false,\n\t']':      true,\n\t'^':      true,\n\t'_':      true,\n\t'`':      true,\n\t'a':      true,\n\t'b':      true,\n\t'c':      true,\n\t'd':      true,\n\t'e':      true,\n\t'f':      true,\n\t'g':      true,\n\t'h':      true,\n\t'i':      true,\n\t'j':      true,\n\t'k':      true,\n\t'l':      true,\n\t'm':      true,\n\t'n':      true,\n\t'o':      true,\n\t'p':      true,\n\t'q':      true,\n\t'r':      true,\n\t's':      true,\n\t't':      true,\n\t'u':      true,\n\t'v':      true,\n\t'w':      true,\n\t'x':      true,\n\t'y':      true,\n\t'z':      true,\n\t'{':      true,\n\t'|':      true,\n\t'}':      true,\n\t'~':      true,\n\t'\\u007f': true,\n}\n"},{"name":"ujson_test.gno","body":"package ujson\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nfunc TestAST(t *testing.T) {\n\tjson := `{\"a\":[42, null, true, false, \"hello\\n\\t\\r\"],\"b\":-3,\"c\":{\"ia\":{}, \"ib\":{     \"foo\"   :    \"bar\"}},\"d\":4,\"e\":5}`\n\ttokens := tokenize(json)\n\texpected := 44\n\tif len(tokens) != expected {\n\t\tt.Errorf(\"Expected %d tokens, got %d\", expected, len(tokens))\n\t}\n\tremainingTokens, ast := parseAST(tokens)\n\tif len(remainingTokens) != 0 {\n\t\tt.Errorf(\"Expected 0 remaining tokens, got %d\", len(remainingTokens))\n\t}\n\tif ast.Kind != JSONKindObject {\n\t\tt.Errorf(\"Expected root node to be an object, got %s\", ast.Kind)\n\t}\n\texpectedTree := `{\"a\":[42,null,true,false,\"hello\\n\\t\\r\"],\"b\":-3,\"c\":{\"ia\":{},\"ib\":{\"foo\":\"bar\"}},\"d\":4,\"e\":5}`\n\tif ast.String() != expectedTree {\n\t\tt.Errorf(\"Expected root node to be `%s`, got `%s`\", expectedTree, ast.String())\n\t}\n}\n\ntype TestType struct {\n\tA []string `json:\"a\"`\n\tB int      `json:\"b\"`\n\tC SubTestType\n\tD uint `json:\"d\"`\n\tE int  `json:\"e\"`\n\tF bool `json:\"f\"`\n\t// G       *EmptyType `json:\"g\"`\n\tAVLTree *avl.Tree `json:\"avlTree\"`\n}\n\nfunc (tt *TestType) FromJSON(ast *JSONASTNode) {\n\tast.ParseObject([]*ParseKV{\n\t\t{Key: \"a\", ArrayParser: func(children []*JSONASTNode) {\n\t\t\ttt.A = make([]string, len(children))\n\t\t\tfor i, child := range children {\n\t\t\t\tchild.ParseAny(\u0026tt.A[i])\n\t\t\t}\n\t\t}},\n\t\t{Key: \"b\", Value: \u0026tt.B},\n\t\t{Key: \"c\", Value: \u0026tt.C},\n\t\t{Key: \"d\", Value: \u0026tt.D},\n\t\t{Key: \"e\", Value: \u0026tt.E},\n\t\t{Key: \"f\", Value: \u0026tt.F},\n\t\t// {Key: \"g\", Value: \u0026tt.G},\n\t\t{Key: \"avlTree\", CustomParser: func(node *JSONASTNode) {\n\t\t\tif node.Kind != JSONKindObject {\n\t\t\t\tpanic(\"Expected avlTree to be an object\")\n\t\t\t}\n\t\t\ttt.AVLTree = avl.NewTree()\n\t\t\tfor _, child := range node.ObjectChildren {\n\t\t\t\tvar t string\n\t\t\t\tchild.Value.ParseAny(\u0026t)\n\t\t\t\ttt.AVLTree.Set(child.Key, t)\n\t\t\t}\n\t\t}},\n\t})\n}\n\nfunc (tt TestType) ToJSON() string {\n\tiSlice := make([]interface{}, len(tt.A))\n\tfor i, v := range tt.A {\n\t\tiSlice[i] = v\n\t}\n\treturn FormatObject([]FormatKV{\n\t\t{Key: \"a\", Value: FormatSlice(iSlice), Raw: true},\n\t\t{Key: \"b\", Value: tt.B},\n\t\t{Key: \"c\", Value: tt.C},\n\t\t{Key: \"d\", Value: tt.D},\n\t\t{Key: \"e\", Value: tt.E},\n\t\t{Key: \"f\", Value: tt.F},\n\t\t// {Key: \"g\", Value: tt.G},\n\t\t{Key: \"avlTree\", Value: tt.AVLTree},\n\t})\n}\n\ntype SubTestType struct {\n\tIA EmptyType      `json:\"ia\"`\n\tIB SubSubTestType `json:\"ib\"`\n}\n\nfunc (stt *SubTestType) FromJSON(ast *JSONASTNode) {\n\tast.ParseObject([]*ParseKV{\n\t\t{Key: \"ia\", Value: \u0026stt.IA},\n\t\t{Key: \"ib\", Value: \u0026stt.IB},\n\t})\n}\n\nfunc (stt SubTestType) ToJSON() string {\n\treturn FormatObject([]FormatKV{\n\t\t{Key: \"ia\", Value: stt.IA},\n\t\t{Key: \"ib\", Value: stt.IB},\n\t})\n}\n\ntype EmptyType struct{}\n\nfunc (et *EmptyType) FromJSON(ast *JSONASTNode) {\n\tast.ParseObject([]*ParseKV{})\n}\n\nfunc (et EmptyType) ToJSON() string {\n\treturn FormatObject([]FormatKV{})\n}\n\ntype SubSubTestType struct {\n\tFoo string `json:\"foo\"`\n}\n\nfunc (sstt *SubSubTestType) FromJSON(ast *JSONASTNode) {\n\tast.ParseObject([]*ParseKV{\n\t\t{Key: \"foo\", Value: \u0026sstt.Foo},\n\t})\n}\n\nfunc (sstt SubSubTestType) ToJSON() string {\n\treturn FormatObject([]FormatKV{\n\t\t{Key: \"foo\", Value: sstt.Foo},\n\t})\n}\n\nfunc TestNestedObject(t *testing.T) {\n\tjson := `{\"a\":[\"42\",\"null\",\"true\",\"false\",\"hello\\t\\n\\r\"],\"b\":-3,\"c\":{\"ia\":{},\"ib\":{\"foo\":\"bar\"}},\"d\":4,\"e\":5,\"f\":true,\"g\":null,\"avlTree\":{\"bar\":\"foo\"}}`\n\tvar tt TestType\n\tParseAny(json, \u0026tt)\n\n\tif len(tt.A) != 5 {\n\t\tt.Errorf(\"Expected A to have 5 elements, got %d\", len(tt.A))\n\t}\n\texpected := \"42, null, true, false, hello\\t\\n\\r\"\n\tif strings.Join(tt.A, \", \") != expected {\n\t\tt.Errorf(\"Expected A to be `%s`, got `%s`\", expected, tt.A[0])\n\t}\n\n\tif tt.B != -3 {\n\t\tt.Errorf(\"Expected B to be -3, got %f\", tt.B)\n\t}\n\n\tif tt.D != 4 {\n\t\tt.Errorf(\"Expected D to be 4, got %d\", tt.D)\n\t}\n\n\tif tt.E != 5 {\n\t\tt.Errorf(\"Expected E to be 5, got %d\", tt.E)\n\t}\n\n\tif !tt.F {\n\t\tt.Errorf(\"Expected F to be true, got false\")\n\t}\n\n\t/*\n\t\tif tt.G != nil {\n\t\t\tt.Errorf(\"Expected G to be nil, got %v\", tt.G)\n\t\t}\n\t*/\n\n\toutput := FormatAny(tt)\n\texpected = `{\"a\":[\"42\",\"null\",\"true\",\"false\",\"hello\\t\\n\\r\"],\"b\":-3,\"c\":{\"ia\":{},\"ib\":{\"foo\":\"bar\"}},\"d\":4,\"e\":5,\"f\":true,\"avlTree\":{\"bar\":\"foo\"}}`\n\tif output != expected {\n\t\tt.Errorf(\"Expected output to be `%s`, got `%s`\", expected, output)\n\t}\n}\n\nfunc TestTime(t *testing.T) {\n\tjson := `\"2020-01-01T00:00:00Z\"`\n\n\tvar tt time.Time\n\tParseAny(json, \u0026tt)\n\texpected := \"2020-01-01T00:00:00Z\"\n\tif tt.Format(time.RFC3339) != expected {\n\t\tt.Errorf(\"Expected A to be `%s`, got `%s`\", expected, tt.Format(time.RFC3339))\n\t}\n\n\tojson := FormatAny(tt)\n\tif ojson != json {\n\t\tt.Errorf(\"Expected output to be `%s`, got `%s`\", json, ojson)\n\t}\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"50000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"25H0OfcWC5ykzMCpfuyYbV0iS25weKiOidZZdei/d4Fb9VZUd/b1z3GZ7e48wT/yWRxEjQa+TuHjG4UQMSfrSA=="}],"memo":""},"blockNum":"181048"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","package":{"name":"flags_index","path":"gno.land/p/teritori/flags_index","files":[{"name":"flags_index.gno","body":"package flags_index\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype FlagID string\n\ntype FlagCount struct {\n\tFlagID FlagID\n\tCount  uint64\n}\n\ntype FlagsIndex struct {\n\tflagsCounts      []*FlagCount // sorted by count descending; TODO: optimize using big brain datastructure\n\tflagsCountsByID  *avl.Tree    // key: flagID -\u003e FlagCount\n\tflagsByFlaggerID *avl.Tree    // key: flaggerID -\u003e *avl.Tree key: flagID -\u003e struct{}\n}\n\nfunc NewFlagsIndex() *FlagsIndex {\n\treturn \u0026FlagsIndex{\n\t\tflagsCountsByID:  avl.NewTree(),\n\t\tflagsByFlaggerID: avl.NewTree(),\n\t}\n}\n\nfunc (fi *FlagsIndex) HasFlagged(flagID FlagID, flaggerID string) bool {\n\tif flagsByFlagID, ok := fi.flagsByFlaggerID.Get(flaggerID); ok {\n\t\tif flagsByFlagID.(*avl.Tree).Has(string(flagID)) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (fi *FlagsIndex) GetFlagCount(flagID FlagID) uint64 {\n\tif flagCount, ok := fi.flagsCountsByID.Get(string(flagID)); ok {\n\t\treturn flagCount.(*FlagCount).Count\n\t}\n\treturn 0\n}\n\nfunc (fi *FlagsIndex) GetFlags(limit uint64, offset uint64) []*FlagCount {\n\tif limit == 0 {\n\t\treturn nil\n\t}\n\tif offset \u003e= uint64(len(fi.flagsCounts)) {\n\t\treturn nil\n\t}\n\tif offset+limit \u003e uint64(len(fi.flagsCounts)) {\n\t\tlimit = uint64(len(fi.flagsCounts)) - offset\n\t}\n\treturn fi.flagsCounts[offset : offset+limit]\n}\n\nfunc (fi *FlagsIndex) Flag(flagID FlagID, flaggerID string) {\n\t// update flagsByFlaggerID\n\tvar flagsByFlagID *avl.Tree\n\tif existingFlagsByFlagID, ok := fi.flagsByFlaggerID.Get(flaggerID); ok {\n\t\tflagsByFlagID = existingFlagsByFlagID.(*avl.Tree)\n\t\tif flagsByFlagID.Has(string(flagID)) {\n\t\t\tpanic(\"already flagged\")\n\t\t}\n\t} else {\n\t\tnewFlagsByFlagID := avl.NewTree()\n\t\tfi.flagsByFlaggerID.Set(flaggerID, newFlagsByFlagID)\n\t\tflagsByFlagID = newFlagsByFlagID\n\t}\n\tflagsByFlagID.Set(string(flagID), struct{}{})\n\n\t// update flagsCountsByID and flagsCounts\n\tiFlagCount, ok := fi.flagsCountsByID.Get(string(flagID))\n\tif !ok {\n\t\tflagCount := \u0026FlagCount{FlagID: flagID, Count: 1}\n\t\tfi.flagsCountsByID.Set(string(flagID), flagCount)\n\t\tfi.flagsCounts = append(fi.flagsCounts, flagCount) // this is valid because 1 will always be the lowest count and we want the newest flags to be last\n\t} else {\n\t\tflagCount := iFlagCount.(*FlagCount)\n\t\tflagCount.Count++\n\t\t// move flagCount to correct position in flagsCounts\n\t\tfor i := len(fi.flagsCounts) - 1; i \u003e 0; i-- {\n\t\t\tif fi.flagsCounts[i].Count \u003e fi.flagsCounts[i-1].Count {\n\t\t\t\tfi.flagsCounts[i], fi.flagsCounts[i-1] = fi.flagsCounts[i-1], fi.flagsCounts[i]\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (fi *FlagsIndex) ClearFlagCount(flagID FlagID) {\n\t// find flagCount in byID\n\tif !fi.flagsCountsByID.Has(string(flagID)) {\n\t\t// panic(\"flag ID not found\") // why did you need this?\n\t\treturn\n\t}\n\n\t// remove from byID\n\tfi.flagsCountsByID.Remove(string(flagID))\n\n\t// remove from byCount, we need to recreate the slice since splicing is broken\n\tnewByCount := []*FlagCount{}\n\tfor i := range fi.flagsCounts {\n\t\tif fi.flagsCounts[i].FlagID == flagID {\n\t\t\tcontinue\n\t\t}\n\t\tnewByCount = append(newByCount, fi.flagsCounts[i])\n\t}\n\tfi.flagsCounts = newByCount\n\n\t// update flagsByFlaggerID\n\tvar empty []string\n\tfi.flagsByFlaggerID.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tt := value.(*avl.Tree)\n\t\tt.Remove(string(flagID))\n\t\tif t.Size() == 0 {\n\t\t\tempty = append(empty, key)\n\t\t}\n\t\treturn false\n\t})\n\tfor _, key := range empty {\n\t\tfi.flagsByFlaggerID.Remove(key)\n\t}\n}\n\nfunc (fi *FlagsIndex) Dump() string {\n\tstr := \"\"\n\n\tstr += \"## flagsCounts:\\n\"\n\tfor i := range fi.flagsCounts {\n\t\tstr += \"- \"\n\t\tif fi.flagsCounts[i] == nil {\n\t\t\tstr += \"nil (\" + strconv.Itoa(i) + \")\\n\"\n\t\t\tcontinue\n\t\t}\n\t\tstr += string(fi.flagsCounts[i].FlagID) + \" \" + strconv.FormatUint(fi.flagsCounts[i].Count, 10) + \"\\n\"\n\t}\n\n\tstr += \"\\n## flagsCountsByID:\\n\"\n\tfi.flagsCountsByID.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tstr += \"- \"\n\t\tif value == nil {\n\t\t\tstr += \"nil (\" + key + \")\\n\"\n\t\t\treturn false\n\t\t}\n\t\tstr += key + \": \" + string(value.(*FlagCount).FlagID) + \" \" + strconv.FormatUint(value.(*FlagCount).Count, 10) + \"\\n\"\n\t\treturn false\n\t})\n\n\tstr += \"\\n## flagsByFlaggerID:\\n\"\n\tfi.flagsByFlaggerID.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tstr += \"- \" + key + \":\\n\"\n\t\tvalue.(*avl.Tree).Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tstr += \"  - \" + key + \"\\n\"\n\t\t\treturn false\n\t\t})\n\t\treturn false\n\t})\n\n\treturn str\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"50000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"meIHZ3x48dNNGD6F6ZEseJJosZIZKBsMnxOBsHj+euZSlxHwS4ObTV2hcxfQPiTckWWswF0X2qh/SjsmpOjMNA=="}],"memo":""},"blockNum":"181050"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","package":{"name":"dao_interfaces","path":"gno.land/p/teritori/dao_interfaces","files":[{"name":"core.gno","body":"package dao_interfaces\n\ntype ActivableProposalModule struct {\n\tEnabled bool\n\tModule  IProposalModule\n}\n\ntype IDAOCore interface {\n\tRender(path string) string\n\n\tVotingModule() IVotingModule\n\tProposalModules() []ActivableProposalModule\n\tActiveProposalModuleCount() int\n\tRegistry() *MessagesRegistry\n\n\tUpdateVotingModule(newVotingModule IVotingModule)\n\tUpdateProposalModules(toAdd []IProposalModule, toDisable []int)\n}\n"},{"name":"core_testing.gno","body":"package dao_interfaces\n\ntype dummyCore struct{}\n\nfunc NewDummyCore() IDAOCore {\n\treturn \u0026dummyCore{}\n}\n\nfunc (d *dummyCore) Render(path string) string {\n\tpanic(\"not implemented\")\n}\n\nfunc (d *dummyCore) VotingModule() IVotingModule {\n\tpanic(\"not implemented\")\n}\n\nfunc (d *dummyCore) ProposalModules() []ActivableProposalModule {\n\tpanic(\"not implemented\")\n}\n\nfunc (d *dummyCore) ActiveProposalModuleCount() int {\n\tpanic(\"not implemented\")\n}\n\nfunc (d *dummyCore) Registry() *MessagesRegistry {\n\tpanic(\"not implemented\")\n}\n\nfunc (d *dummyCore) UpdateVotingModule(newVotingModule IVotingModule) {\n\tpanic(\"not implemented\")\n}\n\nfunc (d *dummyCore) UpdateProposalModules(toAdd []IProposalModule, toDisable []int) {\n\tpanic(\"not implemented\")\n}\n"},{"name":"messages.gno","body":"package dao_interfaces\n\nimport (\n\t\"gno.land/p/teritori/ujson\"\n)\n\ntype ExecutableMessage interface {\n\tujson.JSONAble\n\tujson.FromJSONAble\n\n\tString() string\n\tType() string\n}\n\ntype MessageHandler interface {\n\tExecute(message ExecutableMessage)\n\tMessageFromJSON(ast *ujson.JSONASTNode) ExecutableMessage\n\tType() string\n}\n\ntype MessageHandlerFactory func(core IDAOCore) MessageHandler\n"},{"name":"messages_registry.gno","body":"package dao_interfaces\n\nimport (\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/teritori/ujson\"\n)\n\ntype MessagesRegistry struct {\n\thandlers *avl.Tree\n}\n\nfunc NewMessagesRegistry() *MessagesRegistry {\n\tregistry := \u0026MessagesRegistry{handlers: avl.NewTree()}\n\tregistry.Register(NewRegisterHandlerExecutableMessageHandler(registry))\n\tregistry.Register(NewRemoveHandlerExecutableMessageHandler(registry))\n\treturn registry\n}\n\nfunc (r *MessagesRegistry) Register(handler MessageHandler) {\n\tr.handlers.Set(handler.Type(), handler)\n}\n\nfunc (r *MessagesRegistry) Remove(t string) {\n\tr.handlers.Remove(t)\n}\n\nfunc (r *MessagesRegistry) MessagesFromJSON(messagesJSON string) []ExecutableMessage {\n\tslice := ujson.ParseSlice(messagesJSON)\n\tmsgs := make([]ExecutableMessage, 0, len(slice))\n\tfor _, child := range slice {\n\t\tvar messageType string\n\t\tvar payload *ujson.JSONASTNode\n\t\tchild.ParseObject([]*ujson.ParseKV{\n\t\t\t{Key: \"type\", Value: \u0026messageType},\n\t\t\t{Key: \"payload\", Value: \u0026payload},\n\t\t})\n\t\th, ok := r.handlers.Get(messageType)\n\t\tif !ok {\n\t\t\tpanic(\"invalid ExecutableMessage: invalid message type\")\n\t\t}\n\t\tmsgs = append(msgs, h.(MessageHandler).MessageFromJSON(payload))\n\t}\n\treturn msgs\n}\n\nfunc (r *MessagesRegistry) Execute(msg ExecutableMessage) {\n\th, ok := r.handlers.Get(msg.Type())\n\tif !ok {\n\t\tpanic(\"invalid ExecutableMessage: invalid message type\")\n\t}\n\th.(MessageHandler).Execute(msg)\n}\n\nfunc (r *MessagesRegistry) ExecuteMessages(msgs []ExecutableMessage) {\n\tfor _, msg := range msgs {\n\t\tr.Execute(msg)\n\t}\n}\n\ntype RegisterHandlerExecutableMessage struct {\n\tHandler MessageHandler\n}\n\nfunc (m RegisterHandlerExecutableMessage) Type() string {\n\treturn \"gno.land/p/teritori/dao_interfaces.RegisterHandler\"\n}\n\nfunc (m *RegisterHandlerExecutableMessage) FromJSON(ast *ujson.JSONASTNode) {\n\tpanic(\"not implemented\")\n}\n\nfunc (m *RegisterHandlerExecutableMessage) ToJSON() string {\n\tpanic(\"not implemented\")\n}\n\nfunc (m *RegisterHandlerExecutableMessage) String() string {\n\treturn m.Handler.Type()\n}\n\ntype RegisterHandlerExecutableMessageHandler struct {\n\tregistry *MessagesRegistry\n}\n\nfunc NewRegisterHandlerExecutableMessageHandler(registry *MessagesRegistry) *RegisterHandlerExecutableMessageHandler {\n\treturn \u0026RegisterHandlerExecutableMessageHandler{registry: registry}\n}\n\nfunc (h RegisterHandlerExecutableMessageHandler) Type() string {\n\treturn RegisterHandlerExecutableMessage{}.Type()\n}\n\nfunc (h *RegisterHandlerExecutableMessageHandler) MessageFromJSON(ast *ujson.JSONASTNode) ExecutableMessage {\n\tpanic(\"not implemented\")\n}\n\nfunc (h *RegisterHandlerExecutableMessageHandler) Execute(msg ExecutableMessage) {\n\th.registry.Register(msg.(*RegisterHandlerExecutableMessage).Handler)\n}\n\ntype RemoveHandlerExecutableMessage struct {\n\tHandlerType string\n}\n\nfunc (m RemoveHandlerExecutableMessage) Type() string {\n\treturn \"gno.land/p/teritori/dao_interfaces.RemoveHandler\"\n}\n\nfunc (m *RemoveHandlerExecutableMessage) FromJSON(ast *ujson.JSONASTNode) {\n\tast.ParseAny(\u0026m.HandlerType)\n}\n\nfunc (m *RemoveHandlerExecutableMessage) ToJSON() string {\n\treturn ujson.FormatAny(m.HandlerType)\n}\n\nfunc (m *RemoveHandlerExecutableMessage) String() string {\n\treturn m.HandlerType\n}\n\ntype RemoveHandlerExecutableMessageHandler struct {\n\tregistry *MessagesRegistry\n}\n\nfunc NewRemoveHandlerExecutableMessageHandler(registry *MessagesRegistry) *RemoveHandlerExecutableMessageHandler {\n\treturn \u0026RemoveHandlerExecutableMessageHandler{registry: registry}\n}\n\nfunc (h RemoveHandlerExecutableMessageHandler) Type() string {\n\treturn RemoveHandlerExecutableMessage{}.Type()\n}\n\nfunc (h *RemoveHandlerExecutableMessageHandler) MessageFromJSON(ast *ujson.JSONASTNode) ExecutableMessage {\n\tmsg := \u0026RemoveHandlerExecutableMessage{}\n\tast.ParseAny(msg)\n\treturn msg\n}\n\nfunc (h *RemoveHandlerExecutableMessageHandler) Execute(msg ExecutableMessage) {\n\th.registry.Remove(msg.(*RemoveHandlerExecutableMessage).HandlerType)\n}\n"},{"name":"messages_registry_test.gno","body":"package dao_interfaces\n\nimport (\n\t\"testing\"\n)\n\nfunc TestRegistry(t *testing.T) {\n\tregistry := NewMessagesRegistry()\n\n\tvar value string\n\tmsgHandler := NewCopyMessageHandler(\u0026value)\n\n\t// Test register handler via message\n\tregisterMsg := \u0026RegisterHandlerExecutableMessage{Handler: msgHandler}\n\tregistry.Execute(registerMsg)\n\n\t// Test messages execution\n\tmsgs := registry.MessagesFromJSON(`[{\"type\":\"CopyMessage\",\"payload\":\"Hello\"}]`)\n\tif len(msgs) != 1 {\n\t\tt.Errorf(\"Expected 1 message, got %d\", len(msgs))\n\t}\n\tregistry.Execute(msgs[0])\n\tif value != \"Hello\" {\n\t\tt.Errorf(\"Expected value to be 'Hello', got '%s'\", value)\n\t}\n\n\tmsg2 := \u0026CopyMessage{Value: \"World\"}\n\tregistry.Execute(msg2)\n\tif value != \"World\" {\n\t\tt.Errorf(\"Expected value to be 'World', got '%s'\", value)\n\t}\n\n\t// Test handler removal\n\tremoveMsg := \u0026RemoveHandlerExecutableMessage{HandlerType: msgHandler.Type()}\n\tregistry.Execute(removeMsg)\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic, got none\")\n\t\t\t}\n\t\t}()\n\t\tregistry.Execute(msg2)\n\t}()\n\n\t// Test direct register\n\tregistry.Register(msgHandler)\n\tmsg3 := \u0026CopyMessage{Value: \"!\"}\n\tregistry.Execute(msg3)\n\tif value != \"!\" {\n\t\tt.Errorf(\"Expected value to be '!', got '%s'\", value)\n\t}\n}\n"},{"name":"messages_testing.gno","body":"package dao_interfaces\n\nimport (\n\t\"gno.land/p/teritori/ujson\"\n)\n\ntype CopyMessage struct {\n\tValue string\n}\n\nfunc (m CopyMessage) Type() string {\n\treturn \"CopyMessage\"\n}\n\nfunc (m *CopyMessage) String() string {\n\treturn m.Value\n}\n\nfunc (m *CopyMessage) FromJSON(ast *ujson.JSONASTNode) {\n\tast.ParseAny(\u0026m.Value)\n}\n\nfunc (m *CopyMessage) ToJSON() string {\n\treturn ujson.FormatString(m.Value)\n}\n\ntype CopyMessageHandler struct {\n\tptr *string\n}\n\nfunc NewCopyMessageHandler(ptr *string) *CopyMessageHandler {\n\tif ptr == nil {\n\t\tpanic(\"ptr cannot be nil\")\n\t}\n\treturn \u0026CopyMessageHandler{ptr}\n}\n\nfunc (h *CopyMessageHandler) Execute(imsg ExecutableMessage) {\n\tmsg, ok := imsg.(*CopyMessage)\n\tif !ok {\n\t\tpanic(\"Wrong message type\")\n\t}\n\t*h.ptr = msg.Value\n}\n\nfunc (h CopyMessageHandler) Type() string {\n\treturn \"CopyMessage\"\n}\n\nfunc (h *CopyMessageHandler) MessageFromJSON(ast *ujson.JSONASTNode) ExecutableMessage {\n\tvar msg CopyMessage\n\tast.ParseAny(\u0026msg)\n\treturn \u0026msg\n}\n"},{"name":"modules.gno","body":"package dao_interfaces\n\nimport (\n\t\"std\"\n)\n\ntype ModuleInfo struct {\n\tKind    string\n\tVersion string\n}\n\n// NOTE: Some queries take a height param in DA0-DA0 contracts, but since gno seem to aim to support queries at any height, we shouldn't need it\n\ntype IVotingModule interface {\n\tInfo() ModuleInfo\n\tConfigJSON() string\n\tRender(path string) string\n\tVotingPowerAtHeight(address std.Address, height int64) (power uint64)\n\tTotalPowerAtHeight(height int64) uint64\n}\n\ntype VotingModuleFactory func(core IDAOCore) IVotingModule\n\ntype IProposalModule interface {\n\tCore() IDAOCore\n\tInfo() ModuleInfo\n\tConfigJSON() string\n\tRender(path string) string\n\tExecute(proposalID int)\n\tVoteJSON(proposalID int, voteJSON string)\n\tProposeJSON(proposalJSON string) int\n\tProposalsJSON(limit int, startAfter string, reverse bool) string\n\tProposalJSON(proposalID int) string\n}\n\ntype ProposalModuleFactory func(core IDAOCore) IProposalModule\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"50000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"3e9o0AUkWHchj8fgHOEtQFfXYlrBmAjaw/Cm+NxhZQkv2jnbVly1HxtvUT2ZPVN8yTAUfnvrsYzYh9VbLn/u7g=="}],"memo":""},"blockNum":"181052"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","package":{"name":"social_feeds","path":"gno.land/r/teritori/social_feeds","files":[{"name":"binutils_extra.gno","body":"package social_feeds\n\nimport (\n\t\"encoding/binary\"\n)\n\nfunc EncodeLengthPrefixedStringUint32BE(s string) []byte {\n\tb := make([]byte, 4+len(s))\n\tbinary.BigEndian.PutUint32(b, uint32(len(s)))\n\tcopy(b[4:], s)\n\treturn b\n}\n"},{"name":"feed.gno","body":"package social_feeds\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/teritori/flags_index\"\n\tujson \"gno.land/p/teritori/ujson\"\n)\n\ntype FeedID uint64\n\nfunc (fid FeedID) String() string {\n\treturn strconv.Itoa(int(fid))\n}\n\nfunc (fid *FeedID) FromJSON(ast *ujson.JSONASTNode) {\n\tval, err := strconv.Atoi(ast.Value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t*fid = FeedID(val)\n}\n\nfunc (fid FeedID) ToJSON() string {\n\treturn strconv.Itoa(int(fid))\n}\n\ntype Feed struct {\n\tid        FeedID\n\turl       string\n\tname      string\n\tcreator   std.Address\n\towner     std.Address\n\tposts     avl.Tree // pidkey -\u003e *Post\n\tcreatedAt int64\n\n\tflags             *flags_index.FlagsIndex\n\thiddenPostsByUser avl.Tree // std.Address =\u003e *avl.Tree (postID =\u003e bool)\n\n\tpostsCtr uint64\n}\n\nfunc newFeed(fid FeedID, url string, name string, creator std.Address) *Feed {\n\tif !reName.MatchString(name) {\n\t\tpanic(\"invalid feed name: \" + name)\n\t}\n\n\tif gFeedsByName.Has(name) {\n\t\tpanic(\"feed already exists: \" + name)\n\t}\n\n\treturn \u0026Feed{\n\t\tid:        fid,\n\t\turl:       url,\n\t\tname:      name,\n\t\tcreator:   creator,\n\t\towner:     creator,\n\t\tposts:     avl.Tree{},\n\t\tcreatedAt: time.Now().Unix(),\n\t\tflags:     flags_index.NewFlagsIndex(),\n\t\tpostsCtr:  0,\n\t}\n}\n\nfunc (feed *Feed) incGetPostID() PostID {\n\tfeed.postsCtr++\n\treturn PostID(feed.postsCtr)\n}\n\nfunc (feed *Feed) GetPost(pid PostID) *Post {\n\tpidkey := postIDKey(pid)\n\tpost_, exists := feed.posts.Get(pidkey)\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn post_.(*Post)\n}\n\nfunc (feed *Feed) MustGetPost(pid PostID) *Post {\n\tpost := feed.GetPost(pid)\n\tif post == nil {\n\t\tpanic(\"post does not exist\")\n\t}\n\treturn post\n}\n\nfunc (feed *Feed) AddPost(creator std.Address, parentID PostID, category uint64, metadata string) *Post {\n\tpid := feed.incGetPostID()\n\tpidkey := postIDKey(pid)\n\n\tpost := newPost(feed, pid, creator, parentID, category, metadata)\n\tfeed.posts.Set(pidkey, post)\n\n\t// If post is a comment then increase the comment count on parent\n\tif uint64(parentID) != 0 {\n\t\tparent := feed.MustGetPost(parentID)\n\t\tparent.commentsCount += 1\n\t}\n\n\treturn post\n}\n\nfunc (feed *Feed) FlagPost(flagBy std.Address, pid PostID) {\n\tflagID := getFlagID(feed.id, pid)\n\n\tif feed.flags.HasFlagged(flagID, flagBy.String()) {\n\t\tpanic(\"already flagged\")\n\t}\n\n\tfeed.flags.Flag(flagID, flagBy.String())\n}\n\nfunc (feed *Feed) BanPost(pid PostID) {\n\tpidkey := postIDKey(pid)\n\t_, removed := feed.posts.Remove(pidkey)\n\tif !removed {\n\t\tpanic(\"post does not exist with id \" + pid.String())\n\t}\n}\n\nfunc (feed *Feed) HidePostForUser(caller std.Address, pid PostID) {\n\tuserAddr := caller.String()\n\n\tvalue, exists := feed.hiddenPostsByUser.Get(userAddr)\n\tvar hiddenPosts *avl.Tree\n\tif exists {\n\t\thiddenPosts = value.(*avl.Tree)\n\t} else {\n\t\thiddenPosts = avl.NewTree()\n\t\tfeed.hiddenPostsByUser.Set(userAddr, hiddenPosts)\n\t}\n\n\tif hiddenPosts.Has(pid.String()) {\n\t\tpanic(\"PostID is already hidden: \" + pid.String())\n\t}\n\n\thiddenPosts.Set(pid.String(), true)\n}\n\nfunc (feed *Feed) UnHidePostForUser(userAddress std.Address, pid PostID) {\n\tvalue, exists := feed.hiddenPostsByUser.Get(userAddress.String())\n\tvar hiddenPosts *avl.Tree\n\tif exists {\n\t\thiddenPosts = value.(*avl.Tree)\n\t\t_, removed := hiddenPosts.Remove(pid.String())\n\t\tif !removed {\n\t\t\tpanic(\"Post is not hidden: \" + pid.String())\n\t\t}\n\t} else {\n\t\tpanic(\"User has not hidden post: \" + pid.String())\n\t}\n}\n\nfunc (feed *Feed) Render() string {\n\tpkgpath := std.CurrentRealm().PkgPath()\n\n\tstr := \"\"\n\tstr += ufmt.Sprintf(\"Feed: %s (ID: %s) - Owner: %s\", feed.name, feed.id, feed.owner)\n\tstr += \"\\n\\n There are \" + intToString(feed.posts.Size()) + \" post(s) \\n\\n\"\n\n\tif feed.posts.Size() \u003e 0 {\n\t\tfeed.posts.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tif str != \"\" {\n\t\t\t\tstr += \"\\n\"\n\t\t\t}\n\n\t\t\tpost := value.(*Post)\n\t\t\tpostUrl := strings.Replace(pkgpath, \"gno.land\", \"\", -1) + \":\" + feed.name + \"/\" + post.id.String()\n\n\t\t\tstr += \" * [\" +\n\t\t\t\t\"PostID: \" + post.id.String() +\n\t\t\t\t\" - \" + intToString(post.reactions.Size()) + \" reactions \" +\n\t\t\t\t\" - \" + ufmt.Sprintf(\"%d\", post.tipAmount) + \" tip amount\" +\n\t\t\t\t\"]\" +\n\t\t\t\t\"(\" + postUrl + \")\" +\n\t\t\t\t\"\\n\"\n\t\t\treturn false\n\t\t})\n\n\t\tstr += \"-------------------------\\n\"\n\t\tstr += feed.flags.Dump()\n\t}\n\n\tstr += \"---------------------------------------\\n\"\n\tif feed.hiddenPostsByUser.Size() \u003e 0 {\n\t\tstr += \"Hidden posts by users:\\n\\n\"\n\n\t\tfeed.hiddenPostsByUser.Iterate(\"\", \"\", func(userAddr string, value interface{}) bool {\n\t\t\thiddenPosts := value.(*avl.Tree)\n\t\t\tstr += \"\\nUser address: \" + userAddr + \"\\n\"\n\n\t\t\thiddenPosts.Iterate(\"\", \"\", func(pid string, value interface{}) bool {\n\t\t\t\tstr += \"- PostID: \" + pid + \"\\n\"\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\treturn false\n\t\t})\n\t}\n\n\treturn str\n}\n\nfunc (feed *Feed) ToJSON() string {\n\tposts := []ujson.FormatKV{}\n\tfeed.posts.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tposts = append(posts, ujson.FormatKV{\n\t\t\tKey:   key,\n\t\t\tValue: value.(*Post),\n\t\t})\n\t\treturn false\n\t})\n\tfeedJSON := ujson.FormatObject([]ujson.FormatKV{\n\t\t{Key: \"id\", Value: uint64(feed.id)},\n\t\t{Key: \"url\", Value: feed.url},\n\t\t{Key: \"name\", Value: feed.name},\n\t\t{Key: \"creator\", Value: feed.creator},\n\t\t{Key: \"owner\", Value: feed.owner},\n\t\t{Key: \"posts\", Value: ujson.FormatObject(posts), Raw: true},\n\t\t{Key: \"createdAt\", Value: feed.createdAt},\n\t\t{Key: \"postsCtr\", Value: feed.postsCtr},\n\t\t// TODO: convert flags, hiddenPostsByUser\n\t\t// {Key: \"flags\", Value: feed.flags},\n\t\t// {Key: \"hiddenPostsByUser\", Value: feed.hiddenPostsByUser},\n\t})\n\treturn feedJSON\n}\n\nfunc (feed *Feed) FromJSON(jsonData string) {\n\tast := ujson.TokenizeAndParse(jsonData)\n\tast.ParseObject([]*ujson.ParseKV{\n\t\t{Key: \"id\", CustomParser: func(node *ujson.JSONASTNode) {\n\t\t\tfid, _ := strconv.Atoi(node.Value)\n\t\t\tfeed.id = FeedID(fid)\n\t\t}},\n\t\t{Key: \"url\", Value: \u0026feed.url},\n\t\t{Key: \"name\", Value: \u0026feed.name},\n\t\t{Key: \"creator\", Value: \u0026feed.creator},\n\t\t{Key: \"owner\", Value: \u0026feed.owner},\n\t\t{Key: \"posts\", CustomParser: func(node *ujson.JSONASTNode) {\n\t\t\tposts := avl.NewTree()\n\t\t\tfor _, child := range node.ObjectChildren {\n\t\t\t\tpostNode := child.Value\n\n\t\t\t\tpost := Post{}\n\t\t\t\tpost.FromJSON(postNode.String())\n\t\t\t\tposts.Set(child.Key, \u0026post)\n\t\t\t}\n\t\t\tfeed.posts = *posts\n\t\t}},\n\t\t{Key: \"createdAt\", Value: \u0026feed.createdAt},\n\t\t{Key: \"postsCtr\", Value: \u0026feed.postsCtr},\n\t})\n}\n"},{"name":"feeds.gno","body":"package social_feeds\n\nimport (\n\t\"regexp\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n//----------------------------------------\n// Realm (package) state\n\nvar (\n\tgFeeds       avl.Tree // id -\u003e *Feed\n\tgFeedsCtr    int      // increments Feed.id\n\tgFeedsByName avl.Tree // name -\u003e *Feed\n)\n\n//----------------------------------------\n// Constants\n\nvar reName = regexp.MustCompile(`^[a-z]+[_a-z0-9]{2,29}$`)\n"},{"name":"feeds_test.gno","body":"package social_feeds\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/testutils\"\n\tujson \"gno.land/p/teritori/ujson\"\n)\n\nvar (\n\trootPostID = PostID(0)\n\tpostID1    = PostID(1)\n\tfeedID1    = FeedID(1)\n\tcat1       = uint64(1)\n\tcat2       = uint64(2)\n\tuser       = testutils.TestAddress(\"user\")\n\tfilter_all = []uint64{}\n)\n\nfunc getFeed1() *Feed {\n\treturn mustGetFeed(feedID1)\n}\n\nfunc getPost1() *Post {\n\tfeed1 := getFeed1()\n\tpost1 := feed1.MustGetPost(postID1)\n\treturn post1\n}\n\nfunc testCreateFeed(t *testing.T) {\n\tfeedID := CreateFeed(\"teritori1\")\n\tfeed := mustGetFeed(feedID)\n\n\tif feedID != 1 {\n\t\tt.Fatalf(\"expected feedID: 1, got %q.\", feedID)\n\t}\n\n\tif feed.name != \"teritori1\" {\n\t\tt.Fatalf(\"expected feedName: teritori1, got %q.\", feed.name)\n\t}\n}\n\nfunc testCreatePost(t *testing.T) {\n\tmetadata := `{\"gifs\": [], \"files\": [], \"title\": \"\", \"message\": \"testouille\", \"hashtags\": [], \"mentions\": [], \"createdAt\": \"2023-03-29T12:19:04.858Z\", \"updatedAt\": \"2023-03-29T12:19:04.858Z\"}`\n\tpostID := CreatePost(feedID1, rootPostID, cat1, metadata)\n\tfeed := mustGetFeed(feedID1)\n\tpost := feed.MustGetPost(postID)\n\n\tif postID != 1 {\n\t\tt.Fatalf(\"expected postID: 1, got %q.\", postID)\n\t}\n\n\tif post.category != cat1 {\n\t\tt.Fatalf(\"expected categoryID: %q, got %q.\", cat1, post.category)\n\t}\n}\n\nfunc toPostIDsStr(posts []*Post) string {\n\tvar postIDs []string\n\tfor _, post := range posts {\n\t\tpostIDs = append(postIDs, post.id.String())\n\t}\n\n\tpostIDsStr := strings.Join(postIDs, \",\")\n\treturn postIDsStr\n}\n\nfunc testGetPosts(t *testing.T) {\n\tuser := std.Address(\"user\")\n\tstd.TestSetOrigCaller(user)\n\n\tfeedID := CreateFeed(\"teritori10\")\n\tfeed := mustGetFeed(feedID)\n\n\tCreatePost(feedID, rootPostID, cat1, \"post1\")\n\tCreatePost(feedID, rootPostID, cat1, \"post2\")\n\tCreatePost(feedID, rootPostID, cat1, \"post3\")\n\tCreatePost(feedID, rootPostID, cat1, \"post4\")\n\tCreatePost(feedID, rootPostID, cat1, \"post5\")\n\tpostIDToFlagged := CreatePost(feedID, rootPostID, cat1, \"post6\")\n\tpostIDToHide := CreatePost(feedID, rootPostID, cat1, \"post7\")\n\tCreatePost(feedID, rootPostID, cat1, \"post8\")\n\n\tvar posts []*Post\n\tvar postIDsStr string\n\n\t// Query last 3 posts\n\tposts = getPosts(feed, 0, \"\", \"\", []uint64{}, 0, 3)\n\tpostIDsStr = toPostIDsStr(posts)\n\n\tif postIDsStr != \"8,7,6\" {\n\t\tt.Fatalf(\"expected posts order: 8,7,6. Got: %s\", postIDsStr)\n\t}\n\n\t// Query page 2\n\tposts = getPosts(feed, 0, \"\", \"\", []uint64{}, 3, 3)\n\tpostIDsStr = toPostIDsStr(posts)\n\tif postIDsStr != \"5,4,3\" {\n\t\tt.Fatalf(\"expected posts order: 5,4,3. Got: %s\", postIDsStr)\n\t}\n\n\t// Exclude hidden post\n\tHidePostForMe(feed.id, postIDToHide)\n\n\tposts = getPosts(feed, 0, user.String(), \"\", []uint64{}, 0, 3)\n\tpostIDsStr = toPostIDsStr(posts)\n\n\tif postIDsStr != \"8,6,5\" {\n\t\tt.Fatalf(\"expected posts order: 8,6,5. Got: %s\", postIDsStr)\n\t}\n\n\t// Exclude flagged post\n\tFlagPost(feed.id, postIDToFlagged)\n\n\tposts = getPosts(feed, 0, user.String(), \"\", []uint64{}, 0, 3)\n\tpostIDsStr = toPostIDsStr(posts)\n\n\tif postIDsStr != \"8,5,4\" {\n\t\tt.Fatalf(\"expected posts order: 8,5,4. Got: %s\", postIDsStr)\n\t}\n\n\t// Pagination with hidden/flagged posts\n\tposts = getPosts(feed, 0, user.String(), \"\", []uint64{}, 3, 3)\n\tpostIDsStr = toPostIDsStr(posts)\n\n\tif postIDsStr != \"3,2,1\" {\n\t\tt.Fatalf(\"expected posts order: 3,2,1. Got: %s\", postIDsStr)\n\t}\n\n\t// Query out of range\n\tposts = getPosts(feed, 0, user.String(), \"\", []uint64{}, 6, 3)\n\tpostIDsStr = toPostIDsStr(posts)\n\n\tif postIDsStr != \"\" {\n\t\tt.Fatalf(\"expected posts order: ''. Got: %s\", postIDsStr)\n\t}\n}\n\nfunc testReactPost(t *testing.T) {\n\tfeed := getFeed1()\n\tpost := getPost1()\n\n\ticon := \"🥰\"\n\tReactPost(feed.id, post.id, icon, true)\n\n\t// Set reaction\n\treactionCount_, ok := post.reactions.Get(\"🥰\")\n\tif !ok {\n\t\tt.Fatalf(\"expected 🥰 exists\")\n\t}\n\n\treactionCount := reactionCount_.(int)\n\tif reactionCount != 1 {\n\t\tt.Fatalf(\"expected reactionCount: 1, got %q.\", reactionCount)\n\t}\n\n\t// Unset reaction\n\tReactPost(feed.id, post.id, icon, false)\n\t_, exist := post.reactions.Get(\"🥰\")\n\tif exist {\n\t\tt.Fatalf(\"expected 🥰 not exist\")\n\t}\n}\n\nfunc testCreateAndDeleteComment(t *testing.T) {\n\tfeed1 := getFeed1()\n\tpost1 := getPost1()\n\n\tmetadata := `empty_meta_data`\n\n\tcommentID1 := CreatePost(feed1.id, post1.id, cat1, metadata)\n\tcommentID2 := CreatePost(feed1.id, post1.id, cat1, metadata)\n\tcomment2 := feed1.MustGetPost(commentID2)\n\n\tif comment2.id != 3 { // 1 post + 2 comments = 3\n\t\tt.Fatalf(\"expected comment postID: 3, got %q.\", comment2.id)\n\t}\n\n\tif comment2.parentID != post1.id {\n\t\tt.Fatalf(\"expected comment parentID: %q, got %q.\", post1.id, comment2.parentID)\n\t}\n\n\t// Check comment count on parent\n\tif post1.commentsCount != 2 {\n\t\tt.Fatalf(\"expected comments count: 2, got %d.\", post1.commentsCount)\n\t}\n\n\t// Get comments\n\tcomments := GetComments(feed1.id, post1.id, 0, 10)\n\tcommentsParsed := ujson.ParseSlice(comments)\n\n\tif len(commentsParsed) != 2 {\n\t\tt.Fatalf(\"expected encoded comments: 2, got %q.\", commentsParsed)\n\t}\n\n\t// Delete 1 comment\n\tDeletePost(feed1.id, comment2.id)\n\tcomments = GetComments(feed1.id, post1.id, 0, 10)\n\tcommentsParsed = ujson.ParseSlice(comments)\n\n\tif len(commentsParsed) != 1 {\n\t\tt.Fatalf(\"expected encoded comments: 1, got %q.\", commentsParsed)\n\t}\n\n\t// Check comment count on parent\n\tif post1.commentsCount != 1 {\n\t\tt.Fatalf(\"expected comments count: 1, got %d.\", post1.commentsCount)\n\t}\n}\n\nfunc countPosts(feedID FeedID, categories []uint64, limit uint8) int {\n\toffset := uint64(0)\n\n\tpostsStr := GetPosts(feedID, 0, \"\", categories, offset, limit)\n\tif postsStr == \"[]\" {\n\t\treturn 0\n\t}\n\n\tparsedPosts := ujson.ParseSlice(postsStr)\n\tpostsCount := len(parsedPosts)\n\treturn postsCount\n}\n\nfunc countPostsByUser(feedID FeedID, user string) int {\n\toffset := uint64(0)\n\tlimit := uint8(10)\n\n\tpostsStr := GetPosts(feedID, 0, user, []uint64{}, offset, limit)\n\tif postsStr == \"[]\" {\n\t\treturn 0\n\t}\n\n\tparsedPosts := ujson.ParseSlice(postsStr)\n\tpostsCount := len(parsedPosts)\n\treturn postsCount\n}\n\nfunc testFilterByCategories(t *testing.T) {\n\t// // Re-add reaction to test post list\n\t// ReactPost(1, postID, \"🥰\", true)\n\t// ReactPost(1, postID, \"😇\", true)\n\n\tfilter_cat1 := []uint64{1}\n\tfilter_cat1_2 := []uint64{1, 2}\n\tfilter_cat9 := []uint64{9}\n\tfilter_cat1_2_9 := []uint64{1, 2, 9}\n\n\tfeedID2 := CreateFeed(\"teritori2\")\n\tfeed2 := mustGetFeed(feedID2)\n\n\t// Create 2 posts on root with cat1\n\tpostID1 := CreatePost(feed2.id, rootPostID, cat1, \"metadata\")\n\tpostID2 := CreatePost(feed2.id, rootPostID, cat1, \"metadata\")\n\n\t// Create 1 posts on root with cat2\n\tpostID3 := CreatePost(feed2.id, rootPostID, cat2, \"metadata\")\n\n\t// Create comments on post 1\n\tcommentPostID1 := CreatePost(feed2.id, postID1, cat1, \"metadata\")\n\n\t// cat1: Should return max = limit\n\tif count := countPosts(feed2.id, filter_cat1, 1); count != 1 {\n\t\tt.Fatalf(\"expected posts count: 1, got %q.\", count)\n\t}\n\n\t// cat1: Should return max = total\n\tif count := countPosts(feed2.id, filter_cat1, 10); count != 2 {\n\t\tt.Fatalf(\"expected posts count: 2, got %q.\", count)\n\t}\n\n\t// cat 1 + 2: Should return max = limit\n\tif count := countPosts(feed2.id, filter_cat1_2, 2); count != 2 {\n\t\tt.Fatalf(\"expected posts count: 2, got %q.\", count)\n\t}\n\n\t// cat 1 + 2: Should return max = total on both\n\tif count := countPosts(feed2.id, filter_cat1_2, 10); count != 3 {\n\t\tt.Fatalf(\"expected posts count: 3, got %q.\", count)\n\t}\n\n\t// cat 1, 2, 9: Should return total of 1, 2\n\tif count := countPosts(feed2.id, filter_cat1_2_9, 10); count != 3 {\n\t\tt.Fatalf(\"expected posts count: 3, got %q.\", count)\n\t}\n\n\t// cat 9: Should return 0\n\tif count := countPosts(feed2.id, filter_cat9, 10); count != 0 {\n\t\tt.Fatalf(\"expected posts count: 0, got %q.\", count)\n\t}\n\n\t// cat all: should return all\n\tif count := countPosts(feed2.id, filter_all, 10); count != 3 {\n\t\tt.Fatalf(\"expected posts count: 3, got %q.\", count)\n\t}\n\n\t// add comments should not impact the results\n\tCreatePost(feed2.id, postID1, cat1, \"metadata\")\n\tCreatePost(feed2.id, postID2, cat1, \"metadata\")\n\n\tif count := countPosts(feed2.id, filter_all, 10); count != 3 {\n\t\tt.Fatalf(\"expected posts count: 3, got %q.\", count)\n\t}\n\n\t// delete a post should affect the result\n\tDeletePost(feed2.id, postID1)\n\n\tif count := countPosts(feed2.id, filter_all, 10); count != 2 {\n\t\tt.Fatalf(\"expected posts count: 2, got %q.\", count)\n\t}\n}\n\nfunc testTipPost(t *testing.T) {\n\tcreator := testutils.TestAddress(\"creator\")\n\tstd.TestIssueCoins(creator, std.Coins{{\"ugnot\", 100_000_000}})\n\n\t// NOTE: Dont know why the address should be this to be able to call banker (= std.GetCallerAt(1))\n\ttipper := testutils.TestAddress(\"tipper\")\n\tstd.TestIssueCoins(tipper, std.Coins{{\"ugnot\", 50_000_000}})\n\n\tbanker := std.GetBanker(std.BankerTypeReadonly)\n\n\t// Check Original coins of creator/tipper\n\tif coins := banker.GetCoins(creator); coins[0].Amount != 100_000_000 {\n\t\tt.Fatalf(\"expected creator coin count: 100_000_000, got %d.\", coins[0].Amount)\n\t}\n\n\tif coins := banker.GetCoins(tipper); coins[0].Amount != 50_000_000 {\n\t\tt.Fatalf(\"expected tipper coin count: 50_000_000, got %d.\", coins[0].Amount)\n\t}\n\n\t// Creator creates feed, post\n\tstd.TestSetOrigCaller(creator)\n\n\tfeedID3 := CreateFeed(\"teritori3\")\n\tfeed3 := mustGetFeed(feedID3)\n\n\tpostID1 := CreatePost(feed3.id, rootPostID, cat1, \"metadata\")\n\tpost1 := feed3.MustGetPost(postID1)\n\n\t// Tiper tips the ppst\n\tstd.TestSetOrigCaller(tipper)\n\tstd.TestSetOrigSend(std.Coins{{\"ugnot\", 1_000_000}}, nil)\n\tTipPost(feed3.id, post1.id)\n\n\t// Coin must be increased for creator\n\tif coins := banker.GetCoins(creator); coins[0].Amount != 101_000_000 {\n\t\tt.Fatalf(\"expected creator coin after beging tipped: 101_000_000, got %d.\", coins[0].Amount)\n\t}\n\n\t// Total tip amount should increased\n\tif post1.tipAmount != 1_000_000 {\n\t\tt.Fatalf(\"expected total tipAmount: 1_000_000, got %d.\", post1.tipAmount)\n\t}\n\n\t// Add more tip should update this total\n\tstd.TestSetOrigSend(std.Coins{{\"ugnot\", 2_000_000}}, nil)\n\tTipPost(feed3.id, post1.id)\n\n\tif post1.tipAmount != 3_000_000 {\n\t\tt.Fatalf(\"expected total tipAmount: 3_000_000, got %d.\", post1.tipAmount)\n\t}\n}\n\nfunc testFlagPost(t *testing.T) {\n\tflagger := testutils.TestAddress(\"flagger\")\n\n\tfeedID9 := CreateFeed(\"teritori9\")\n\tfeed9 := mustGetFeed(feedID9)\n\n\tCreatePost(feed9.id, rootPostID, cat1, \"metadata1\")\n\tpid := CreatePost(feed9.id, rootPostID, cat1, \"metadata1\")\n\n\t// Flag post\n\tstd.TestSetOrigCaller(flagger)\n\tFlagPost(feed9.id, pid)\n\n\t// Another user flags\n\tanother := testutils.TestAddress(\"another\")\n\tstd.TestSetOrigCaller(another)\n\tFlagPost(feed9.id, pid)\n\n\tflaggedPostsStr := GetFlaggedPosts(feed9.id, 0, 10)\n\tparsed := ujson.ParseSlice(flaggedPostsStr)\n\tif flaggedPostsCount := len(parsed); flaggedPostsCount != 1 {\n\t\tt.Fatalf(\"expected flagged posts: 1, got %d.\", flaggedPostsCount)\n\t}\n}\n\nfunc testFilterUser(t *testing.T) {\n\tuser1 := testutils.TestAddress(\"user1\")\n\tuser2 := testutils.TestAddress(\"user2\")\n\n\t// User1 create 2 posts\n\tstd.TestSetOrigCaller(user1)\n\n\tfeedID4 := CreateFeed(\"teritori4\")\n\tfeed4 := mustGetFeed(feedID4)\n\n\tCreatePost(feed4.id, rootPostID, cat1, `{\"metadata\": \"value\"}`)\n\tCreatePost(feed4.id, rootPostID, cat1, `{\"metadata2\": \"value\"}`)\n\n\t// User2 create 1 post\n\tstd.TestSetOrigCaller(user2)\n\tCreatePost(feed4.id, rootPostID, cat1, `{\"metadata\": \"value\"}`)\n\n\tif count := countPostsByUser(feed4.id, user1.String()); count != 2 {\n\t\tt.Fatalf(\"expected total posts by user1: 2, got %d.\", count)\n\t}\n\n\tif count := countPostsByUser(feed4.id, user2.String()); count != 1 {\n\t\tt.Fatalf(\"expected total posts by user2: 1, got %d.\", count)\n\t}\n\n\tif count := countPostsByUser(feed4.id, \"\"); count != 3 {\n\t\tt.Fatalf(\"expected total posts: 3, got %d.\", count)\n\t}\n}\n\nfunc testHidePostForMe(t *testing.T) {\n\tuser := std.Address(\"user\")\n\tstd.TestSetOrigCaller(user)\n\n\tfeedID8 := CreateFeed(\"teritor8\")\n\tfeed8 := mustGetFeed(feedID8)\n\n\tpostIDToHide := CreatePost(feed8.id, rootPostID, cat1, `{\"metadata\": \"value\"}`)\n\tpostID := CreatePost(feed8.id, rootPostID, cat1, `{\"metadata\": \"value\"}`)\n\n\tif count := countPosts(feed8.id, filter_all, 10); count != 2 {\n\t\tt.Fatalf(\"expected posts count: 2, got %q.\", count)\n\t}\n\n\t// Hide a post for me\n\tHidePostForMe(feed8.id, postIDToHide)\n\n\tif count := countPosts(feed8.id, filter_all, 10); count != 1 {\n\t\tt.Fatalf(\"expected posts count after hidding: 1, got %q.\", count)\n\t}\n\n\t// Query from another user should return full list\n\tanother := std.Address(\"another\")\n\tstd.TestSetOrigCaller(another)\n\n\tif count := countPosts(feed8.id, filter_all, 10); count != 2 {\n\t\tt.Fatalf(\"expected posts count from another: 2, got %q.\", count)\n\t}\n\n\t// UnHide a post for me\n\tstd.TestSetOrigCaller(user)\n\tUnHidePostForMe(feed8.id, postIDToHide)\n\n\tif count := countPosts(feed8.id, filter_all, 10); count != 2 {\n\t\tt.Fatalf(\"expected posts count after unhidding: 2, got %q.\", count)\n\t}\n}\n\nfunc testMigrateFeedData(t *testing.T) {\n\tfeedID := CreateFeed(\"teritor11\")\n\n\t// Post to test\n\tpostID := CreatePost(feedID, PostID(0), 2, `{\"metadata\": \"value\"}`)\n\tReactPost(feedID, postID, \"🇬🇸\", true)\n\n\t// Add comment to post\n\tcommentID := CreatePost(feedID, postID, 2, `{\"comment1\": \"value\"}`)\n\tReactPost(feedID, commentID, \"🇬🇸\", true)\n\n\t// // Post with json metadata\n\tCreatePost(feedID, PostID(0), 2, `{'a':1}`)\n\n\t// Expect: should convert feed data to JSON successfully without error\n\tdataJSON := ExportFeedData(feedID)\n\tif dataJSON == \"\" {\n\t\tt.Fatalf(\"expected feed data exported successfully\")\n\t}\n\n\t// Import data =====================================\n\tImportFeedData(FeedID(uint64(feedID)), dataJSON)\n\n\t// Test public func\n\t// MigrateFromPreviousFeed(feedID)\n}\n\nfunc Test(t *testing.T) {\n\ttestCreateFeed(t)\n\n\ttestCreatePost(t)\n\n\ttestGetPosts(t)\n\n\ttestReactPost(t)\n\n\ttestCreateAndDeleteComment(t)\n\n\ttestFilterByCategories(t)\n\n\ttestTipPost(t)\n\n\ttestFilterUser(t)\n\n\ttestFlagPost(t)\n\n\ttestHidePostForMe(t)\n\n\ttestMigrateFeedData(t)\n}\n"},{"name":"flags.gno","body":"package social_feeds\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/teritori/flags_index\"\n)\n\nvar seperator = \"/\"\n\nfunc getFlagID(fid FeedID, pid PostID) flags_index.FlagID {\n\treturn flags_index.FlagID(fid.String() + seperator + pid.String())\n}\n\nfunc parseFlagID(flagID flags_index.FlagID) (FeedID, PostID) {\n\tparts := strings.Split(string(flagID), seperator)\n\tif len(parts) != 2 {\n\t\tpanic(\"invalid flag ID '\" + string(flagID) + \"'\")\n\t}\n\tfid, err := strconv.Atoi(parts[0])\n\tif err != nil || fid == 0 {\n\t\tpanic(\"invalid feed ID in flag ID '\" + parts[0] + \"'\")\n\t}\n\tpid, err := strconv.Atoi(parts[1])\n\tif err != nil || pid == 0 {\n\t\tpanic(\"invalid post ID in flag ID '\" + parts[1] + \"'\")\n\t}\n\treturn FeedID(fid), PostID(pid)\n}\n"},{"name":"messages.gno","body":"package social_feeds\n\nimport (\n\t\"strings\"\n\n\t\"gno.land/p/teritori/dao_interfaces\"\n\t\"gno.land/p/teritori/ujson\"\n)\n\n// Ban a post\ntype ExecutableMessageBanPost struct {\n\tdao_interfaces.ExecutableMessage\n\n\tFeedID FeedID\n\tPostID PostID\n\tReason string\n}\n\nfunc (msg ExecutableMessageBanPost) Type() string {\n\treturn \"gno.land/r/teritori/social_feeds.BanPost\"\n}\n\nfunc (msg *ExecutableMessageBanPost) ToJSON() string {\n\treturn ujson.FormatObject([]ujson.FormatKV{\n\t\t{Key: \"feedId\", Value: msg.FeedID},\n\t\t{Key: \"postId\", Value: msg.PostID},\n\t\t{Key: \"reason\", Value: msg.Reason},\n\t})\n}\n\nfunc (msg *ExecutableMessageBanPost) String() string {\n\tvar ss []string\n\tss = append(ss, msg.Type())\n\n\tfeed := getFeed(msg.FeedID)\n\ts := \"\"\n\n\tif feed != nil {\n\t\ts += \"Feed: \" + feed.name + \" (\" + feed.id.String() + \")\"\n\n\t\tpost := feed.GetPost(msg.PostID)\n\t\tif post != nil {\n\t\t\ts += \"\\n Post: \" + post.id.String()\n\t\t} else {\n\t\t\ts += \"\\n Post: \" + msg.PostID.String() + \" (not found)\"\n\t\t}\n\t} else {\n\t\ts += \"Feed: \" + msg.FeedID.String() + \" (not found)\"\n\t}\n\n\ts += \"\\nReason: \" + msg.Reason\n\n\tss = append(ss, s)\n\n\treturn strings.Join(ss, \"\\n---\\n\")\n}\n\ntype BanPostHandler struct {\n\tdao_interfaces.MessageHandler\n}\n\nfunc NewBanPostHandler() *BanPostHandler {\n\treturn \u0026BanPostHandler{}\n}\n\nfunc (h *BanPostHandler) Execute(iMsg dao_interfaces.ExecutableMessage) {\n\tmsg := iMsg.(*ExecutableMessageBanPost)\n\tBanPost(msg.FeedID, msg.PostID, msg.Reason)\n}\n\nfunc (h BanPostHandler) Type() string {\n\treturn ExecutableMessageBanPost{}.Type()\n}\n\nfunc (h *BanPostHandler) MessageFromJSON(ast *ujson.JSONASTNode) dao_interfaces.ExecutableMessage {\n\tmsg := \u0026ExecutableMessageBanPost{}\n\tast.ParseObject([]*ujson.ParseKV{\n\t\t{Key: \"feedId\", Value: \u0026msg.FeedID},\n\t\t{Key: \"postId\", Value: \u0026msg.PostID},\n\t\t{Key: \"reason\", Value: \u0026msg.Reason},\n\t})\n\treturn msg\n}\n"},{"name":"misc.gno","body":"package social_feeds\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc getFeed(fid FeedID) *Feed {\n\tfidkey := feedIDKey(fid)\n\tfeed_, exists := gFeeds.Get(fidkey)\n\tif !exists {\n\t\treturn nil\n\t}\n\tfeed := feed_.(*Feed)\n\treturn feed\n}\n\nfunc mustGetFeed(fid FeedID) *Feed {\n\tfeed := getFeed(fid)\n\tif feed == nil {\n\t\tpanic(\"Feed does not exist\")\n\t}\n\treturn feed\n}\n\nfunc incGetFeedID() FeedID {\n\tgFeedsCtr++\n\treturn FeedID(gFeedsCtr)\n}\n\nfunc feedIDKey(fid FeedID) string {\n\treturn padZero(uint64(fid), 10)\n}\n\nfunc postIDKey(pid PostID) string {\n\treturn padZero(uint64(pid), 10)\n}\n\nfunc padLeft(str string, length int) string {\n\tif len(str) \u003e= length {\n\t\treturn str\n\t} else {\n\t\treturn strings.Repeat(\" \", length-len(str)) + str\n\t}\n}\n\nfunc padZero(u64 uint64, length int) string {\n\tstr := strconv.Itoa(int(u64))\n\tif len(str) \u003e= length {\n\t\treturn str\n\t} else {\n\t\treturn strings.Repeat(\"0\", length-len(str)) + str\n\t}\n}\n\nfunc intToString(val int) string {\n\treturn strconv.Itoa(val)\n}\n"},{"name":"post.gno","body":"package social_feeds\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\tujson \"gno.land/p/teritori/ujson\"\n)\n\ntype PostID uint64\n\nfunc (pid PostID) String() string {\n\treturn strconv.Itoa(int(pid))\n}\n\nfunc (pid *PostID) FromJSON(ast *ujson.JSONASTNode) {\n\tval, err := strconv.Atoi(ast.Value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t*pid = PostID(val)\n}\n\nfunc (pid PostID) ToJSON() string {\n\treturn strconv.Itoa(int(pid))\n}\n\ntype Reaction struct {\n\ticon  string\n\tcount uint64\n}\n\nvar Categories []string = []string{\n\t\"Reaction\",\n\t\"Comment\",\n\t\"Normal\",\n\t\"Article\",\n\t\"Picture\",\n\t\"Audio\",\n\t\"Video\",\n}\n\ntype Post struct {\n\tid            PostID\n\tparentID      PostID\n\tfeedID        FeedID\n\tcategory      uint64\n\tmetadata      string\n\treactions     avl.Tree // icon -\u003e count\n\tcomments      avl.Tree // Post.id -\u003e *Post\n\tcreator       std.Address\n\ttipAmount     uint64\n\tdeleted       bool\n\tcommentsCount uint64\n\n\tcreatedAt int64\n\tupdatedAt int64\n\tdeletedAt int64\n}\n\nfunc newPost(feed *Feed, id PostID, creator std.Address, parentID PostID, category uint64, metadata string) *Post {\n\treturn \u0026Post{\n\t\tid:        id,\n\t\tparentID:  parentID,\n\t\tfeedID:    feed.id,\n\t\tcategory:  category,\n\t\tmetadata:  metadata,\n\t\treactions: avl.Tree{},\n\t\tcreator:   creator,\n\t\tcreatedAt: time.Now().Unix(),\n\t}\n}\n\nfunc (post *Post) String() string {\n\treturn post.ToJSON()\n}\n\nfunc (post *Post) Update(category uint64, metadata string) {\n\tpost.category = category\n\tpost.metadata = metadata\n\tpost.updatedAt = time.Now().Unix()\n}\n\nfunc (post *Post) Delete() {\n\tpost.deleted = true\n\tpost.deletedAt = time.Now().Unix()\n}\n\nfunc (post *Post) Tip(from std.Address, to std.Address) {\n\treceivedCoins := std.GetOrigSend()\n\tamount := receivedCoins[0].Amount\n\n\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\t// banker := std.GetBanker(std.BankerTypeRealmSend)\n\tcoinsToSend := std.Coins{std.Coin{Denom: \"ugnot\", Amount: amount}}\n\tpkgaddr := std.GetOrigPkgAddr()\n\n\tbanker.SendCoins(pkgaddr, to, coinsToSend)\n\n\t// Update tip amount\n\tpost.tipAmount += uint64(amount)\n}\n\n// Always remove reaction if count = 0\nfunc (post *Post) React(icon string, up bool) {\n\tcount_, ok := post.reactions.Get(icon)\n\tcount := 0\n\n\tif ok {\n\t\tcount = count_.(int)\n\t}\n\n\tif up {\n\t\tcount++\n\t} else {\n\t\tcount--\n\t}\n\n\tif count \u003c= 0 {\n\t\tpost.reactions.Remove(icon)\n\t} else {\n\t\tpost.reactions.Set(icon, count)\n\t}\n}\n\nfunc (post *Post) Render() string {\n\treturn post.metadata\n}\n\nfunc (post *Post) FromJSON(jsonData string) {\n\tast := ujson.TokenizeAndParse(jsonData)\n\tast.ParseObject([]*ujson.ParseKV{\n\t\t{Key: \"id\", CustomParser: func(node *ujson.JSONASTNode) {\n\t\t\tpid, _ := strconv.Atoi(node.Value)\n\t\t\tpost.id = PostID(pid)\n\t\t}},\n\t\t{Key: \"parentID\", CustomParser: func(node *ujson.JSONASTNode) {\n\t\t\tpid, _ := strconv.Atoi(node.Value)\n\t\t\tpost.parentID = PostID(pid)\n\t\t}},\n\t\t{Key: \"feedID\", CustomParser: func(node *ujson.JSONASTNode) {\n\t\t\tfid, _ := strconv.Atoi(node.Value)\n\t\t\tpost.feedID = FeedID(fid)\n\t\t}},\n\t\t{Key: \"category\", Value: \u0026post.category},\n\t\t{Key: \"metadata\", Value: \u0026post.metadata},\n\t\t{Key: \"reactions\", CustomParser: func(node *ujson.JSONASTNode) {\n\t\t\treactions := avl.NewTree()\n\t\t\tfor _, child := range node.ObjectChildren {\n\t\t\t\treactionCount := child.Value\n\t\t\t\treactions.Set(child.Key, reactionCount)\n\t\t\t}\n\t\t\tpost.reactions = *reactions\n\t\t}},\n\t\t{Key: \"commentsCount\", Value: \u0026post.commentsCount},\n\t\t{Key: \"creator\", Value: \u0026post.creator},\n\t\t{Key: \"tipAmount\", Value: \u0026post.tipAmount},\n\t\t{Key: \"deleted\", Value: \u0026post.deleted},\n\t\t{Key: \"createdAt\", Value: \u0026post.createdAt},\n\t\t{Key: \"updatedAt\", Value: \u0026post.updatedAt},\n\t\t{Key: \"deletedAt\", Value: \u0026post.deletedAt},\n\t})\n}\n\nfunc (post *Post) ToJSON() string {\n\treactionsKV := []ujson.FormatKV{}\n\tpost.reactions.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcount := value.(int)\n\t\tdata := ujson.FormatKV{Key: key, Value: count}\n\t\treactionsKV = append(reactionsKV, data)\n\t\treturn false\n\t})\n\treactions := ujson.FormatObject(reactionsKV)\n\n\tpostJSON := ujson.FormatObject([]ujson.FormatKV{\n\t\t{Key: \"id\", Value: uint64(post.id)},\n\t\t{Key: \"parentID\", Value: uint64(post.parentID)},\n\t\t{Key: \"feedID\", Value: uint64(post.feedID)},\n\t\t{Key: \"category\", Value: post.category},\n\t\t{Key: \"metadata\", Value: post.metadata},\n\t\t{Key: \"reactions\", Value: reactions, Raw: true},\n\t\t{Key: \"creator\", Value: post.creator},\n\t\t{Key: \"tipAmount\", Value: post.tipAmount},\n\t\t{Key: \"deleted\", Value: post.deleted},\n\t\t{Key: \"commentsCount\", Value: post.commentsCount},\n\t\t{Key: \"createdAt\", Value: post.createdAt},\n\t\t{Key: \"updatedAt\", Value: post.updatedAt},\n\t\t{Key: \"deletedAt\", Value: post.deletedAt},\n\t})\n\treturn postJSON\n}\n"},{"name":"public.gno","body":"package social_feeds\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/teritori/flags_index\"\n)\n\n// Only registered user can create a new feed\n// For the flexibility when testing, allow all user to create feed\nfunc CreateFeed(name string) FeedID {\n\tpkgpath := std.CurrentRealm().PkgPath()\n\n\tfid := incGetFeedID()\n\tcaller := std.PrevRealm().Addr()\n\turl := strings.Replace(pkgpath, \"gno.land\", \"\", -1) + \":\" + name\n\tfeed := newFeed(fid, url, name, caller)\n\tfidkey := feedIDKey(fid)\n\tgFeeds.Set(fidkey, feed)\n\tgFeedsByName.Set(name, feed)\n\treturn feed.id\n}\n\n// Anyone can create a post in a existing feed, allow un-registered users also\nfunc CreatePost(fid FeedID, parentID PostID, catetory uint64, metadata string) PostID {\n\tcaller := std.PrevRealm().Addr()\n\n\tfeed := mustGetFeed(fid)\n\tpost := feed.AddPost(caller, parentID, catetory, metadata)\n\treturn post.id\n}\n\n// Only post's owner can edit post\nfunc EditPost(fid FeedID, pid PostID, category uint64, metadata string) {\n\tcaller := std.PrevRealm().Addr()\n\tfeed := mustGetFeed(fid)\n\tpost := feed.MustGetPost(pid)\n\n\tif caller != post.creator {\n\t\tpanic(\"you are not creator of this post\")\n\t}\n\n\tpost.Update(category, metadata)\n}\n\n// Only feed creator/owner can call this\nfunc SetOwner(fid FeedID, newOwner std.Address) {\n\tcaller := std.PrevRealm().Addr()\n\tfeed := mustGetFeed(fid)\n\n\tif caller != feed.creator \u0026\u0026 caller != feed.owner {\n\t\tpanic(\"you are not creator/owner of this feed\")\n\t}\n\n\tfeed.owner = newOwner\n}\n\n// Only feed creator/owner or post creator can delete the post\nfunc DeletePost(fid FeedID, pid PostID) {\n\tcaller := std.PrevRealm().Addr()\n\tfeed := mustGetFeed(fid)\n\tpost := feed.MustGetPost(pid)\n\n\tif caller != post.creator \u0026\u0026 caller != feed.creator \u0026\u0026 caller != feed.owner {\n\t\tpanic(\"you are nor creator of this post neither creator/owner of the feed\")\n\t}\n\n\tpost.Delete()\n\n\t// If post is comment then decrease comments count on parent\n\tif uint64(post.parentID) != 0 {\n\t\tparent := feed.MustGetPost(post.parentID)\n\t\tparent.commentsCount -= 1\n\t}\n}\n\n// Only feed owner can ban the post\nfunc BanPost(fid FeedID, pid PostID, reason string) {\n\tcaller := std.PrevRealm().Addr()\n\tfeed := mustGetFeed(fid)\n\t_ = feed.MustGetPost(pid)\n\n\t// For experimenting, we ban only the post for now\n\t// TODO: recursive delete/ban comments\n\tif caller != feed.owner {\n\t\tpanic(\"you are owner of the feed\")\n\t}\n\n\tfeed.BanPost(pid)\n\n\tfeed.flags.ClearFlagCount(getFlagID(fid, pid))\n}\n\n// Any one can react post\nfunc ReactPost(fid FeedID, pid PostID, icon string, up bool) {\n\tfeed := mustGetFeed(fid)\n\tpost := feed.MustGetPost(pid)\n\n\tpost.React(icon, up)\n}\n\nfunc TipPost(fid FeedID, pid PostID) {\n\tcaller := std.PrevRealm().Addr()\n\tfeed := mustGetFeed(fid)\n\tpost := feed.MustGetPost(pid)\n\n\tpost.Tip(caller, post.creator)\n}\n\n// Get a list of flagged posts\n// NOTE: We can support multi feeds in the future but for now we will have only 1 feed\n// Return stringified list in format: postStr-count,postStr-count\nfunc GetFlaggedPosts(fid FeedID, offset uint64, limit uint8) string {\n\tfeed := mustGetFeed(fid)\n\n\t// Already sorted by count descending\n\tflags := feed.flags.GetFlags(uint64(limit), offset)\n\n\tvar postList []string\n\tfor _, flagCount := range flags {\n\t\tflagID := flagCount.FlagID\n\n\t\tfeedID, postID := parseFlagID(flagID)\n\t\tif feedID != feed.id {\n\t\t\tcontinue\n\t\t}\n\n\t\tpost := feed.GetPost(postID)\n\t\tpostList = append(postList, ufmt.Sprintf(\"%s\", post))\n\t}\n\n\tSEPARATOR := \",\"\n\tres := strings.Join(postList, SEPARATOR)\n\treturn ufmt.Sprintf(\"[%s]\", res)\n}\n\n// NOTE: due to bug of std.PrevRealm().Addr() return \"\" when query so we user this proxy function temporary\n// in waiting of correct behaviour of std.PrevRealm().Addr()\nfunc GetPosts(fid FeedID, parentID PostID, user string, categories []uint64, offset uint64, limit uint8) string {\n\tcaller := std.PrevRealm().Addr()\n\tdata := GetPostsWithCaller(fid, parentID, caller.String(), user, categories, offset, limit)\n\treturn data\n}\n\nfunc GetPostsWithCaller(fid FeedID, parentID PostID, callerAddrStr string, user string, categories []uint64, offset uint64, limit uint8) string {\n\t// Return flagged posts, we process flagged posts differently using FlagIndex\n\tif len(categories) == 1 \u0026\u0026 categories[0] == uint64(9) {\n\t\treturn GetFlaggedPosts(fid, offset, limit)\n\t}\n\n\t// BUG: normally std.PrevRealm().Addr() should return a value instead of empty\n\t// Fix is in progress on Gno side\n\tfeed := mustGetFeed(fid)\n\tposts := getPosts(feed, parentID, callerAddrStr, user, categories, offset, limit)\n\n\tSEPARATOR := \",\"\n\tvar postListStr []string\n\n\tfor _, post := range posts {\n\t\tpostListStr = append(postListStr, post.String())\n\t}\n\n\tres := strings.Join(postListStr, SEPARATOR)\n\treturn ufmt.Sprintf(\"[%s]\", res)\n}\n\n// user here is: filter by user\nfunc getPosts(feed *Feed, parentID PostID, callerAddrStr string, user string, categories []uint64, offset uint64, limit uint8) []*Post {\n\tcaller := std.Address(callerAddrStr)\n\n\tvar posts []*Post\n\tvar skipped uint64\n\n\t// Create an avlTree for optimizing the check\n\trequestedCategories := avl.NewTree()\n\tfor _, category := range categories {\n\t\tcatStr := strconv.FormatUint(category, 10)\n\t\trequestedCategories.Set(catStr, true)\n\t}\n\n\tfeed.posts.ReverseIterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpost := value.(*Post)\n\n\t\tpostCatStr := strconv.FormatUint(post.category, 10)\n\n\t\t// NOTE: this search mechanism is not efficient, only for demo purpose\n\t\tif post.parentID == parentID \u0026\u0026 post.deleted == false {\n\t\t\tif requestedCategories.Size() \u003e 0 \u0026\u0026 !requestedCategories.Has(postCatStr) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tif user != \"\" \u0026\u0026 std.Address(user) != post.creator {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\t// Filter hidden post\n\t\t\tflagID := getFlagID(feed.id, post.id)\n\t\t\tif feed.flags.HasFlagged(flagID, callerAddrStr) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\t// Check if post is in hidden list\n\t\t\tvalue, exists := feed.hiddenPostsByUser.Get(caller.String())\n\t\t\tif exists {\n\t\t\t\thiddenPosts := value.(*avl.Tree)\n\t\t\t\t// If post.id exists in hiddenPosts tree =\u003e that post is hidden\n\t\t\t\tif hiddenPosts.Has(post.id.String()) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif skipped \u003c offset {\n\t\t\t\tskipped++\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tposts = append(posts, post)\n\t\t}\n\n\t\tif len(posts) == int(limit) {\n\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t})\n\n\treturn posts\n}\n\n// Get comments list\nfunc GetComments(fid FeedID, parentID PostID, offset uint64, limit uint8) string {\n\treturn GetPosts(fid, parentID, \"\", []uint64{}, offset, limit)\n}\n\n// Get Post\nfunc GetPost(fid FeedID, pid PostID) string {\n\tfeed := mustGetFeed(fid)\n\n\tdata, ok := feed.posts.Get(postIDKey(pid))\n\tif !ok {\n\t\tpanic(\"Unable to get post\")\n\t}\n\n\tpost := data.(*Post)\n\treturn post.String()\n}\n\nfunc FlagPost(fid FeedID, pid PostID) {\n\tcaller := std.PrevRealm().Addr()\n\tfeed := mustGetFeed(fid)\n\n\tfeed.FlagPost(caller, pid)\n}\n\nfunc HidePostForMe(fid FeedID, pid PostID) {\n\tcaller := std.PrevRealm().Addr()\n\tfeed := mustGetFeed(fid)\n\n\tfeed.HidePostForUser(caller, pid)\n}\n\nfunc UnHidePostForMe(fid FeedID, pid PostID) {\n\tcaller := std.PrevRealm().Addr()\n\tfeed := mustGetFeed(fid)\n\n\tfeed.UnHidePostForUser(caller, pid)\n}\n\nfunc GetFlags(fid FeedID, limit uint64, offset uint64) string {\n\tfeed := mustGetFeed(fid)\n\n\ttype FlagCount struct {\n\t\tFlagID flags_index.FlagID\n\t\tCount  uint64\n\t}\n\n\tflags := feed.flags.GetFlags(limit, offset)\n\n\tvar res []string\n\tfor _, flag := range flags {\n\t\tres = append(res, ufmt.Sprintf(\"%s:%d\", flag.FlagID, flag.Count))\n\t}\n\n\treturn strings.Join(res, \"|\")\n}\n\n// TODO: allow only creator to call\nfunc GetFeedByID(fid FeedID) *Feed {\n\treturn mustGetFeed(fid)\n}\n\n// TODO: allow only admin to call\nfunc ExportFeedData(fid FeedID) string {\n\tfeed := mustGetFeed(fid)\n\tfeedJSON := feed.ToJSON()\n\treturn feedJSON\n}\n\n// TODO: allow only admin to call\nfunc ImportFeedData(fid FeedID, jsonData string) {\n\tfeed := mustGetFeed(fid)\n\tfeed.FromJSON(jsonData)\n}\n\n// func MigrateFromPreviousFeed(fid feedsV7.FeedID) {\n// \t// Get exported data from previous feeds\n// \tjsonData := feedsV7.ExportFeedData(fid)\n// \tImportFeedData(FeedID(uint64(fid)), jsonData)\n// }\n"},{"name":"render.gno","body":"package social_feeds\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc renderFeed(parts []string) string {\n\t// /r/demo/social_feeds_v4:FEED_NAME\n\tname := parts[0]\n\tfeedI, exists := gFeedsByName.Get(name)\n\tif !exists {\n\t\treturn \"feed does not exist: \" + name\n\t}\n\treturn feedI.(*Feed).Render()\n}\n\nfunc renderPost(parts []string) string {\n\t// /r/demo/boards:FEED_NAME/POST_ID\n\tname := parts[0]\n\tfeedI, exists := gFeedsByName.Get(name)\n\tif !exists {\n\t\treturn \"feed does not exist: \" + name\n\t}\n\tpid, err := strconv.Atoi(parts[1])\n\tif err != nil {\n\t\treturn \"invalid thread id: \" + parts[1]\n\t}\n\tfeed := feedI.(*Feed)\n\tpost := feed.MustGetPost(PostID(pid))\n\treturn post.Render()\n}\n\nfunc renderFeedsList() string {\n\tstr := \"There are \" + intToString(gFeeds.Size()) + \" available feeds:\\n\\n\"\n\tgFeeds.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tfeed := value.(*Feed)\n\t\tstr += \" * [\" + feed.url + \" (FeedID: \" + feed.id.String() + \")](\" + feed.url + \")\\n\"\n\t\treturn false\n\t})\n\treturn str\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderFeedsList()\n\t}\n\n\tparts := strings.Split(path, \"/\")\n\n\tif len(parts) == 1 {\n\t\t// /r/demo/social_feeds_v4:FEED_NAME\n\t\treturn renderFeed(parts)\n\t} else if len(parts) == 2 {\n\t\t// /r/demo/social_feeds_v4:FEED_NAME/POST_ID\n\t\treturn renderPost(parts)\n\t}\n\n\treturn \"Not found\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"50000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"w48TrCwL2gOFSXEu2RxiPGi8gPIIDhA2KnNLIZuV7H1VAx9yT3+c3hc6isZUrAG8Z0WacNhAKYrbS+bMwZhOPQ=="}],"memo":""},"blockNum":"181054"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g16n55jt73sl8s5kl3z5ahrf0qrlxp47n205j9ex","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreateFeed","args":["teritori"]}],"fee":{"gas_wanted":"3000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AuV5emMEFmGPn60kfPFTcFKQyfmK/in6PINsq3k18anO"},"signature":"77C/EUbRrakjWmMScvcJmFLzJhID6Ybu/RE6qipAeuB5N1mp1kqYWa8gtyla8s2QllQnWPCM3LjTBQMRvVqyCQ=="}],"memo":""},"blockNum":"181056"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AddContextToTask","args":["1","9"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"wiZV+ewr8b2dNSEslt+T3dExHOgtlxJ5KDaypEkrU/swMrZMbtL78OK3p5FwGn2FF4rk7EW9zVuIl0qfpcKQYg=="}],"memo":""},"blockNum":"182010"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"SetTaskDueDate","args":["9","2024-07-17"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"4+2+8j+BZHGPTJdGIGcwDuOXnBroUV6/kK1wiDfim3EU3B00qfU+7KaR4qrTSMi5EZ1Tr8OF3r5i3cGCqSyoDg=="}],"memo":""},"blockNum":"182012"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MoveTaskToRealm","args":["9","3"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"EBQy0v8BKXHZAoFYnlTqdmFff70wdwCAUWLDSaavRDxolg/dhRSPtbL7BHB+y96FBHDxxLgKck8WXFgRntKmTQ=="}],"memo":""},"blockNum":"182019"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1nzs3t27xc8yjgyrqt4q8g98nfsptsykd7ajrhh","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"BtJMjmMT4XD4FwB1hHx1/STiGo1bIPT+2z5bBnGN/wpFf8kiRwpwIDhTwWIVCQpmZV6om9Q98MSs3qa7CWaaRA=="}],"memo":""},"blockNum":"182103"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AddProject","args":["Deploy to Test4"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"42Jz5PQOhZlf67k/gCqq5j68oCI7BIN4guY43YvftVIB1AfyB2xqI4YJHREzMpdHFx+e4zZsUCaN7Bm1yMaAsQ=="}],"memo":""},"blockNum":"182173"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AttachTaskToProject","args":["Review keys and deploy scripts","2"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"LwmhuDzbNLb6eTmqepZQqgglRkQzeQlMzPm3f+iuDdgwpCqu++AgJRbMUmCgEuAxJdoiqt1C9kxrjhW+pkDqqw=="}],"memo":""},"blockNum":"182180"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AttachTaskToProject","args":["Change endpoints in fronted","2"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"/+Dgcih55M19RLtuV6WyA13DrVYszmUhr6Udm4oBlPN25O2Ja6mCGlk9Ucfwt5mSujxfB1p711uWEbyAVzWK1A=="}],"memo":""},"blockNum":"182188"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"SetTaskDueDate","args":["5","2024-07-17"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"6i5BqEmy0MexdcYsLhL8fUBoz0IAfZqI8Gu/QrY1zLNiXhDF/lFmLlg21Elzsc4Qj+ADTx6K5v/C1rveuwIkGA=="}],"memo":""},"blockNum":"182405"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AddContextToTask","args":["4","5"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"7SfdaF37dnPhbrGKgtFYjYW64yYqSlRRguaWHVVDn7kx/4YST1ZC5B4SUfqXBAhPUyo/EIZ10sdtZXbD6F6AOA=="}],"memo":""},"blockNum":"182407"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MoveTaskToRealm","args":["5","3"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"Jz70qvWQbibXzKmpWVqMGpnAkuHHPZmj6UQfA7ROQFsY389XUFSHXkHTrJRCQwj8A6kYPPRBPLdVKl4eiLxjgQ=="}],"memo":""},"blockNum":"182412"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3","send":"20000000ugnot","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","zentasktic","Natural Productivity"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3z5VSeKU6dQZ0MPlCtAUtPw1aBlpkfN1NuYewD/3rRa"},"signature":"2vphnx7RPAS7OO5WDCIC+U3H5Pq2RQrwCYgPV7AbxfBkJc7aLJzTPlics1WOEPxhezyKtsWyOY1fimJmL6beZg=="}],"memo":""},"blockNum":"182526"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MoveProjectToRealm","args":["2","2"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"5+2wPyfrcXU+JyXmv4XSIFn15+0PkCbkPCOotS13sP94762HLKNOuLRmUBLJbb+NY3wByvYsThEPnYDvIYgQcg=="}],"memo":""},"blockNum":"182536"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AddContextToProject","args":["1","2"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"CdZoP1J9en0tmvSyE0uRDQv7rh31qXFCgTD+TofuNgZfUpLcGSFVaMhK0aS0Y8E0GeYq3Ob0T0V7nO/bTR1vtw=="}],"memo":""},"blockNum":"182540"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"SetProjectDueDate","args":["2","2024-07-18"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"k/j1t9ppMr450Z/miraMC6l5AY/zsBOmKK+zlZR/B6RnoGuFMpQV5FvWjnYXAysufMXXPN/jD2emJ67I/FWw5g=="}],"memo":""},"blockNum":"182542"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AddContextToProjectTask","args":["1","2","3"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"QOfFoBXeHhrTcfb2JBKBVtYt02uH5fPZX49KqQ+VZ8dAGN/X9DXqhf46IRPIs648s31BjifHqsZJWOXjBDEPgg=="}],"memo":""},"blockNum":"182544"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"SetProjectTaskDueDate","args":["2","3","2024-07-18"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"o/NlUaAP+ncUpscaLspY7Jbz9mqswLHPZ5NhFSmpOzdtNiZsrV8nzotsOd1TgB+1d3AFW0B1LL6bSiaJktDnUQ=="}],"memo":""},"blockNum":"182546"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AddContextToProjectTask","args":["1","2","4"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"sceqtfZBBQhes9CKMO0KEmv90NbI/yZZL2kOEKsqS4oQK4uhuLLRqLz8mJgR32mMswWTmRNH9Bfy1eU7HTLpmQ=="}],"memo":""},"blockNum":"182547"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"SetProjectTaskDueDate","args":["2","4","2024-07-18"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"w5k30i4t3BF4SGdKUqjnBMmrVlTVHs/4w1DtHoMpWNxQzrHFDxs7N7jv9D+3wROCZA6IDSLP/yTzBQW+AhEB9g=="}],"memo":""},"blockNum":"182549"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MoveProjectToRealm","args":["2","3"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"hdptheRiL/YxtLmVt6rnPTmqXguTMx8BUtn93UAeM7QPcgLvLz5cd5EcBJI3wq/MdVu/fm6hFGX0Nq+yEQyjCg=="}],"memo":""},"blockNum":"182552"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1jxkgkn0vcxhvq2ruxuj4dwvfgxa8jy48snl0d3","amount":"15000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"6YiVNiXslSXmNHn1BmyoIzY2WjmdZoRPcSeAp5XhsQdzCtbsiWLVYvydPkyWZr+Nt9AjROK9zMWC6em1C6lG9A=="}],"memo":""},"blockNum":"182696"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jxkgkn0vcxhvq2ruxuj4dwvfgxa8jy48snl0d3","send":"","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms","func":"CreateForm","args":["Untitled form","Form description","2024-07-16","2024-07-18","[{\"fieldType\":\"text\",\"label\":\"How was your day?\",\"required\":true}]"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aqiazgru8g7JMr3ZQAHrBlEDF4tERsNexRbTJzhr3h3r"},"signature":"OMLhjRFmL71U1jkpTWM0gcdIOmq6EbdpFl8Abq7R1sR8zNHZHToG6I40j0MMKOCCLTbErYYQiTlEdVf/tTDsFw=="}],"memo":""},"blockNum":"182700"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jxkgkn0vcxhvq2ruxuj4dwvfgxa8jy48snl0d3","send":"","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/forms","func":"SubmitForm","args":["0000001","[\"Mohammed\",19,1]"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aqiazgru8g7JMr3ZQAHrBlEDF4tERsNexRbTJzhr3h3r"},"signature":"AvEkeNVbBqzsgdO+dQttKRa0rr3UAxK9TdjgdCpS/NU9RndGcxXhmNZfZjffHOaXWn5GpzIALZcNhBR7b9RjmA=="}],"memo":""},"blockNum":"182724"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g18syxa0vh0vmne90mwhtynjet0zgeqf6prh3ryy","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"AFCnynFbEKL0N6jDE2VQPbAoUbo6RMbaAEkgzRGExl4BUZ3Hw9C076UM0YDGqxzlXb7Zjg3mqrJYSzKwYuFcbw=="}],"memo":""},"blockNum":"182760"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g18syxa0vh0vmne90mwhtynjet0zgeqf6prh3ryy","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","2","{\"message\":\"Hey Gnomes!\",\"files\":[],\"gifs\":[],\"hashtags\":[],\"mentions\":[],\"title\":\"\",\"createdAt\":\"2024-07-17T15:10:28.763Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3GjOAi0K77aU30Hh65nUVsJfBA+IcMA1m6CZ4arVQBU"},"signature":"n3bhwfC3I9S9iKORMCHmBSjpTMycSC9N3V7jE8n9/+FJywDPe7AtkujMucRKPQGx/XmrUPoUZ3O1R/wxsxmdFQ=="}],"memo":""},"blockNum":"182763"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jxkgkn0vcxhvq2ruxuj4dwvfgxa8jy48snl0d3","send":"3000000ugnot","pkg_path":"gno.land/r/g1w62226g8hykfmtuasvz80rdf0jl6phgxsphh5v/testing/disperse2","func":"DisperseGnotString","args":["g1jxkgkn0vcxhvq2ruxuj4dwvfgxa8jy48snl0d3,g1jxkgkn0vcxhvq2ruxuj4dwvfgxa8jy48snl0d3","1000000,2000000"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Aqiazgru8g7JMr3ZQAHrBlEDF4tERsNexRbTJzhr3h3r"},"signature":"xo+PHKwOwTeYKf+3LImpHJV9xSw40VOr1KjMf5J0iesKjmiVh27jfmcG9dQBXeSECoq0lFd8uwIXajjDiTwhxA=="}],"memo":""},"blockNum":"182781"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"PJJhT4lw8QaxpSgXze+Uv1CgGSpkBevVNm/wdBMfklw31FFDlNV7y3BaPFW9HOfdA0ZlpMwyJaBwQMQKFecOOg=="}],"memo":""},"blockNum":"182841"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","4","{\"message\":\"Guilhem (gno core mate) @ Nebular Summit, Bruxelles, 2024.\\n\\n#report #gnoland #event #workshop\",\"files\":[{\"fileName\":\"signal-2024-07-12-152705_002.jpeg\",\"url\":\"ipfs://bafybeiddydwkgx4aa7h3c2l2k2ck3hx5pj2mupqlsqjbpgh7obm3oll3py\",\"mimeType\":\"image/jpeg\",\"size\":220904,\"fileType\":\"image\"}],\"gifs\":[],\"hashtags\":[\"#report\",\"#gnoland\",\"#event\",\"#workshop\"],\"mentions\":[],\"title\":\"\",\"createdAt\":\"2024-07-17T15:16:12.894Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AyDlf14q7C2aBqar/Qryh6dVR9VACxVZV6fOaM3X5YEA"},"signature":"LfdXscHM9uQ56tylx5v6XyjipC+1imzaqiPx+LGI9UQI7GhhRxa0Zmcf2Ko0T4Rd+EfwzteV8k3Ns96eDD5CqQ=="}],"memo":""},"blockNum":"182847"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g18l9us6trqaljw39j94wzf5ftxmd9qqkvrxghd2","to_address":"g1yr6mh5k8cjdkrjcmp5mu2przkgjf5265umzj3t","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AxjyQBsJI8CesbgwihvS/eQtYKoezyoA9P+FRlLAKRwg"},"signature":"utt18tlrB9/1bsYbn0HyzLK3Fanp7aRKBGHzfMImImcuNALmucAQ9KOYnQWQrfpJt7eWgxMMsYVA6ctCUXRQ3w=="}],"memo":""},"blockNum":"182939"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3","to_address":"g1qn6w9uvep7t5ktyqh2qwjjrvv9s67klzq9ydzd","amount":"1000000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3z5VSeKU6dQZ0MPlCtAUtPw1aBlpkfN1NuYewD/3rRa"},"signature":"+hF9TuPDoYywgefaNuYX22ntMlzrp5egsXmRCjsp1r4XTQLbqSw/Fv6cPsyKxg4/5Bu11NnqQgrpOsapxhWkdQ=="}],"memo":""},"blockNum":"182987"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3","to_address":"g1q6gqjdwxm46xkjh6dre904c3jjausnt9zdcqx8","amount":"1000000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3z5VSeKU6dQZ0MPlCtAUtPw1aBlpkfN1NuYewD/3rRa"},"signature":"cdNmMW9ssYM/eiLBumpIHFiw5xlJEBOldlmzQtom3VA9Rnu8YcvHUQ1+hNhGj12UYOeIdEZqkoVBZsa7N0rdXw=="}],"memo":""},"blockNum":"183038"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3","to_address":"g19vccsxy753yhahg9tdt8xz6mezvdqktr4u7yfu","amount":"1000000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3z5VSeKU6dQZ0MPlCtAUtPw1aBlpkfN1NuYewD/3rRa"},"signature":"QHWFapdJGtxTC/54z7sK8caNUpPyHdiC8IneiONx4tc4s+PCL7rfvke8aF6u3s6FjS3xzJUK4V8bc+OJPfmUxA=="}],"memo":""},"blockNum":"183051"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g19vccsxy753yhahg9tdt8xz6mezvdqktr4u7yfu","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AddTask","args":["Need to update some docs :)"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Avpz8QFpWrxjjt4z+Os2kbO3hMLfdB1TvruKd+qC+uYd"},"signature":"b9O/KmEW64XT2JgDjiHeH+bN/TNa7tWNulUJa/RUOTFwK0ANYOy9tDo/uc6yEFEoon7ai1xSIkWV1Yc6jvO6rg=="}],"memo":""},"blockNum":"183058"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g19vccsxy753yhahg9tdt8xz6mezvdqktr4u7yfu","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MoveTaskToRealm","args":["11","2"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Avpz8QFpWrxjjt4z+Os2kbO3hMLfdB1TvruKd+qC+uYd"},"signature":"trQhNrPo2ZEqi9nEbKY6gKacHjkDrehHVnS9DwkStAM7S27UCtNkM/bzHRK7/zwq1IUBZ41nmDgCmL9WGIN0xA=="}],"memo":""},"blockNum":"183060"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MarkProjectTaskAsDone","args":["2","3"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"+ZN6Da1hsWc0/9bVZpl9DNPLzCQY7nenmm2ZX0gWnU1/gpNGYOgX+ddOhRjPUo+OCWMkgG2yFGL+ahv0Dzq0aA=="}],"memo":""},"blockNum":"183159"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"SetTaskDueDate","args":["11","2024-07-17"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"ordwTrUvpns2R74FKWlpoblF1zTYPMHvw0gJ6Rax0Lk1/AuF7QNPHCZJxXuLG7YdA4uVWJmOw//qXx3ZdGMXkQ=="}],"memo":""},"blockNum":"183326"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"AddContextToTask","args":["1","11"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"Lo6ZuiKX4oBt7QHWSKDXqpRnrUGJlPZqDNr8KRIxCIpbP+oNQ2qvicJqyyMnoZzFC4i3if1QrWNybfdJcnyeFA=="}],"memo":""},"blockNum":"183327"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MoveTaskToRealm","args":["11","3"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"ikKpwGqWGrGOMVQL9EcOd7Vw6G8kN9Ri0HWBjT3cuTEzhhEiz6mTZjEzTQKwV1mWQ5NCDCiLDJcJIuR9OM1ZJA=="}],"memo":""},"blockNum":"183341"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MoveTaskToRealm","args":["5","4"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"s0jUWah0kF676CHc6O1JMtanF7pAuKn2gvq6Omlwgkkgh7fY3qHksH5IKo29AxBHMtoETuQA8Nsr9xMdJLefbw=="}],"memo":""},"blockNum":"183437"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1xdraj62n8kpwukvedmels6h2ppmmpazuwfd4ny","send":"","pkg_path":"gno.land/r/g17ernafy6ctpcz6uepfsq2js8x2vz0wladh5yc3/zentasktic_core","func":"MarkProjectTaskAsDone","args":["2","4"]}],"fee":{"gas_wanted":"8000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Anm6Fnh9HKT7op0Abmsng6nK24zNb2wlCwcn0Fm85yW5"},"signature":"i6YpR1nlpmOZuX40NMKVvnD9ZFKfuizpRA4ZQQ4F1t9CXZzAvAxnlKzTHG4UYrO+s3pDBtbhcFVA8AcEoL8RQQ=="}],"memo":""},"blockNum":"183461"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1747t5m2f08plqjlrjk2q0qld7465hxz8gkx59c","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","4","{\"message\":\"\",\"files\":[{\"fileName\":\"Teritori puzzle.jpg\",\"url\":\"ipfs://bafybeigyc6bles3kswqdnqbrh4kdk6hzu3mt5euvvdmjlakupn4jt7bhnm\",\"mimeType\":\"image/jpeg\",\"size\":1085399,\"fileType\":\"image\"}],\"gifs\":[],\"hashtags\":[],\"mentions\":[],\"title\":\"\",\"createdAt\":\"2024-07-17T16:01:43.203Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AyDlf14q7C2aBqar/Qryh6dVR9VACxVZV6fOaM3X5YEA"},"signature":"41rntcdLs7O2/Lf4JUoTa6zi7J26QFvI9dicRKo7sDZiMFOCdSaGVJzcLn4b/HQTtCvkL37n+CoTBZ2tqaHuPw=="}],"memo":""},"blockNum":"183524"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g16f5chytu99dmjqtekxf8qzg04vcv7dck6qny6d","send":"20000000ugnot","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","flippando","Estory flippando en colores"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/sttU8T86q2o/GuqK6RktPJEmHu2JEZ0gz3/iGf71ox"},"signature":"ZCJIhCpkzc6LCm1zFuHzhW3m5rNMVbDDCWzOu85G7r8PQMPegqRLXsp45MLHnSUqEhQ+tLZgQxDzuCoKLEFiGw=="}],"memo":""},"blockNum":"183593"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","salmad","Danny from DevX"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"5y+72Eo5ZKwfQreMBkM0IPCMsrAYobtRnR/5i8L0JOBL7t30axHOYhazXPwmUNLPhVVcZXLkQWVAnQ+5uooXvA=="}],"memo":"Called through gno.studio"},"blockNum":"184955"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"name":"simplefeedback","path":"gno.land/r/g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7/simplefeedback","files":[{"name":"simplefeedback.gno","body":"package simplefeedback\n\nimport (\n    \"gno.land/p/demo/ufmt\"\n    \"std\"\n    \"strings\"\n)\n\ntype Feedback struct {\n    ID       int\n    User     std.Address\n    Content  string\n    Response string\n}\n\nvar feedbackList []Feedback\nvar nextID = 1\n\n// SubmitFeedback allows users to submit feedback.\nfunc SubmitFeedback(content string) string {\n    user := std.GetOrigCaller()\n    feedback := Feedback{ID: nextID, User: user, Content: content}\n    feedbackList = append(feedbackList, feedback)\n    nextID++\n    return ufmt.Sprintf(\"Feedback submitted successfully with ID: %d\", feedback.ID)\n}\n\n// RespondToFeedback allows any user to respond to a feedback.\nfunc RespondToFeedback(feedbackID int, response string) string {\n    for i, fb := range feedbackList {\n        if fb.ID == feedbackID {\n            feedbackList[i].Response = response\n            return \"Response added successfully\"\n        }\n    }\n    return \"Feedback ID not found\"\n}\n\n// Render displays all feedback and responses.\nfunc Render(path string) string {\n    var output strings.Builder\n    output.WriteString(\"# Feedback Collection\\n\")\n    for _, fb := range feedbackList {\n        output.WriteString(ufmt.Sprintf(\"## Feedback ID: %d\\n\", fb.ID))\n        output.WriteString(ufmt.Sprintf(\"- User: %s\\n\", fb.User))\n        output.WriteString(ufmt.Sprintf(\"- Content: %s\\n\", fb.Content))\n        if fb.Response != \"\" {\n            output.WriteString(ufmt.Sprintf(\"- Response: %s\\n\", fb.Response))\n        } else {\n            output.WriteString(\"- Response: Pending\\n\")\n        }\n        output.WriteString(\"\\n\")\n    }\n    return output.String()\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"uTnoiEmL/w1Xz8qS9QqjLSydQF3NlWOelccvLMszQSQrd5g3e7atnKQec6MKBd1RCf0OH9wz6EuJxCxjkYaw2A=="}],"memo":"Deployed through play.gno.land"},"blockNum":"185434"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","send":"","pkg_path":"gno.land/r/g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7/simplefeedback","func":"SubmitFeedback","args":["hello"]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"sYSH57s3f97Uqi5BKXb0JUNa0gRPuTZWvaxBifLb7iJoTWuwedQInsL1h5erL7TmPBFyz5BMIB0XTuKLfsZmcA=="}],"memo":"Called through gno.studio"},"blockNum":"185440"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","x1unix",""]}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"D5w/Y4qDG2ArOlei0DMYN6QukCXwsHRNYXyuyuF30+xsM731knf/6Ezw07G/s3eU0QdC1Ly1Y2VbxCCE+AxR8Q=="}],"memo":"Called through gno.studio"},"blockNum":"185871"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1njagaeg7e398hze39ygfgvc4gwsh6lkz7dwnuz","to_address":"g1ytrxtq8jq8tfy65ry5qp703ffj6g780j0t6jms","amount":"10000000ugnot"}],"fee":{"gas_wanted":"100000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"As2VmUYjIs+Q+esyTyrgv8nQpAtImqdkUUKCpJYzNQ4a"},"signature":"aDD8CPq0AELG4m59Lg1aDaU7ZZDD10zObfzz8sbP4a8NtuvUiiU7O1RYBB2aMuRFnbGlSW4qkuOqSsOREyuDKA=="}],"memo":""},"blockNum":"186197"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ytrxtq8jq8tfy65ry5qp703ffj6g780j0t6jms","send":"1000000ugnot","pkg_path":"gno.land/r/teritori/social_feeds","func":"TipPost","args":["1","gnotest4-3"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+X/44cZZbJ7j1yMwjs8TeGDdb9PUYcQIhmTHKdHtp7/"},"signature":"T112VpZaixoSu4JgAiFHB38iXIOVjQi80lEsBknaUWli7PaP1lK5XJ8VQmmYVQUuPMB/RRR068IlnJiILzV08w=="}],"memo":""},"blockNum":"186221"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1ytrxtq8jq8tfy65ry5qp703ffj6g780j0t6jms","send":"","pkg_path":"gno.land/r/teritori/social_feeds","func":"CreatePost","args":["1","0","2","{\"message\":\"Nice Picture\",\"files\":[],\"gifs\":[],\"hashtags\":[],\"mentions\":[],\"title\":\"\",\"createdAt\":\"2024-07-17T18:07:40.544Z\"}"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+X/44cZZbJ7j1yMwjs8TeGDdb9PUYcQIhmTHKdHtp7/"},"signature":"L60+1bEG9OABcdN9oJGf3/cu4GLyuTRDbmn4iwJqpIVaXXTLmU5ppKz+zK5k2b1MqrFYmwvcz3ZMytvAQ2egiA=="}],"memo":""},"blockNum":"186255"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g15ruzptpql4dpuyzej0wkt5rq6r26kw4nxu9fwd","send":"20000000ugnot","pkg_path":"gno.land/r/demo/users","func":"Register","args":["","x1unix","carbon-based liveform"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Ax8dMlyeZTx7/5c7upbCj/sMsgJdjajg4b8kgHZ+d1mV"},"signature":"7EJjtPdmo8EKVek1rTcz+K/Pk8soumloRMi+FebcbKlhRBvghGX249SYL1yOTvamQ9OKwIJvRRmvWd/FuP4yAA=="}],"memo":""},"blockNum":"186737"}
